<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前端26-ES6知识点脑图</title>
    <url>/2019/09/10/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/ES6%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1924341-08207b62a1fd73a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ES6知识点.png"></p>
<p>注：若图片无法显示，可移步至该平台查看<a href="https://www.cnblogs.com/dasusu/p/11557470.html" target="_blank" rel="noopener">本文章</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>三大框架知识点比较</title>
    <url>/2019/07/20/Angular/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%AF%94%E8%BE%83%EF%BC%88Angular,-Vue,-React%EF%BC%89/</url>
    <content><![CDATA[<p><img src="https://github.com/woshidasusu/Doc/blob/master/%E8%84%91%E5%9B%BE/%E5%89%8D%E7%AB%AF/Vue%E5%92%8CReact%E5%92%8CAngular.png" alt="Vue和React和Angular.png"></p>
<p>注：若图片无法显示，可移步至该平台查看<a href="https://www.cnblogs.com/dasusu/p/11557458.html" target="_blank" rel="noopener">本文章</a></p>
]]></content>
      <categories>
        <category>Angular</category>
      </categories>
  </entry>
  <entry>
    <title>Angular（06）-- 为什么数据发生变化，绑定的视图就会刷新</title>
    <url>/2019/07/19/Angular/Angular%EF%BC%8806%EF%BC%89--%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%EF%BC%8C%E7%BB%91%E5%AE%9A%E7%9A%84%E8%A7%86%E5%9B%BE%E5%B0%B1%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E4%BA%86%EF%BC%9F/</url>
    <content><![CDATA[<p>这里提一点，前端三大框架（Angular，React，Vue）的数据驱动来更新视图的原理，即 MVVM 的实现。<br><strong>为什么数据发生变化，绑定的视图就会刷新了呢？</strong>  </p>
<p>以下是我的个人理解，仅供参考：  </p>
<p>在还是 jQuery 的时代，当在 js 中改变了某个变量的数据，而这个变量是需要在 Html 中显示出来的。那么，这个时候，我们的做法也就是通过 DOM 先获取到显示该变量的视图元素，然后借助 DOM API 来更新这个视图元素，是吧。这是原始的方式。</p>
<p>那么，不管三大框架都做了些什么，MVVM 的实现原理是什么，它们最终其实也都还是要通过操纵 DOM API 来更新视图元素，与原始方式的区别就是，这部分操纵 DOM 的工作，由框架来负责，我们无需关心了，只需要关心数据的变化工作即可。  </p>
<p>好处就是，我们可以更关注于业务逻辑的编程，而无须再去为如何操纵 DOM 树而烦恼。  </p>
<p>那么，<strong>既然框架要来帮我们处理这部分工作，它们实现的关键点就在于，如何知道，我们对数据进行了更新？</strong>  </p>
<p>什么意思？也就是说，这部分工作由我们自己来做时，我们是能够明确的知道什么时候该去操纵 DOM 树了，不就是我们对数据进行更新的时刻吗。但，框架并不知道我们什么时刻会对数据进行更新。  </p>
<p>所以，回想一下，你在使用三大框架时，是不是每个框架基本都有一些注意事项，或者说它的规定？  </p>
<p>比如说：  </p>
<p><strong>react 要求修改 state 局部变量时，得通过 <code>this.setState(...)</code></strong><br><strong>vue 要求得声明在 data 中的变量，当它变化时才会被追踪到，以更新视图</strong>  </p>
<p>为什么这些框架会有这些要求，或者说这些规定？<br>因为它需要知道我们到底什么时刻会去对数据进行更新啊。  </p>
<p>对于 react 来说，当我们需要更新变量的数据值时，都通过调用它的方法，那么，它自然就知道我们什么时候更新了数据了。  </p>
<p>对于 vue 来说，虽然我们更新数据时是直接对变量进行赋值操作，但实际上，声明在 data 中的这些变量，都会被转换成存取器属性，也就是 set 和 get。那么，当我们直接对变量的赋值操作，其实会去执行 set 的内部逻辑，而 vue 只需要在这里就可以获取我们更新数据的时机了。  </p>
<p>那么，对于 Angular 呢？好像使用 Angular 过程中，并没有需要遵循什么规定。  </p>
<p>这是因为，Angular 的实现原理并不类似于 react 和 vue。  </p>
<p><strong>react 和 vue 的原理类似于主动通知的模式，也就是，当我发生变化了，那我就通知你一下，你就需要去做些更新处理了。</strong>  </p>
<p>而 <strong>Angular 的原理，类似于被动轮询的模式。也就是，你不知道我什么时候会变化，那么你就在我有可能会变化的情况下，不断的读取我的值，比对一下，看看有没有发生变化。</strong>  </p>
<p>验证 Angular 的这种原理的猜测很简单，你在页面上某个元素绑定个方法，方法内打个日志，然后你滑动下页面试试看，看看日志是不是一直在输出。  </p>
<p>总结一下：<br>三大框架实现的原理其实有所差异<br>react 是通过调用 <code>setState()</code> 方式来告知视图刷新；<br>vue 是通过将声明在 data 中的数据属性转换为存取器数据（set 和 get）的方式，来监听数据变化的时机；<br>angular 则是在会触发视图变化的情况下，主动去检测绑定的数据源，比对下是否有发生变化来判断是否需要刷新视图。  </p>
<p>当然，以上的理解仅仅是很浅的层面，只是理清了三大框架是如何知道我们数据更新的时机这个问题。  </p>
<p>对于三大框架来说，他们的视图刷新并非是这么简单的实现。比如说：  </p>
<p>对于 vue，当它监听到某个数据源发生变化了，但它并不会立马去刷新视图，而是将相关的信息先记录起来，等待一个固定频率的下个帧信号，在这期间发生变化的数据源都会被记录起来。直到信号来的时候，再一起去处理这次的视图刷新。  </p>
<p>这也是为什么一些 vue 的书中或者项目中，会有要求说某些代码需要放在下一个 tick 中去执行，因为数据源刚发生变化时，页面不一定就更新了。</p>
<p>原理跟 Android 的屏幕刷新机制很像，就都是以一个固定频率来刷新页面，在每个帧信号之间，只是收集发生变化的视图，或者说，只更新虚拟 DOM，并不会去更新真实的页面。直到帧信号到的时候，再一次性的批处理地刷新页面。  </p>
<p>对于 Angular 来说，虽然它是不断轮询的方式来检测数据源是否发生变化，但并不意味着时时刻刻都在轮询检测，而只在一些有可能导致视图更新的场景下才会去检测。比如说，滑动页面，比如说 settimeout 事件。  </p>
<p>这也是为什么在 Angular 项目中，经常会看到一些 settimeout(…, 0) 这样的操作。  </p>
<p>以上，个人的理解，如有错误，欢迎指点一下。</p>
]]></content>
      <categories>
        <category>Angular</category>
      </categories>
  </entry>
  <entry>
    <title>Angular（05）-- 组件知识点脑图</title>
    <url>/2019/07/18/Angular/Angular%EF%BC%8805%EF%BC%89--%E7%BB%84%E4%BB%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE/</url>
    <content><![CDATA[<p><img src="https://github.com/woshidasusu/Doc/blob/master/%E8%84%91%E5%9B%BE/%E5%89%8D%E7%AB%AF/Angular%E7%BB%84%E4%BB%B6.png" alt="Angular组件.png"></p>
<p>注：若图片无法显示，可移步至该平台查看<a href="https://www.cnblogs.com/dasusu/p/11557428.html" target="_blank" rel="noopener">本文章</a></p>
]]></content>
      <categories>
        <category>Angular</category>
      </categories>
  </entry>
  <entry>
    <title>Angular（04）-- 知识点脑图</title>
    <url>/2019/07/17/Angular/Angular%EF%BC%8804%EF%BC%89-%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE/</url>
    <content><![CDATA[<p><img src="https://github.com/woshidasusu/Doc/blob/master/%E8%84%91%E5%9B%BE/%E5%89%8D%E7%AB%AF/Angular%E7%9F%A5%E8%AF%86%E7%82%B9.png" alt="Angular知识点清单.png"></p>
<p>注：若图片无法显示，可移步至该平台查看<a href="https://www.cnblogs.com/dasusu/p/11557386.html" target="_blank" rel="noopener">本文章</a></p>
]]></content>
      <categories>
        <category>Angular</category>
      </categories>
  </entry>
  <entry>
    <title>Angular学习（03）--lint检查规范和WebStorm小技巧</title>
    <url>/2019/07/16/Angular/Angular%E5%AD%A6%E4%B9%A0%EF%BC%8803%EF%BC%89--lint%E6%A3%80%E6%9F%A5%E8%A7%84%E8%8C%83%E5%92%8CWebStorm%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>在开始讲 Angular 各个核心知识点之前，想先来讲讲开发工具 WebStorm 的一些配置以及相应配置文件如  tslint.json 的配置。</p>
<p>因为我个人比较注重代码规范、代码风格，而对于这些规范，我只有一个观点：<strong>一切需要依赖开发人员的主观意识去遵守的规范都没有多大意义。</strong>  </p>
<p>以前做 Android 开发时会借助 AndroidStudio 来强制遵守一些规范，现在前端项目我用的是 WebStorm 开发，这两个开发工具本质上同源，所以很多功能都差不多。</p>
<p>那么，这篇就来讲一讲，如何对 WebStorm 进行一些设置，让它可以更好的辅助我们遵守风格规范，同时，理清一些比如 tslint.json 的配置，来让开发工具实时检测我们写的代码是否有很好的遵守规范。</p>
<h1 id="风格规范"><a href="#风格规范" class="headerlink" title="风格规范"></a>风格规范</h1><p>Angular 项目的很多文件都是通过 Angular-CLI 工具的 ng 命令来生成的，生成时就有默认一些代码风格，而且，WebStorm 默认也有一些代码风格，也许有人觉得直接使用默认的风格来即可。</p>
<p>但对于默认的一些风格规范，我不是很赞同，比如说：</p>
<p><code>name: string = &#39;dasu&#39;</code> </p>
<p>简单的在某个类中声明这么一个 name 变量，类型是 string，初始值为 dasu，但默认的 tslint.json 配置的代码风格会报错，因为它建议我们，既然已经初始化为字符串类型了，就没有必要再去声明变量的类型了。</p>
<p>对于这种默认风格，我个人并不赞同，因为个人习惯了 Java 的风格，对于变量的类型声明已经习惯了，更何况，这个初始值有可能在未来被去掉，那么，这时候岂不是还要去加上类型说明？</p>
<p>所以，我个人还是比较习惯声明变量的类型，不管有没有对其进行初始化。</p>
<p>以上只是个简单的例子，默认的一些代码风格，我个人都不是很习惯，所以，下面列举我的个人代码风格，供大伙借鉴、参考。</p>
<p>不多，只有几点而已，因为大多直接使用默认的代码风格，只是默认的一些风格中，我不是很习惯的情况下，才会对其进行修改。</p>
<h4 id="命名方面"><a href="#命名方面" class="headerlink" title="命名方面"></a>命名方面</h4><ul>
<li>私有属性和方法以 <code>_</code> 一个下划线开头，并添加 <code>private</code> 修饰符</li>
<li>公有属性和方法使用默认的不加修饰符</li>
<li>与组件对应的模板 html 绑定事件相关的方法，以 <code>on</code> 为前缀</li>
<li>组件的输出属性（@Output) 不以 <code>on</code> 为前缀</li>
<li>表格数据的 *ngFor 指令时，建议以 item 命名每一项，如 <code>*ngFor=&quot;let item of page?.result&quot;</code> 这样便于各个页面的代码直接复制粘贴</li>
</ul>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ul>
<li>HTML 中使用 <code>&quot;&quot;</code> 双引号，ts 中使用 <code>&#39;&#39;</code> 单引号</li>
<li>HTML 和 ts 的缩进都使用 4 个空格</li>
<li>局部变量允许使用 let，并不一定强制使用 const</li>
<li>所有变量声明时直接指明其类型</li>
</ul>
<h1 id="tslint-json"><a href="#tslint-json" class="headerlink" title="tslint.json"></a>tslint.json</h1><p>创建一个新的 Angular 项目时，会自动生成项目的脚手架，里面包括了各种各样的文件，其中有一份是 tslint.json 文件，是用来给 WebStorm 实时对代码进行 lint 检测时的代码风格配置。</p>
<p>我修改了部分默认的配置，下面给出的是所有项的配置，其中带有注释的配置项，就是我增加或修改原本默认的配置项，是基于我上面说的个人的一些习惯风格而进行的修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;rules&quot;: &#123;</span><br><span class="line">    &quot;arrow-return-shorthand&quot;: true,</span><br><span class="line">    &quot;adjacent-overload-signatures&quot;: true, // override 函数是否集中放置 (新增)</span><br><span class="line">    &quot;callable-types&quot;: true,</span><br><span class="line">    &quot;class-name&quot;: true,</span><br><span class="line">    &quot;comment-format&quot;: [</span><br><span class="line">      true,</span><br><span class="line">      &quot;check-space&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;curly&quot;: true,</span><br><span class="line">    &quot;deprecation&quot;: &#123;</span><br><span class="line">      &quot;severity&quot;: &quot;warn&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;eofline&quot;: false,  // 文件末尾是否需要空新行 (默认 true)</span><br><span class="line">    &quot;encoding&quot;: true,  // 文件编码是否默认 UTF-8 (新增)</span><br><span class="line">    &quot;forin&quot;: true,</span><br><span class="line">    &quot;import-blacklist&quot;: [</span><br><span class="line">      true,</span><br><span class="line">      &quot;rxjs/Rx&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;import-spacing&quot;: true,</span><br><span class="line">    &quot;indent&quot;: [</span><br><span class="line">      true,</span><br><span class="line">      &quot;spaces&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interface-over-type-literal&quot;: true,</span><br><span class="line">    &quot;label-position&quot;: true,</span><br><span class="line">    &quot;max-line-length&quot;: [</span><br><span class="line">      true,</span><br><span class="line">      240 // 默认140，我屏幕挺大的，所以并不反感某一行代码过长，相反，很多代码因为自动换行后，我个人感觉更不习惯，还不如我手动来选择从某个地方换行</span><br><span class="line">    ],</span><br><span class="line">    &quot;member-access&quot;: false,</span><br><span class="line">    &quot;member-ordering&quot;: [</span><br><span class="line">      true,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;order&quot;: [</span><br><span class="line">          &quot;static-field&quot;,</span><br><span class="line">          &quot;instance-field&quot;,</span><br><span class="line">          &quot;static-method&quot;,</span><br><span class="line">          &quot;instance-method&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;no-arg&quot;: true,</span><br><span class="line">    &quot;no-bitwise&quot;: true,</span><br><span class="line">    &quot;no-console&quot;: [</span><br><span class="line">      true,</span><br><span class="line">      &quot;debug&quot;,</span><br><span class="line">      &quot;info&quot;,</span><br><span class="line">      &quot;time&quot;,</span><br><span class="line">      &quot;timeEnd&quot;,</span><br><span class="line">      &quot;trace&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;no-construct&quot;: true,</span><br><span class="line">    &quot;no-consecutive-blank-lines&quot;: [  // 空白行最多几行 (新增)</span><br><span class="line">      true,</span><br><span class="line">      3</span><br><span class="line">    ],</span><br><span class="line">    &quot;no-debugger&quot;: false,</span><br><span class="line">    &quot;no-duplicate-super&quot;: true,</span><br><span class="line">    &quot;no-duplicate-switch-case&quot;: true, // 是否禁止重复 case (新增)</span><br><span class="line">    &quot;no-duplicate-imports&quot;: true,     // 是否禁止重复 import (新增)</span><br><span class="line">    &quot;no-duplicate-variable&quot;: [        // 是否禁止重复变量声明 (新增)</span><br><span class="line">      true,</span><br><span class="line">      &quot;check-parameters&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;no-conditional-assignment&quot;: true, // 禁止在分支条件判断中有赋值操作 (新增)</span><br><span class="line">    &quot;no-empty&quot;: false,</span><br><span class="line">    &quot;no-empty-interface&quot;: true,</span><br><span class="line">    &quot;no-eval&quot;: true,</span><br><span class="line">    &quot;no-inferrable-types&quot;: [  // 是否禁止在有初始值的变量声明上，增加类型声明 (默认 true)</span><br><span class="line">      false,</span><br><span class="line">      &quot;ignore-params&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;no-mergeable-namespace&quot;: true, // 是否禁止重复的命名空间 (新增)</span><br><span class="line">    &quot;no-misused-new&quot;: true,</span><br><span class="line">    &quot;no-non-null-assertion&quot;: true,</span><br><span class="line">    &quot;no-shadowed-variable&quot;: true,</span><br><span class="line">    &quot;no-string-literal&quot;: false,</span><br><span class="line">    &quot;no-string-throw&quot;: true,</span><br><span class="line">    &quot;no-switch-case-fall-through&quot;: true,</span><br><span class="line">    &quot;no-trailing-whitespace&quot;: false,      // 是否禁止末尾空格 (默认 true)</span><br><span class="line">    &quot;no-unnecessary-initializer&quot;: true,</span><br><span class="line">    &quot;no-unused-expression&quot;: false,  // 是否允许无用的表达式存在 (默认 true)</span><br><span class="line">    &quot;no-unused-variable&quot;: false,   // 是否允许无用的变量存在 (新增)</span><br><span class="line">    &quot;no-use-before-declare&quot;: true,</span><br><span class="line">    &quot;no-unsafe-finally&quot;: true,</span><br><span class="line">    &quot;no-for-in-array&quot;: true,</span><br><span class="line">    &quot;no-var-keyword&quot;: true,</span><br><span class="line">    &quot;object-literal-sort-keys&quot;: false,</span><br><span class="line">    &quot;one-line&quot;: [</span><br><span class="line">      true,</span><br><span class="line">      &quot;check-open-brace&quot;,</span><br><span class="line">      &quot;check-catch&quot;,</span><br><span class="line">      &quot;check-else&quot;,</span><br><span class="line">      &quot;check-whitespace&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;prefer-const&quot;: false,  // 不强制使用 const，允许使用 let</span><br><span class="line">    &quot;quotemark&quot;: [  // 引号设置，ts 中单引号</span><br><span class="line">      true,</span><br><span class="line">      &quot;single&quot;,</span><br><span class="line">      &quot;jsx-double&quot;,</span><br><span class="line">      &quot;avoid-escape&quot;,</span><br><span class="line">      &quot;avoid-template&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;radix&quot;: true,</span><br><span class="line">    &quot;semicolon&quot;: [</span><br><span class="line">      true,</span><br><span class="line">      &quot;always&quot;,</span><br><span class="line">      &quot;ignore-interfaces&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;space-within-parens&quot;: [</span><br><span class="line">      true,</span><br><span class="line">      0</span><br><span class="line">    ],</span><br><span class="line">    &quot;triple-equals&quot;: [</span><br><span class="line">      true,</span><br><span class="line">      &quot;allow-null-check&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;typedef-whitespace&quot;: [</span><br><span class="line">      true,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;call-signature&quot;: &quot;nospace&quot;,</span><br><span class="line">        &quot;index-signature&quot;: &quot;nospace&quot;,</span><br><span class="line">        &quot;parameter&quot;: &quot;nospace&quot;,</span><br><span class="line">        &quot;property-declaration&quot;: &quot;nospace&quot;,</span><br><span class="line">        &quot;variable-declaration&quot;: &quot;nospace&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;unified-signatures&quot;: true,</span><br><span class="line">    &quot;variable-name&quot;: false,</span><br><span class="line">    &quot;whitespace&quot;: [</span><br><span class="line">      true,</span><br><span class="line">      &quot;check-branch&quot;,</span><br><span class="line">      &quot;check-decl&quot;,</span><br><span class="line">      &quot;check-operator&quot;,</span><br><span class="line">      &quot;check-separator&quot;,</span><br><span class="line">      &quot;check-type&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;no-output-on-prefix&quot;: true,</span><br><span class="line">    &quot;use-input-property-decorator&quot;: true,</span><br><span class="line">    &quot;use-output-property-decorator&quot;: true,</span><br><span class="line">    &quot;use-host-property-decorator&quot;: true,</span><br><span class="line">    &quot;no-input-rename&quot;: true,</span><br><span class="line">    &quot;no-output-rename&quot;: true,</span><br><span class="line">    &quot;use-life-cycle-interface&quot;: true,</span><br><span class="line">    &quot;use-pipe-transform-interface&quot;: true,</span><br><span class="line">    &quot;component-class-suffix&quot;: true,</span><br><span class="line">    &quot;directive-class-suffix&quot;: true</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>tslint.json 文件只是用来在执行 <code>ng lint</code> 命令，或者代码编程过程中，开发工具实时检测，当检测到不符合风格规范的代码时，进行报错处理。</p>
<p>虽然可以在执行 <code>ng lint --fix</code> 时添加 <code>--fix</code> 参数来自动修正一些风格错误，但这种方式很耗时，而是代码编写过程中，也没法应用。</p>
<p>所以，可以借助 Webstorm 的一些配置，一些小技巧，来进行代码的格式化操作，让开发工具自动帮我们将代码整理成符合规范的风格。</p>
<h1 id="WebStorm-小技巧"><a href="#WebStorm-小技巧" class="headerlink" title="WebStorm 小技巧"></a>WebStorm 小技巧</h1><p>下面介绍的这些配置项，都是为代码的格式化操作（快捷键：<code>Ctrl + Alt + L</code>）服务的，意思也就是说，当我们为当前文件进行代码格式化操作时，WebStorm 就会自动按照我们的这些配置项来自动整理代码，将代码整理成遵循规范的风格。</p>
<h3 id="标点符号（引号，分号，逗号）"><a href="#标点符号（引号，分号，逗号）" class="headerlink" title="标点符号（引号，分号，逗号）"></a>标点符号（引号，分号，逗号）</h3><p>设置路径：<code>Settings -&gt; Editor -&gt; Code Style -&gt; TypeScript -&gt; Punctuation</code>  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a09aa1367d940f1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>这里配置项很少，就三个，分别是配置分号，引号和逗号。</p>
<ul>
<li><p>第一行用来配置每行代码末尾是否需要有 <code>;</code> 分号，且格式化时是否对旧代码（已经过格式化的代码）进行处理。</p>
</li>
<li><p>第二行用来配置，代码中是使用 <code>&#39;&#39;</code> 单引号，还是 <code>&quot;&quot;</code> 双引号（默认是双引号），且格式化时是否对旧代码（已经过格式化的代码）进行处理。</p>
</li>
<li><p>第三行用来配置是否需要保留，还是去掉数组或对象属性列表中，最后一项末尾的逗号。</p>
</li>
</ul>
<p>我的代码风格是 HTML 中使用 <code>&quot;&quot;</code> 双引号，TypeScript 中使用 <code>&#39;&#39;</code> 单引号，但使用工具自动生成 ts 文件时，引号默认是双引号，或者某些时候某些因素下，代码中出现一些双引号，这时候，通过修改这个配置，在每次格式化代码时，就都会自动将双引号转成单引号，方便、高效。</p>
<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>设置路径：<code>Settings -&gt; Editor -&gt; Code Style -&gt; TypeScript -&gt; Spaces</code>  </p>
<p>格式化操作时，会自动在比如方法的 <code>{</code> 右括号前，赋值语句的 <code>=</code> 等号两侧等等这些位置自动加上一个空格，如果我们写代码时漏掉这些空格时。</p>
<p>这个功能其实是根据这里的配置项来决定的，这里面默认勾选了很多，基本符合常见的风格规范：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-4444c2d4e47fe1ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>对于空格，我没有改掉默认格式化时空格风格，只是增加了几种场景也需要自动进行空格处理，分别是：</p>
<ul>
<li>Within -&gt; ES6 import/export braces</li>
</ul>
<p>导入语句 <code>{}</code> 距离内容之间增加一个空格，默认是没有的，如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f7b4502ca73d1382.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<ul>
<li>Within -&gt; Object literal braces 勾选</li>
<li>Within -&gt; Object literal type braces 勾选</li>
</ul>
<p>这两个是对象内部的空格处理，默认也是没有的，如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-58481a48f99c1716.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<h3 id="对齐和换行"><a href="#对齐和换行" class="headerlink" title="对齐和换行"></a>对齐和换行</h3><p>设置路径：<code>Settings -&gt; Editor -&gt; Code Style -&gt; TypeScript -&gt; Wrapping and Braces</code>  </p>
<p>这里是设置一些对齐或者换行策略：</p>
<ul>
<li>Chained method calls 设置为 Wrap always</li>
<li>Chained method calls -&gt; Align when multiline 勾选</li>
<li>Chained method calls -&gt; ‘:’ on new line 勾选</li>
</ul>
<p>上面三个是用来设置方法链时，代码的整理，默认不做处理，可以改成格式化时，自动将每层的方法调用进行换行，并且对齐处理，个人建议。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-c14c88a54699907b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>‘if()’ statement -&gt; Force braces 设置为 always</li>
</ul>
<p>这个是设置，即使 if 代码块内只有简单的一行代码，也要自动为其加上大括号处理，默认是不做处理。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-980fc42055c29eeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>Ternaty operation 设置为 Chop down if long</li>
<li>Ternaty operation -&gt; Align when multiline 勾选</li>
<li>Ternaty operation -&gt; ‘?’ and ‘:’ signs on next line 勾选</li>
</ul>
<p>这个是用来设置 <code>? :</code> 运算符的处理，上面的设置意思是，当代码过长时，自动将 <code>?</code> 和 <code>:</code> 的代码换行，并对其处理，默认是不做处理。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-384a716038b37bb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<ul>
<li>Array initializer 设置为 Chop down if long</li>
<li>Array initializer -&gt; Align when multiline 勾选</li>
<li>Array initializer -&gt; New line after ‘[‘ 勾选</li>
<li>Array initializer -&gt; Place ‘]’ on new line 勾选</li>
</ul>
<p>这个是用来设置数组的处理，以上配置的意思是，当数组过长时，自动将每一项进行换行并对其处理，<code>[]</code> 单独占据一行：</p>
<p>[图片上传失败…(image-e2d886-1553268791353)]  </p>
<p>对于 Angular 中的 @NgModel 的文件来说，经常会有这种风格需要，所以就直接这么配置了。</p>
<ul>
<li>Objects -&gt; Align 设置为 On Value</li>
<li>Variable declarations 设置为 Chop down if long</li>
<li>Variable declarations -&gt; Align 设置为 when grouped</li>
</ul>
<p>这个是用来设置变量或者对象的属性列表的赋值语句的对齐模式，如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-acbb903450cf5dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5ac7ee768f2b644b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>同理，也可以设置 CSS 的样式属性的对齐方式：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-b30e1b207292d771.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>以上，只是我的个人风格习惯，大体上，我都直接按照默认的风格规范来遵守，但在个把一些项上，个人有不同的看法和习惯，所以修改掉了默认的风格配置。</p>
<p>另外，我比较习惯使用格式化代码操作，而且一个项目中，代码全是我自己写的可能性也很小，别人写的代码或多或少都存在一些风格规范问题，也没办法强制性要求他人必须遵守，所以，就瞎折腾了下 WebStorm 的相关配置。</p>
<p>这样，就方便我对别人的代码也直接通过格式化操作来自动进行风格规范处理。</p>
]]></content>
      <categories>
        <category>Angular</category>
      </categories>
  </entry>
  <entry>
    <title>Angular学习（02）-- Angular-CLI 命令</title>
    <url>/2019/07/15/Angular/Angular%E5%AD%A6%E4%B9%A0%EF%BC%8802%EF%BC%89--Angular-CLI%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容梳理自以下来源：</p>
<ul>
<li><a href="https://www.angular.cn/docs" target="_blank" rel="noopener">Angular 官方中文版教程</a></li>
</ul>
<p>官方的教程，其实已经很详细且易懂，这里再次梳理的目的在于复习和巩固相关知识点，刚开始接触学习 Angular 的还是建议以官网为主。</p>
<p>因为这系列文章，更多的会带有我个人的一些理解和解读，由于目前我也才刚开始接触 Angular 不久，在该阶段的一些理解并不一定是正确的，担心会有所误导，所以还是以官网为主。</p>
<h1 id="正文-Angular-CLI-命令"><a href="#正文-Angular-CLI-命令" class="headerlink" title="正文- Angular-CLI 命令"></a>正文- Angular-CLI 命令</h1><p>Angular 的项目其实相比老旧的前端项目模式或者是 Vue 的项目来说，都会比较重一点，因为它包括了： 模块 @NgModel， 组件 @Component， 指令 @Directive 等各种各样的东西，而每一种类型的 ts 文件，都需要有一些元数据的配置项。</p>
<p>这就导致了，如果是手工创建 ts 文件，需要自己编写很多重复代码，因此，可以借助 Angular-CLI 命令来创建这些文件，自动生成所需的这些重复代码。</p>
<p>而且，不仅在创建文件方面，在对项目的编译、打包等各种操作中也需要借助 Angular-CLI。</p>
<p>所以，日常开发中，不管是借助 WebStrom 的图形操作，还是直接自己使用命令方式，都需要跟 Angular-CLI 打交道，了解一些基本的配置和命令也是有好处的。</p>
<p>安装的方式就不讲了，要么直接使用 WebStrom 内置的，要么借助 npm 下载一个，要么通过 WebStrom 创建的 Angular 项目的 package.json 中就会自动配置一个 cli 依赖库。</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p> 命令格式：ng commandNameOrAlias arg [optionalArg] [options]</p>
<p>也就是 ng 之后带相应命令或命令的别名，接着带命令所需的参数，如果有多个参数就紧接着，最后是一些选项配置，选项的格式都加 <code>--</code> 前缀，如 <code>--spec=false</code> </p>
<p>示例：ng g component –flat –spec=false</p>
<p>g 是 generate 命令的别名，component 是 g 命令的参数，表示要创建组件，–flat 和 –spec 是选项配置，具体意思后面说。</p>
<p>Angular-CLI 大体上两种类型的命令，一是创建或修改文件，二是类似运行某个脚本来编译、构建项目。</p>
<p>比如创建项目生成初始骨架的命令、创建组件、指令、服务这类文件命令；</p>
<p>或者是执行 build 编译命令，或者是 server 构建命令等等。</p>
<p>以下是概览，粗体字是我较为常接触的：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">别名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>generate</strong></td>
<td align="center"><strong>g</strong></td>
<td align="center">创建相应的文件，如组件、指令、管道、服务、模块、路由、实体类等</td>
</tr>
<tr>
<td align="center"><strong>build</strong></td>
<td align="center"><strong>b</strong></td>
<td align="center">编译项目，并输出最后的文件到指定目录，可以配置很多参数来达到各种效果，比如实时更新等目的</td>
</tr>
<tr>
<td align="center"><strong>server</strong></td>
<td align="center"><strong>s</strong></td>
<td align="center">编译项目，并让它运行起来，且默认支持实时更新修改</td>
</tr>
<tr>
<td align="center">new</td>
<td align="center">n</td>
<td align="center">创建新项目，生成项目初始骨架，默认包括根模块、根视图，还有基本的各种配置文件</td>
</tr>
<tr>
<td align="center">e2e</td>
<td align="center">e</td>
<td align="center">编译并运行项目，跑起来后，运行 e2e 测试</td>
</tr>
<tr>
<td align="center">lint</td>
<td align="center">l</td>
<td align="center">对项目进行 lint 检查</td>
</tr>
<tr>
<td align="center">test</td>
<td align="center">t</td>
<td align="center">运行单元测试</td>
</tr>
<tr>
<td align="center">help</td>
<td align="center"></td>
<td align="center">查看命令的帮助信息</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">还有一些没用过，也不大清楚的命令，后续再补充</td>
</tr>
</tbody></table>
<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><p>其实，这么多命令中，我最常使用的，就只有 <code>ng g</code> 命令，也就是 generate 命令，用来生成各种类型的文件代码，比如生成组件、生成服务等。</p>
<p>因为项目开发过程中，就是在编写组件，编写服务，而这些文件又都需要一些元数据配置，自己创建 ts 文件再去写那么代码有些繁琐，借助命令比较方便。</p>
<p>还有，运行项目时，会使用 build 或 server 命令。</p>
<p>所以，下面就只介绍这三个命令，其他命令，等到后续有接触，深入了解后再补充。</p>
<h4 id="ng-g-component"><a href="#ng-g-component" class="headerlink" title="ng g component"></a>ng g component</h4><p><code>ng g component xxx</code> 是用来创建组件的，直接使用该命令，会默认在当前目录下创建一个 xxx 文件夹，并在内部创建以下几个文件：</p>
<ul>
<li>xxx.component.css </li>
<li>xxx.component.html</li>
<li>xxx.component.spec.ts</li>
<li>xxx.component.ts</li>
</ul>
<p>每个文件内都会自动生成一些所需的代码，另外，还会在当前目录所属的模块文件中，将该 xxxComponent 组件声明在相应的 declarations 列表中。</p>
<p>以上是命令的默认行为，如果要改变这个默认行为，有两种方式，一是使用命令时携带一些选项配置，二是直接修改 angular.json 配置文件来替换掉默认行为。</p>
<p>先介绍第一种方式，使用命令时，加上一些选项配置：</p>
<table>
<thead>
<tr>
<th>选项配置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>–export=true|false</strong></td>
<td>生成的组件在对应的模块文件中，是否自动在 exports 列表中声明该组件好对外公开，默认值 false。</td>
</tr>
<tr>
<td><strong>–flat=true|false</strong></td>
<td>当为 true 时，生成的组件不自动创建 xxx 的文件夹，直接在当前目录下创建那几份文件，默认值 false。</td>
</tr>
<tr>
<td><strong>–spec=true|false</strong></td>
<td>当为 false 时，不自动创建 .spec.ts 文件，默认值为 true。</td>
</tr>
<tr>
<td><strong>–skipTests=true|false</strong></td>
<td>当为 true 时，不自动创建 .spec.ts 文件，默认值 false。该选项配置是新版才有，旧版就使用 –spec 配置。</td>
</tr>
<tr>
<td><strong>–styleext=css|scss|sass|less|styl</strong></td>
<td>设置组件是否使用预处理器，旧版接口</td>
</tr>
<tr>
<td><strong>–style=css|scss|sass|less|styl</strong></td>
<td>设置组件是否使用预处理器，新版接口</td>
</tr>
<tr>
<td><strong>–entryComponent=true|false</strong></td>
<td>当为 true 时，生成的组件自动在其对应的模块内的 entryComponents 列表中声明，默认 false。</td>
</tr>
<tr>
<td><strong>–inlineStyle=true|false</strong></td>
<td>当为 true 时，组件使用内联的 style，不创建对应的 css 文件，默认 false。</td>
</tr>
<tr>
<td><strong>–inlineTemplate=true|false</strong></td>
<td>当为 true 时，组件使用内联的模板，不创建对应的 html 文件，默认 false。</td>
</tr>
<tr>
<td>–lintFix=true|false</td>
<td>当为 true 时，组件创建后，自己进行 lintFix 操作，默认 false。</td>
</tr>
<tr>
<td>–module=module</td>
<td>指定组件归属的模块，默认当前目录所属的模块。</td>
</tr>
<tr>
<td>–prefix=prefix</td>
<td>指定组件 selector 取值的前缀，默认 app。</td>
</tr>
<tr>
<td>–project=project</td>
<td>指定组件归属的 project。</td>
</tr>
<tr>
<td>–selector=selector</td>
<td>指定组件的 selector 名。</td>
</tr>
<tr>
<td>–skipImport=true|false</td>
<td>当为 true，生成的组件不在对应的模块中声明任何信息，默认 false。</td>
</tr>
<tr>
<td>–changeDetection=Default|OnPush</td>
<td>设置改变组件的检测策略，默认 Default。</td>
</tr>
</tbody></table>
<p>以上，是使用 ng g component 命令时，可以携带的一些选项配置，来修改默认的行为，其中，如果选项配置为 true，那么 value 值可以省略，如 <code>--flat=true</code> 可以简写成 <code>--flat</code>。</p>
<p>比如：<code>ng g component xxx --flat --inlineStyle --inlineTemplate --spec=false --export</code></p>
<p>另外，其实这些选项配置中，除了前面几项可能比较常用外，其他的我基本都还没怎么接触过。</p>
<p>下面，讲讲第二种方式，修改 angular.json 配置文件来修改默认行为：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-644a7544a3b0e38f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>也就是在 projects 里选择当前项目，然后再其 schematics 下进行配置，至于 <code>@schematics/angular:component</code> 这串怎么来的，可以去开头第一行所指的那份 schema.json 文件中查找。</p>
<p>其实，这份 schema.json 文件，就是 Angular-CLI 的默认配置，当忘记都有哪些命令或参数，除了可以借助 help 命令或到官网查阅外，也可以到这份文件中查阅。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-cbbce632792906e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>除了组件外，也还有指令、模块等命令的默认配置，可以看下其中一项默认配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"@schematics/angular:component"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"changeDetection"</span>: &#123;</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"Specifies the change detection strategy."</span>,</span><br><span class="line">                <span class="attr">"enum"</span>: [</span><br><span class="line">                    <span class="string">"Default"</span>,</span><br><span class="line">                    <span class="string">"OnPush"</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                <span class="attr">"default"</span>: <span class="string">"Default"</span>,</span><br><span class="line">                <span class="attr">"alias"</span>: <span class="string">"c"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"entryComponent"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"boolean"</span>,</span><br><span class="line">                <span class="attr">"default"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"Specifies if the component is an entry component of declaring module."</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"export"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"boolean"</span>,</span><br><span class="line">                <span class="attr">"default"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"Specifies if declaring module exports the component."</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"flat"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"boolean"</span>,</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"Flag to indicate if a directory is created."</span>,</span><br><span class="line">                <span class="attr">"default"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"inlineStyle"</span>: &#123;</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"Specifies if the style will be in the ts file."</span>,</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"boolean"</span>,</span><br><span class="line">                <span class="attr">"default"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"alias"</span>: <span class="string">"s"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"inlineTemplate"</span>: &#123;</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"Specifies if the template will be in the ts file."</span>,</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"boolean"</span>,</span><br><span class="line">                <span class="attr">"default"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"alias"</span>: <span class="string">"t"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"module"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"Allows specification of the declaring module."</span>,</span><br><span class="line">                <span class="attr">"alias"</span>: <span class="string">"m"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"prefix"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                <span class="attr">"format"</span>: <span class="string">"html-selector"</span>,</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"The prefix to apply to generated selectors."</span>,</span><br><span class="line">                <span class="attr">"alias"</span>: <span class="string">"p"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"selector"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                <span class="attr">"format"</span>: <span class="string">"html-selector"</span>,</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"The selector to use for the component."</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"skipImport"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"boolean"</span>,</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"Flag to skip the module import."</span>,</span><br><span class="line">                <span class="attr">"default"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"spec"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"boolean"</span>,</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"Specifies if a spec file is generated."</span>,</span><br><span class="line">                <span class="attr">"default"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"styleext"</span>: &#123;</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"The file extension to be used for style files."</span>,</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                <span class="attr">"default"</span>: <span class="string">"css"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"viewEncapsulation"</span>: &#123;</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"Specifies the view encapsulation strategy."</span>,</span><br><span class="line">                <span class="attr">"enum"</span>: [</span><br><span class="line">                    <span class="string">"Emulated"</span>,</span><br><span class="line">                    <span class="string">"Native"</span>,</span><br><span class="line">                    <span class="string">"None"</span>,</span><br><span class="line">                    <span class="string">"ShadowDom"</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                <span class="attr">"alias"</span>: <span class="string">"v"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在官网中看到的关于 component 的各个选项配置的信息，其实在这份文件中也全列出来了，每一项配置的值类型，描述，默认值都清清楚楚在文件中了。</p>
<h4 id="ng-g-directive"><a href="#ng-g-directive" class="headerlink" title="ng g directive"></a>ng g directive</h4><p>这个是创建指令的命令，组件其实是指令的一种，所以，上面介绍的关于组件命令中的各种选项配置，在指令这里也基本都可以使用，这里不列举了，清楚相关默认文件来源后，不懂的，去翻阅下就可以了。</p>
<p>因为指令并没有对应的 Template 模板和 CSS 样式文件，所以，默认生成的文件中，只有 xxx.directive.ts 和 xxx.spec.ts 两份文件。</p>
<h4 id="ng-g-pipe"><a href="#ng-g-pipe" class="headerlink" title="ng g pipe"></a>ng g pipe</h4><p>这个是创建管道的命令，它支持的选项配置跟指令的命令基本一样。</p>
<p>所以，同样的，它生成的也只有两份文件，ts 文件和测试文件。</p>
<h4 id="ng-g-service"><a href="#ng-g-service" class="headerlink" title="ng g service"></a>ng g service</h4><p>这个是创建服务类的命令，支持的选项配置参考上面几种命令。</p>
<p>默认生成的有两份文件，ts 和 测试文件。</p>
<h4 id="ng-g-class-interface-enum"><a href="#ng-g-class-interface-enum" class="headerlink" title="ng g class/interface/enum"></a>ng g class/interface/enum</h4><p>创建实体类，接口，或枚举的命令，因为这些类型的文件，默认需要的代码模板并不多，即使不用命令创建，手动创建也行。</p>
<h4 id="ng-g-module"><a href="#ng-g-module" class="headerlink" title="ng g module"></a>ng g module</h4><p>创建一个模块，这个命令有几个比较常用的选项配置：</p>
<ul>
<li><strong>–flat=true|false</strong></li>
</ul>
<p>当为 true 时，在当前目录下创建指定的 xxx.module.ts 和 xxx-routing.module.ts 文件，默认 false，会自动创建 xxx 的文件夹。</p>
<ul>
<li><strong>–routing=true|false</strong></li>
</ul>
<p>当为 true 时，会自动创建对应的 routing 路由模块，默认 false。</p>
<ul>
<li><strong>–routingScope=Child|Root</strong></li>
</ul>
<p>创建路由模块时，配置项是 Child 还是 Root，默认 Child。</p>
<p>以上，是 <code>ng generate</code> 命令的常见用法，它还可以用来创建其他东西，但我常用的就这几种，而且，很多时候，都不是使用默认的行为，因此常常需要配置选项配置一起使用。</p>
<p>另外，为什么非得用 Angular-CLI 命令来创建文件，用 WebStrom 自己创建个 ts 文件不行吗？</p>
<p>借助 CLI 工具其实就是为了高效开发，减少繁琐的处理，比如，创建一个 xxx.component.ts 文件：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-cc'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;p&gt;</span></span><br><span class="line"><span class="string">      cc works!</span></span><br><span class="line"><span class="string">    &lt;/p&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  styles: []</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CcComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是执行了 <code>ng g component cc --inlineStyle --inlineTemplate</code> 命令后创建的 cc.component.ts 文件的内容，如果不借助 CLI 工具，那么这些代码就需要自己手动去输入，即使复制黏贴也比较繁琐。</p>
<h4 id="ng-server"><a href="#ng-server" class="headerlink" title="ng server"></a>ng server</h4><p>使用该命令，可以编译我们的项目，并在本地某个端口上运行该项目，默认还可以做到实时更新修改，不用重新编译，是本地调试项目常用的命令。</p>
<p>目前对该命令的使用，只接触到默认配置，还不清楚一些选项配置的适用场景，后续有了解再补充。</p>
<h4 id="ng-build"><a href="#ng-build" class="headerlink" title="ng build"></a>ng build</h4><p>该命令用来将 Angular 项目编译、打包输出到指定目录下，最终输出的文件就是些 HTML，CSS，JavaScript 这些浏览器能够识别、运行的文件。</p>
<p>有时候，前端和后端的工作都由同一个人开发，此时在本地调试时，前端就没必要造假数据，可以直接将 Angular 项目编译输出到后端项目的容器中，直接在本地调试后端接口。</p>
<p>那么，这种时候就不能用 <code>ng server</code> 命令了，只能使用 <code>ng build</code> 命令，但该命令，默认只是编译项目，那么岂不是每次代码发生修改，都得重新跑一次 <code>ng build</code> 命令？当项目有些复杂时，岂不是需要浪费很多时间？</p>
<p>这种时候，就该来了解了解这个命令的一些选项配置了，经过配置，它也可以达到类似 <code>ng server</code> 命令一样自动检测文件变更并增量更新部署，提高开发效率。</p>
<table>
<thead>
<tr>
<th>选项配置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>–watch=true|false</strong></td>
<td>当为 true 时，会自动检测文件变更，并同步更新，默认 false</td>
</tr>
</tbody></table>
<p>还有其他配置项，没使用过，就用过这个，因为我们是直接前端后端一起做，后端用了 spring boot，所以 Angular 项目使用 <code>ng build</code> 命令编译输出到后端项目的容器中，后端跑起来，就可以直接在本地调试了。</p>
]]></content>
      <categories>
        <category>Angular</category>
      </categories>
  </entry>
  <entry>
    <title>Angular学习（01）-- 架构概览</title>
    <url>/2019/07/14/Angular/Angular%E5%AD%A6%E4%B9%A0(01)-%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容梳理自以下来源：</p>
<ul>
<li><a href="https://www.angular.cn/docs" target="_blank" rel="noopener">Angular 官方中文版教程</a></li>
</ul>
<p>官方的教程，其实已经很详细且易懂，这里再次梳理的目的在于复习和巩固相关知识点，刚开始接触学习 Angular 的还是建议以官网为主。</p>
<p>因为这系列文章，更多的会带有我个人的一些理解和解读，由于目前我也才刚开始接触 Angular 不久，在该阶段的一些理解并不一定是正确的，担心会有所误导，所以还是以官网为主。</p>
<p>注：若图片无法显示，可移步至该平台查看<a href="https://www.cnblogs.com/dasusu/p/10518722.html" target="_blank" rel="noopener">本文章</a></p>
<h1 id="正文-架构概览"><a href="#正文-架构概览" class="headerlink" title="正文- 架构概览"></a>正文- 架构概览</h1><p>接触 Angular 大概一个月吧，期间写了个项目，趁现在稍微有点时间，来回顾梳理一下。</p>
<p>其实，如果前端网站并不是特别复杂，那么使用 Angular 无非也就是常跟几个重要的知识点打交道，在官网的核心知识的第一节中就将这些知识点罗列出来了，也就是：架构概览。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-1b6c19239aebba6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Angular架构概览.png">  </p>
<p>画了这个图来大概表示下 Angular 的架构概览，基本涉及到一些常见的重要的知识点了，比如：</p>
<ul>
<li>模块</li>
<li>路由</li>
<li>组件</li>
<li>模板</li>
<li>服务</li>
<li>指令</li>
<li>管道</li>
</ul>
<p>不同的类型，文件名通常会都按照一定的规范来命名，以便直接看出该文件的角色。</p>
<p>当然，文件命名只是给开发人员来方便维护、辨别，对于 Angular 来说，这些都是一份份的 ts 文件代码，所以，都需要在相对应的文件中加上一些装饰器比如：@Directive，@Pipe，@Component，@NgModel 等这些，才能够让 Angular 识别出该文件的角色、用途。</p>
<p>基本上，用 Angular 做一个简单的前端项目，就是跟上面这些打交道，理清它们各自的用途及用法，还有之间的联系，基本上，就可以上手进行一些开发了。</p>
<p>当然，像在 Service 服务中，还会有异步编程、HttpClient 网络编程的相关知识点；</p>
<p>在 Component 组件中，也还会有表单、动画相关的编程知识点，这些都是需要进一步去深入学习研究，但从总体架构上来看，就是要先了解以上这些知识点了。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>一个 Angular 项目，至少会有一个模块，即最少都会有一份用 @NgModel 声明的 ts 文件，表明该文件作为模块角色，来管理其他角色。</p>
<p>其他角色包括：组件、指令、管道、服务等等，这些角色必须在模块文件中声明了，才能够被该模块内的其他角色所使用，而且同一个组件、指令、管道不允许同时在多个模块中进行声明，只能通过模块 exports 给其他模块使用。</p>
<p>Angular 里的模块，并不等同于 Android 项目中的模块概念。</p>
<p>在 Android 项目代码中，可能我们会根据功能来进行模块的划分，但这个模块仅仅是抽象上的概念，也就是建个包，把代码都集中管理。</p>
<p>而 Angular 里的模块，不仅可以在项目结构上集中管理同一个模块的代码文件，还可以为模块内的代码提供一个运行的上下文。</p>
<p>意思就是说，不同模块在运行期间互不影响，就好像各自运行在各自的沙箱容器中一样。举个简单的例子，在不同模块中声明相同的变量名，或相同的 css 的类选择器，它们之间并不会起冲突。</p>
<p>当然，模块之间可以有交互，模块可以依赖于另一模块，模块内的可以共享资源等等，所以，NgModel 中有许多需要配置的声明项，比如：</p>
<ul>
<li>declarations：声明属于本模块内的组件、指令、管道</li>
<li>providers：声明属于本模块内的服务</li>
<li>imports：声明本模块所引用的其他模块，通常是 imports 其他模块在 exports 中声明的项</li>
<li>exports：声明本模块对外公开的组件、指令、管道等，在这里公开的项才可以被其他模块所使用</li>
<li>bootstrap：只有根模块才需要配置，用来设置应用主视图，Angular 应用启动后，这里就是入口，类似于 Android 中的入口 Activity</li>
<li>还有其他一些可选配置，比如应用主题，或者动态的组件声明等等</li>
</ul>
<p>在 Angular 中，大多数的模式就是，一个根模块管理着很多功能模块，然后，每个模块管理自己模块内部所使用到的组件、指令、管道、服务、或者需要依赖于其他模块，如果该模块内部的这些角色，有些可以供其他模块使用，那么就需要对外暴露。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>一个项目这么多模块，Angular 并不会一开始就把所有模块都加载，而是惰性加载，按需加载。</p>
<p>那么，什么时候会去加载呢？</p>
<p>就是等某个模块内部的组件被使用的时候会加载，而组件是什么时候会被使用的呢？</p>
<p>有两个时机，一是组件被直接调用；二是触发了路由去加载；</p>
<p>路由通常的配置方式是用一个 @NgModel 声明的模块，但只用其中两项配置：imports 和 exports，imports 用来导入当前模块所有组件与 url 的映射表，而 exports 用来将这些映射表信息暴露，以供相对应的模块去引入使用。</p>
<p>当然，你不想抽离路由配置，直接将其配置在对应模块的 imports 内也可以，抽离的话，相对独立，可维护。</p>
<p>区别于传统的前端网页的跳转方式，Angular 项目是一个单页应用，所谓的单页应用就是说只有一个页面，所有页面的跳转，其实是将当前页面的显示内容进行替换，页面仍旧只有一个，并不会打开新的页面。</p>
<p>而页面的跳转，通常有以下几种场景：</p>
<ul>
<li>用户输入 url 进行跳转</li>
<li>用户点击交互按钮进行跳转</li>
<li>用户操作前进或后退进行跳转</li>
</ul>
<p>这些场景，路由的工作机制都能够很好的支持。</p>
<p>如果网页很简单，只有一个首页，并不存在页面跳转场景，那么可以不用配置路由，只需要在 index.html 中配置根视图，以及在根模块的 bootstrap 中配置根视图组件即可。</p>
<p>但如果项目划分成了多个功能模块，那么应该交由每个模块管理自己的路由表，而后选择一个上层模块，来统一关联各个模块路由，有两种方式：一是在上层模块的 imports 内按照一定顺序来导入各个功能模块；但这种方式想要按照路由层级来查看路由表就比较麻烦，需要到各个模块内部去查看或者借助一些工具。</p>
<p>另一种方式是，在上层模块的路由表中使用 loadChildren 加载各个功能模块，然后各个功能模块默认路由都显示成空视图，各自内部再通过配置 children 的路由表方式来管理各个模块内部自己的路由表。</p>
<h3 id="组件与模板"><a href="#组件与模板" class="headerlink" title="组件与模板"></a>组件与模板</h3><p>在 Angular 中，最常接触的应该就是组件了。</p>
<p>我是这么理解的，组件可以是你在界面上看到的任何东西，可以是一个页面，可以是页面上的一个按钮。</p>
<p>而对于浏览器解析并呈现前端页面时，Html、CSS、JavaScript 这三分文件通常都是需要的，而 Angular 是使用了 TypeScript，所以一个组件，其实就包括了：Html，CSS，TypeScript。</p>
<p>在 Angular 中，可以说，是以组件为单位来组成页面的，组件是核心，因为 Angular 提供的功能基本都是用来为组件服务的。</p>
<p>以上，是我的理解。</p>
<p>但要注意，官网教程中，很多地方的组件描述，更多时候是倾向于表示 TypeScript 的那份文件，因为对于组件来说，TypeScript 可以说是它的核心，CSS 只是样式文件，Html 更类似于模板存在。</p>
<p>所以这里将组件和模板放在一起讲，因为就像开头那张图一样，组件是一份 TypeScript 文件，在该文件中，定义了这个组件的模板（template）来源和 CSS 样式来源。</p>
<p>模板提供了该组件的呈现结构，而 TypeScript 里定义了组件的数据来源及交互行为，它们两一起组织成一个视图呈现给用户。</p>
<p>既然，这份 TypeScript 的组件文件和模板文件需要共同合作，那么它们之间就少不了交互，所以就涉及到很多所谓的模板语法，也就是所谓的组件和模板之间的交互方式。</p>
<p>比如，当要往模板中嵌入 TypeScript 中的变量数据时，可以使用 <code></code> 这种语法形式，同样的，还有模板中标签的属性绑定，事件回调注册的交互方式的语法。</p>
<p>总之，Angular 支持双向数据绑定，是一种以数据驱动的思想来让页面进行交互刷新的方式，区别于传统的前端模式。在以往，如果需要动态的更新 DOM 上的信息时，需要先获取到相对应的元素实例对象，然后调用相应的 DOM API 来操纵 DOM；</p>
<p>而使用 Angular 的话，可以直接在模板的相应元素中，将某个属性与 TypeScript 文件中某个变量直接进行绑定，后续这个变量值变化时，Angular 会自动去更新相应 DOM 的属性，也就是说，原本那些操纵 DOM 的代码，Angular 帮我们做了，我们不用再自己去处理了。</p>
<p>另外，注意，以上出现的 TypeScript 的描述，你可以理解成官网中的组件，我之所以不想用组件的方式来进行描述，是因为，我觉得，组件是一个整体，它本身就包括了 TypeScript 文件和模板文件，所以官网中说的组件和模板的交互，我觉得，换成组件中的 TypeScript 文件与模板文件的交互更为适合。</p>
<p>当然，这只是我目前阶段的理解。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>服务是一个广义上的概念，通常用来处理那些跟 UI 交互无关的事情，比如网络请求的工作等。</p>
<p>所以它也是为组件服务，而且 Angular 有一套依赖注入机制，也就是说，组件只需要告诉 Angular，它需要哪些服务，至于这些服务的实例是什么时候创建，交给谁去管理等这些组件内部都不用自己去处理了。</p>
<p>Angular 会自动创建相关的服务实例，然后在组件适当的时候，将这个实例注入给组件去使用。</p>
<p>这种模式跟以前在 Android 端开发时有所区别，在 Android 端中，当需要业务层某个实例对象时，通常都需要自己内部去初始化，或者这个实例是个单例的话，也需要自己去实现单例。</p>
<p>但在 Angular 中，你可以借助它依赖注入的机制，来让 Angular 帮你去做这些依赖的对象的实例管理的事，如果需要一个全局的单例服务，那么可以将该服务声明成 root 即全局可用；如果需要一个模块内的单例，那么可以在该模块的 providers 中声明该服务；如果需要一个组件自己的实例对象，那么可以在组件的元数据块的 providers 中配置该服务。</p>
<p>总之，就是，跟 UI 交互无关的工作，可以抽到服务中去处理，而该服务实例的管理，交给 Angular 就可以了，组件只需要告诉 Angular 它需要哪种形式的服务即可。</p>
<p>那么，组件是怎么告诉 Angular 的呢？</p>
<p>同样在 Android 项目或者后端项目中，也有一些依赖注入框架，那些通常都是借助注解的方式来实现。</p>
<p>但在 Angular 中，不用这么麻烦，直接在组件的构造函数的参数中，声明某个服务类型的参数即可。</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>指令也是为组件服务的，但是，是在组件的模板文件中来使用。</p>
<p>因为组件的模板，其实就是一份 HTML 文件，基于 HTML 的标签之上，加上一些 Angular 的模板语法，而 Angular 在将这份 HTML 文件代码交给浏览器解析之前，会先自行解析一遍，去将模板中不属于 HTML 的那些语法解析出相应的行为。</p>
<p>而指令分为结构型指令和属性型指令，它们的区别，其实就在于，一个是改变 DOM 的结构，一个是改变 DOM 元素的样式。</p>
<p>所以说，指令的目的，其实就是简化一些操纵 DOM 的工作，比如你需要让某些按钮都具有统一的行为和样式，当被点击时先做什么，再做什么。</p>
<p>实现这个，你当然可以在 TypeScript 中去书写这些逻辑，但要应用到每个按钮上，就比较繁琐。</p>
<p>这个时候，就可以将这些工作都封装到指令内部，然后在每个按钮标签上加上该指令，Angular 在解析模板时，发现了这个指令，就会为每个按钮都加上这么一段程序逻辑。</p>
<p>我个人觉得，指令的功能，让我们处理一些相同的行为，可以更好的去封装，减少冗余和繁琐。</p>
<p>当然，上面举的场景，也可以自己封装个按钮组件，然后在其他模板中，不使用原生按钮，而使用封装后的按钮组件，也可以达到目的。</p>
<p>所以，组件其实也是指令的一种，但组件的实现方式会比较重，有时候，只需要封装一些简单的行为逻辑，就可以直接借助指令的方式封装。</p>
<p>指令的原理也很简单，在模板中某个元素标签上，添加上某个指令后，解析到这个指令时，会进入这个指令的相关工作，而指令内部，会获取到一个当前指令挂载的元素标签对象，既然都拿到这个对象了，那么，在指令内部想对这个元素做什么，都可以了。</p>
<p>指令还有另一个通途，通常用来扩展原有的功能，因为可能项目中，在模板里使用的组件或者 HTML 元素的标签因为种种原生无权或不方便进行修改，而又想在其基础上扩展一些功能，此时就可以利用指令来实现。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道同样是为组件服务，也同样是在组件的模板文件中来使用。</p>
<p>它的用途，在于，将数据按照一定的规则进行转换，比如 Object 对象，转换成 json 格式数据，再比如，long 型的时间，转换成具体的时间日期等等。</p>
<p>Angular 中已经内置了一些管道，也可以自定义管道。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>大概了解了 Angular 的架构概览，接下去就来看看一个简单的 Angular 项目结构，以及各个文件、模块的用途，稍微讲一下。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-45fa3c8f2b84e458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>这是用 WebStrom 创建一个 Angular 项目后，自动生成的简单架构。</p>
<p>在利用 Angular Cli 工具生成脚手架时，默认就已经生成了很多配置项，而且此时，项目已经是可以运行的，因为也自动生成了一个根模块和根视图，默认页面是 Angular 的欢迎界面。</p>
<p>挑几个来讲讲。</p>
<h4 id="angular-json"><a href="#angular-json" class="headerlink" title="angular.json"></a>angular.json</h4><p>这是 Angular-CLI 的配置文件，而 Angular-CLI 是自动化的工程构建工具，也就是利用这个工具，可以帮助我们完成很多工作，比如创建项目、创建文件、构建、打包等等。</p>
<p>原本的 HTML、CSS、JavaScript 的前端开发模式，并没有工程的概念，只要用浏览器打开 HTML 文件就能够运行。而 Angular 引入了 TypeScript，Scss 等浏览器并不无法识别的语言，自然，要让浏览器运行 Angular 项目之前，需要进行一次编译，一次转换。</p>
<p>这些工作就可以借助 Angular-CLI 来进行。另外，创建一个模块，创建一个组件，也都可以通过 Angular-CLI 来。</p>
<p>那么，在创建这些文件或者说，打包编译这些项目文件时，该按照怎样的规则，就是参照 angular.json 这份配置文件。</p>
<p>大概看一下内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "$schema": "./node_modules/@angular/cli/lib/config/schema.json", // 默认的配置项，比如默认配置了 ng g component 生成组件时应该生成哪些文件等等</span><br><span class="line">  "version": 1,</span><br><span class="line">  "newProjectRoot": "projects",</span><br><span class="line">  "projects": &#123;</span><br><span class="line">    "daView": &#123;  // 项目的配置</span><br><span class="line">      "root": "",</span><br><span class="line">      "sourceRoot": "src",  // 源代码路基</span><br><span class="line">      "projectType": "application", // 项目的类型，是应用还是三方库（library)</span><br><span class="line">      "prefix": "app", // 利用命令生成 component 和 directive 的前缀</span><br><span class="line">      "schematics": &#123;&#125;, // 替换掉第一行的 schema.json 中的一些默认配置项，不如创建组件时，不要生成spec文件</span><br><span class="line">      "architect": &#123; // 执行一些构造工作时的配置</span><br><span class="line">        "build": &#123; // 执行 ng build 时的一些配置项</span><br><span class="line">          "builder": "@angular-devkit/build-angular:browser",</span><br><span class="line">          "options": &#123;</span><br><span class="line">            "outputPath": "dist/daView", // 编译后的文件输出的位置</span><br><span class="line">            "index": "src/index.html",   // 构建所需的模板 Index.html</span><br><span class="line">            "main": "src/main.ts",       // 构建所需的文件</span><br><span class="line">            "polyfills": "src/polyfills.ts", // 构建所需的文件</span><br><span class="line">            "tsConfig": "src/tsconfig.app.json", // 对 typescript 编译的配置文件 </span><br><span class="line">            "assets": [ // 构建所需的资源</span><br><span class="line">              "src/favicon.ico",</span><br><span class="line">              <span class="string">"src/assets"</span></span><br><span class="line">            ],</span><br><span class="line">            "styles": [ // 构建所需的样式文件，可以是 scss</span><br><span class="line">              <span class="string">"src/styles.css"</span></span><br><span class="line">            ],</span><br><span class="line">            "scripts": [] // 构建所需的三方库，比如 jQuery</span><br><span class="line">          &#125;,</span><br><span class="line">          "configurations": &#123;/*...*/&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "serve": &#123;/*...*/&#125;, // 执行 ng serve 时的一些配置项</span><br><span class="line">        "extract-i18n": &#123;/*...*/&#125;,</span><br><span class="line">        "test": &#123;/*...*/&#125;,</span><br><span class="line">        "lint": &#123;/*...*/&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "daView-e2e": &#123;/*...*/&#125;,</span><br><span class="line">  "defaultProject": "daView"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，利用 Angular-CLI 生成的初始项目中，有许多基本的文件，这些文件，基本也都在 angular.json 中被配置使用了，每个配置文件基本都有各自的用途。</p>
<p>比如，tslint 用来配置 lint 检查，tsconfig 用来配置 TypeScript 的编译配置，其他那些 html，css，ts，js 文件基本都是 Angular 项目运行所需的基础文件。</p>
<h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>对于一个工程项目来说，依赖的三方库管理工具也很重要，在 Android 项目中，通常是借助 Gradle 或 maven 来管理三方库。</p>
<p>而在 Angular 项目中，是使用 npm 来进行三方库的管理，对应的配置文件就是 package.json。</p>
<p>在这份配置文件中，配置了项目所需要的三方库，npm 会自动去将这些三方库下载到 <code>node_modules</code> 目录中。然后，再去将一些需要一起打包的三方库在 angular.json 中进行配置。 </p>
<h4 id="app-src-源码"><a href="#app-src-源码" class="headerlink" title="app/src 源码"></a>app/src 源码</h4><p>以上就是利用 Angular-CLI 创建项目生成的初始架构中各个文件的大概用途，下面讲讲 Angular 项目的大概运行流程。</p>
<p>在 src 中的 <code>index.html</code> 文件就是单页应用的页面文件，里面的 body 标签内，自动加入了一行根视图的组件：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-573cdd300d4936e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p><code>&lt;app-root&gt;&lt;/app-root&gt;</code> 就是根组件 AppComponent （自动生成的）的组件标签，当 Angular 在 HTML 文件中发现有组件标签时，就会去加载该组件所属的模块，并去解析组件的模板文件，将其嵌入到 HTML 文件的组件标签中。</p>
<p>看一下自动生成的根模块的部分内容：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.component.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.css'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent &#123;</span><br><span class="line">  title = <span class="string">'daView'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>app.module.ts</code> 文件用 @NgModule 表示该文件角色是模块，并在内部配置了它的组件 AppComponent，这样 AppComponent 组件就只属于该模块了，并能够在该模块内的其他组件中被使用。</p>
<p>另外，由于该模块是根模块，所以还需要配置 bootstrap，设置应用的根视图，这个配置需要和 <code>index.html</code> 里的 body 标签内的根视图组件是同一个组件，否则运行时就会报错了。</p>
<p>当项目中模块多了的时候，各模块之间基本是通过路由或者组件来进行相互关联。</p>
<p>比如，我们新创建个 Home 模块，然后在根模块中创建个 app-routing 路由配置文件：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app-routing.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'home'</span>, loadChildren: <span class="string">'./home/home.module#HomeModule'</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes)],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppRoutingModule &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>然后在 app.module.ts 的 imports 中将该路由配置导入，这样当路由到 home 时，会去加载 home 模块，然后看看 home 模块的路由配置：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//home-routing.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HomeComponent&#125; <span class="keyword">from</span> <span class="string">'./home.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HomeCenterComponent&#125; <span class="keyword">from</span> <span class="string">'./component/home-center.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">''</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">''</span>, component: HomeCenterComponent</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [RouterModule.forChild(routes)],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HomeRoutingModule &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>home 模块的默认视图为空，但交由其子视图来控制，所以，当导航到 home 时，home 模块会去加载它内部的 HomeCenterComponent 组件。</p>
<p>以上，是当项目中有多模块时，我的处理方式。</p>
<p>当按照这种方式来实现时，对于了解一个 Angular，就有一定的规律可循了：</p>
<ol>
<li>先找根视图组件，然后确认根视图组件中的 router-outlet 标签的区域，因为这个区域展示的就是由根模块路由导航到的新的组件内容；</li>
<li>去根模块的配置中找到根模块的路由配置表，来查看第一个层级的路由分别对应哪些模块；</li>
<li>去这些相应的模块中，查看它们各自内部的路由配置表，来确定各自模块的默认视图组件是哪个，下一个层级的各个路由所对应的视图组件；</li>
<li>这样，一个页面的组件层次结构就能够很快的理清。  </li>
</ol>
]]></content>
      <categories>
        <category>Angular</category>
      </categories>
  </entry>
  <entry>
    <title>我的2018年--本命的一年</title>
    <url>/2019/01/26/%E7%9E%8E%E6%89%AF%E6%89%AF/%E6%88%91%E7%9A%842018%E5%B9%B4--%E6%9C%AC%E5%91%BD%E7%9A%84%E4%B8%80%E5%B9%B4/</url>
    <content><![CDATA[<p>马上要过年了，年底是稍微忙了点，趁着昨天刚过完年会，这周末抽空写写 2018 的总结。  </p>
<h1 id="本命年"><a href="#本命年" class="headerlink" title="本命年"></a>本命年</h1><p>2018 年是我的本命年，都说本命年是比较衰的一年，我反而觉得 18 年是我运气很好的一年，不管是工作上还是生活上。那么，就开始来慢慢的回忆下吧~</p>
<p>首先，先来看下去年写的 17 年的总结：</p>
<blockquote>
<p>3 月 4 月偷偷离校满怀憧憬的跑去公司实习；  </p>
<p>5 月 6 月回校做毕设、写论文，享受最后的校园时光，同时喜欢上了每天跑 3 公里，因为有着一个腹肌梦；  </p>
<p>6 月底找了个基友，啥准备也没有就来了趟毕业旅行，跑到了人生中离开家最远的一次，爬了山，看了水，满足；   </p>
<p>7 月作为职场小菜鸟步入公司，开始打怪升级，同时找了几个同学一起合租，开始学做菜，每天一下班就想着赶回去练手做菜；   </p>
<p>8 月用第一次工资给老爸、老妈换了部手机，当然，找老姐资助了点，但功劳都是我的，哈哈哈；   </p>
<p>9 月用剩余的工资给自己买了很多健身器材，开始了自己的健身梦；   </p>
<p>10 月发现自己还是职场小菜鸟，经验条太长升级太慢，决定做做支线任务，每月至少写篇技术博客；   </p>
<p>10 月底写了第一篇源码分析博客，投给了郭神，过了！成就感瞬间充满，开心，又更有动力了；   </p>
<p>11 月发现小腹肌有了雏形，开心，工作也开始适应了，虽然还是小菜鸟，但多少可以为公司做点贡献了；   </p>
<p>11 月 12 月事情开始多了，做菜的事也放一边了，锻炼也放一边了，给自己找了个借口：天冷；   </p>
<p>12 月底想要总结一下，发现这一年来，喜欢的事很多，尝试的事也很多，但更多的都是没能坚持下去；   </p>
<p>18 年给自己说了句话：锻炼的事得重新拿起来，不能放，博客的事也不能放，得坚持； </p>
</blockquote>
<p>因为 17 年刚刚结束学生时代，正式进入职场，一切都是那么的新奇，对未来也都怀着大大的憧憬，也给自己的 18 年立了几个 flag：</p>
<ul>
<li>坚持写博客</li>
<li>坚持健身</li>
<li>学做菜、学游泳、学会玩</li>
</ul>
<p>emmm，19 年也还是这几个 flag，因为 18 年没能将这些事坚持下去，可能坚持得比较好的就是写博客了。</p>
<p>下面想从工作上、兴趣上、生活上、以及 18 年的遗憾这几点来回忆我的 2018：</p>
<h1 id="工作上"><a href="#工作上" class="headerlink" title="工作上"></a>工作上</h1><p>17 年下半年还可以说自己是刚毕业的小雏鸟，那么 18 年也就是雏鸟不得不长大的一年了。</p>
<p>17 年时，一直是有个师傅带着我做项目，当时有不懂的、做不完的都有师傅顶着，所以工作上并没有太大的压力或者紧迫感。</p>
<p>但 18 年时，师傅由于职业规划内部转岗了，我不得不将师傅负责的项目都接下来，这时候也才算是正在体验到工作的压力吧。</p>
<h3 id="第一次独立设计"><a href="#第一次独立设计" class="headerlink" title="第一次独立设计"></a>第一次独立设计</h3><p>在初期，也就是 2 月 3 月，这时候也还好，因为师傅负责的项目还有另外一个同事协作开发，所以虽然师傅走了，但产品的需求迭代、线上 bug 排查等也都还是由另一位同事主导，我则仍旧倾向于协作打下手。  </p>
<p>但相比于 17 年刚进来时的改改 bug，改改模块的小功能而言，这个时候，我开始参与独立模块的设计与开发了。</p>
<p>记得比较清楚的是，某个大迭代中，有一个全新的功能模块，leader 信任我，交给我来做。当时还是有点担心的，因为那时我还并不清楚这个功能该如何实现，所以很担心自己做不出来。</p>
<p>但毕竟已经毕业半年了，也不能再老是让人罩着了，所以咬咬牙，自己去摸索，查资料、看源码、参考、借鉴别人的实现思路，然后跟老大汇报，老大也给出了一些建议，最后确定了实现方案后就开始写代码了。</p>
<p>做了有两周左右，做出来后是特别开心的，但还是很担心会不会有哪些没注意到的问题，所以提测时跟测试小姐姐解释我的各种实现原理，哈哈哈，可怜测试的小姐姐硬是被我强制灌输了这么多原理性知识。</p>
<p>后来，在提测阶段，leader review 了我写的所有代码，然后整理出了一份 word 文档记录了她对我写的代码的各种建议。</p>
<p>蛮感激 leader 的，没有直说我写的代码烂，而是耐心的跟我说，如果这样设计、这样写会不会更好，我这么写是不是会有一些问题之类的，然后在 leader 建议下，我对代码做了改进，这个过程是真的学到了特别多。</p>
<p>尤其是，写代码时，设计时，应该考虑哪些方面，以前根本没有想过这些，所以那时就觉得同事都好厉害，我也好幸运。</p>
<h3 id="第一次深入源码底层"><a href="#第一次深入源码底层" class="headerlink" title="第一次深入源码底层"></a>第一次深入源码底层</h3><p>因为之前自己独立设计、负责的功能模块，突然被测出一个很严重的问题，因为这个功能重点就是动画，但在某个场景下，动画会特别卡顿，所以被要求必须解决这个问题。</p>
<p>但是，对这个问题，我懵了，束手无策了，因为，这个现象是只有在特定设备、特定渠道中才出现的问题，也就是在其他设备都很正常，偏偏特定设备上出问题。</p>
<p>从代码上根本看不出任何问题，而且在我自己的测试设备上也完全正常，为了定位具体原因，做了很多种猜想，也做了很多测试，但都得不到结果。</p>
<p>在我一筹莫展时，老大来帮我了，他先理清了我实现的原理，后来就带着我去深入 Andorid 的动画还有屏幕刷新的底层源码，从源码上来排查、定位问题。</p>
<p>也就是在这个时候，我学会了碰到疑难问题时，该如何从源码着手；学会了排查一个问题的能力；也学会了很多 Android Studio 的使用技巧，比如 Method Tracing 图的分析。</p>
<p>在这个过程，我也学到了很多 Android 的源码实现原理，能力上也增长了很多，过后，我也将老大带着我深入源码梳理的这些知识写到博客上，也就是这篇：</p>
<p><a href="https://www.cnblogs.com/dasusu/p/8311324.html" target="_blank" rel="noopener">Android 屏幕刷新机制</a></p>
<p>这篇投稿给了郭神的公众号，后来还被鸿神赞赏并转发朋友圈了，加上我发布到博客园和简书上，总的阅读量有小几万，我觉得干货还是有的。</p>
<p>因为写了这篇源码梳理的文章，也引起了我写源码分析博客的兴趣，后续也在动画方面陆续写了几篇，也都投给了郭神的公众号。</p>
<p>说回正事，因为有老大带着，最后定位到了问题后，也就有了相应的解决方案。然后，老大还让我把这次排查这个问题的过程，还有相关知识梳理出来，找个时间给大伙分享一下。</p>
<p>也是因为这个经历，培养了我解决问题的思路和能力。也开启了我们小组的分享、学习氛围。</p>
<p>现在每次碰到疑难问题，第一个想的就是定位，如何定位只是手段，可以利用搜索引擎，可以自己去研究原理，但只要能定位，那么也就能有相应的解决方案，所以一个问题，难的不是如何去解决，难的是是否能够准确定位。</p>
<p>现在，如果我碰到疑难问题，自己解决不了，我也只是会让同事帮忙看看，他觉得问题的根源可能会是在哪，而不是直接寻求解决方案，因为我知道，难点在于定位，这样麻烦同事，也不会占用他太多时间和精力。</p>
<p>同样的，如果有新人来请教我，我也不会直接给出解决方案，也不会直接跟他说问题根源在哪，而是尝试引导他，如何去定位到这个问题的根源，因为老大就是这么带我过来的，我自己觉得这样的方式会比直接帮他处理更有效。  </p>
<p>当然，后面也仍旧碰到过很多很奇葩的疑难问题，这种时候，我已经能够独立去深入源码排查、定位、分析问题了，可以让老大放心的把任务交给我了，比如：</p>
<p>碰到过 so 文件加载异常的奇葩问题，在深入源码后，总结出了这篇：<a href="https://www.cnblogs.com/dasusu/p/9810673.html" target="_blank" rel="noopener">Android 的 so 文件加载机制</a></p>
<p>碰到过 ftp 文件上传的超时处理的奇怪现象，也深入源码梳理出了这篇：<a href="https://www.cnblogs.com/dasusu/p/10006899.html" target="_blank" rel="noopener">记录 FTPClient 超时处理的相关问题</a></p>
<p>还有 ReyclerView 的优化问题，当然也梳理出了这篇满满干货的文章：<a href="https://www.cnblogs.com/dasusu/p/7746946.html" target="_blank" rel="noopener">基于场景解析RecyclerView的回收复用机制原理</a> </p>
<p>当然，因为最初是独立负责动画模块，这方面问题是最多的，也梳理了很多动画源码相关的文章：</p>
<p><a href="https://www.cnblogs.com/dasusu/p/8287822.html" target="_blank" rel="noopener">View 动画 Animation 运行原理解析</a></p>
<p><a href="https://www.cnblogs.com/dasusu/p/8595422.html" target="_blank" rel="noopener">属性动画 ValueAnimator 运行原理全解析</a></p>
<p><a href="https://www.cnblogs.com/dasusu/p/8647702.html" target="_blank" rel="noopener">【Android】你知道还可以通过 View.animate() 来实现动画么</a></p>
<h3 id="第一次主导项目迭代"><a href="#第一次主导项目迭代" class="headerlink" title="第一次主导项目迭代"></a>第一次主导项目迭代</h3><p>之前说过，因为师傅内部转岗了，师傅的项目都交给另一个同事负责，后来这个同事也跳槽了，接触过这些项目的除了老大，就是师傅的徒弟我了，我不得不接下来。</p>
<p>而凑巧，其中一个项目又刚好有一次为期一个月左右的大迭代，对项目最熟悉的也就是我了，能做的也就只有我了。</p>
<p>而老大担心我自己一个人没办法做完，他参与到这个迭代中来帮我，另外又叫了一个对这个项目完全不熟悉的同事也来帮忙。</p>
<p>现在想想，特别感激老大，因为老大原本是没必要参与迭代开发的，也感激另一个同事，临时被抽调来帮忙开发一个自己完全就不熟的项目。</p>
<p>在这个月里，我天天加班，天天十点、十一点才回去，睡觉都在想该如何设计，周末被老妈强制叫回家时都将电脑带回去。</p>
<p>但尽管这样，开发还是延期了，没能按时完成，因为这次的改动特别大，需求特别多，而当初虽然跟着师傅的时候有接触这个项目，但最多也就是改改小 bug，做做小功能，也没花时间去梳理过整个项目，所以其实，说句难听的，虽然我是最熟悉这个项目的，但也就那样。</p>
<p>正是因为这次经历，让我明白了作为一个项目的主要负责人所要承担起的责任，该如何对待你的项目。以前有师傅带着，碰到我解决不了的问题时，就是丢给师傅，抱着的就是这种心态。</p>
<p>但现在不行了，这个项目是你负责的，你解决不了，也没人可以让你丢了，你必须得解决，不得不解决。作为项目主要负责人和师傅的徒弟，对待同个项目是完全两种不一样的态度，观念。</p>
<p>也正是因为这次经历，让我养成了很多好习惯，作为一个项目的主要负责人，这个项目就像你的孩子一样，你需要去了解他的一切。</p>
<p>所以，现在，每次有同事提交代码时，我都会习惯性的过一下他提交的代码，一来了解这次提交了什么、改动了什么；二来，学习同事的设计。</p>
<p>而且，现在对于一个项目而言，如果时间允许，我不会再局限于自己负责的模块了，或多或少也会去了解其他模块的代码。</p>
<p>最后，也因为这一两个月的付出，老大帮我争取到了当季度的部门之星，特别开心，更有成就感也更有动力了。</p>
<h3 id="第一次写专利"><a href="#第一次写专利" class="headerlink" title="第一次写专利"></a>第一次写专利</h3><p>因为部门有着一个专利指标，在 18 年后半年事情不是特别忙的时候，我们老大每周特意抽出一个下午的时间，来给我们讲如何写专利，如何挖掘专利，项目中哪些点可以去挖掘、可以去写。</p>
<p>可能因为我大学时比较喜欢瞎写东西，我的文笔表达还算可以，老大将他的很多想法都跟我说，让我来执笔写。</p>
<p>没让老大失望的是，基本上老大的想法，我都能很好的描述出来，写出来，一年下来跟老大合作得很愉快，我们两一起完成了多篇专利的输出，完美完成并超出预定的指标。</p>
<p>也因此，我们小组被称为部门里的土豪组，因为我们将专利的一半奖金拿来当做小组经费，然后每周下午茶，经常出去嗨皮、玩桌游啦、密室逃脱啦、剧情杀啦等等。</p>
<p>年底，我也因此有幸获评到了公司的年度杰出个人专利奖。感谢老大~</p>
<h3 id="第一次讲课"><a href="#第一次讲课" class="headerlink" title="第一次讲课"></a>第一次讲课</h3><p>18 年后半年，事情不是特别忙，老大为此安排了每周的分享会，想要以为来扩展大伙的技术栈。</p>
<p>为了产品线的后续需要，老大带头学习前端、带我们入门，后来可能是想锻炼我们，又让我们小组内的成员也来分享自己的学习成果。</p>
<p>而我学习时习惯记笔记，曾经学 Android 期间记了两三百页的笔记，这次学习前端，同样记了一大堆笔记。</p>
<p>然后老大让我来给大伙上课，带领大伙入门前端。</p>
<p>从这个时候开始，我们小组基本上每周都会有一次分享会，有时是由我来分享，如果事情太多忙不过来，那么就由另一个同事来分享，或者老大亲自分享来给大伙上课。</p>
<p>如果事情很多，可能一个月就一次，不多时就保持一周一次，总之就是持续不断的分享会。</p>
<p>而我会将每次分享的课程知识点都当做笔记记录下来，记录在一份 word 文档中，截止目前，已经有三百多页了，内容涉及 HTML，CSS，JavaScript，TypeScript 等等，有些是基础的概念知识，但也有很多涉及原理性知识。</p>
<p>后来，抽了时间，将部分内容梳理到博客上，写成一个系列：<a href="https://www.cnblogs.com/dasusu/category/1330072.html" target="_blank" rel="noopener">前端入门</a>  </p>
<p>这个系列，目前已经发表了 25 篇博客了。</p>
<p>年底时，也因为我们小组的持续不断的分享会，我和老大两人都被评选为年度优秀讲师。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我觉得我在工作上，一直都很幸运。</p>
<p>首先是毕业时，可以直接从事我所感兴趣的 Android 开发，然后所在的小组，同事人都很好，教了我很多东西。</p>
<p>有人教我该如何设计代码，该如何去思考，如何去写代码、改代码；</p>
<p>有人教我遇到疑难问题时，如何去排查定位、如何去阅读源码；</p>
<p>我的老大，人也特别好，带着我成长了很多。</p>
<p>大学时，就有想过，等自己在 Android 方面学精了，想试着去扩展自己的技术栈，学学前端，学学后台。很幸运的是，由于产品线调整，在公司内就可以有这样的机会。</p>
<p>虽然目前我的 Android 并不是特别牛逼，但两个方向我都会持续花时间去学习，总之，干着开心，比什么都好。</p>
<h1 id="兴趣上"><a href="#兴趣上" class="headerlink" title="兴趣上"></a>兴趣上</h1><p>我兴趣其实不多，就喜欢写写博客，投稿给大神，然后看着大伙的评论，暗暗自喜；</p>
<p>或者健健身，看着那逐渐成型的小腹肌，深深自恋，虽然因为喜欢喝点小酒，有了点小肚子；</p>
<p>或者阳台上，晒着太阳看书，我特别喜欢看东野圭吾的小说，巨喜欢；</p>
<p>再或者，叫上两三好友，出去吃大餐，厦门有家蛙小侠的店，巨好吃，我是他家的忠实粉丝；</p>
<p>再或者，约上四五好友，买好食材，去他家，我们自己下厨；</p>
<p>再或者，去溜冰？我是很喜欢溜冰，但我朋友都不喜欢，我又不喜欢自己一个人去，所以虽然喜欢，但 18 年就去了一次；</p>
<p>还有，学游泳，因为听说游泳是最好的健身方式，但一直没机会；</p>
<p>然后，没了。</p>
<p>哦，还有，喝点小酒，我不喜欢喝啤酒，因为它让我有了小肚子，也不喜欢喝红酒，因为涩，我就喜欢白酒，钟爱小糊涂神，而且我不爱喝多，就单纯喜欢喝点儿，然后跟朋友吹吹牛逼，聊聊天。</p>
<p>想想我的 18 年，健身坚持到 4 月份左右吧，后面搬家了，搬到民房去，就不想健身了，所以就荒废到现在，因为又搬家了，搬到挺不错的环境，现在 19 年又恢复我的健身了。</p>
<p>然后是做菜，刚毕业时特别想做菜，特别想学，也做了差不多八九个月吧，18 年就渐渐懒了，尤其搬家后就更没做过了，19 年，几个小伙伴又搬到一起了，希望可以继续捡起来。</p>
<p>最后讲讲博客，18 年我唯一能拿得出来的应该就是博客了，我大概从大四开始写，上学期间写得不多，毕业后到现在，不知不觉中，已经写了 100 来篇博客了。</p>
<p>当然，里面并不是全部都是技术博客，有些是我发牢骚，瞎扯的，就像这篇一样。</p>
<p>但技术博客还是占大头，这是让我蛮有成就感的一件事。</p>
<p>18 年大概写了五十几篇吧，我没细数，一般是当我事情不忙时，抽空在晚上或周末写的，事情忙时，可能就顾不上了，所以有些文章会间隔一两个月。</p>
<p>平均下来，每两三周一篇吧，质量上我觉得应该还可以把。</p>
<p>这些博客里，我投给了郭神很多篇，都过了，很开心，也投稿给鸿神过，现在鸿神貌似记得大苏这号人了，哈哈哈，我不清楚，也许有点映像吧，因为加了鸿神微信后，我就经常隔断时间偷偷去鸿神网站打赏，好让他记住我，哈哈哈，我是个心机 boy。</p>
<p>最后，我觉得 18 年，我转变最多的是，我对于知识付费的观念。</p>
<p>因为我接入了帅张和主席的星球，主席（任玉刚）的星球是想学点技术，而帅张的星球是想提高认知。因为帅张说过，同一个层次的圈子里，认知都差不了多少，那么是没有人会来给你讲一些你不知道，或者你这个层次无法理解的观念的，也无法给你一个准确的建议的。</p>
<p>加入帅张星球后，帅张经常在星球里会给我们讲很多事，给很多人的选择提建议，在星球里还是收获蛮多的吧，至少我现在不排斥知识付费了，看见好的文章就会想打赏，因为我觉得这篇文章教会了我一些，那么自然又打赏它的理由；</p>
<p>也懂得了要延迟满足的思想，也学会了要投资给自己，投资自己是一件不会吃亏的事，所以现在舍得给自己花钱了。</p>
<h1 id="生活上"><a href="#生活上" class="headerlink" title="生活上"></a>生活上</h1><p>18 年生活没有 17 年精彩、有趣。</p>
<p>因为 17 年刚毕业，几个小伙子合租了套房，天天聚一起、研究做菜、开开黑，比较热闹；</p>
<p>18 年因为房子到期，大伙各自搬走了，我嫌原本地方离公司太远，来回麻烦，搬到了离公司走路就十几分钟的民房中。</p>
<p>因为是民房，环境自然不怎么好，而宿舍我基本也就晚上回去睡觉用而已，大部分时间都待在公司里，也因为这样，除了博客外，其他的都没有时间、也没有场所去坚持下去了。</p>
<p>所以，好久没自己做菜了，怀念我的糖糖排骨（因为我讨厌醋，做糖醋排骨时故意不加醋），怀念西瓜的招牌碎鸡腿，怀念飞哥的炒豆角，怀念兴姐的蛋糕。</p>
<p>17 年健身了半年，18 年因为搬家后，就荒废掉了，然后又天天待公司，又离公司近，根本没啥运动。是的，我现在已经胖了一圈了。</p>
<p>所以，19 年，我要减肥，减肥！</p>
<p>虽然 18 年，几个小伙伴并没有住在一起了，不过我们还是经常在周末会聚在一起。因为有两个小伙伴是去住的比较豪华，大空间的单间公寓。</p>
<p>所以，周末时，尤其是冬天时，我跟飞哥会去沃尔玛，买上一车的火锅料，然后去西瓜和兴姐的住所，一起吃火锅，吃完一起五黑。</p>
<p>虽然来回很累，要做好久的公交。</p>
<p>但现在， 19 年，我们几个小伙伴又住到一起去了，虽然不是合租，但都在同一个小区里，同一栋楼的不同楼层里，又可以一起玩耍了。</p>
<p>这次搬家，新的环境还不错，四十几平大房间，还有个阳台，所以我自己买了沙发，买了电视，买了书架，就为了回去后可以躺着看电视，阳台晒着太阳看书。</p>
<p>19 年，我要开始我的养老的、惬意的生活~</p>
<h1 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h1><p>18 年有很多遗憾，遗憾很多事没能坚持下去，遗憾我胖了。</p>
<p>最遗憾的是，女神有主了。</p>
<p>哎，其实，18 年我基本把所有的时间都花在公司里了，是的，所以活该我单身。</p>
<p>19 年想多花点时间给自己了，我想遇到她了，不然过年都不知道该怎么回家，我觉得我要扛不住我爸妈的催了。</p>
<h1 id="19-年愿景"><a href="#19-年愿景" class="headerlink" title="19 年愿景"></a>19 年愿景</h1><p>19 年，我还想立很多 flag，还想做很多事，但我不想一个人做。</p>
<p>想带着她，来次随性的旅行，走走停停、看看人群、看看风景、吹吹海风~</p>
<p>想带着她，去厦门吃遍美食广场，胖就胖了，反正那时已经有她了~</p>
<p>想带着她，到处走，她来拍照，我来带她~</p>
<p>想买一堆小说，如果她喜欢，阳台晒着太阳看书，惬意~</p>
<p>希望，这不是个梦  </p>
<hr>
]]></content>
      <categories>
        <category>谈人生</category>
      </categories>
  </entry>
  <entry>
    <title>记录 FTPClient 超时处理的相关问题</title>
    <url>/2018/11/23/Android%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95-FTPClient-%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>apache 有个开源库：<a href="https://github.com/apache/commons-net" target="_blank" rel="noopener">commons-net</a>，这个开源库中包括了各种基础的网络工具类，我使用了这个开源库中的 FTP 工具。</p>
<p>但碰到一些问题，并不是说是开源库的 bug，可能锅得算在产品头上吧，各种奇怪需求。  </p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>当将网络限速成 1KB/S 时，使用 commons-net 开源库中的 FTPClient 上传本地文件到 FTP 服务器上，FTPClient 源码内部是通过 Socket 来实现传输的，当终端和服务器建立了连接，调用 <code>storeFile()</code> 开始上传文件时，由于网络限速问题，一直没有接收到是否传输结束的反馈，导致此时，当前线程一直卡在 <code>storeFile()</code>，后续代码一直无法执行。</p>
<p>如果这个时候去 FTP 服务器上查看一下，会发现，新创建了一个 0KB 的文件，但本地文件中的数据内容就是没有上传上来。</p>
<p>产品要求，需要有个超时处理，比如上传工作超过了 30s 就当做上传失败，超时处理。但我明明调用了 FTPClient 的相关超时设置接口，就是没有一个会生效。</p>
<p>一句话简述下上述的场景问题：</p>
<p><strong>网络限速时，为何 FTPClient 设置了超时时间，但文件上传过程中超时机制却一直没生效？</strong></p>
<p>一气之下，干脆跟进 FTPClient 源码内部，看看为何设置的超时失效了，没有起作用。</p>
<p>所以，本篇也就是梳理下 FTPClient 中相关超时接口的含义，以及如何处理上述场景中的超时功能。</p>
<h1 id="源码跟进"><a href="#源码跟进" class="headerlink" title="源码跟进"></a>源码跟进</h1><p>先来讲讲对 FTPClient 的浅入学习过程吧，如果不感兴趣，直接跳过该节，看后续小节的结论就可以了。</p>
<p>ps:本篇所使用的 commons-net 开源库版本为 3.6</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>首先，先来看看，使用 FTPClient 上传文件到 FTP 服务器大概需要哪些步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.与 FTP 服务器创建连接</span><br><span class="line">ftpClient.connect(hostUrl, port);</span><br><span class="line">//2.登录</span><br><span class="line">ftpClient.login(username, password);</span><br><span class="line">//3.进入到指定的上传目录中</span><br><span class="line">ftpClient.makeDirectory(remotePath);</span><br><span class="line">ftpClient.changeWorkingDirectory(remotePath);</span><br><span class="line">//4.开始上传文件到FTP</span><br><span class="line">ftpClient.storeFile(file.getName(), fis);</span><br></pre></td></tr></table></figure>

<p>当然，中间省略其他的配置项，比如设置主动模式、被动模式，设置每次读取本地文件的缓冲大小，设置文件类型，设置超时等等。但大体上，使用 FTPClient 来上传文件到 FTP 服务器的步骤就是这么几个。</p>
<p>既然本篇主要是想理清超时为何没生效，那么也就先来看看都有哪些设置超时的接口：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a8baa120eab99727.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setTimeout">  </p>
<p>粗体字是 FTPClient 类中提供的方法，而 FTPClient 的继承关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FTPClient extends FTP extends SocketClient</span><br></pre></td></tr></table></figure>

<p>非粗体字的方法都是 SocketClient 中提供的方法。</p>
<p>好，先清楚有这么几个设置超时的接口存在，后面再从跟进源码过程中，一个个来了解它们。</p>
<h3 id="跟进"><a href="#跟进" class="headerlink" title="跟进"></a>跟进</h3><h4 id="1-connect"><a href="#1-connect" class="headerlink" title="1. connect()"></a>1. connect()</h4><p>那么，就先看看第一步的 <code>connect()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SocketClient#connect()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String hostname, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> SocketException, IOException </span>&#123;</span><br><span class="line">	_hostname_ = hostname;</span><br><span class="line">	_connect(InetAddress.getByName(hostname), port, <span class="keyword">null</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SocketClient#_connect()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">_connect</span><span class="params">(InetAddress host, <span class="keyword">int</span> port, InetAddress localAddr, <span class="keyword">int</span> localPort)</span> <span class="keyword">throws</span> SocketException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建socket</span></span><br><span class="line">    _socket_ = _socketFactory_.createSocket();</span><br><span class="line">    <span class="comment">//2.设置发送窗口和接收窗口的缓冲大小</span></span><br><span class="line">    <span class="keyword">if</span> (receiveBufferSize != -<span class="number">1</span>) &#123;</span><br><span class="line">        _socket_.setReceiveBufferSize(receiveBufferSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sendBufferSize != -<span class="number">1</span>) &#123;</span><br><span class="line">        _socket_.setSendBufferSize(sendBufferSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.socket（套接字：ip 和 port 组成）</span></span><br><span class="line">    <span class="keyword">if</span> (localAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        _socket_.bind(<span class="keyword">new</span> InetSocketAddress(localAddr, localPort));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.连接，这里出现 connectTimeout 了</span></span><br><span class="line">    _socket_.connect(<span class="keyword">new</span> InetSocketAddress(host, port), connectTimeout);</span><br><span class="line">    _connectAction_();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以， FTPClient 调用的 <code>connect()</code> 方法其实是调用父类的方法，这个过程会去创建客户端 Socket，并和指定的服务端的 ip 和 port 创建连接，这个过程中，出现了一个 connectTimeout，与之对应的 FTPClient 的超时接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SocketClient#setConnectTimeout()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectTimeout</span><span class="params">(<span class="keyword">int</span> connectTimeout)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.connectTimeout = connectTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于内部是如何创建计时器，并在超时后是如何抛出 SocketTimeoutException 异常的，就不跟进了，有兴趣自行去看，这里就看一下接口的注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Connects this socket to the server with a specified timeout value.</span></span><br><span class="line"><span class="comment">     * A timeout of zero is interpreted as an infinite timeout. The connection</span></span><br><span class="line"><span class="comment">     * will then block until established or an error occurs.</span></span><br><span class="line"><span class="comment">     * (用该 socket 与服务端创建连接，并设置一个指定的超时时间，如果超时时间是0，表示超时时间为无穷大，</span></span><br><span class="line"><span class="comment">     *  创建连接这个过程会进入阻塞状态，直到连接创建成功，或者发生某个异常错误）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   endpoint the &#123;<span class="doctag">@code</span> SocketAddress&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   timeout  the timeout value to be used in milliseconds.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IOException if an error occurs during the connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  SocketTimeoutException if timeout expires before connecting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  java.nio.channels.IllegalBlockingModeException</span></span><br><span class="line"><span class="comment">     *          if this socket has an associated channel,</span></span><br><span class="line"><span class="comment">     *          and the channel is in non-blocking mode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException if endpoint is null or is a</span></span><br><span class="line"><span class="comment">     *          SocketAddress subclass not supported by this socket</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@spec</span> JSR-51</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SocketAddress endpoint, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释有大概翻译了下，总之到这里，先搞清一个超时接口的作用了，虽然从方法命名上也可以看出来了：</p>
<p><strong><code>setConnectTimeout()</code></strong>： 用于设置终端和服务器建立连接这个过程的超时时间。</p>
<p>还有一点需要注意，当终端和服务端建立连接这个过程中，当前线程会进入阻塞状态，即常说的同步请求操作，直到连接成功或失败，后续代码才会继续进行。</p>
<p>当连接创建成功后，会调用 <code>_connectAction_()</code>，看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SocketClient#_connectAction_()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">_connectAction_</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	_socket_.setSoTimeout(_timeout_);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又出现一个 _timeout_ 了，看看它对应的 FTPClient 的超时接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SocketClient#setDefaultTimeout()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span></span>&#123;</span><br><span class="line">    _timeout_ = timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>setDefaultTimeout()</code></strong> ：用于当终端与服务端创建完连接后，初步对用于传输控制命令的 Socket 调用 <code>setSoTimeout()</code> 设置超时，所以，这个超时具体是何作用，取决于 Socket 的 <code>setSoTimeout()</code>。</p>
<p>另外，还记得 FTPClient 也有这么个超时接口么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SocketClient#setSoTimeout()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSoTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">	_socket_.setSoTimeout(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，对于 FTPClient 而言，<code>setDefaultTimeout()</code> 超时的工作跟 <strong><code>setSoTimeout()</code></strong> 是相同的，区别仅在于后者会覆盖掉前者设置的值。</p>
<h4 id="2-login"><a href="#2-login" class="headerlink" title="2. login()"></a>2. login()</h4><p>接下去看看其他步骤的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FTPClient#login()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    user(username);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> FTPReply.isPositiveCompletion(pass(password));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FTP#user()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">user</span><span class="params">(String username)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sendCommand(FTPCmd.USER, username);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FTP#pass()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pass</span><span class="params">(String password)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sendCommand(FTPCmd.PASS, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，login 主要是发送 FTP 协议的一些控制命令，因为连接已经创建成功，终端发送的 FTP 控制指令给 FTP 服务器，完成一些操作，比如登录，比如创建目录，进入某个指定路径等等。</p>
<p>这些步骤过程中，没看到跟超时相关的处理，所以，看看最后一步上传文件的操作：</p>
<h4 id="3-storeFile"><a href="#3-storeFile" class="headerlink" title="3. storeFile"></a>3. storeFile</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FTPClient#storeFile()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">storeFile</span><span class="params">(String remote, InputStream local)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __storeFile(FTPCmd.STOR, remote, local);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FTPClient#__storeFile()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">__storeFile</span><span class="params">(FTPCmd command, String remote, InputStream local)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _storeFile(command.getCommand(), remote, local);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FTPClient#_storeFile()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">_storeFile</span><span class="params">(String command, String remote, InputStream local)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 创建并连接用于传输 FTP 数据的 Socket</span></span><br><span class="line">    Socket socket = _openDataConnection_(command, remote);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//2. 设置传输监听，这里出现了一个timeout</span></span><br><span class="line">    CSL csl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (__controlKeepAliveTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        csl = <span class="keyword">new</span> CSL(<span class="keyword">this</span>, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Treat everything else as binary for now</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3.开始发送本地数据到FTP服务器</span></span><br><span class="line">        Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在学习 FTP 协议的端口时，还记得么，通常 20 端口是数据端口，21 端口是控制端口，当然这并不固定。但总体上，整个过程分两步：一是先建立用于传输控制命令的连接，二是再建立用于传输数据的连接。</p>
<p>所以，当调用 <code>_storeFile()</code> 上传文件时，会再通过 <code>_openDataConnection_()</code> 创建一个用于传输数据的 Socket，并与服务端连接，连接成功后，就会通过 Util 的 <code>copyStream()</code> 将本地文件 copy 到用于传输数据的这个 Socket 的 OutputStream 输出流上，此时，Socket 底层会自动去按照 TCP 协议往发送窗口中写数据来发给服务器。</p>
<p>这个步骤涉及到很多超时处理的地方，所以就来看看，首先是 <code>_openDataConnection_()</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FTPClient#_openDataConnection_()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Socket <span class="title">_openDataConnection_</span><span class="params">(String command, String arg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//1. 根据被动模式或主动模式创建不同的 Socket 配置</span></span><br><span class="line">    <span class="keyword">if</span> (__dataConnectionMode == ACTIVE_LOCAL_DATA_CONNECTION_MODE) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// We must be in PASSIVE_LOCAL_DATA_CONNECTION_MODE</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//2. 我项目中使用的是被动模式，所以我只看这个分支了</span></span><br><span class="line">        <span class="comment">//3. 创建用于传输数据的 Socket</span></span><br><span class="line">        socket = _socketFactory_.createSocket();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//4. 对这个传输数据的 Socket 设置了 SoTimeout 超时</span></span><br><span class="line">        <span class="keyword">if</span> (__dataTimeout &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            socket.setSoTimeout(__dataTimeout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 跟服务端建立连接，指定超时处理</span></span><br><span class="line">        socket.connect(<span class="keyword">new</span> InetSocketAddress(__passiveHost, __passivePort), connectTimeout);</span><br><span class="line">        <span class="comment">//...        </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> socket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，创建用于传输数据的 Socket 跟传输控制命令的 Socket 区别不是很大，当跟服务端建立连接时也都是用的 FTPClient 的 <code>setConnectTimeout()</code> 设置的超时时间处理。</p>
<p>有点区别的地方在于，传输控制命令的 Socket 是当在与服务端建立完连接后才会去设置 Socket 的 SoTimeout，而这个超时时间则来自于调用 FTPClient 的 <code>setDefaultTimeout()</code> ，和 <code>setSoTimeout()</code>，后者设置的值优先。</p>
<p>而传输数据的 Socket 则是在与服务端建立连接之前就设置了 Socket 的 SoTimeout，超时时间值来自于 FTPClient 的 <code>setDataTimeout()</code>。</p>
<p>那么，<strong><code>setDataTimeout()</code></strong> 也清楚一半了，设置用于传输数据的 Socket 的 SoTimeout 值。</p>
<p>所以，只要能搞清楚，Socket 的 <code>setSoTimeout()</code> 超时究竟指的是对哪个工作过程的超时处理，那么就能够理清楚 FTPClient 的这些超时接口的用途：<code>setDefaultTimeout()</code>，<code>setSoTimeout()</code>，<code>setDataTimeout()</code>。</p>
<p>这个先放一边，继续看 <code>_storeFile()</code> 流程的第二步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FTPClient#_storeFile()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">_storeFile</span><span class="params">(String command, String remote, InputStream local)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//2. 设置传输监听</span></span><br><span class="line">    CSL csl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (__controlKeepAliveTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        csl = <span class="keyword">new</span> CSL(<span class="keyword">this</span>, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Treat everything else as binary for now</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3.开始发送本地数据到FTP服务器</span></span><br><span class="line">        Util.copyStream(local, output, getBufferSize(), CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FTPClient#setControlKeepAliveTimeout()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setControlKeepAliveTimeout</span><span class="params">(<span class="keyword">long</span> controlIdle)</span></span>&#123;</span><br><span class="line">	__controlKeepAliveTimeout = controlIdle * <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FTPClient#setControlKeepAliveReplyTimeout()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setControlKeepAliveReplyTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">	__controlKeepAliveReplyTimeout = timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FTPClient 的最后两个超时接口也找到使用的地方了，那么就看看 CSL 内部类是如何处理这两个 timeout 的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FTPClient$CSL</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CSL</span> <span class="keyword">implements</span> <span class="title">CopyStreamListener</span> </span>&#123;</span><br><span class="line">    CSL(FTPClient parent, <span class="keyword">long</span> idleTime, <span class="keyword">int</span> maxWait) <span class="keyword">throws</span> SocketException &#123;</span><br><span class="line">        <span class="keyword">this</span>.idle = idleTime;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        parent.setSoTimeout(maxWait);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//每次读取文件的过程，都让传输控制命令的 Socket 发送一个无任何操作的 NOOP 命令，以便让这个 Socket keep alive</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bytesTransferred</span><span class="params">(<span class="keyword">long</span> totalBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> bytesTransferred, <span class="keyword">long</span> streamSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> ((now - time) &gt; idle) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                parent.__noop();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">                notAcked++;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Ignored</span></span><br><span class="line">            &#125;</span><br><span class="line">            time = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CSL 是监听 <code>copyStream()</code> 这个过程的，因为本地文件要上传到服务器，首先，需要先读取本地文件的内容，然后写入到传输数据的 Socket 的输出流中，这个过程不可能是一次性完成的，肯定是每次读取一些、写一些，默认每次是读取 1KB，可配置。而 Socket 的输出流缓冲区也不可能可以一直往里写的，它有一个大小限制。底层的具体实现其实也就是 TCP 的发送窗口，那么这个窗口中的数据自然需要在接收到服务器的 ACK 确认报文后才会清空，腾出位置以便可以继续写入。</p>
<p>所以，<code>copyStream()</code> 是一个会进入阻塞的操作，因为需要取决于网络状况。而 <code>setControlKeepAliveTimeout()</code> 方法命名中虽然带有 timeout 关键字，但实际上它的用途并不是用于处理传输超时工作的。它的用途，其实将方法的命名翻译下就是了：</p>
<p><strong><code>setControlKeepAliveTimeout()</code></strong>：用于设置传输控制命令的 Socket 的 alive 状态，注意单位为 s。</p>
<p>因为 FTP 上传文件过程中，需要用到两个 Socket，一个用于传输控制命令，一个用于传输数据，那当处于传输数据过程中时，传输控制命令的 Socket 会处于空闲状态，有些路由器可能监控到这个 Socket 连接处于空闲状态超过一定时间，会进行一些断开等操作。所以，在传输过程中，每读取一次本地文件，传输数据的 Socket 每要发送一次报文给服务端时，根据 <code>setControlKeepAliveTimeout()</code> 设置的时间阈值，来让传输控制命令的 Socket 也发送一个无任何操作的命令 NOOP，以便让路由器以为这个 Socket 也处于工作状态。这些就是 <code>bytesTransferred()</code> 方法中的代码干的事。</p>
<p><strong><code>setControlKeepAliveReplyTimeout()</code></strong>：这个只有在调用了 <code>setControlKeepAliveTimeout()</code> 方法，并传入一个大于 0 的值后，才会生效，用于在 FTP 传输数据这个过程，对传输控制命令的 Socket 设置 SoTimeout，这个传输过程结束后会恢复传输控制命令的 Socket 原本的 SoTimeout 配置。</p>
<p>那么，到这里可以稍微来小结一下：</p>
<p>FTPClient 一共有 6 个用于设置超时的接口，而终端与 FTP 通信过程会创建两个 Socket，一个用于传输控制命令，一个用于传输数据。这 6 个超时接口与两个 Socket 之间的关系：</p>
<p><code>setConnectTimeout()</code>：用于设置两个 Socket 与服务器建立连接这个过程的超时时间，单位 ms。</p>
<p><code>setDefaultTimeout()</code>：用于设置传输控制命令的 Socket 的 SoTimeout，单位 ms。</p>
<p><code>setSoTimeout()</code>：用于设置传输控制命令的 Socket 的 SoTimeout，单位 ms，值会覆盖上个方法设置的值。</p>
<p><code>setDataTimeout()</code>：被动模式下，用于设置传输数据的 Socket 的 SoTimeout，单位 ms。</p>
<p><code>setControlKeepAliveTimeout()</code>：用于在传输数据过程中，也可以让传输控制命令的 Socket 假装保持处于工作状态，防止被路由器干掉，注意单位是 s。</p>
<p><code>setControlKeepAliveReplyTimeout()</code>：只有调用上个方法后，该方法才能生效，用于设置在传输数据这个过程中，暂时替换掉传输控制命令的 Socket 的 SoTimeout，传输过程结束恢复这个 Socket 原本的 SoTimeout。</p>
<h4 id="4-SoTimeout"><a href="#4-SoTimeout" class="headerlink" title="4. SoTimeout"></a>4. SoTimeout</h4><p>大部分超时接口最后设置的对象都是 Socket 的 SoTimeout，所以，接下来，学习下这个是什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Socket#setSoTimeout()</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Enable/disable &#123;<span class="doctag">@link</span> SocketOptions#SO_TIMEOUT SO_TIMEOUT&#125;</span></span><br><span class="line"><span class="comment">     *  with the specified timeout, in milliseconds. With this option set</span></span><br><span class="line"><span class="comment">     *  to a non-zero timeout, a read() call on the InputStream associated with</span></span><br><span class="line"><span class="comment">     *  this Socket will block for only this amount of time.  If the timeout</span></span><br><span class="line"><span class="comment">     *  expires, a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the</span></span><br><span class="line"><span class="comment">     *  Socket is still valid. The option &lt;B&gt;must&lt;/B&gt; be enabled</span></span><br><span class="line"><span class="comment">     *  prior to entering the blocking operation to have effect. The</span></span><br><span class="line"><span class="comment">     *  timeout must be &#123;<span class="doctag">@code</span> &gt; 0&#125;.</span></span><br><span class="line"><span class="comment">     *  A timeout of zero is interpreted as an infinite timeout.</span></span><br><span class="line"><span class="comment">     *  （设置一个超时时间，用来当这个 Socket 调用了 read() 从 InputStream 输入流中</span></span><br><span class="line"><span class="comment">     *    读取数据的过程中，如果线程进入了阻塞状态，那么这次阻塞的过程耗费的时间如果</span></span><br><span class="line"><span class="comment">     *    超过了设置的超时时间，就会抛出一个 SocketTimeoutException 异常，但只是将</span></span><br><span class="line"><span class="comment">     *    线程从读数据这个过程中断掉，并不影响 Socket 的后续使用。</span></span><br><span class="line"><span class="comment">     *    如果超时时间为0，表示无限长。）</span></span><br><span class="line"><span class="comment">     *  （注意，并不是读取输入流的整个过程的超时时间，而仅仅是每一次进入阻塞等待输入流中</span></span><br><span class="line"><span class="comment">     *    有数据可读的超时时间）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the specified timeout, in milliseconds.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span> SocketException if there is an error</span></span><br><span class="line"><span class="comment">     * in the underlying protocol, such as a TCP error.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>   JDK 1.1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getSoTimeout()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSoTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SocketOptions#SO_TIMEOUT</span></span><br><span class="line">   <span class="comment">/** Set a timeout on blocking Socket operations:</span></span><br><span class="line"><span class="comment">     * （设置一个超时时间，用于处理一些会陷入阻塞的 Socket 操作的超时处理，比如：）</span></span><br><span class="line"><span class="comment">     * &lt;PRE&gt;</span></span><br><span class="line"><span class="comment">     * ServerSocket.accept();</span></span><br><span class="line"><span class="comment">     * SocketInputStream.read();</span></span><br><span class="line"><span class="comment">     * DatagramSocket.receive();</span></span><br><span class="line"><span class="comment">     * &lt;/PRE&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;P&gt; The option must be set prior to entering a blocking</span></span><br><span class="line"><span class="comment">     * operation to take effect.  If the timeout expires and the</span></span><br><span class="line"><span class="comment">     * operation would continue to block,</span></span><br><span class="line"><span class="comment">     * &lt;B&gt;java.io.InterruptedIOException&lt;/B&gt; is raised.  The Socket is</span></span><br><span class="line"><span class="comment">     * not closed in this case.</span></span><br><span class="line"><span class="comment">     * （设置这个超时的操作必须要在 Socket 那些会陷入阻塞的操作之前才能生效，</span></span><br><span class="line"><span class="comment">     *   当超时时间到了，而当前还处于阻塞状态，那么会抛出一个异常，但此时 Socket 并没有被关闭）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;P&gt; Valid for all sockets: SocketImpl, DatagramSocketImpl</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Socket#setSoTimeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ServerSocket#setSoTimeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> DatagramSocket#setSoTimeout</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SO_TIMEOUT = <span class="number">0x1006</span>;</span><br></pre></td></tr></table></figure>

<p>以上的翻译是基于我的理解，我自行的翻译，也许不那么正确，你们也可以直接看英文。</p>
<p>或者是看看这篇文章：<a href="https://www.cnblogs.com/renhui/p/7389820.html" target="_blank" rel="noopener">关于 Socket 设置 setSoTimeout 误用的说明</a>，文中有一句解释：</p>
<blockquote>
<p><strong>读取数据时阻塞链路的超时时间</strong> </p>
</blockquote>
<p>我再基于他的基础上理解一波，我觉得他这句话中有两个重点，一是：读取，二是：阻塞。</p>
<p>这两个重点是理解 SoTimeout 超时机制的关键，就像那篇文中所说，很多人将 SoTimeout 理解成链路的超时时间，或者这一次传输过程的总超时时间，但这种理解是错误的。</p>
<p>第一点，SoTimeout 并不是传输过程的总超时时间，不管是上传文件还是下载文件，服务端和终端肯定是要分多次报文传输的，我对 SoTimeout 的理解是，它是针对每一次的报文传输过程而已，而不是总的传输过程。</p>
<p>第二点，SoTimeout 只针对从 Socket 输入流中读取数据的操作。什么意思，如果是终端下载 FTP 服务器的文件，那么服务端会往终端的 Socket 的输入流中写数据，如果终端接收到了这些数据，那么 FTPClient 就可以去这个 Socket 的输入流中读取数据写入到本地文件的输出流。而如果反过来，终端上传文件到 FTP 服务器，那么 FTPClient 是读取本地文件写入终端的 Socket 的输出流中发送给终端，这时就不是对 Socket 的输入流操作了。</p>
<p>总之，<strong><code>setSoTimeout()</code></strong> 用于设置从 Socket 的输入流中读取数据时每次陷入阻塞过程的超时时间。</p>
<p>那么，在 FTPClient 中，所对应的就是，<code>setSoTimeout()</code> 对下述方法有效：</p>
<ul>
<li><code>retrieveFile()</code></li>
<li><code>retrieveFileStream()</code></li>
</ul>
<p>相反的，下述这些方法就无效了：</p>
<ul>
<li><code>storeFile()</code></li>
<li><code>storeFileStream()</code></li>
</ul>
<p>这样就可以解释得通，开头我所提的问题了，在网络被限速之下，由于 <code>sotreFile()</code> 会陷入阻塞，并且设置的 <code>setDataTimeout()</code> 超时由于这是一个上传文件的操作，不是对 Socket 的输入流的读取操作，所以无效。所以，也才会出现线程进入阻塞状态，后续代码一直得不到执行，UI 层迟迟接收不到上传成功与否的回调通知。</p>
<p>最后我的处理是，在业务层面，自己写了超时处理。</p>
<p>注意，以上分析的场景是：FTP 被动模式的上传文件的场景下，相关接口的超时处理。所以很多表述都是基于这个场景的前提下，有一些源码，如 Util 的 <code>copyStream()</code> 不仅在文件上传中使用，在下载 FTP 上的文件时也同样使用，所以对于文件上传来说，这方法就是用来读取本地文件写入传输数据的 Socket 的输出流；而对于下载 FTP 文件的场景来说，这方法的作用就是用于读取传输数据的 Socket 的输入流，写入到本地文件的输出流中。以此类推。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>总结来说，如果是对于网络开发这方面领域内的来说，这些超时接口的用途应该都是基础，但对于我们这些很少接触 Socket 的来说，如果单凭接口注释文档无法理解的话，那可以尝试翻阅下源码，理解下。</p>
<p>梳理之后，FTPClient 一共有 6 个设置超时的接口，而不管是文件上传或下载，这过程，FTP 都会创建两个 Socket，一个用于传输控制命令，一个用于传输文件数据，超时接口和这两个 Socket 之间的关系如下：</p>
<ul>
<li><code>setConnectTimeout()</code> 用于设置终端 Socket 与 FTP 服务器建立连接这个过程的超时时间。</li>
<li><code>setDefaultTimeout()</code> 用于设置终端的传输控制命令的 Socket 的 SoTimeout，即针对传输控制命令的 Socket 的输入流做读取操作时每次陷入阻塞的超时时间。</li>
<li><code>setSoTimeout()</code> 作用跟上个方法一样，区别仅在于该方法设置的超时会覆盖掉上个方法设置的值。</li>
<li><code>setDataTimeout()</code> 用于设置终端的传输数据的 Socket 的 Sotimeout，即针对传输文件数据的 Socket 的输入流做读取操作时每次陷入阻塞的超时时间。</li>
<li><code>setControlKeepAliveTimeout()</code> 用于设置当处于传输数据过程中，按指定的时间阈值定期让传输控制命令的 Socket 发送一个无操作命令 NOOP 给服务器，让它 keep alive。</li>
<li><code>setControlKeepAliveReplyTimeout()</code>：只有调用上个方法后，该方法才能生效，用于设置在传输数据这个过程中，暂时替换掉传输控制命令的 Socket 的 SoTimeout，传输过程结束恢复这个 Socket 原本的 SoTimeout。</li>
</ul>
<p>超时接口大概的用途明确了，那么再稍微来讲讲该怎么用：</p>
<p>针对使用 FTPClient 下载 FTP 文件，一般只需使用两个超时接口，一个是 <code>setConnectTimeout()</code>，用于设置建立连接过程中的超时处理，而另一个则是 <code>setDataTimeout()</code>，用于设置下载 FTP 文件过程中的超时处理。</p>
<p>针对使用 FTPClient 上传文件到 FTP 服务器，建立连接的超时同样需要使用 <code>setConnectTimeout()</code>，但文件上传过程中，建议自行利用 Android 的 Handler 或其他机制实现超时处理，因为 <code>setDataTimeout()</code> 这个设置对上传的过程无效。</p>
<p>另外，使用 <code>setDataTimeout()</code> 时需要注意，这个超时不是指下载文件整个过程的超时处理，而是仅针对终端 Socket 从输入流中，每一次可进行读取操作之前陷入阻塞的超时。</p>
<p>以上，是我所碰到的问题，及梳理的结论，我只以我所遇的现象来理解，因为我对网络编程，对 Socket 不熟，如果有错误的地方，欢迎指证一下。</p>
<h1 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h1><p>最后附上 FTPClient 文件上传过程中，常见的一些异常，便于针对性的进行分析：</p>
<h3 id="1-storeFile-上传文件超时，该超时时间由-Linux-系统规定"><a href="#1-storeFile-上传文件超时，该超时时间由-Linux-系统规定" class="headerlink" title="1.storeFile() 上传文件超时，该超时时间由 Linux 系统规定"></a>1.storeFile() 上传文件超时，该超时时间由 Linux 系统规定</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.commons.net.io.CopyStreamException: IOException caught while copying.</span><br><span class="line">        at org.apache.commons.net.io.Util.copyStream(Util.java:136)</span><br><span class="line">        at org.apache.commons.net.ftp.FTPClient._storeFile(FTPClient.java:675)</span><br><span class="line">        at org.apache.commons.net.ftp.FTPClient.__storeFile(FTPClient.java:639)</span><br><span class="line">        at org.apache.commons.net.ftp.FTPClient.storeFile(FTPClient.java:2030)</span><br><span class="line">        at com.chinanetcenter.component.log.FtpUploadTask.run(FtpUploadTask.java:121)</span><br><span class="line">Caused by: java.net.SocketException: sendto failed: ETIMEDOUT (Connection timed out)</span><br><span class="line">        at libcore.io.IoBridge.maybeThrowAfterSendto(IoBridge.java:546)</span><br><span class="line">        at libcore.io.IoBridge.sendto(IoBridge.java:515)</span><br><span class="line">        at java.net.PlainSocketImpl.write(PlainSocketImpl.java:504)</span><br><span class="line">        at java.net.PlainSocketImpl.access$100(PlainSocketImpl.java:37)</span><br><span class="line">        at java.net.PlainSocketImpl$PlainSocketOutputStream.write(PlainSocketImpl.java:266)</span><br><span class="line">        at java.io.BufferedOutputStream.write(BufferedOutputStream.java:174)</span><br><span class="line">        at</span><br></pre></td></tr></table></figure>

<p>分析：异常的关键信息：ETIMEOUT。</p>
<p>可能的场景：由于网络被限速 1KB/S，终端的 Socket 发给服务端的报文一直收不到 ACK 确认报文（原因不懂），导致发送缓冲区一直处于满的状态，导致 FTPClient 的 <code>storeFile()</code> 一直陷入阻塞。而如果一个 Socket 一直处于阻塞状态，TCP 的 keeplive 机制通常会每隔 75s 发送一次探测包，一共 9 次，如果都没有回应，则会抛出如上异常。</p>
<p>可能还有其他场景，上述场景是我所碰到的，FTPClient 的 <code>setDataTimeout()</code> 设置了超时，但没生效，原因上述已经分析过了，最后过了十来分钟自己抛了超时异常，至于为什么会抛了一次，看了下篇文章里的分析，感觉对得上我这种场景。</p>
<p>具体原理参数：<a href="https://www.cnblogs.com/promise6522/archive/2012/03/03/2377935.html" target="_blank" rel="noopener">浅谈TCP/IP网络编程中socket的行为</a></p>
<h3 id="2-retrieveFile-下载文件超时"><a href="#2-retrieveFile-下载文件超时" class="headerlink" title="2. retrieveFile 下载文件超时"></a>2. retrieveFile 下载文件超时</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.commons.net.io.CopyStreamException: IOException caught while copying.</span><br><span class="line">        at org.apache.commons.net.io.Util.copyStream(Util.java:136)</span><br><span class="line">        at org.apache.commons.net.ftp.FTPClient._retrieveFile(FTPClient.java:1920)</span><br><span class="line">        at org.apache.commons.net.ftp.FTPClient.retrieveFile(FTPClient.java:1885)</span><br><span class="line">        at com.chinanetcenter.component.log.FtpUploadTask.run(FtpUploadTask.java:143)</span><br><span class="line">Caused by: java.net.SocketTimeoutException</span><br><span class="line">        at java.net.PlainSocketImpl.read(PlainSocketImpl.java:488)</span><br><span class="line">        at java.net.PlainSocketImpl.access$000(PlainSocketImpl.java:37)</span><br><span class="line">        at java.net.PlainSocketImpl$PlainSocketInputStream.read(PlainSocketImpl.java:237)</span><br><span class="line">        at java.io.InputStream.read(InputStream.java:162)</span><br><span class="line">        at java.io.BufferedInputStream.fillbuf(BufferedInputStream.java:149)</span><br><span class="line">        at java.io.BufferedInputStream.read(BufferedInputStream.java:234)</span><br><span class="line">        at java.io.PushbackInputStream.read(PushbackInputStream.java:146)</span><br></pre></td></tr></table></figure>

<p>分析：该异常注意跟第一种场景的异常区分开，注意看异常栈中的第一个异常信息，这里是由于 read 过程的超时而抛出的异常，而这个超时就是对 Socket 设置了 <code>setSoTimeout()</code>，归根到 FTPClient 的话，就是调用了 <code>setDataTimeout()</code> 设置了传输数据用的 Socket 的 SoTimeout，由于是文件下载操作，是对 Socket 的输入流进行的操作，所以这个超时机制可以正常运行。</p>
<h3 id="2-Socket-建立连接超时异常"><a href="#2-Socket-建立连接超时异常" class="headerlink" title="2. Socket 建立连接超时异常"></a>2. Socket 建立连接超时异常</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.net.SocketTimeoutException: failed to connect to /123.103.23.202 (port 2121) after 500ms</span><br><span class="line">        at libcore.io.IoBridge.connectErrno(IoBridge.java:169)</span><br><span class="line">        at libcore.io.IoBridge.connect(IoBridge.java:122)</span><br><span class="line">        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:183)</span><br><span class="line">        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:456)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:882)</span><br><span class="line">        at org.apache.commons.net.SocketClient._connect(SocketClient.java:243)</span><br><span class="line">        at org.apache.commons.net.SocketClient.connect(SocketClient.java:202)</span><br><span class="line">        at com.chinanetcenter.component.log.FtpUploadTask.run(FtpUploadTask.java:93)</span><br></pre></td></tr></table></figure>

<p>分析：这是由于 Socket 在创建连接时超时的异常，通常是 TCP 的三次握手，这个连接对应着 FTPClient 的 <code>connect()</code> 方法，其实关键是 Socket 的 <code>connect()</code> 方法，在 FTPClient 的 <code>stroreFile()</code> 方法内部由于需要创建用于传输的 Socket，也会有这个异常出现的可能。</p>
<p>另外，这个超时时长的设置由 FTPClient 的 <code>setConnectTimeout()</code> 决定。</p>
<h3 id="3-其他-TCP-错误"><a href="#3-其他-TCP-错误" class="headerlink" title="3. 其他 TCP 错误"></a>3. 其他 TCP 错误</h3><p>参考：<a href="https://www.ibm.com/support/knowledgecenter/zh/SSEPGG_10.5.0/com.ibm.db2.luw.messages.doc/doc/r0058740.html" target="_blank" rel="noopener">TCP/IP错误列表</a> ，下面是部分截图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-40f90d402ddbf4eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常见错误.png">    </p>
]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>前端25-TypeScript</title>
    <url>/2018/11/07/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A825-%E7%A6%8F%E9%9F%B3-TypeScript/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本篇内容摘抄自以下来源：</p>
<ul>
<li><a href="https://www.tslang.cn/docs/handbook/namespaces.html" target="_blank" rel="noopener">TypeScript 中文网</a></li>
</ul>
<p>只梳理其中部分知识点，更多更详细内容参考官网。</p>
<h1 id="正文-TypeScript"><a href="#正文-TypeScript" class="headerlink" title="正文-TypeScript"></a>正文-TypeScript</h1><p>今天来讲讲有 Java 基础转 JavaScript 的福音：TypeScript</p>
<h3 id="为什么学习-TypeScript"><a href="#为什么学习-TypeScript" class="headerlink" title="为什么学习 TypeScript"></a>为什么学习 TypeScript</h3><p>如果学习 JavaScript 之前已经有了 Java 的基础，那么学习过程中肯定会有很多不习惯的地方，因为 JavaScript 不管是在语法上面、还是编程思想上与 Java 这类语言都有一些差异。</p>
<p>下面就大概来看几个方面的差异：</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>JavaScript 是弱语言，声明变量时无需指明变量的数据类型，运行期间会自动推断，所以声明方式很简单： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> wx = <span class="string">"dasu_Android"</span></span><br></pre></td></tr></table></figure>

<p>Java 是强类型语言，声明变量时必须明确指出变量数据类型： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">String wx = <span class="string">"dasu_Android"</span>;</span><br></pre></td></tr></table></figure>

<p>弱类型语言虽然比较灵活，但也很容易出问题，而且需要一些额外的处理工作，比如函数期待接收数组类型的参数，但调用时却传入了字符串类型，此时 js 引擎并不会报错，对于它来说，这是合理的行为，但从程序、从功能角度来看，也许就不会按照预期的执行，所以通常需要在函数内部进行一些额外处理，如果没有额外处理，那么由于这种参数类型导致的问题也很难排查。 </p>
<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>JavaScript 的变量在 ES5 只有全局作用域和函数内作用域，ES6 新增了块级作用域。</p>
<p>Java 的变量分：类变量和实例变量，属于类的变量如果是公开权限，那么所有地方都允许访问，属于实例的变量，分成员变量和局部变量，成员变量在实例内部所有地方都可以访问，在实例外部如果是公开权限，可通过对象来访问，局部变量只具有块级作用域。</p>
<ul>
<li>变量被覆盖问题</li>
</ul>
<p>因为 JavaScript 在 ES5 时并没有块级作用域，有些场景下会导致变量被覆盖的情况，由于这种情况造成的问题也很难排查，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 中，两次 i 的输出应该 0, -1，因为三个地方的 i 变量并不是同一个，块级作用域内又生成一个新的局部 i 变量，但在 JavaScript 里，ES5 没有块级作用域，函数内三个 i 都是同一个变量，此时就发送变量被覆盖的情况了。</p>
<ul>
<li>拼写错误问题</li>
</ul>
<p>而且，JavaScript 的全局变量会被作为全局对象的属性存在，而在 JavaScript 里对象的属性是允许动态添加的，这就会导致一个问题：当使用某变量，但拼写错误时，js 引擎并不会报错，对它来说，会认为新增了一个全局对象的属性；但从程序，从功能角度来看，常常就会导致预期外的行为，而这类问题也很难排查，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> main = <span class="string">"type-script"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modify</span>(<span class="params">pre</span>) </span>&#123;</span><br><span class="line">    mian = <span class="string">`<span class="subst">$&#123;pre&#125;</span>-script`</span>;</span><br><span class="line">&#125;</span><br><span class="line">modify(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>在 Java 里会找不到 mian 变量报错，但在 JavaScript 里 mian 会被当做全局对象的属性来处理。</p>
<ul>
<li>全局变量冲突问题</li>
</ul>
<p>而且，JavaScript 的变量允许重复申请，这样一来，全局变量一旦多了，很容易造成变量冲突问题，这类问题即使在运行期间也很难被发现和排查，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"js"</span>;</span><br></pre></td></tr></table></figure>

<p>在不同文件中，如果全局变量命名一样，会导致变量冲突，但浏览器不会有任何报错行为，因为对它来说，这是正常的行为，但对于程序来说，功能可能就会出现预期外的行为。 </p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>JavaScript 是基于原型的继承，原型本质上也是对象，所以 JavaScript 中对象是从对象上继承的，同时对象也是由对象创建的，一切都是对象。</p>
<p>Java 中有 class 机制，对象的抽象模板概念，用于描述对象的属性和行为以及继承结构，而对象是从类实例化创建出来的。</p>
<p>正是因为 JavaScript 中并没有 class 机制，所以有 Java 基础的可能会比较难理解 JavaScript 中的继承、实例化对象等原理。</p>
<p>那么在面向对象的编程中，自定义了某个对象，并赋予它一定的属性和行为，这样的描述在 Java 里很容易实现，但在 JavaScript 里却需要通过定义构造函数，对构造函数的 prototype 操作等处理，语义不明确，不怎么好理解，比如定义 Dog 对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Book.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; </span><br><span class="line">Book.prototype.name = <span class="string">"dog"</span>;</span><br></pre></td></tr></table></figure>

<p>对于习惯了 Java 的面向对象编程，在 JavaScript 里自定义一个 Dog 对象的写法可能会很不习惯。</p>
<h4 id="Class-机制"><a href="#Class-机制" class="headerlink" title="Class 机制"></a>Class 机制</h4><p>JavaScript 虽然在 ES6 中加入了 class 写法，但本质上只是语法糖，而且从使用上，仍旧与 Java 的 class 机制有些区别，比如： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(theName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName;</span><br><span class="line">        <span class="keyword">this</span>.ll = <span class="number">23</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    move(distanceInMeters = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是 JavaScript 中 ES6 自定义某个类的用法，与 Java 的写法有如下区别：</p>
<ul>
<li>类的属性只能在构造函数内声明和初始化，无法像 Java 一样在构造函数外面先声明成员变量的存在；</li>
<li>无法定义静态变量或静态方法，即没有 static 语法；</li>
</ul>
<h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>JavaScript 里没有 public 这些权限修饰符，对于对象的属性，只能通过控制它的可配置性、可写性、可枚举性来达到一些限制效果，对于对象，可通过控制对象的可扩展性来限制。</p>
<p>Java 里有 package 权限、publick 权限、protection 权限、private 权限之分，权限修饰符可修饰类、变量、方法，不同权限修饰符可以让被修饰的具有不一样的权限限制。</p>
<p>在 JavaScript 如果要实现对外部隐藏内部实现细节，大多时候，只能利用闭包来实现。</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>JavaScript 虽然在 ES6 中引入了 class 的写法，但本质上只是语法糖，并没有类似 Java 中抽象类、抽象方法的机制存在，即使要模拟，也只能是定义一些抛异常的方法来模拟抽象方法，子类不实现的话，那么在运行期间就会抛异常，比如： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不允许使用该构造函数创建对象，来模拟抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AbstractClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"u can't instantiate abstract class"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有实现的抽象方法，通过抛异常来模拟</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abstractMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"abstract method,u should implement it"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义抽象方法，子类继承之后，如果不自己实现，直接使用会抛异常</span></span><br><span class="line">AbstractClass.prototype.onMearsure = abstractMethod;</span><br><span class="line">AbstractClass.prototype.onLayout = abstractMethod;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-42778af044285005.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>相比于 Java 的抽象类的机制，在编译期间就可以报错的行为，JavaScript 的运行期抛异常行为效果可能没法强制让所有开发者都能正确实现抽象方法。 </p>
<h4 id="对象标识"><a href="#对象标识" class="headerlink" title="对象标识"></a>对象标识</h4><p>JavaScript 由于没有 class 机制，又是基于原型的继承，运行期间原型还可动态变化，导致了在 JavaScript 里没有一种完美的方式可以用来获取对象的标识，以达到区分不同对象的目的。</p>
<p>Java 中的对象都是从类实例化创建出来的，因此通过 instanceof 即可判断不同对象所属类别是否一致。</p>
<p>在 JavaScript 中，只能根据不同使用场景，选择 typeof，instanceof，isPrototypeOf()，对象的类属性，对象的构造函数名等方式来区别不同对象所属类别。</p>
<h4 id="鸭式辩型"><a href="#鸭式辩型" class="headerlink" title="鸭式辩型"></a>鸭式辩型</h4><p>正是由于 JavaScript 里没有 class 机制，没有哪种方式可以完美适用所有需要区分对象的场景，因此在 JavaScript 中有一种编程理念：鸭式辩型（只要会游泳且嘎嘎叫的鸟，也可以认为它是鸭子）</p>
<p>意思就是说，编程中不要从判断对象是否是预期的类别角度出发，而是从判断对象是否具有预期的属性角度出发。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>所以，对于如果有 Java 基础的，JavaScript 学习过程可能会有些不习惯，那么如果是 TypeScript 的话，可以说是个福利，因为 TypeScript 很多语法和编程思想上都跟 Java 很类似，很容易就理解。</p>
<p>那么，来认识下，TypeScript 是什么？</p>
<p>TypeScript 是 JavaScript 的超集，超集是什么意思，就是说，JavaScript 程序可以不加修改就运行在 TypeScript 的环境中，TypeScript 在语法上是基于 JavaScript 进行扩展的。</p>
<p>那么，TypeScript 在 JavaScript 语法基础上做了哪些扩展呢？其实就是加入了各种约束性的语法，比如加入了类似强类型语言的语法。</p>
<p>比如说，声明变量时，需要指定变量的数据类型的约束，以此来减少类型错误导致的问题。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wx:<span class="built_in">string</span> = <span class="string">"dasu_Android"</span>;</span><br></pre></td></tr></table></figure>

<p>其实，本质上是因为 JavaScript 是解释型语言，因为没有编译阶段，很多问题只能是运行期才可能被发现，而运行期暴露的问题也不一定可以很好的排查出来。</p>
<p>而 TypeScript 语法编写的 ts 文件代码，浏览器并不认识，所以需要经过一个编译阶段，编译成 js 文件，那么 TypeScript 就提供了一个编译过程，加上它语法上的支持，在编译期间编译器就可以帮助开发者找出一些可能出错的地方。</p>
<p>举个例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> main = <span class="string">"type-script"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modify</span>(<span class="params">pre</span>) </span>&#123;</span><br><span class="line">    mian = <span class="string">`<span class="subst">$&#123;pre&#125;</span>-script`</span>;</span><br><span class="line">&#125;</span><br><span class="line">modify(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>这个例子中，定义了一个全局变量和一个函数，函数本意是接收一个字符串类型的值，然后修改这个全局变量的值，但开发者可能由于粗心，将全局变量的变量名拼写错误了，而且调用方法时并没有传入字符串类型，而是数字类型。</p>
<p>如果是在 JavaScript 中，这段代码运行期间并不会报错，也不会导致程序异常，js 解释器会认为它是合理的，它会认为这个函数是用来增加全局对象的 mian 属性，同时函数参数它也不知道开发者希望使用的是什么类型，它所有类型都接受。</p>
<p>由于程序并没有出现异常，即使运行期间，开发者也很难发现这个拼写错误的问题，相反，程序由于拼写错误而没有执行预期的功能时，反而会让开发者花费很多时间来排查原因。                                                                         </p>
<p>但这段代码如果是用 TypeScript 来写：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-9a9bc88bd777164f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>这些基础的语法错误，编译器甚至不用进入编译阶段，在开发者刚写完这些代码就能给出错误提示。而且，一些潜在的可能造成错误的代码，在编译阶段也会给出错误提示。 </p>
<p>虽然 TypeScript 语法上支持了很多类似于 Java 语言的特性，比如强类型约束等，但 JavaScript 本质上并不支持，可以看看上面那段代码最后编译成的 js 代码： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> main = <span class="string">"type-script"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modify</span>(<span class="params">pre</span>) </span>&#123;</span><br><span class="line">    mian = <span class="string">`<span class="subst">$&#123;pre&#125;</span>-script`</span>;</span><br><span class="line">&#125;</span><br><span class="line">modify(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>发现没有，编译后的代码其实也就是上述举例的 js 代码段，也就是说，你用 JavaScript 写和用 TypeScript 写，最后的代码都是一样的，区别在于，TypeScript 它有一个编译阶段，借助编译器可以在编译期就能发现可能的语法错误，不用等到运行期。 </p>
<h3 id="WebStrom-配置"><a href="#WebStrom-配置" class="headerlink" title="WebStrom 配置"></a>WebStrom 配置</h3><p>将 TypeScript 编写的 ts 文件编译成 js 文件有两种途径，一是借助命令，二是借助开发工具。</p>
<p>如果电脑已经有安装了 node.js 环境，那么可以直接执行下述命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>

<p>然后打开终端，在命令行执行: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc xxx.ts</span><br></pre></td></tr></table></figure>

<p>tsc 命令就可以将 ts 文件编译输出 js 文件了。</p>
<p>我选择的开发工具是 WebStrom，这个开发工具本身就是支持 TypeScript 的了，如果你有尝试过查看 ES5、ES6 相关 api，你可能会发现：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-e0157b3b4820a9dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>.d.ts 文件就是用 TypeScript 编写的，所以如果你熟悉 TypeScript 的语法，这些代码就能很清楚了，.d.ts 是一份声明文件，作用类似于 C++ 中的 .h 文件。 </p>
<p>在 WebStrom 中右键 -&gt; 新建文件中，可以选择创建 TypeScript 的文件，可以设置 FileWatcher 来自动编译，也可以将项目初始化成 node.js 项目，利用 package.json 里的 scripts 脚本命令来手动触发编译。</p>
<p>我选择的是后者，如果你对 package.json 或 FileWatcher 配置不熟悉，可以参考之前<a href="https://www.cnblogs.com/dasusu/p/10105433.html" target="_blank" rel="noopener">模块化那篇最后对这些配置的介绍</a>。</p>
<p>而编译器在编译过程，类似于 Android 里的 Gradle，可以设置很多配置项，进行不同的编译，而 TypeScript 编译过程对应的配置文件是 tsconfig.json</p>
<h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><p><a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">TypeScript 中文网</a> 里对于这份配置文件的描述很清楚了，这里摘抄部分内容：</p>
<ul>
<li>不带任何输入文件的情况下调用 tsc，编译器会从当前目录开始去查找 tsconfig.json 文件，逐级向上搜索父目录。 </li>
<li>不带任何输入文件的情况下调用 tsc，且使用命令行参数 –project（或 -p）指定一个包含 tsconfig.json 文件的目录。 </li>
<li>当命令行上指定了输入文件时，tsconfig.json 文件会被忽略。</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,     //编译输出的 js 以哪种模块规范实现，有 commonjs,amd,umd,es2015等等</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,          //编译输出的 js 以哪种 js 标准实现，有 es3,es5,es6,es2015,es2016,es2017,es2018等</span><br><span class="line">    &quot;sourceMap&quot;: false,       //编译时是否生成对应的 source map 文件</span><br><span class="line">    &quot;removeComments&quot;: false,  //编译输出的 js 文件删掉注释</span><br><span class="line">    &quot;outDir&quot;: &quot;./js/dist&quot;     //编译输出的 js 路径</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;exclude&quot;: [               //编译时排除哪些文件</span><br><span class="line">    &quot;node_modules&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>最后来看看一些基础语法，你会发现，如果你有 Java 基础，这些是多少的熟悉，用 TypeScript 来编写 js 代码是多么的轻松。</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>ES6 中的数据类型是：number，string，boolean，symbol，null，undefined，object</p>
<p>TypeScript 在此基础上，额外增加了：any，void，enum，never</p>
<ul>
<li>any：表示当前这个变量可以被赋予任何数据类型使用；</li>
<li>void：表示当前这个变量只能被赋予 null 或 undefined，通常用于函数的返回值声明；</li>
<li>enum：枚举类型，弥补 JavaScript 中无枚举的数据类型；</li>
<li>never：表示永不存在的值，常用于死循环函数，抛异常函数等的返回值声明，因为这些函数永远也不会有一个返回值。</li>
</ul>
<p>TypeScript 中的数据类型是用于类型声明服务的，类似于 Java 中定义变量或声明方法的返回值时必须指定一个类型。</p>
<h4 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h4><p>ES5 中声明变量是通过 var，而 ES6 中引入块级作用域后新增了 let 和 const 的声明方式，TypeScript 建议声明变量时，都使用 let，因为 var 会很容易造成很多问题，不管是全局变量还是函数作用域的局部变量。 </p>
<p>先来看看原始类型的声明：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num:<span class="built_in">number</span> = <span class="number">1</span>;      <span class="comment">//声明number类型变量</span></span><br><span class="line"><span class="keyword">let</span> str:<span class="built_in">string</span> = <span class="string">"ts"</span>;   <span class="comment">//声明string类型变量</span></span><br><span class="line"><span class="keyword">let</span> is:<span class="built_in">boolean</span> = <span class="literal">true</span>;   <span class="comment">//声明boolean类型变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>):<span class="title">void</span> </span>&#123;  <span class="comment">//函数参数类型和返回值类型的声明</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个变量时，就可以在变量名后面跟 : 冒号来声明变量的数据类型，如果赋值给变量声明的数据类型之外的类型，编译器会有错误提示；函数的返回值的类型声明方式类似。</p>
<p>如果某个变量的取值可以是任意类型的，那么可以声明为 any：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> variable:<span class="built_in">any</span> = <span class="number">1</span>;    <span class="comment">//声明可为任意类型的变量</span></span><br><span class="line">variable = <span class="literal">true</span>;<span class="comment">//此时赋值其他类型都不会报错</span></span><br></pre></td></tr></table></figure>

<p>如果某个变量取值只能是某几个类型之间，可以用 <code>|</code> 声明允许的多个类型： </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numStr:<span class="built_in">number</span>|<span class="built_in">string</span> = <span class="number">1</span>;   <span class="comment">//声明可为string或number类型变量</span></span><br><span class="line">numStr = <span class="string">"str"</span>;</span><br><span class="line">numStr = <span class="literal">true</span>;<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>如果变量是个数组： </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numArr:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">//声明纯数字数组，如果某个元素不是数字类型，会报错</span></span><br><span class="line"><span class="keyword">let</span> anyArr:<span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="string">"tr"</span>, <span class="literal">true</span>];  <span class="comment">//数组元素类型不限制</span></span><br><span class="line"><span class="keyword">let</span> numStrArr:(<span class="built_in">number</span>|<span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="string">"tr"</span>, <span class="number">2</span>, <span class="number">4</span>];  <span class="comment">// 数组元素类型限制在只能是 number 和 string</span></span><br></pre></td></tr></table></figure>

<p>如果变量是个对象：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj:object = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>但这通常没有什么意义，因为函数，数组，自定义对象都属于 object，所以可以更具体点，比如声明变量是个函数： </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fun:<span class="function">(<span class="params">a:<span class="built_in">number</span></span>)=&gt;</span><span class="built_in">string</span> = <span class="function"><span class="keyword">function</span> (<span class="params">a:<span class="built_in">number</span></span>):<span class="title">string</span> </span>&#123;    <span class="comment">//声明函数类型的变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明 fun 变量是一个函数类型时，还需要将函数的结构声明出来，也就是函数参数，参数类型，返回值类型，通过 ES6 的箭头函数语法来声明。</p>
<p>但赋值的时候，赋值的函数参数类型，返回值类型可以不显示声明，因为编译器可以根据函数体来自动推断，比如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fun:<span class="function">(<span class="params">a:<span class="built_in">number</span></span>)=&gt;</span><span class="built_in">string</span> = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果变量是某个自定义的对象：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Dog &#123;</span><br><span class="line">    name:<span class="built_in">string</span>;</span><br><span class="line">    age:<span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog:Dog = <span class="keyword">new</span> Dog();  <span class="comment">//声明自定义对象类型的变量</span></span><br></pre></td></tr></table></figure>

<p>定义类的语法后面介绍，在 JavaScript 里，鸭式辩型的编程理念比较适用，也就说，判断某个对象是否归属于某个类时，并不是看这个对象是否是从这个类创建出来的，而是看这个对象是否具有类的特征，即类中声明的属性，对象是否拥有，有，则认为这个对象是属于这个类的。如： </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dog:Dog = &#123;name:<span class="string">"dog"</span>, age:<span class="number">123</span>&#125;;  <span class="comment">//可以赋值成功，因为对象直接量具有 Dog 类中的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog1:Dog = &#123;name:<span class="string">"dog"</span>, age:<span class="number">1</span>, sex:<span class="string">"male"</span>&#125;; <span class="comment">//错误，多了个 sex</span></span><br><span class="line"><span class="keyword">let</span> dog2:Dog = &#123;name:<span class="string">"dog"</span>&#125;; <span class="comment">//错误，少了个 age</span></span><br><span class="line"><span class="keyword">let</span> dog3:Dog = &#123;name:<span class="string">"dog"</span>, age:<span class="string">"12"</span>&#125;; <span class="comment">//错误，age 类型不一样</span></span><br></pre></td></tr></table></figure>

<p>以上例子中：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dog1:Dog = &#123;name:<span class="string">"dog"</span>, age:<span class="number">1</span>, sex:<span class="string">"male"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>从鸭式辩型角度来说，这个应该是要可以赋值成功的，因为目标对象拥有类指定的特征行为了，TypeScript 觉得额外多出的属性可能会造成问题，所以会给一个错误提示。</p>
<p>针对这种因为额外多出的属性检查而报错的情况，如果想要绕开这个限制，有几种方法：</p>
<ul>
<li>类型断言</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dog1:Dog = &lt;Dog&gt;&#123;name:<span class="string">"dog"</span>, age:<span class="number">1</span>, sex:<span class="string">"male"</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> dog1:Dog = &#123;name:<span class="string">"dog"</span>, age:<span class="number">1</span>, sex:<span class="string">"male"</span>&#125; <span class="keyword">as</span> Dog;</span><br></pre></td></tr></table></figure>

<p>类型断言就是类似 Java 里的强制类型转换概念，通过 <code>&lt;&gt;</code> 尖括号或者 <code>as</code> 关键字，可以告诉编译器这个值的数据类型。</p>
<p>类型断言常用于开发者明确知道某个变量的数据类型的情况下。</p>
<ul>
<li>用变量做中转赋值</li>
</ul>
<p>如果赋值语句右侧是一个变量，而不是对象直接量的话，那么只会检查变量是否拥有赋值语句左侧所声明的类型的特征，而不会去检查变量额外多出来的属性，如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;name:<span class="string">"dog"</span>, age:<span class="number">1</span>, sex:<span class="string">"male"</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> dog1:Dog = o;</span><br></pre></td></tr></table></figure>

<ul>
<li>剩余属性</li>
</ul>
<p>这种方式是最佳的方式，官网中对它的描述是字符串索引签名，但我觉得这个描述很难理解，而且看它实现的方式，有些类似于 ES6 中的函数的剩余参数的处理，所以我干脆自己给它描述成剩余属性的说法了。</p>
<p>方式是这样的，在类中定义一个用于存储其他没有声明的属性数组：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Dog &#123;</span><br><span class="line">    name:<span class="built_in">string</span>;</span><br><span class="line">    age:<span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    [propName:<span class="built_in">string</span>]:<span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一行 <code>[propName:string]:any</code> 就表示：具有 Dog 特征的对象除了需要包含 name 和 age 属性外，还可以拥有其他任何类型的属性。所以：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dog1:Dog = &#123;name:<span class="string">"dog"</span>, age:<span class="number">1</span>, sex:<span class="string">"male"</span>, s:<span class="literal">true</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这样就是被允许的了。 </p>
<p>当然，这三种可以绕开多余属性的检查手段，应该适场景而使用，不能滥用，因为，大部分情况下，当 TypeScript 检查出你赋值的对象多了某个额外属性时，程序会因此而出问题的概念是比较大的。</p>
<p>鸭式辩型在 TypeScript 里更常用的是利用接口来实现，后续介绍。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>鸭式辩型其实严格点来讲就是对具有结构的值进行类型检查，而具有结构的值也就是对象了，所以对对象的类型检查，其实也就是在对对象进行类别划分。</p>
<p>既然是类别划分，那么不同类别当然需要有个标识来相互区分，在 TypeScript 里，接口的作用之一也就是这个，作为不同对象类别划分的依据。</p>
<p>比如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">    name:<span class="built_in">string</span>;</span><br><span class="line">    age:<span class="built_in">number</span>;</span><br><span class="line">    eat():<span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述就是定义了，对象如果拥有 name, age 属性和 eat 行为，那么就可以将这个对象归类为 Dog，即使创建这个对象并没有从实现了 Dog 接口的类上实例化，如： </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dog:Dog = &#123;</span><br><span class="line">    name: <span class="string">"小黑"</span>,</span><br><span class="line">    age:<span class="number">1</span>,</span><br><span class="line">    eat: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码声明了一个 Dog 类型的变量，那么什么对象才算是 Dog 类型，只要拥有 Dog 中声明的属性和行为就认为这个对象是 Dog，这就是鸭式辩型。（属性和行为是 Java 里面向对象常说的概念，属性对应变量，行为对应方法，在 JavaScript 里变量和方法都属于对象的属性，但既然 TypeScript 也有类似 Java 的接口和类语法，所以这里我习惯以 Java 那边的说法来描述了，反正能理解就行）</p>
<p>当然，也可以通过定义一个 Dog 类来作为变量的类型声明，但接口相比于类的好处在于，接口里只能有定义，一个接口里具有哪些属性和行为一目了然，而类中常常携带各种逻辑。</p>
<p>既然接口作用之一是用来定义对象的类别特征，那么，它还有很多其他的用法，比如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">    name:<span class="built_in">string</span>;</span><br><span class="line">    age:<span class="built_in">number</span>;</span><br><span class="line">    eat:<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">    master?:<span class="built_in">string</span>;  <span class="comment">//狗的主人属性，可有可无</span></span><br><span class="line">    readonly variety:<span class="built_in">string</span>; <span class="comment">//狗的品种，一生下来就固定了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog1:Dog = &#123;name:<span class="string">"dog1"</span>, age:<span class="number">1</span>, eat:<span class="function"><span class="params">()</span>=&gt;</span><span class="string">""</span>, variety:<span class="string">"柯基"</span>&#125;;</span><br><span class="line">dog1.age = <span class="number">2</span>;</span><br><span class="line">dog1.variety = <span class="string">"中华犬"</span>;<span class="comment">//报错，variety声明时就被固定了，无法更改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog2:Dog = &#123;name:<span class="string">"dog2"</span>, age:<span class="number">1</span>, eat:<span class="function"><span class="params">()</span>=&gt;</span><span class="string">""</span>, master: <span class="string">"me"</span>,variety:<span class="string">"柯基"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>在接口里声明属性时，可用 <code>?</code> 问号表示该属性可有也可没有，可用 readonly 来表示该属性为只读属性，那么在定义时初始化后就不能再被赋值。</p>
<p><code>?</code> 问号用来声明该项可有可无不仅可以用于在定义接口的属性时使用，还可以用于声明函数参数时使用。</p>
<p>在类型声明一节中说过，声明一个变量的类型时，也可以声明为函数类型，而函数本质上也是对象，所以，如果有需求是需要区分多个不同的函数是否属于同一个类别的函数时，也可以用接口来实现，如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Func &#123;</span><br><span class="line">    (name:<span class="built_in">string</span>):<span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func:Func = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种使用接口的方式称为声明函数类型的接口，可以简单的理解为，为 Func 类型的变量定义了 <code>()</code> 运算符，需传入指定类型参数和返回指定类型的值。</p>
<p>如果想让某个类型既可以当做函数被调用，又可以作为对象，拥有某些属性行为，那么可以结合上述声明函数类型的接口方式和正常的接口定义属性行为方式一起使用。</p>
<p>当对象或函数作为函数参数时，通过接口来定义这些参数的类型，就特别有用，这样可以控制函数调用时传入了预期类型的数据，如果类型不一致时，编译阶段就会报错。</p>
<p>当然，接口除了用来在鸭式辩型中作为值类型的区分外，也可以像 Java 里的接口一样，定义一些行为规范，强制实现该接口的类的行为，如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">    name:<span class="built_in">string</span>;</span><br><span class="line">    age:<span class="built_in">number</span>;</span><br><span class="line">    eat:<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">    master?:<span class="built_in">string</span>;  <span class="comment">//狗的主人属性，可有可无</span></span><br><span class="line">    readonly variety:<span class="built_in">string</span>; <span class="comment">//狗的品种，一生下来就固定了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ChinaDog <span class="keyword">implements</span> Dog&#123;</span><br><span class="line">    age: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    eat: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line">    master: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    readonly variety: <span class="built_in">string</span> = <span class="string">"中华犬"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChinaDog 实现了 Dog 接口，那么就必须实现该接口所定义的属性行为，所以，ChinaDog 创建的对象明显就属于 Dog：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dog3:Dog = <span class="keyword">new</span> ChinaDog();</span><br></pre></td></tr></table></figure>

<p>除了这些基本用法外，TypeScript 的接口还有其他很多用法，比如，定义构造函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">    <span class="keyword">new</span> (name:<span class="built_in">string</span>): Dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再比如接口的继承：接口可继承自接口，也可继承自类，继承的时候，可同时继承多个等。</p>
<p>更多高级用法，等有具体的使用场景，碰到的时候再深入去学习，先了解到这程度吧。</p>
<h4 id="Class-语法"><a href="#Class-语法" class="headerlink" title="Class 语法"></a>Class 语法</h4><p>习惯 Java 代码后，首次接触 ES5 多多少少会很不适应，因为 ES5 中都是基于原型的继承，没有 class 概念，自定义个对象都是写构造函数，写 prototype。</p>
<p>后来 ES6 中新增了 class 语法糖，可以类似 Java 一样通过 class 自定义对象，但还是有很多区别，比如，ES6 中的 class 语法糖，就无法声明成员变量，成员变量只能在构造函数内定义和初始化；而且，也没有权限控制、也没有抽象方法机制、也不能定义静态变量等等。</p>
<p>然而，这一切问题，在 TypeScript 中都得到了解决，TypeScript 的 class 语法基本跟 Java 一样，有 Java 基础的，学习 TypeScript 的 class 语法会很轻松。</p>
<p>看个例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;  <span class="comment">//定义抽象类</span></span><br><span class="line">    age:<span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> eat():<span class="built_in">void</span>;  <span class="comment">//抽象方法，权限修饰符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal&#123;   <span class="comment">//类的继承</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> readonly TAG:<span class="built_in">string</span> = <span class="string">"Dog"</span>;  <span class="comment">//定义静态常量</span></span><br><span class="line">    <span class="keyword">public</span> name:<span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> isDog:<span class="built_in">boolean</span> = <span class="literal">true</span>;   <span class="comment">//定义私有变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> eat:<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">any</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isDog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> age():<span class="built_in">number</span> &#123;  <span class="comment">//将 age 定义为存取器属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> age(age:<span class="built_in">number</span>) &#123;  <span class="comment">//将 age 定义为存取器属性</span></span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            age = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog:Dog = <span class="keyword">new</span> Dog(<span class="string">"小黑"</span>);</span><br></pre></td></tr></table></figure>

<p>大概有几个地方跟 Java 有些许小差别： </p>
<ul>
<li>变量类型的声明</li>
<li>构造函数不是用类名表示，而是使用 constructor</li>
<li>如果有继承关系，则构造函数中必须要调用super</li>
<li>不手动使用权限修饰符，默认是 public 权限</li>
</ul>
<p>其余方面，不管是权限的控制、继承的写法、成员变量的定义或初始化、抽象类的定义、基本上都跟 Java 的语法差不多。</p>
<p>所以说 TypeScript 的 class 语法比 ES6 的 class 语法糖要更强大。</p>
<p>还有很多细节的方面，比如在构造函数的参数前面加上权限修饰符，此时这个参数就会被当做成员变量来处理，可以节省掉赋值的操作；</p>
<p>比如在 TypeScript 里，类还可以当做接口来使用。更多用法后续有深入再慢慢记录。</p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>Java 里在操作实体数据时，经常会需要用到泛型，但 JavaScript 本身并不支持泛型，不过 TypeScript 支持，比如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Adapter&lt;T&gt; &#123;</span><br><span class="line">    data:T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> StringAdapter <span class="keyword">implements</span> Adapter&lt;<span class="built_in">string</span>&gt;&#123;</span><br><span class="line">    data: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>&lt;<span class="title">Y</span> <span class="title">extends</span> <span class="title">Animal</span>&gt;(<span class="params">arg:Y</span>):<span class="title">Y</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(<span class="keyword">new</span> Dog(<span class="string">"小黑"</span>));</span><br></pre></td></tr></table></figure>

<p>Dog 和 Animal 使用的是上个小节中的代码。</p>
<p>用法基本跟 Java 类似，函数泛型、类泛型、泛型约束等。 </p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>JavaScript 跟 Java 很不一样的一点就是，Java 有 class 机制，不同文件都需要有一个 public class，每个文件只是用于描述一个类的属性和行为，类中的变量不会影响其他文件内的变量，即使有同名类，只要类文件路径不一致即可。</p>
<p>但 JavaScript 所有的 js 文件都是运行在全局空间内，因此如果不在函数内定义的变量都属于全局变量，即使分散在多份不同文件内，这就很容易造成变量冲突。</p>
<p>所以也才有那么多模块化规范的技术。</p>
<p>虽然 TypeScript 的 class 语法很类似于 Java，但 TypeScript 最终仍旧是要转换成 JavaScript 语言的，因此即使用 TypeScript 来写 class，只要有出现同名类，那么即使在不同文件内，仍旧会造成变量冲突。</p>
<p>解决这个问题的话，TypeScript 也支持了模块化的语法。</p>
<p>而且，TypeScript 模块化语法有一个好处是，你只需掌握 TypeScript 的模块化语法即可，编译阶段可以根据配置转换成 commonJs, amd, cmd, es6 等不同模块化规范的实现。</p>
<p>TypeScript 的语法跟 ES6 中的模块语法很类似，只要 ts 文件内出现 import 或 export，该文件就会被当做模块文件来处理，即整个文件内的代码都运行在模块作用域内，而不是全局空间内。</p>
<ul>
<li>使用 export 暴露当前模块对外接口</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AarCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; AarCodeValidator &#125;;</span><br></pre></td></tr></table></figure>

<p>export 的语法基本跟 ES6 中 export 的用法一样。</p>
<p>如果其他模块需要使用该模块的相关接口：</p>
<ul>
<li>使用 import 依赖其他模块的接口</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">"./module"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> ZipCodeValidator();</span><br></pre></td></tr></table></figure>

<p>如果想描述非 TypeScript 编写的类库的类型，我们需要声明类库所暴露出的API。通常需要编写 .d.ts 声明文件，类似于 C++ 中的 .h 文件。</p>
<p>.d.ts 声明文件的编写，以及引用时需要用到三斜杠指令：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="./m2.d.ts"/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这部分内容我还没理解清楚，后续碰到实际使用掌握后再来说说。</p>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>命名空间与模块的区别在于，模块会涉及到 import 或 export，而命名空间纯粹就是当前 ts 文件内的代码不想运行在全局命名空间内，所以可以通过 命名空间的语法，让其运行在指定的命名空间内，防止污染全局变量。</p>
<p>语法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>本篇只讲了 TypeScript 的一些基础语法，还有其他更多知识点，比如引入三方不是用 TypeScript 写的库时需要编写的 .d.ts 声明文件，比如编译配置文件的各种配置项，比如枚举，更多更多的内容，请参考开头声明部分给出的 TypeScript 中文网连接。  </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>前端24-响应式布局Bootstrap</title>
    <url>/2018/11/06/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A824-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%EF%BC%88BootStrap%EF%BC%89/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本篇内容摘抄自以下两个来源：</p>
<ul>
<li><a href="http://www.bootcss.com/" target="_blank" rel="noopener">BootStrap中文网</a></li>
</ul>
<p>感谢大佬们的分享。</p>
<h1 id="正文-响应式布局（BootStrap）"><a href="#正文-响应式布局（BootStrap）" class="headerlink" title="正文-响应式布局（BootStrap）"></a>正文-响应式布局（BootStrap）</h1><p>这次想来讲讲一个前端开发框架：BootStrap</p>
<p>BootStrap 目前已经出了 4 个版本，每个版本都有对应的官网教程，先来看看不同版本里的宣传语：</p>
<blockquote>
<p>简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。— BootStrap 2.x.x 版本 </p>
</blockquote>
<blockquote>
<p>Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目。 — BootStrap 3.x.x 版本</p>
</blockquote>
<blockquote>
<p>Bootstrap 是全球最受欢迎的前端组件库，用于开发响应式布局、移动设备优先的 WEB 项目。</p>
<p>Bootstrap 是一套用于 HTML、CSS 和 JS 开发的开源工具集。利用我们提供的 Sass 变量和大量 mixin、响应式栅格系统、可扩展的预制组件、基于 jQuery 的强大的插件系统，能够快速为你的想法开发出原型或者构建整个 app 。 — BootStrap 4.x.x 版本</p>
</blockquote>
<p>那么，什么是响应式布局呢？</p>
<p>通俗的理解，就是在不同的屏幕规格上能够有不同的布局效果，比如在大尺寸屏幕上呈现多列的布局，在小尺寸屏幕上呈现不了这么多，可能就只剩下一列布局了。</p>
<p>那么，当屏幕尺寸发生变化时，在不同屏幕规格上，应该呈现怎样的布局，一般是通过媒体查询 @Media 来实现，但自己在 CSS 中书写的话，需要处理较多工作。</p>
<p>所以，也可以选择一些热门的框架，由它来帮忙处理这些响应式布局的工作，就像 BootStrap，但 BootStrap 功能不仅只有响应式功能，它还内置了很多预制组件等等，总之，很强大，虽然我还没用过。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>那就来学学如何使用，首先第一步肯定是安装，我直接选择最新版 4.x.x 系列的来作为入手了，旧版本没去了解，有机会再说。</p>
<p>将 BootStrap 引入项目中使用有两种方式：</p>
<ul>
<li>直接使用网上资源</li>
<li>将相关资源下载至本地使用</li>
</ul>
<h4 id="使用网上资源"><a href="#使用网上资源" class="headerlink" title="使用网上资源"></a>使用网上资源</h4><p>第一种方式最简单，直接在 HTML 文档中声明 css 和 js 文件来源即可，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Required meta tags --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap CSS --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css"</span> <span class="attr">integrity</span>=<span class="string">"sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Optional JavaScript --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.2.1/jquery.slim.min.js"</span> <span class="attr">integrity</span>=<span class="string">"sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js"</span> <span class="attr">integrity</span>=<span class="string">"sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js"</span> <span class="attr">integrity</span>=<span class="string">"sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 BootStrap，上面的 HTML 文档模板是必须的，带有注释的都是在所有使用了 BootStrap 的页面中需要引入的，需要注意的是，由于 BootStrap 一些组件依赖于 jQuery 和 Popper，所以需要引入这两份 js，而且顺序是 jQuery 先，Popper 后，最后再引入 BootStrap 提供的 bootstrap.min.js。</p>
<p>这是第一种方式，也是最省力的。</p>
<h4 id="将资源下载至本地使用"><a href="#将资源下载至本地使用" class="headerlink" title="将资源下载至本地使用"></a>将资源下载至本地使用</h4><p>这种方式就比较折腾了，好处就在于资源文件都可以放在自己服务器上，无需依赖他人。下载资源到本地也有两种方式，一是手动到官网下载，下面三个地址：</p>
<p><a href="https://v4.bootcss.com/docs/4.0/getting-started/download/" target="_blank" rel="noopener">下载 BootStrap</a></p>
<p><a href="https://jquery.com/download/" target="_blank" rel="noopener">下载 jQuery</a></p>
<p><a href="https://github.com/FezVrasta/popper.js#installation" target="_blank" rel="noopener">下载 popper</a></p>
<p>二是利用一些工具来下载，如 node.js 的 npm 命令来下载，打开终端，进入项目的根目录：</p>
<ol>
<li><p><code>npm init -y</code> </p>
</li>
<li><p><code>npm install bootstrap</code></p>
</li>
<li><p><code>npm install jquery</code></p>
</li>
<li><p><code>npm install popper.js --save</code></p>
</li>
</ol>
<p>如果执行命令过程中报错了，自行去搜索解决吧，我是一次性成功，没出啥问题，都下载结束后，项目里的结构如下，node_modules 文件夹里会有下载好的资源：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-ab7880d54e0f6f7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>package.json 配置项如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-ed196f8679e0e8ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>这是我下载使用的版本。</p>
<p>好，不管是手动去下载，还是接着 npm 下载，最后都需要将下载的资源放进项目中，那么，下载下来的这么多东西，该怎么用，哪些是有用的？</p>
<p>可借鉴上面第一种方式里的 HTML 文档，总共需要的其实就四份文件：</p>
<ul>
<li>bootstrap.min.css</li>
<li>jquery.slim.min.js</li>
<li>popper.min.js</li>
<li>bootstrap.min.js</li>
</ul>
<p>分别找下四份文件在哪，我的是在这几个路径下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Required meta tags --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap CSS --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"node_modules/bootstrap/dist/css/bootstrap.min.css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Optional JavaScript --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/jquery/dist/jquery.slim.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/popper.js/dist/popper.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/bootstrap/dist/js/bootstrap.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>官方教程说了，上面这是使用 BootStrap 的 HTML 模板，当然也有进行了解释，下面稍微说说：</p>
<p><code>&lt;!DOCTYPE html&gt;</code></p>
<p>这是 h5 的 HTML 文档的声明，不加这句的话，可能会出现一些奇怪的样式；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>这行代码表示的意思是，让网页可以自动适应当前移动设备的屏幕。</p>
<p>所以，使用 BootStrap 除了需要在 HTML 文档中引入所需的资源文件外，别忘了加上上面两个处理。</p>
<h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><p>BootStrap 4.x.x 版本，官方还没有中文教程，3.x.x 的中文教程倒是很齐全了。但 4.x.x 版本和 3.x.x 版本差别还是蛮大的，首先，4.x.x 选用 Sass 来作为预处理器，选择 flex 来实现它的栅格布局系统等等。</p>
<p>反正，BootStrap 本质就就是一个框架，封装了一系列的属性样式、组件给开发者使用，开发者只要了解有哪些属性样式可以用、有哪些组件可以用、效果怎么样、怎么用就可以了，至于这些，就只能是一步步在实际开发中，一边写一边查文档来慢慢积累了。</p>
<p>所以，本篇也就不会去列举各个组件效果、属性样式效果、还一个个去说明怎么用。</p>
<p>接下去的内容，就是想着，能够读懂官方某个示例项目的代码就足够了。</p>
<p>选择了官方的这个示例：<a href="https://v4.bootcss.com/docs/4.0/examples/album/" target="_blank" rel="noopener">Album</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5c07defdb2056bed.gif?imageMogr2/auto-orient/strip" alt>      </p>
<p>一步步来读懂它的 HTML 代码吧：</p>
<ul>
<li>第一步就是 HTML 的模板了，就上一小节中介绍的，需要进行 H5 声明、meta 声明、引入四个资源文件的那份模板；</li>
<li>第二步，来看看 &lt;body&gt; 内的 &lt;header&gt; 代码：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Required meta tags --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap CSS --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"node_modules/bootstrap/dist/css/bootstrap.min.css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--header 部分--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"collapse bg-dark"</span> <span class="attr">id</span>=<span class="string">"navbarHeader"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-8 col-md-7 py-4"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"text-white"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-muted"</span>&gt;</span>Add some information about the album below, the author, or any other background context. Make it a few sentences long so folks can pick up some informative tidbits. Then, link them off to some social networking sites or contact information.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-4 offset-md-1 py-4"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"text-white"</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list-unstyled"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"text-white"</span>&gt;</span>Follow on Twitter<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"text-white"</span>&gt;</span>Like on Facebook<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"text-white"</span>&gt;</span>Email me<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar navbar-dark bg-dark box-shadow"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container d-flex justify-content-between"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"navbar-brand d-flex align-items-center"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">width</span>=<span class="string">"20"</span> <span class="attr">height</span>=<span class="string">"20"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 24 24"</span> <span class="attr">fill</span>=<span class="string">"none"</span> <span class="attr">stroke</span>=<span class="string">"currentColor"</span> <span class="attr">stroke-width</span>=<span class="string">"2"</span> <span class="attr">stroke-linecap</span>=<span class="string">"round"</span> <span class="attr">stroke-linejoin</span>=<span class="string">"round"</span> <span class="attr">class</span>=<span class="string">"mr-2"</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"12"</span> <span class="attr">cy</span>=<span class="string">"13"</span> <span class="attr">r</span>=<span class="string">"4"</span>&gt;</span><span class="tag">&lt;/<span class="name">circle</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Album<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"navbar-toggler"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">data-toggle</span>=<span class="string">"collapse"</span> <span class="attr">data-target</span>=<span class="string">"#navbarHeader"</span> <span class="attr">aria-controls</span>=<span class="string">"navbarHeader"</span> <span class="attr">aria-expanded</span>=<span class="string">"false"</span> <span class="attr">aria-label</span>=<span class="string">"Toggle navigation"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"navbar-toggler-icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Optional JavaScript --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/jquery/dist/jquery.slim.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/popper.js/dist/popper.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/bootstrap/dist/js/bootstrap.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>看看效果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-3121815420e6b629.gif?imageMogr2/auto-orient/strip" alt>  </p>
<p>目前的代码里，我们完全没有写过 CSS，只在 HTML 文档中，添加了 &lt;header&gt; 标签内容，就能够达到这样的页面效果了，所以，其实，BootStrap 已经封装好了一大堆属性样式，我们只要在标签上通过 class 将这些属性样式应用起来就可以了。</p>
<p>示例中使用的 class 很多，基本都是 BootStrap 封装好的，我也没想把所有用到的都搞清楚具体作用，只是想了解个大概，后续在使用中慢慢积累学习吧。</p>
<p>对于这个 &lt;header&gt; 的效果，我主要想理清楚两点：</p>
<ul>
<li>展开和折叠是怎么实现的？</li>
<li>展开时那些列表是如何实现的？</li>
</ul>
<p>回过头看上面的动图，&lt;header&gt; 部分是作为导航栏，并且存在两种状态，折叠和展开，所以两种状态对应着两个 &lt;div&gt;，&lt;header&gt; 儿子标签里刚好两个 &lt;div&gt;；</p>
<p>看第一个 &lt;div&gt; 的 class：<code>collapse bg-dark</code>，collapse 是折叠的意思，所以第一个 &lt;div&gt; 就是一开始被折叠的容器，而控制这个 &lt;div&gt; 折叠起来，也就是 BootStrap 提供的 collapse 起的作用了；</p>
<p>同层次的第二个 &lt;div&gt; 的 class：<code>navbar navbar-dark bg-dark box-shadow</code>，两个 &lt;div&gt; 都有同一个 bg-dark，那么这个其实就是用来设置背景的，因为展开后，其实 &lt;header&gt; 区域是由两个 &lt;div&gt; 拼接起来的，只是背景色刚好一样，看不出来而已。</p>
<p>所以，页面渲染后，其实有个 &lt;div&gt; 被 collapse 折叠起来了，此时页面上只呈现第二个 &lt;div&gt; 内容而已，这个 &lt;div&gt; 的高度等样式由 navbar、navbar-dark、bg-dark 这些决定。</p>
<p>那么，点击完按钮后，第一个 &lt;div&gt; 为什么会被展开了呢？</p>
<p>看一下那个按钮：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"navbar-toggler"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">data-toggle</span>=<span class="string">"collapse"</span> <span class="attr">data-target</span>=<span class="string">"#navbarHeader"</span> <span class="attr">aria-controls</span>=<span class="string">"navbarHeader"</span> <span class="attr">aria-expanded</span>=<span class="string">"false"</span> <span class="attr">aria-label</span>=<span class="string">"Toggle navigation"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"navbar-toggler-icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&lt;button&gt; 的子标签 &lt;span&gt; 里的那个 navbar-toggler-icon 就是按钮的 icon，而之所以点击了后可以展开第一个 &lt;div&gt; 就是由其他属性来控制。</p>
<p>首先，需要对当前这个按钮添加 navbar-toggler 的 class，然后需要通过 data-target 指明控制展开的区域，这也是为什么第一个 &lt;div&gt; 中会有一个 id 属性，就是用来给这个按钮控制它的。</p>
<p>所以，梳理一下，通过给 &lt;div&gt; 添加 collapse 的 class 可以让这个区域折叠隐藏起来，然后给它设置一个 id；然后给控制这个折叠区域的按钮添加 data-toggle 和 data-target 属性，通过 id 来控制指定区域的折叠和展开。</p>
<p>至于其他 class 则是各种样式效果。</p>
<p>那么，展开之后的区域里的列表控件上，出现了一些例如：row，col-sm-8 之类的 class，这些又是什么意思呢？</p>
<p>首先，container 来设定区域的大小，row 用来设置这个容器作为 flex 布局，而弹性布局中，一行会被划分成 12 列，看张图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-03a91e133e27d79b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>所以 col-sm-8 表示当显示区域 &gt;= 576px 时，该控件占据 8 列，所以，同一个控件里会出现诸如：<code>col-sm-8 col-md-7</code> 其实就是响应式布局处理，在不同显示区域大小时，呈现不同的大小。</p>
<p>而 py-4 是 pading-top 的意思，-4 表示不同的大小。</p>
<p>offset 表示在一个 12 列的一行里，前面需要空出几列。</p>
<p>总之，<a href="https://getbootstrap.com/docs/4.0/layout/grid/" target="_blank" rel="noopener">官方教程里有对栅格系统 Grid</a> 做了详细的介绍，虽然是英文的，慢慢啃吧。</p>
<p>只有理清楚了这篇文章中介绍的 Grid，才能够理解，怎么写可以达到响应式的效果。</p>
<p>我们再来看导航栏的一个效果，我再来分析下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a4bfb71b4f52e683.gif?imageMogr2/auto-orient/strip" alt>  </p>
<p>当显示区域逐渐变小时，布局从一行变成了两行，这就是响应式布局，来解释下为什么会有这个行为：</p>
<p>看看这两个区域的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-8 col-md-7 py-4"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-4 offset-md-1 py-4"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面说过，BootStrap 里的 Grid 将每一行划分成 12 列，所以当显示区域大小在 md 范围，即 &gt;= 768px 情况下，第一个 &lt;div&gt; 的 col-md-7 生效，它占据 7 列的宽度，第二个 &lt;div&gt; 的 offset-md-1 和 col-sm-4 都生效，所以它前面空着 1 列的宽度，然后它占据着 4 列的宽度，这加起来是不是刚好 12 列，所以在 &gt;= 768 时，一行可以放下这两个 &lt;div&gt;。</p>
<p>但当显示区域逐渐缩小，当进入 sm 范围，即 &gt;= 576px 时，此时，第一个 &lt;div&gt; 的 col-sm-8 生效，所以它占据 8 列，而第二个 &lt;div&gt; 仍旧是 offset-md-1 和 col-sm-4 生效，那么此时加起来一共 13 列，超过了 12 列，一行里已经不足够放这两个 &lt;div&gt; 了，根据 flex 的弹性布局，此时超过的会自动换行。</p>
<p>以上，就是我对 Grid 的理解，也许有误，如果是错的，等后续用熟悉了再回来改，大伙看的时候，就当个借鉴看一看就好了。</p>
<p>分析到这里，大概清楚了 Grid 还有导航栏的一些用法了，也大体清楚 BootStrap 的响应式原理好像是基于它的栅格系统，通过为不同控件设置诸如 col-(sm/md/ls/xl)-(1/2/3/4/5/6/7/8/9/10/11/12) 来达到在不同显示区域下，不一样的布局效果，实现响应式布局。</p>
<p>所以，剩余的代码不想看了，头有点懵了，我对 BootStrap 唯一的感觉就是，学习成本好高，它提供太多东西了，封装了太多的样式、控件，反而不知道从哪看。</p>
<p>也许，本来就不需要特意去看，学习 BootStrap 应该是当需要时，再来查阅文档，然后逐步，慢慢积累对 BootStrap 的熟悉程度，而不是一开始就来看细看文档，文档当然要看，但快速过一遍，大概清楚提供了哪些东西就好了。 </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>前端23-CSS预处理器（Less&Sass）</title>
    <url>/2018/11/06/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A823-CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88Less&amp;Sass%EF%BC%89/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本篇内容梳理自以下几个来源：</p>
<ul>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://less.bootcss.com/" target="_blank" rel="noopener">Bootstrap网站的 less 文档</a> </li>
<li><a href="https://www.sasscss.com/" target="_blank" rel="noopener">Sass中文网</a></li>
</ul>
<p>感谢大佬们的分享。</p>
<h1 id="正文-CSS预处理（less-amp-Sass）"><a href="#正文-CSS预处理（less-amp-Sass）" class="headerlink" title="正文-CSS预处理（less&amp;Sass）"></a>正文-CSS预处理（less&amp;Sass）</h1><h3 id="CSS预处理"><a href="#CSS预处理" class="headerlink" title="CSS预处理"></a>CSS预处理</h3><p>什么是 CSS 预处理？为什么要有 CSS 预处理？</p>
<p>这里就讲讲这两个问题，写过 CSS 应该就会比较清楚，虽然我才刚入门，但在写一些练手时就已经有点感觉了：写 CSS 后，很难维护，维护基本要靠注释来，而且由于 HTML 文档中标签的嵌套层次复杂，导致写 CSS 的选择器时也很费劲，尤其是在后期为某部分标签新增样式时，总会不知道到底应该在 CSS 文件中哪里写这个选择器，这个选择器是否会与前面冲突。</p>
<p>最有感觉的一点是，CSS 代码基本没法复用，一个页面一份 CSS，每次都需要重写，只是很多时候，可以直接去旧的里面复制粘贴。</p>
<p>有这么些问题是因为 CSS 本身并不是一门编程语言，它只是一个标记语言，静态语言，不具备编程语言的特性，所以写容易，但维护会比较难。</p>
<p>这个时候，CSS 预处理器就出现了，其实应该是说 Sass 和 Less 这类语言出现了。</p>
<p>Sass 和 Less 这类语言，其实可以理解成 CSS 的超集，也就是它们是基于 CSS 原本的语法格式基础上，增加了编程语言的特性，如变量的使用、逻辑语句的支持、函数等。让 CSS 代码更容易维护和复用。</p>
<p>但浏览器最终肯定是只认识 CSS 文件的，它并无法处理 CSS 中的那些变量、逻辑语句，所以需要有一个编译的过程，将 Sass 或 Less 写的代码转换成标准的 CSS 代码，这个过程就称为 CSS 预处理。 </p>
<p>所以，CSS 预处理器其实只是一个过程的称呼，主要工作就是将源代码编译并输出标准的 CSS 文件，而这个源代码可以用 Sass 写，也可以用 Less，当然还有其他很多种语言。</p>
<p>那么，到底哪一种语言好，我还没能力来讨论，反正存在即有理，每种语言总它的优缺点、总有它的适用场景。</p>
<p>下面，主要就来介绍下其中的两种语言：Less 和 Sass。</p>
<p>我觉得，掌握 CSS 预处理的关键，其实也就两点，一是掌握语言的语法、二是清楚怎么编译成标准的 CSS 文件；语法基本都不会很难，编译一般需要配置一些环境，因为我使用的开发工具是 WebStrom，所以会介绍下 WebStrom 上的配置。</p>
<h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>Less 写的 CSS 文件后缀名为 <code>.less</code>，但浏览器并不认识 less 文件，所以最后需要转换成 css 文件，有两种方式：</p>
<ul>
<li><strong>借助 less.js</strong>，程序运行期间，浏览器会自动借助 less.js 来解析 less 文件内的代码，转成 css 标准语法</li>
</ul>
<p>这种方式，不需要配置任何其他环境，只需要下载 less.js，并在项目中使用即可，但有几点需要注意：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--link标签需要设置 rel=stylesheet/less, less.js的加载需要放在所有 link 标签后面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet/less"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"css/src/main.less"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet/less"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"css/src/test.less"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/lib/less.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>HTML 文档通过 link 标签引入 less 文件时，需要将 link 标签的 rel 属性设置为 stylesheet/less，否则无效；</p>
<p>而且，用 &lt;script&gt; 标签加载 less.js 的代码需要放在最后，即所有用 link 标签引入 less 文件的后面，因为 less.js 文件加载成功后就会去将 less 转成 css 标准样式，在 &lt;script&gt; 标签后面才用 link 标签引入的那些 less 文件就无法被转换了。</p>
<p><a href="https://github.com/less/less.js/releases" target="_blank" rel="noopener">less.js 下载地址：https://github.com/less/less.js/releases</a></p>
<ul>
<li><strong>借助 node.js 环境</strong>，安装完 less 后，执行 lessc 命令</li>
</ul>
<p>第一种方式，虽然便捷，但会让页面的渲染多了一个转换步骤，延长页面渲染时长，所以，还可以用第二种方式，直接在本地将 less 转成 css 文件后，项目直接使用转换后输出的 css 文件。</p>
<p>假设你已经在电脑上安装了 node.js 了，如果还没有，先去网上自行搜索下教程，很多，也很快。</p>
<p>首次使用需要先安装 less，打开终端，执行下述命令：</p>
<p><code>npm install -g less</code></p>
<p>安装完后，就可以使用 lessc 命令，如：</p>
<p><code>lessc main.less main.css</code></p>
<p>这是最简单的用法，将 main.less 文件编译输出 main.css；还有其他高级的用法，比如顺便压缩 css 文件，输出 .min.css 文件等等。</p>
<h4 id="WebStorm配置"><a href="#WebStorm配置" class="headerlink" title="WebStorm配置"></a>WebStorm配置</h4><p>我是比较习惯使用第二种方式，也就是在本地就将 less 文件转成 css 文件，项目里是直接使用转换后输出的 css 文件了，而且我用的开发工具是 WebStrom，所以可以借助它，省去了每次自己输命令的操作：</p>
<p>第一步：在项目根目录下执行 <code>npm init -y</code> 初始化项目，初始化完项目后，根目录会生成 package.json 文件；</p>
<p>第二步：打开 package.json，在里面的 scripts 字段，根据你的项目结构，输入脚本命令；</p>
<p>第三步：点击 scripts 旁边的三角形按钮，就可以自动执行脚本命令，完成转换工作；</p>
<p>第四步：（可选）如果嫌每次都需要自己手动点击按钮麻烦，可以将这项工作添加进 File Watcher 功能中，每次文件改动就会自动执行脚本命令，完成转换，具体参考<a href="https://www.cnblogs.com/dasusu/p/10105433.html" target="_blank" rel="noopener">上一篇</a>，或者自行搜索，很简单。</p>
<p>这是例子的项目结构：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-62c124ed1dbc6c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>src 目录中存放 less 文件，dist 目录中存放转换后输出的 css 文件，所以，我的 package.json 里的脚本命令如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-9ebc6e6b0af1287e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>具体的脚本命令可根据实际需求，实际项目结构，自行决定。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>好了，清楚了 less 文件的两种使用方式后，就可以来学习语法了，这样在学习语法过程中，就可以随时进行转换，查看 less 书写的代码，最终转换的 css 代码是什么样的，这样比较着学习比较容易掌握。</p>
<ul>
<li><strong>变量</strong></li>
</ul>
<p>通过 <code>@变量名:</code> 来定义变量，通过 <code>@变量名</code> 使用变量，其实本质上是常量了，如：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@width:</span> <span class="number">10px</span>;  <span class="comment">/*定义变量*/</span></span><br><span class="line"><span class="variable">@height:</span> <span class="variable">@width</span> + <span class="number">10px</span>; <span class="comment">/*使用变量，和逻辑语句*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">@width</span>;  <span class="comment">/*使用变量*/</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">@height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换成 CSS 文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义变量*/</span></span><br><span class="line"><span class="comment">/*使用变量，和逻辑语句*/</span></span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="comment">/*使用变量*/</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注释</strong></li>
</ul>
<p>上个例子中，转换后的注释也还保留着，这是因为 less 和 css 都支持 <code>/* */</code> 的注释方式，所以这种会保留，但如果是 <code>//</code>，这种只有在 less 中支持，css 不支持，那么这种注释就不会保留，验证下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*这是注释1*/</span></span><br><span class="line"><span class="comment">//这是注释2</span></span><br></pre></td></tr></table></figure>

<p>转换成 css 文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*这是注释1*/</span></span><br></pre></td></tr></table></figure>

<p>所以，在 less 中使用注释时，需要注意下，哪些是想保留，哪些是不想保留的。</p>
<ul>
<li><strong>Mixins（混合）</strong></li>
</ul>
<p>也有的文章里翻译成混入，还有的文章直接保留单词，不做翻译，可能是觉得中文翻译不能够很好的表达意思吧。</p>
<p>先说有这么种场景：有时候写在某个选择器中的属性样式，在其他选择器中也需要，所以通常是直接将那部分复制粘贴过来使用。</p>
<p>而 less 的 Mixins 允许你在某个选择器内，直接使用其他选择器内的属性样式，所以中文翻译才有混合，或混入之说，其实也就是将其他的属性样式混合到当前选择器中。</p>
<p>看个例子就明白了：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class1</span> &#123;   <span class="comment">//类选择器 class1 的属性样式</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.class2</span>(<span class="variable">@color</span>: <span class="number">#fff</span>) &#123;  <span class="comment">//定义了一个模板样式，类似于函数的作用</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#id1</span>() &#123;  <span class="comment">//定义了一个模板样式，类似于函数作用</span></span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ff22ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mian</span> &#123; </span><br><span class="line">  <span class="selector-class">.class1</span>; <span class="comment">//直接使用其他选择器定义的属性样式</span></span><br><span class="line">  <span class="selector-class">.class2</span>(<span class="number">#f2f</span>); <span class="comment">//使用模板样式，传入参数</span></span><br><span class="line">  <span class="selector-id">#id1</span>; <span class="comment">//使用模板样式，不传参时，括号可省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换后的 CSS 文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.mian</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f2f</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ff22ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意对比源代码和转换后的代码，原本就定义好的基本选择器，如 <code>.class1</code>，可直接在其他选择器内通过 <code>.calss1</code> 将它内部的属性样式都复制过来。</p>
<p>也可以在基本选择器后面加上 <code>()</code> 括号，这样一来，这个就会被当做模板处理，作用类似于函数，可接收参数，使用时就类似于调用函数那么使用，如果不传参，调用时也可以将括号省略。既然是作为函数使用，那么它们存在的意义就只是被调用，所以转换后的 CSS 中并不会存在这个函数。</p>
<p>另外，有的文章中，对 Mixins 的解释是说，在 class 中使用 class，但上面的例子中也测试了，class 中也是可以使用其他 id 选择器的属性样式的，所以应该不仅限于 class 类选择器，但不能用于组合选择器中。 </p>
<ul>
<li><strong>命名空间</strong></li>
</ul>
<p>我对于命名空间的理解：属于 less 自己的命名空间，也就是这些代码并不会在转换后的 CSS 文件中出现，因为它只属于 less。</p>
<p>所以，其实也就是上述例子中，类似函数存在的那些模板选择器，当在书写选择器时，在其后面增加 <code>()</code> 括号，则表示这个选择器只属于 less 的命名空间，转成 CSS 后并不会出现。k</p>
<ul>
<li><strong>嵌套</strong></li>
</ul>
<p>在写 CSS 时，组合选择器经常写得很复杂，因为 HTML 里的标签嵌套层次本身就很复杂，而且组合选择器写完也不是能够很明显的表示出它的目的，所以 less 允许依据 HTML 中的嵌套层次来书写，不用去记那么多组合选择器的规则，如：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="selector-class">.banner</span> &#123;</span><br><span class="line">      <span class="selector-tag">ul</span> &#123;</span><br><span class="line">        <span class="selector-tag">img</span> &#123;</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">700px</span>;</span><br><span class="line">          <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">          <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换成 CSS 文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> <span class="selector-class">.content</span> <span class="selector-class">.banner</span> <span class="selector-tag">ul</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">700px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> <span class="selector-class">.content</span> <span class="selector-class">.banner</span> <span class="selector-tag">ul</span> <span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是，子孙后代的组合选择器规则可以不用去记，直接根据 HTML 文档中标签的嵌套层次来书写即可，这样便于后期维护，如果要对某个标签新增某些样式，也知道该去哪里找。</p>
<p>有一点需要注意的是，类似 <code>a:hover</code> 这种伪类选择器，需要加一个 <code>&amp;</code> 符号。</p>
<ul>
<li><strong>运算</strong></li>
</ul>
<p>less 允许在代码中进行一些简单的加、减、乘、除基本运算，结合变量的使用，可进行一些字体、颜色等的动态运算效果。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@border:</span> <span class="number">1px</span>;</span><br><span class="line"><span class="variable">@color:</span> <span class="number">#fff</span>;</span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@color</span> * <span class="number">0.5</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="variable">@border</span> <span class="variable">@border</span>*<span class="number">2</span> <span class="variable">@border</span>*<span class="number">3</span> <span class="variable">@border</span>*<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换成 CSS 后：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">1px</span> <span class="number">2px</span> <span class="number">3px</span> <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，变量和运算都是用于对颜色、大小等进行计算。</p>
<ul>
<li><strong>内置函数</strong></li>
</ul>
<p>less 内置了一些基础函数，可用于转换颜色、处理字符串、算术运算等，这里列举一些函数：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">color</span>(<span class="string">"#aaa"</span>);  <span class="comment">//输出 #aaa， 将字符串的颜色值转换为颜色值</span></span><br><span class="line"><span class="selector-tag">image-size</span>(<span class="string">"file.png"</span>);  <span class="comment">//输出 =&gt; 10px 10px，获取图片文件的宽高信息</span></span><br><span class="line"><span class="comment">//image-with("file.png"); image-height("file.png"); 获取图片文件宽高</span></span><br><span class="line"><span class="selector-tag">convert</span>(<span class="number">9s</span>, <span class="string">"ms"</span>);  <span class="comment">//输出 =&gt; 9000ms，单位换算，例如对 m,cm,mmin,pt,pc的换算</span></span><br><span class="line">@<span class="selector-tag">size</span>: <span class="selector-tag">if</span>((true), <span class="number">1px</span>, <span class="number">0px</span>);  <span class="comment">//if函数，第一个参数为条件，满足则返回第二个参数，不满足返回第三个参数</span></span><br><span class="line"><span class="selector-tag">if</span>(not (true), <span class="number">1px</span>, <span class="number">0px</span>);     <span class="comment">//非语句， not</span></span><br><span class="line"><span class="selector-tag">if</span>((true) and (true), <span class="number">1px</span>, <span class="number">0px</span>); <span class="comment">//逻辑与语句， and </span></span><br><span class="line"><span class="selector-tag">if</span>((false) or (true), <span class="number">1px</span>, <span class="number">0px</span>); <span class="comment">//逻辑或语句， or </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理数组</span></span><br><span class="line">@list: "banana", "tomato", "potato", "peach";</span><br><span class="line"><span class="selector-tag">length</span>(<span class="variable">@list</span>);  <span class="comment">// 输出 =&gt; 4</span></span><br><span class="line"><span class="selector-tag">extract</span>(<span class="variable">@list</span>, <span class="number">3</span>);  <span class="comment">//输出 =&gt; potato,注意第一个不是从 0 开始计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型判断</span></span><br><span class="line"><span class="selector-tag">isnumber</span>(<span class="number">#ff0</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="selector-tag">isstring</span>(<span class="string">"234"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="selector-tag">iscolor</span>(<span class="number">#ff0</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="selector-tag">isXXX</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>内置函数很多，用途也很多，覆盖了基本算术运算、逻辑语句、颜色计算、字符串处理等等，需要用时再查手册吧。</p>
<ul>
<li><strong>作用域</strong></li>
</ul>
<p>作用域很好理解，就是类似 JavaScript 中的变量作用域，因为在 less 中都是通过 <code>@变量名:</code> 来定义变量的，后定义的会覆盖掉前定义的，但当在不同嵌套层次中定义同一变量时，就存在局部变量和外部变量之分，内部变量并不会覆盖掉外部变量。</p>
<p>而且，less 的变量定义也有类似 JavaScript 中的提前特性，如：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@var:</span> red;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#aaa</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@var</span>;  <span class="comment">// yellow，因为后面定义的 @var:yellow 将 @var:red 覆盖掉了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#page</span> &#123;</span><br><span class="line">  <span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@var</span>; <span class="comment">// white，内部变量不影响外部变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">@var:</span> white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@var:</span> yellow;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ppp</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@var</span>;  <span class="comment">//yellow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看转换成 CSS 后：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#aaa</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#page</span> <span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#ppp</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>import（导入）</strong></li>
</ul>
<p>如果某份 less 文件是可以复用的，那么可以使用 <code>@import</code> 命令将其全部引入使用。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"main"</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-dc39a7a68fbca83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>最后在 test.css 里会汇合 main.less 里的代码。</p>
<p>以上，只是介绍 less 的基础语法，还有更多详细、复杂的语法用途，需要时再翻阅文档吧。</p>
<h3 id="Sass（Scss）"><a href="#Sass（Scss）" class="headerlink" title="Sass（Scss）"></a>Sass（Scss）</h3><p>Sass 相比于 Less 功能会更强大，但也更复杂。</p>
<p>Sass 和 Scss 本质是一家，Sass 早期版本的文件后缀名是 <code>.sass</code>，从 Sass 3 之后，因为修改了一些特性语法，Sass 更加强大且易使用，从这个版本之后的文件后缀名改成了 <code>.scss</code>，所以 Scss 其实 Sass 的新版本的称呼，但两者本质上没太大区别。</p>
<p>Scss 是基于 Sass 的语法基础上，修改了一部分的语法。比如早期的 Sass 是通过换行和缩进如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#sidebar</span><br><span class="line">  width: 30%</span><br><span class="line">  background-color: #faa</span><br></pre></td></tr></table></figure>

<p>这种语法格式跟 CSS 不一致，让使用者会很不习惯，Scss 之后就换成用分号和括号了：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#faa</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>Sass 不像 Less 一样可以直接借助 less.js 来进行转换，它是基于 Ruby 运行环境，所以电脑上需要先安装 Ruby，然后才能有办法将 Sass 文件转成 CSS。</p>
<p><a href="https://rubyinstaller.org/downloads/" target="_blank" rel="noopener">Ruby 下载地址：https://rubyinstaller.org/downloads/</a>  </p>
<p>因为是 exe 文件，下载完直接按提示安装就可以了，安装后打开终端，执行 gem 命名安装 Sass：</p>
<p><code>gem install sass</code></p>
<p>安装完 Sass 后，就可以通过 scss 命令来进行转换工作了，如：</p>
<p><code>scss main.scss main.css</code></p>
<p>上述命令中，scss 换成 sass 也可以，但注意，scss 或 sass 命令是基于 Ruby 环境下运行的命令，因为电脑上已经安装过 Ruby 了，也通过 Ruby 安装了 Sass，所以才可以在终端里直接执行 scss 命令。</p>
<p>而类似于 Less 中说到的，WebStrom 可以借助 package.json 里的 scripts 来手动运行脚本命令，这有个前提，就这些脚本命令是运行在 node.js 环境上的，所以如果你直接将上述 scss 命令配置到 package.json 的 script 里，你会发现，是运行不了的。</p>
<p>要解决这个问题，让 WebStrom 能够运行 sass 命令来处理转换工作有两种方式：</p>
<ul>
<li>直接去 WebStrom 配置 File Watcher，program 选择 Ruby 目录中的 sass.bat 或 scss.bat</li>
</ul>
<p>这种方式下，每次配置的文件变动时，会自动生成对应的 css 文件，转换工作会自动实时进行。但如果不习惯这种方式，想要每次编写完 scss 代码后，手动来触发转换工作，那么可以选择第二种方式：</p>
<ul>
<li>通过 npm 命令安装 sass</li>
</ul>
<p>在终端里执行 <code>npm install -g sass</code>，这样就可以类似配置 less 那样的步骤来使用 sass 命令了，在 package.json 里配置相关命令，然后手动点击脚本的运行即可。</p>
<p>但 npm 安装的 sass 跟在 Ruby 下安装的 sass 是否有和区别，我不清楚，用段时间，如果有啥问题再来说说。</p>
<p>而且，对于选择使用 Sass，刚接触可能会有些困惑，是应该使用哪个后缀名的文件，命令是该用 sass 还是 scss 来进行转换，我也有这个困惑，但感觉好像并没有什么区别，先试着用段时间，以后熟悉了再来讲讲。</p>
<p>最后，Sass 虽然有 <code>.sass</code> 和 <code>.scss</code> 两种后缀名的文件，但建议使用 <code>.scss</code>，因为前者的语法跟 CSS 很不一样，使用起来会有些不习惯，当然如果你有 Ruby 基础的话，可能会比较喜欢这种。我个人会选择后者。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p>语法方面，大部分类似于 Less，但就细节方面可能有些不一样，还有，支持更多更强大的功能吧。</p>
<p>上面介绍的 Less 的基础语法、基础功能，Sass 也基本全部支持，也差不了多少，所以下面就不一个个来介绍了，详细的到开头声明部分给的中文网链接中去查阅即可。</p>
<p>下面就主要列一些不同的地方：</p>
<ul>
<li><strong>变量</strong></li>
</ul>
<p>Sass 中的变量用 <code>$变量名:</code> 定义，用 <code>$变量名</code> 使用，其余跟 Less 差不了多少。</p>
<ul>
<li><strong>作用域</strong></li>
</ul>
<p>Less 中的变量分局部作用域和全局作用域，但在 Sass 中，不同版本，作用域范围并不一样，摘抄一段原文中描述：</p>
<blockquote>
<p>Sass 中变量的作用域在过去几年已经发生了一些改变。直到最近，规则集和其他范围内声明变量的作用域才默认为本地。如果已经存在同名的全局变量，则局部变量覆盖全局变量。从 Sass 3.4 版本开始，Sass 已经可以正确处理作用域的概念，并通过创建一个新的局部变量来代替。 </p>
</blockquote>
<ul>
<li><strong>条件语句</strong></li>
</ul>
<p>Less 中并不支持条件语句，当然，可以通过内置函数 if 以及 and，or，not 这些来模拟条件语句。</p>
<p>在 Sass 中是支持条件语句的，但也不是像其他编程语言直接 if 这样通过保留字来编写，需要加个 <code>@</code> 符合，如：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">if</span> <span class="variable">$support-legacy</span> &#123;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>教程中给了几条准则要求：</p>
<ul>
<li>除非必要，不然不需要括号；</li>
<li>务必在 <code>@if</code> 之前添加空行；</li>
<li>务必在左开大括号(<code>{</code>)后换行；</li>
<li><code>@else</code> 语句和它前面的右闭大括号(<code>}</code>)写在同一行；</li>
<li>务必在右闭大括号(<code>}</code>)后添加空行，除非下一行还是右闭大括号(<code>}</code>)，那么就在最后一个右闭大括号(<code>}</code>)后添加空行。</li>
</ul>
<p>另外，教程中也说了：</p>
<blockquote>
<p>除非你的代码中有偏复杂的逻辑，否则没必要在日常开发的样式表中使用条件语句。实际上，条件语句主要适用于库和框架。 </p>
</blockquote>
<p>其他区别，等用段时间，熟悉了再来讲讲。</p>
<h4 id="框架-Compass"><a href="#框架-Compass" class="headerlink" title="框架-Compass"></a>框架-<a href="http://compass-style.org/" target="_blank" rel="noopener">Compass</a></h4><p>Sass 有一点比 Less 有优势的就是，目前有很多稳定且热门的基于 Sass 编写的框架库，比如：<a href="http://compass-style.org/" target="_blank" rel="noopener">Compass</a>、<a href="http://bourbon.io/" target="_blank" rel="noopener">Bourbon</a> 和 <a href="http://susy.oddbird.net/" target="_blank" rel="noopener">Susy</a> 等。</p>
<p>这些框架库就类似于 jQurey 和 JavaScript 关系，对 Sass 进行了一层封装，让编写 Sass 代码的人，可以极为简便的开发，我还没用过，就不过多介绍了。  </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>前端22-讲讲模块化</title>
    <url>/2018/11/05/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A822-%E8%AE%B2%E8%AE%B2%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本篇内容摘抄自以下来源：</p>
<ul>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://segmentfault.com/a/1190000011081338" target="_blank" rel="noopener">JavaScript模块化开发的演进历程</a>  </li>
<li><a href="https://huangxuan.me/js-module-7day/#/4" target="_blank" rel="noopener">JavaScript模块化七日谈</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">ES6:Module 的加载实现</a></li>
<li><a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">CommonJS规范</a></li>
</ul>
<p>感谢各位大佬的分享，解惑了很多。</p>
<h1 id="正文-模块化"><a href="#正文-模块化" class="headerlink" title="正文-模块化"></a>正文-模块化</h1><p>现在回过头来想想，也许选择以《JavaScript权威指南》一书来作为入门有些不好，因为这本书毕竟是很早之前的，书中所讲的思想、标准也基本都只是 ES5 及那时代的相关技术。</p>
<p>这也就导致了，在书中看到的很多例子，虽然觉得所用到的思想很奇妙，比如临时命名空间之类的处理，但其实，有些技术到现在已经有了更为强大的技术替代了。</p>
<p>就像这篇要讲的模块化，目前，以我看到的各资料后，所收获的知识是，大概有四种较为常用且热门的模块化技术，也许还有更新的技术，也许还有我不知道的技术，无所谓，慢慢来，这篇的内容已经够我消化了。</p>
<p>目前四种模块化技术：</p>
<ul>
<li>CommonJS规范&amp;node.js</li>
<li>AMD规范&amp;Require.js</li>
<li>CMD规范&amp;Sea.js</li>
<li>ES6标准</li>
</ul>
<p>前面是规范，规范就是类似于 ES5，ES6 只是提出来作为一种标准规范，而不同规范有具体的实现，比如 nodeJS 实现了 CommonJS 规范。</p>
<h3 id="模块化历程"><a href="#模块化历程" class="headerlink" title="模块化历程"></a>模块化历程</h3><p>在声明部分中的第二、第三链接里那两篇，以时间线介绍了模块化的相关技术的发展历程，我觉得很有必要一看，对于掌握和理解目前的模块化技术挺有帮助的。</p>
<p>这里，就稍微摘抄其中一些内容，详细内容还是需要到原文阅读。</p>
<ol>
<li><strong>全局变量、全局函数（1999年）</strong></li>
</ol>
<p>这时候的多个 js 脚本文件之间，直接通过全局变量或全局函数的方式进行通信，这种方式叫做：直接定义依赖。</p>
<p>虽然做的好一些的会对这些 js 文件做一些目录规划，将资源归类整理，但仍无法解决全局命名空间被大量污染，极其容易导致变量冲突问题。</p>
<ol start="2">
<li><strong>对象作为命名空间（2002年）</strong></li>
</ol>
<p>为了解决遍地的全局变量问题，这时候提出一种命名空间模式的思路，即将本要定义成全局变量、全局函数的这些全都作为一个对象的属性存在，这个对象的角色充当命名空间，不同模块的 JS 文件中通过访问这个对象的属性来进行通信。</p>
<ol start="3">
<li><strong>立即执行的函数作为临时命名空间 + 闭包（2003年）</strong></li>
</ol>
<p>虽然提出利用一个对象来作为命名空间的思路，一定程度解决了大量的全局变量的问题，但仍旧存在很多局限，比如没有模块的隐藏性，所以针对这些问题，这时候又新提出一种思路：利用立即执行的函数来作为临时命名空间，这样就可以避免污染全局命名空间，同时，结合闭包特性，来实现隐藏细节，只对外暴露指定接口。</p>
<p>虽然这种思路，解决了很多问题，但仍旧有一些局限，比如，缺乏管理者，什么意思，就是说，在前端里，开发人员得手动将不同 JS 脚本文件按照它们之间的依赖关系，以被依赖在前面的顺序来手动书写 &lt;script&gt; 加载这些文件。</p>
<p>也就是不同 &lt;script&gt; 的前后顺序实际上表示着它们之间的依赖关系，一旦文件过多，将会很难维护，这是上述方案都存在的问题。</p>
<ol start="4">
<li><strong>动态创建 &lt;script&gt; 工具（2009年）</strong></li>
</ol>
<p>针对上述问题，也就衍生出了一些加载 js 文件的工具，先看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$LAB.script(<span class="string">"greeting.js"</span>).wait()</span><br><span class="line">    .script(<span class="string">"x.js"</span>)</span><br><span class="line">    .script(<span class="string">"y.js"</span>).wait()</span><br><span class="line">    .script(<span class="string">"run.js"</span>);</span><br></pre></td></tr></table></figure>

<p>LAB.js 这类加载工具的原理实际上是动态的创建 &lt;script&gt;，达到作为不同 JS 脚本文件的管理者作用，来决定 JS 文件的加载和执行顺序。</p>
<p>虽然我没用过这种工具，但我觉得它的局限还是有很多，其实就是将开发人员本来需要手动书写在 HTML 文档里的 &lt;script&gt; 代码换成写在 JS 文件中，不同 JS 文件之间的依赖关系仍旧需要按照前后顺序手动维护。</p>
<ol start="5">
<li><strong>CommonJS规范&amp;node.js（2009年）</strong></li>
</ol>
<p>中间跳过了一些过程，比如 YUI 的沙箱模式等，因为不熟，想了解更详细的可以去原文阅读。</p>
<p>当 CommonJS 规范出来时，模块化算是进入了真正的革命，因为在此之前的探索，都是基于语言层面的优化，也就是利用函数特性、对象特性等来在运行期间模拟出模块的作用，而从这个时候起，模块化的探索就大量的使用了预编译。</p>
<p>CommonJS 模块化规范有如下特点：</p>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
<p>不同的模块间的依赖关系通过 <code>require</code> 来控制，而每个模块需要对外暴露的接口通过 <code>exports</code> 来决定。</p>
<p>由于 CommonJS 规范本身就只是为了服务端的 node.js 而考虑的，node.js 实现了 CommonJS 规范，所以运行在 node.js 环境中的 js 代码可以使用 <code>require</code> 和 <code>exports</code> 这两个命令，但在前端里，浏览器的 js 执行引擎并不认识 <code>require</code> 这些命令，所以需要进行一次转换工作，后续介绍。</p>
<p>再来看看 <code>require</code> 命令的工作原理：</p>
<p><code>require</code> 命令是 CommonJS 规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的 <code>module.require</code> 命令，而后者又调用 Node 的内部命令 <code>Module._load</code>。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Module._load = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 检查 Module._cache，是否缓存之中有指定模块</span></span><br><span class="line">  <span class="comment">// 2. 如果缓存之中没有，就创建一个新的Module实例</span></span><br><span class="line">  <span class="comment">// 3. 将它保存到缓存</span></span><br><span class="line">  <span class="comment">// 4. 使用 module.load() 加载指定的模块文件，</span></span><br><span class="line">  <span class="comment">//    读取文件内容之后，使用 module.compile() 执行文件代码</span></span><br><span class="line">  <span class="comment">// 5. 如果加载/解析过程报错，就从缓存删除该模块</span></span><br><span class="line">  <span class="comment">// 6. 返回该模块的 module.exports</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Module.prototype._compile = <span class="function"><span class="keyword">function</span>(<span class="params">content, filename</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 生成一个require函数，指向module.require</span></span><br><span class="line">  <span class="comment">// 2. 加载其他辅助方法到require</span></span><br><span class="line">  <span class="comment">// 3. 将文件内容放到一个函数之中，该函数可调用 require</span></span><br><span class="line">  <span class="comment">// 4. 执行该函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以，其实 CommonJS 的模块化规范之所以可以实现控制作用域、模块依赖、模块通信，其实本质上就是将模块内的代码都放在一个函数内来执行，这过程中会创建一个对象 Module，然后将模块的相关信息包括对外的接口信息都添加到对象 Module 中，供其他模块使用。</p>
<ol start="6">
<li><strong><a href="https://github.com/amdjs/amdjs-api" target="_blank" rel="noopener">AMD规范</a>&amp;<a href="https://requirejs.org/" target="_blank" rel="noopener">Require.js</a>（2009年）</strong></li>
</ol>
<p>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS 规范比较适用。</p>
<p>但是，如果是浏览器环境，这种同步加载文件的模式就会导致浏览器陷入卡死状态，因为网络原因是不可控的。所以，针对浏览器环境的模块化，新提出了一种规范：AMD（Asynchronous Modules Definition）异步模块定义。</p>
<p>也就是说，对于 Node.js，对于服务端而言，模块化规范就是按照 CommonJS 规范即可。</p>
<p>但对于浏览器，对于前端而言，CommonJS 不适用，需要看看 AMD 规范。</p>
<p>AMD 规范中定义：</p>
<ul>
<li>定义一个模块时通过 <code>define</code> 命令，通过 <code>return</code> 声明模块对外暴露的接口</li>
<li>依赖其他模块时，通过 <code>require</code> 命令</li>
</ul>
<p>而规范终归只是规范，使用时还是需要有规范的具体实现，针对 AMD 规范，具体的实现是 Require.js，在前端里，如果基于 Require.js 来使用 AMD 规范的模块化技术，后续介绍。</p>
<ol start="7">
<li><strong><a href="https://github.com/cmdjs/specification" target="_blank" rel="noopener">CMD规范</a>&amp;<a href="https://seajs.github.io/seajs/docs/" target="_blank" rel="noopener">Sea.js</a>（2013年）</strong></li>
</ol>
<p>CMD（Common Module Definition）也是专门针对浏览器、针对前端而提出的一种模块化规范。它跟 AMD 规范都是用途都是一样，用途解决前端里的模块化技术。</p>
<p>但两种规范各有各的优缺点，各有各的适用场景和局限性吧，我还没使用过这两种规范，所以无从比较，但网上关于这两种规范比较的文章倒是不少。</p>
<p>CMD 规范中定义：</p>
<ul>
<li>使用 <code>define</code> 命令定义一个模块，使用 <code>exports</code> 来暴露模块对外的接口</li>
<li>使用 <code>require</code> 来同步加载依赖的模块，但也可使用 <code>require.async</code> 来异步加载依赖的模块 </li>
</ul>
<p>总之，虽然两种规范都是用于解决前端里的模块化技术，但实现的本质上还是有些不同，后续介绍。</p>
<p>对于 CMD 规范的具体实现是 Sea.js，前端里如果想使用 CMD 规范的模块化技术，需要借助 Sea.js。</p>
<ol start="8">
<li><strong>ES6标准（2015年）</strong></li>
</ol>
<p>2015 年发布的 ES6 标准规范中，新增了 Module 特性，也就是官方在 ES6 中，在语言本身层面上，添加了模块的机制支持，让 JavaScript 语言本身终于可以支持模块特性了。</p>
<p>在 ES6 之前的各种方案，包括 CommonJS，AMD，CMD，本质上其实都是利用函数具有的本地变量的特性进行封装从而模拟出模块机制。也就是说，这些方案都是需要在运行期间，才会动态的创建出某个模块，并暴露模块的相关接口。这种方案其实也存在一些局限性。</p>
<p>而 ES6 新增了模块的机制后，在代码的解析阶段，就能够确定模块以及模块对外的接口，而不用等到运行期。这种本质上的区别，在借助开发工具写代码阶段的影响很明显就是，终于可以让开发工具智能的提示依赖的模块都对外提供了哪些接口。</p>
<p>但 ES6 由于是新增的特性，在支持方面目前好像还不是很理想，并不是所有环境都支持 ES6 的模块机制好像，所以会看到某些大佬的文章里会介绍一些诸如：Babel、Browserify。</p>
<p>Babel 用于将 ES6 转换为 ES5 代码，好让不支持 ES6 特性的环境可以运行 ES5 代码。</p>
<p>Browserify 用于将编译打包 js，处理 require 这些浏览器并不认识的命令。</p>
<p>上面只是简单介绍了下模块化的发展历程，而且中间略过一些阶段，想看详细的可以去原文阅读。下面就具体介绍下，目前四个比较稳定的模块技术：</p>
<h3 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h3><p>由于 CommonJS 是针对服务端设计的模块化规范，对于 Node.js 来说，一个 JS 文件就是一个模块，所以并不需要类似 AMD 或 CMD 中的 <code>define</code> 来声明一个模块。这是我的理解。</p>
<h4 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h4><p>既然在 Node.js 中，每个 JS 文件就是一个模块，那么这个模块文件内的变量都是对外隐藏的，外部无权访问，只能访问 <code>exports</code> 对外暴露的接口，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"dasu"</span>;</span><br><span class="line"><span class="keyword">var</span> wx = <span class="string">"dasuAndroidTv"</span>;</span><br><span class="line"><span class="keyword">var</span> getBlog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"http://www.cnblogs.com/dasusu/"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上变量和函数，外部都无权访问,外部只能访问到下面通过 exports 暴露的接口</span></span><br><span class="line"><span class="built_in">module</span>.exports.name = name;</span><br><span class="line">exports.getWx = <span class="function"><span class="params">()</span> =&gt;</span> wx;</span><br></pre></td></tr></table></figure>

<p>模块内，可以通过对 module.exports 或 exports 添加属性来达到对外暴露指定接口的目的，当然，从程序上来说，你可以直接改变 module.exports 的指向，让它指向一个新对象而不是在原本对象上添加属性，这个就类似于对构造函数 prototype 属性的修改。</p>
<p>但建议使用方式还是尽可能在 exports 对象上添加属性。</p>
<p>如果有想探究它的原理的话，可以尝试利用 Browserify 来转换这段模块代码，看看最后生成的是什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">require,module,exports</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//module.js</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"dasu"</span>;</span><br><span class="line">    <span class="keyword">var</span> wx = <span class="string">"dasuAndroidTv"</span>;</span><br><span class="line">    <span class="keyword">var</span> getBlog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"http://www.cnblogs.com/dasusu/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上变量和函数，外部都无权访问,外部只能访问到下面通过 exports 暴露的接口</span></span><br><span class="line">    <span class="built_in">module</span>.exports.name = name;</span><br><span class="line">    exports.getWx = <span class="function"><span class="params">()</span> =&gt;</span> wx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然，对于 Node.js 来说，它其实对待每个 JS 文件，本质上，会将文件内的代码都放于一个函数内，如果该模块首次被其他模块引用了，那么就会去执行这个函数，也就是执行模块内的代码，由于函数本身有三个参数，其中有两个分别是：module 和 exports，这也是内部为什么可以直接通过 module.exports 或 exports 来操作的原因。</p>
<p>Module 对象是 Node.js 会为每个模块文件创建的一个对象，模块之间的通信，其实就是通过访问每个 Module 对象的属性来实现。</p>
<p>所以，说白了，CommonJS 模块化技术的本质，其实就是利用了函数的局部作用域的特性来实现模块作用域，然后结合一个对象作为命名空间的方式，来保存模块内部需要对外暴露的信息方式。最后，通过 <code>require</code> 命令来组织各模块之间的依赖关系，解决以前方案没有管理者角色的局限，解决谁先加载谁后加载的问题。</p>
<h4 id="require"><a href="#require" class="headerlink" title="require"></a>require</h4><p>每个 JS 文件其实都被当做一个模块处理，也就是文件内的代码都会被放入到一个函数内，那这个函数什么时候执行呢？也就是说，模块什么时候应该被加载呢？</p>
<p>这就是由 <code>require</code> 命令决定，当某个模块内使用了 require 命令去加载其他模块，那么这时候，被加载的模块如果是首次被调用，它是没有对应的 Module 对象的，所以会去调用它的函数，执行模块内代码，这个过程是同步的，这期间会完善这个模块的 Module 对象信息。之后，其他模块如果也引用了这个模块，因为模块内代码已经被执行过了，已经存在对应的 Module 对象，所以此时就不会再重复去加载这个模块了，直接返回 Module 对象。</p>
<p>以上，基本也就是模块间依赖的加载处理过程。而 require 命令用法很简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">var</span> module1 = <span class="built_in">require</span>(<span class="string">"./module"</span>);</span><br><span class="line"></span><br><span class="line">module1.name;  <span class="comment">//输出=&gt; dasu</span></span><br><span class="line">module1.getWx(); <span class="comment">//输出 =&gt; dasuAndroidTv</span></span><br><span class="line"><span class="comment">//module1.getBlog(); //没有权限访问</span></span><br></pre></td></tr></table></figure>

<p>其实，Node.js 对 main.js 的处理也是认为它是个模块，所以文件内的代码也都放入一个函数内，还记得函数的第一个参数就是 require 么，这也就是为什么模块内可以直接使用 <code>require()</code> 的原因，require 其实本质上是一个函数，具体的实现是 Node.js 的一个内置方法：Module._load()，主要工作上一节有介绍过了。</p>
<p>说得稍微严谨点，Node.js 其实才是作为各模块之间的管理者，由它来管控着哪个模块先加载，哪个后加载，维护着各模块对外暴露的信息。</p>
<p>到这里再来理解，有些文章中对 Module 对象的介绍：</p>
<blockquote>
<ul>
<li><code>module.id</code> 模块的识别符，通常是带有绝对路径的模块文件名。</li>
<li><code>module.filename</code> 模块的文件名，带有绝对路径。</li>
<li><code>module.loaded</code> 返回一个布尔值，表示模块是否已经完成加载。</li>
<li><code>module.parent</code> 返回一个对象，表示调用该模块的模块。</li>
<li><code>module.children</code> 返回一个数组，表示该模块要用到的其他模块。</li>
<li><code>module.exports</code> 表示模块对外输出的值。</li>
</ul>
</blockquote>
<p>这时，对于 Module 对象内的各属性用途，理解应该会比较容易点了。</p>
<p>最后说一点，CommonJS 只是一种模块化的规范，而 Node.js 才是这个规范的具体实现者，但 Node.js 通常用于服务端的运行环境，对于前端而言，对于浏览器而言，因为不存在 Node.js 这东西，所以 require 或 exports 这类在前端里是无法运行的，但可以借助 Browerify 来进行代码转换。</p>
<h3 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h3><p><a href="https://github.com/amdjs/amdjs-api" target="_blank" rel="noopener">AMD规范</a>和规范实现者：<a href="https://requirejs.org/" target="_blank" rel="noopener">Require.js</a></p>
<p>前端里没有 Node.js 的存在，即使有类似的存在，但由于 CommonJS 的模块化规范中，各模块的加载行为是同步的，也就是被依赖的模块必须执行结束，当前模块才能继续处理，这对于前端而言，模块的加载就多了一个下载的过程，而网络是不可靠的，所以 CommonJS 并不适用于前端的场景。</p>
<p>所以，针对前端，提出了另一种模块化规范：AMD，即异步模块加载，通过增加回调处理的方式，来移除被依赖模块和当前模块的前后关联，两个模块可同时下载，执行。当前模块内，需要依赖于其他模块信息的代码放置于回调函数内，这样就可以先行处理当前模块内其他代码。</p>
<h4 id="define"><a href="#define" class="headerlink" title="define"></a>define</h4><p>前端里是通过 &lt;script&gt; 来加载 JS 文件代码的，不能像 Node.js 那样从源头上处理 JS 文件，所以它多了一个 <code>define</code> 来定义模块，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"dasu"</span>;</span><br><span class="line">    <span class="keyword">var</span> wx = <span class="string">"dasuAndroidTv"</span>;</span><br><span class="line">    <span class="keyword">var</span> getBlog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"http://www.cnblogs.com/dasusu/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        getWx: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> wx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果定义的模块又依赖了其他模块时，此时 define 需要接收两个参数，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个参数，第一个参数是数组，数组里是当前模块依赖的所有模块，第二个参数是函数，函数需要参数，参数个数跟数组个数一直，也跟数组里依赖的模块一一对应，该模块内部就是通过参数来访问依赖的模块。</span></span><br><span class="line">define([<span class="string">'module2'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//module2.xxx  使用模块 module2 提供的接口</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//本模块的内部逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">//对外暴露的接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>define 有两个参数，第一个参数是数组，数组里是当前模块依赖的所有模块，第二个参数是函数，函数需要参数，参数个数跟数组个数一直，也跟数组里依赖的模块一一对应，该模块内部就是通过参数来访问依赖的模块。</p>
<h4 id="require-1"><a href="#require-1" class="headerlink" title="require"></a>require</h4><p>如果其他地方有需要使用到某个模块提供的功能时，此时就需要通过 require 来声明依赖关系，但声明依赖前，需要先通过 requirejs.config 来配置各个模块的路径信息，方便 Require.js 能够获得正确路径自动去下载。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">requirejs.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        module1: <span class="string">'./module'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> module1 = <span class="built_in">require</span>([<span class="string">'module1'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module1</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(module1.name);    <span class="comment">//访问模块内的 name 接口</span></span><br><span class="line">    <span class="built_in">console</span>.log(module1.getWx()); <span class="comment">//访问模块内的 getWx 接口</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他不依赖于模块的代码</span></span><br></pre></td></tr></table></figure>

<p>这种方式的话，require 的第一个数组参数内的值就可以模块的别称，而第二个参数是个函数，同样，函数的参数就是加载后的模块，该 JS 文件内需要依赖到模块信息的代码都可以放到回调函数中，通过回调函数的参数来访问依赖的模块信息。</p>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol>
<li>下载 Require.js，并放到项目中</li>
</ol>
<p><a href="https://requirejs.org/docs/download.html#requirejs" target="_blank" rel="noopener">Require.js:https://requirejs.org/docs/download.html#requirejs</a>  </p>
<ol start="2">
<li>新建作为模块的文件，如 module.js，并通过 define 定义模块</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"dasu"</span>;</span><br><span class="line">    <span class="keyword">var</span> wx = <span class="string">"dasuAndroidTv"</span>;</span><br><span class="line">    <span class="keyword">var</span> getBlog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"http://www.cnblogs.com/dasusu/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        getWx: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> wx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在其他 js 文件内先配置所有的模块来源信息</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line">requirejs.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        module1: <span class="string">'./module'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>配置完模块信息后，通过 require 声明需要依赖的模块</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">var</span> module1 = <span class="built_in">require</span>([<span class="string">'module1'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module1</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(module1.name);    <span class="comment">//访问模块内的 name 接口</span></span><br><span class="line">    <span class="built_in">console</span>.log(module1.getWx()); <span class="comment">//访问模块内的 getWx 接口</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他不依赖于模块的代码</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>最后也最重要的一步，在 html 中声明 require.js 和 入口 js 如 main.js 的加载关系</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/lib/require.js"</span> <span class="attr">data-main</span>=<span class="string">"js/src/main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，这只是基础用法的步骤，其中第 3 步的模块初始化步骤也可通过其他方式，如直接利用 require 的不同参数类型来实现等等，但大体上需要这几个过程，尤其是最后一步，也是最重要一步，因为 AMD 在前端的具体实现都依靠于 Require.js，所以必须等到 Require.js 下载并执行结束后会开始处理其他 js。</p>
<p>以上例子的项目结构如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-034cd83f8f6c1bd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>最后小结一下，AMD 规范的具体实现 Require.js 其实从使用上来看，已经比较容易明白它的原理是什么了。</p>
<p>本质上，也还是利用了函数的特性，作为模块存在的那些代码本身已经通过 define 规范被定义在函数内了，所以模块内的代码自然对外是隐藏的，外部能访问到的只有函数内 return 的接口，那么这里其实也就利用了闭包的特性。</p>
<p>所以，模块化的实现，无非就是让函数作为临时命名空间结合闭包或者对象作为命名空间方式， 这种方式即使没有 CommonJS 规范，没有 AMD 规范，自己写代码很可以容易的实现。那么为什么会有这些规范技术的出现呢？</p>
<p>无非就是为了引入一个管理者的角色，没有管理者的角色，模块之间的依赖关系，哪个文件先加载，哪个后加载，&lt;script&gt; 的书写顺序都只能依靠人工来维护、管理。</p>
<p>而这些模块化规范，其实目的就在于解决这些问题，CommonJS 是由 Node.js 作为管理者角色，来维护、控制各模块的依赖关系，文件的加载顺序。而 AMD 则是由 Require.js 来作为管理者角色，开发者不用在 HTML 里写那么多 &lt;script&gt;，而且也没必要去关心这些文件谁写前谁写后，Require.js 会自动根据 require 来维护这些依赖关系，自动根据 requirejs.config 的配置信息去决定先加载哪个文件后加载哪个文件。</p>
<h3 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h3><p>CMD 规范，类似于 AMD，同样也是用于解决前端里的模块化技术问题。而有了 AMD 为什么还会有 CMD，我个人的理解是，AMD 的适用场景并没有覆盖整个前端里的需求，或者说 AMD 本身也有一些缺点，导致了新的 CMD 规范的出现。</p>
<p>比如说，从使用方式上，AMD 就有很多跟 CommonJS 规范不一致的地方，对于从 CommonJS 转过来的这部分人来说，可能就会很不习惯；再比如说，AMD 考虑的场景可能太多，又要适配 jQurey，又要适配 Node 等等；</p>
<p>总之，CMD 规范总有它出现和存在的理由，下面就大概来看看 CMD 的用法：</p>
<h4 id="define-amp-exports"><a href="#define-amp-exports" class="headerlink" title="define&amp;exports"></a>define&amp;exports</h4><p>类似于 AMD，CMD 规范中，也是通过 define 定义一个模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"dasu"</span>;</span><br><span class="line">    <span class="keyword">var</span> wx = <span class="string">"dasuAndroidTv"</span>;</span><br><span class="line">    <span class="keyword">var</span> getBlog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"http://www.cnblogs.com/dasusu/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    exports.name = name;</span><br><span class="line">    exports.getWx = <span class="function"><span class="params">()</span> =&gt;</span> wx;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>跟 AMD 不一样的地方是，CMD 中 define 只接收一个参数，参数类型是一个函数，函数的参数也很重要，有三个，按顺序分别是 require，exports，module，作用就是 CommonJS 规范中三个命令的用途。</p>
<p>如果当前模块需要依赖其他模块，那么在内部，使用 require 命令即可，所以，函数的三个参数很重要。</p>
<p>当前模块如果不依赖其他模块，也没有对外提供任何接口，那么，函数可以没有参数，因为有了内部也没有使用。</p>
<p>而如果当前模块需要依赖其他模块，那么就需要使用到 require，所以函数第一个参数就是必须的；如果当前模块需要对外暴露接口，那么后两个参数也是需要的；</p>
<p>总之，建议使用 define 定义模块时，将函数三个参数都带上，用不用再说，规范一点总没错。</p>
<h4 id="require-2"><a href="#require-2" class="headerlink" title="require"></a>require</h4><p>在有需要使用某个模块提供的功能时，通过 require 来声明依赖关系：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"=====main.js======="</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> module1 = <span class="built_in">require</span>(<span class="string">"./module"</span>);<span class="comment">//同步加载模块</span></span><br><span class="line">    <span class="built_in">console</span>.log(module1.name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">require</span>.async(<span class="string">"./module2"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">module2</span>) </span>&#123;<span class="comment">//异步加载模块</span></span><br><span class="line">        <span class="built_in">console</span>.log(module2.wx);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>require 默认是以同步方式加载模块，如果需要异步加载，需要使用 require.async</p>
<h4 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol>
<li>下载 Sea.js，并放到项目中</li>
</ol>
<p><a href="https://github.com/seajs/seajs/releases" target="_blank" rel="noopener">Sea.js:https://github.com/seajs/seajs/releases</a>  </p>
<ol start="2">
<li>新建作为模块的文件，如 module.js，并通过 define 定义模块</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"dasu"</span>;</span><br><span class="line">    <span class="keyword">var</span> wx = <span class="string">"dasuAndroidTv"</span>;</span><br><span class="line">    <span class="keyword">var</span> getBlog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"http://www.cnblogs.com/dasusu/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    exports.name = name;</span><br><span class="line">    exports.getWx = <span class="function"><span class="params">()</span> =&gt;</span> wx;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>其他需要依赖到该模块的地方通过 require 声明</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"=====main.js======="</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> module1 = <span class="built_in">require</span>(<span class="string">"./module"</span>);<span class="comment">//同步加载模块</span></span><br><span class="line">    <span class="built_in">console</span>.log(module1.name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">require</span>.async(<span class="string">"./module2"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">module2</span>) </span>&#123;<span class="comment">//异步加载模块</span></span><br><span class="line">        <span class="built_in">console</span>.log(module2.wx);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>最后也最重要的一步，在 html 中先加载 sea.js 并指定主模块的 js</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/lib/require.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">     seajs.use(<span class="string">"./js/src/main.js"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用步骤跟 AMD 很类似，首先是需要依赖于 Sea.js，所以必须先下载它。</p>
<p>然后定义模块、依赖模块、使用模块的方式就跟 CommonJS 很类似，这几个操作跟 AMD 会有些不同，也许这点也正是 CMD 存在的原因之一。</p>
<p>最后一步也是最重要一步，需要在 HTML 文档中加载 sea.js 文档，并指定入口的 js，注意做的事虽然跟 AMD 一样，但实现方式不一样。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>其实，CMD 跟 CommonJS 很类似，甚至在模块化方面的工作，可以很通俗的将 sea.js 理解成 node.js 所做的事，只是有些 node.js 能完成但却无法通过 sea.js 来负责的工作需要开发人员手动处理，比如定义一个模块、通过 &lt;script&gt; 加载 sea.js 和指定主入口的 js 的工作。</p>
<h3 id="CommonJS-AMD-CMD-三者间区别"><a href="#CommonJS-AMD-CMD-三者间区别" class="headerlink" title="CommonJS, AMD, CMD 三者间区别"></a>CommonJS, AMD, CMD 三者间区别</h3><p>下面分别从适用场景、使用步骤、使用方式、特性等几个方面来对比这些不同的规范：</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>CommonJS 用于服务端，基于 Node.js 的运行环境；</p>
<p>AMD 和 CMD 用于前端，基于浏览器的运行环境；</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>CommonJS 通过 require 来依赖其他模块，通过 exports 来为当前模块暴露接口；</p>
<p>AMD 通过 define 来定义模块，通过 requirejs.config 来配置模块路径信息，通过 require 来依赖其他模块，通过 retrurn 来暴露模块接口；</p>
<p>CMD 通过 define 来定义模块，通过 require 来依赖其他模块，通过 exports 来为当前模块暴露接口；</p>
<h4 id="使用步骤-2"><a href="#使用步骤-2" class="headerlink" title="使用步骤"></a>使用步骤</h4><p>CommonJS 适用的 Node.js 运行环境，无需其他步骤，正常使用模块技术即可；</p>
<p>AMD 适用的前端浏览器的运行环境没有 Require.js，所以项目中需要先加载 Require.js，然后再执行主入口的 js 代码，需要在 HTML 中使用类似如下命令：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/lib/require.js"</span> <span class="attr">data-main</span>=<span class="string">"js/src/main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CMD 适用的前端浏览器的运行环境也没有 Sea.js，所以项目中也需要先加载 Sea.js，然后再执行主入口的 js 代码，需要在 HTML 中使用类似如下命令：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/lib/sea.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    seajs.use(<span class="string">"./js/src/main.js"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>AMD：依赖前置、提前执行，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'module1'</span>,<span class="string">'module2'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">m1, m2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br><span class="line">define([<span class="string">'module1'</span>,<span class="string">'module2'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">m1, m2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>需要先将所有的依赖的加载完毕后，才会去处理回调中的代码，这叫依赖前置、提前执行；</p>
<p>CMD：依赖就近、延迟执行，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">var</span> module1 = <span class="built_in">require</span>(<span class="string">"./module1"</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"./module2"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m2</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>等代码执行到 require 这行代码时才去加载对应的模块</p>
<h3 id="ES6标准"><a href="#ES6标准" class="headerlink" title="ES6标准"></a>ES6标准</h3><p>ES6 中新增的模块特性，在上一篇中已经稍微介绍了点，这里也不具体展开介绍了，需要的话开头的声明部分有给出链接，自行查阅。</p>
<p>这里就简单说下，在前端浏览器中使用 ES6 模块特性的步骤：</p>
<ol>
<li><p>定义模块，通过指定 &lt;script type=”module”&gt; 方式</p>
</li>
<li><p>依赖其他模块使用 import，模块对外暴露接口时使用 export；</p>
</li>
</ol>
<p>需要注意的一点是，当 JS 文件内出现 import 或者 export 时，这份 JS 文件必须声明为模块文件，即在 HTML 文档中通过指定 &lt;script&gt; 标签的 type 为 module，这样 import 或 export 才能够正常运行。</p>
<p>也就是说，使用其他模块的功能时，当前的 JS 文件也必须是模块。</p>
<p>另外，有一点，ES6 的模块新特性，所有作为模块的文件都需要开发人员手动去 HTML 文档中声明并加载，这是与其他方案不同的一点，ES6 中 import 只负责导入指定模块的接口而已，声明模块和加载模块都需要借助 &lt;script&gt; 实现。</p>
<p>这里不详细讲 ES6 的模块特性，但想来讲讲，一些转换工作的配置，因为：</p>
<ul>
<li>有些浏览器不支持 ES6 的语法，写完 ES6 的代码后，需要通过 Babel 将 ES6 转化为 ES5。</li>
<li>生成了 ES5 之后，里面仍然有 require 语法，而浏览器并不认识 require 这个关键字。此时，可以用 Browserify 编译打包 js，进行再次转换。</li>
</ul>
<p>而我是选择使用 WebStrom 作为开发工具的，所以就来讲讲如何配置</p>
<h4 id="WebStrom-的-Babel-配置"><a href="#WebStrom-的-Babel-配置" class="headerlink" title="WebStrom 的 Babel 配置"></a>WebStrom 的 Babel 配置</h4><p>教程部分摘抄自：<a href="https://github.com/smyhvae/Web/blob/master/10-ES6/03-ES6%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.md" target="_blank" rel="noopener">ES6的介绍和环境配置</a>  </p>
<ol>
<li>新建项目</li>
<li>通过 npm 初始化项目</li>
</ol>
<p>在安装 Babel 之前，需要先用 npm 初始化我们的项目。打开终端或者通过 cmd 打开命令行工具，进入项目目录，输入如下命令： <code>npm init -y</code>，命令执行结束后，会在项目根目录下生成 package.json 文件</p>
<ol start="3">
<li>（首次）全局安装 Babel-cli</li>
</ol>
<p>在终端里执行如下命令：</p>
<p><code>npm install -g babel-cli</code></p>
<ol start="4">
<li>本地安装 babel-preset-es2015 和 babel-cli</li>
</ol>
<p><code>npm install --save-dev babel-preset-es2015 babel-cli</code></p>
<p>本地是指在项目的根目录下打开终端执行以上命令，执行结束，项目根目录的 package.json 文件中会多了 devDependencies 选项</p>
<ol start="5">
<li>新建 .babelrc 文件</li>
</ol>
<p>在根目录下新建文件 .babelrc，输入如下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>:[</span><br><span class="line">        <span class="string">"es2015"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"plugins"</span>:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>执行命令转换</li>
</ol>
<p><code>babel js/src/main.js -o js/dist/main.js</code></p>
<p><code>-o</code> 前是原文件，后面是转换后的目标文件</p>
<p>这是我的项目结构：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-31d87a30a0ebf287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>.json 文件和 node_modules 文件夹都是操作完上述步骤后会自动生成的，最后执行完命令后，会在 dist 目录下生成目标文件。</p>
<ol start="7">
<li>（可选）如果嫌每次执行的命令太过复杂，可利用 npm 脚本</li>
</ol>
<p>将 <code>babel js/src/main.js -o js/dist/main.js</code> 这行代码复制到 package.json 里的 scripts 字段中：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-29092902bb38740b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>以后每次都点一下 build 左边的三角形按钮运行一下脚本就可以了，省去了手动输命令的时间。</p>
<ol start="8">
<li>（可选）如果还嫌每次手动点击按钮运行脚本麻烦，可配置监听文件改动自动进行转换</li>
</ol>
<p>打开 WebStrom 的 Setting -&gt; Tools -&gt; File Watchers，然后点击 <code>+</code> 按钮，选择 Babel 选项，然后进行配置：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-eb1db6734321b859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<ol start="9">
<li>最后，以后每次新的项目，除了第 3 步不用了之外，其余步骤仍旧需要进行。</li>
</ol>
<h4 id="WebStrom-的-Browserify-配置"><a href="#WebStrom-的-Browserify-配置" class="headerlink" title="WebStrom 的 Browserify 配置"></a>WebStrom 的 Browserify 配置</h4><p>步骤跟上述很类似，区别仅在于一个下载 babel，这里下载的是 browserify，以及转换的命令不同而已：</p>
<ol>
<li>新建项目</li>
<li>通过 npm 初始化项目</li>
</ol>
<p>打开终端，进入到项目的根目录，执行 <code>npm init -y</code>，执行结束后会在根目录生成 package.json 文件</p>
<ol start="3">
<li>（首次）全局安装 browserify</li>
</ol>
<p>在终端里执行如下命令：</p>
<p><code>npm install browserify -g</code></p>
<ol start="4">
<li>执行命令转换</li>
</ol>
<p><code>browserify js/src/main.js -o js/dist/main.js --debug</code></p>
<p><code>-o</code> 前是原文件，后面是转换后的目标文件</p>
<ol start="5">
<li>（可选）如果嫌每次执行的命令太过复杂，可利用 npm 脚本</li>
</ol>
<p>将 <code>browserify js/src/main.js -o js/dist/main.js --debug</code> 这行代码复制到 package.json 里的 scripts 字段中：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-81403dd08b5a1477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>    </p>
<p>以后每次都点一下 build 左边的三角形按钮运行一下脚本就可以了，省去了手动输命令的时间。</p>
<ol start="6">
<li>（可选）如果还嫌每次手动点击按钮运行脚本麻烦，可配置监听文件改动自动进行转换</li>
</ol>
<p>打开 WebStrom 的 Setting -&gt; Tools -&gt; File Watchers，然后点击 <code>+</code> 按钮，选择 &lt;custom&gt; 选项，然后进行配置：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-c793bcc1cfc2333a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<ol start="7">
<li>最后，以后每次新的项目，除了第 3 步不用了之外，其余步骤仍旧需要进行。  </li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>前端21-JavaScript的ES6新特性</title>
    <url>/2018/11/05/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A821-JavaScript%E7%9A%84ES6%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本篇内容全部摘自阮一峰的：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a></p>
<p>阮一峰的这本书，我个人觉得写得挺好的，不管是描述方面，还是例子，都讲得挺通俗易懂，每个新特性基本都还会跟 ES5 旧标准做比较，说明为什么会有这个新特性，这更于理解。</p>
<p>所以，后续不会再写个关于 ES6 系列的文章了，就在这篇里大概的列举一下，大体清楚都有哪些新特性就好了，以后需要用时再去翻一翻阮一峰的书。</p>
<h1 id="正文-ES6新特性"><a href="#正文-ES6新特性" class="headerlink" title="正文-ES6新特性"></a>正文-ES6新特性</h1><p>ES6 新标准规范相比于 ES5 旧标准规范中，无非就三个方面的改动：新增、更新、废弃。</p>
<p>由于更新和废弃需要考虑到兼容性问题，所以这两方面的内容应该并不多，那么大部分基本都是新增的特性。对于新增的特性来说，大体上也还可以再分两类：完全新增的特性和基于旧标准扩展的特性。</p>
<p>下面就大概来过一下，ES6 中新增的特性。</p>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>这是新增的一种原始数据类型，ES5 中原始类型有 5 种，在 ES6 中新引入了一种后，现在就是有 6 种原始数据类型了：Number、String、Boolean、null、undefined、Symbol</p>
<p>这个单词中文直译是：符号、标志等，但好像并没有在书中有这种叫法，书中都是直接使用 Symbol 来描述，可能中文翻译不能够很好的表示出这种原始数据类型的含义吧。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>之所以新增了这种原始数据类型，是为了解决：</p>
<blockquote>
<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。 </p>
</blockquote>
<h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'s1'</span>); <span class="comment">//参数只是用来描述当前 s1 变量，跟其他 Symbol 数据类型的变量相区分，在调用 toString 或 typeOf 时会输出当前数据类型跟描述信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o[s1] = <span class="string">"dasu"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    [s1]: <span class="string">"dasu"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, s1, &#123;<span class="attr">value</span>: <span class="string">"dasu"</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>给一个对象定义一个属性名用 Symbol 数据类型来表述的方法有上述三种，如果使用 <code>o.s1 = &quot;dasu&quot;</code> 这种方式，是给 o 对象定义了一个属性名为 s1 且数据类型为字符串的属性，字符串就存在相等与否的场景。而使用上述三种方式，是给对象定义了一个属性名为 s1 但数据类型为 Symbol 的属性，如果后期又定义了另一个属性名为 s1 的 Symbol 原始值的属性，并不会覆盖之前定义的属性。</p>
<p>其他内容，包括关于 Symbol 属性的遍历、Symbol 自带的方法、Symbol 应用场景等见：<a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener">Symbol</a>  </p>
<h3 id="块作用域-let-和-const"><a href="#块作用域-let-和-const" class="headerlink" title="块作用域 let 和 const"></a>块作用域 let 和 const</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>ES5 中变量的作用域只分全局作用域和函数内作用域，且全局变量本质上是全局对象的属性，书中是这么评价的：</p>
<blockquote>
<p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 </p>
</blockquote>
<p>为了解决这些问题，ES6 中新增了块级作用域的变量，通过关键字：let 和 const 声明的变量，作用域是块级作用域，同时，这些变量不属于顶层对象的属性。</p>
<p>const 定义的变量是常量，除此外，这个变量跟用 let 定义的变量没有其他方面的区别了。而通过 let 和 const 定义的变量行为、作用域类似于 Java 语言中定义的变量行为。</p>
<p>换句话说，let 和 const 定义的变量已经不包含 var 定义的变量的各种特性行为了，比如：没有变量的声明提前特性、存在暂时性死区（在定义之前不能使用，只能在定义变量位置之后使用）、不允许重复声明、作用域只有块级作用域等。</p>
<p>更多的参考：<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">let 和 const  命令</a></p>
<h3 id="Module-模块机制"><a href="#Module-模块机制" class="headerlink" title="Module 模块机制"></a>Module 模块机制</h3><h3 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h3><p>ES5 中并没有模块机制，常见的方式是：前端里通过 &lt;script&gt; 加载各种不同的 js 文件代码，在 js 文件代码内部中提供一些全局变量或全局函数供其他 &lt;script&gt; 使用。</p>
<p>说白了，就是不同 js 文件通过全局对象作为通信的桥梁来相互访问。而为了解决不同 js 文件共享全局对象造成的变量冲突问题，通常作为模块的 js 里的代码都会放在一个立即执行的函数内。</p>
<p>而 ES6 中，引入了模块的机制。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>当在 HTML 文档中，通过指定 &lt;script&gt; 标签的 type 属性为 module 时，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器会按照模块的处理方式来加载这份 js 文件，与模块脚本的处理方式与正常 js 脚本文件处理方式最不同的地方在于，模块内的代码都是在模块作用域中执行，也就是在模块 js 文件中的全局变量这些并不会被添加到全局对象的属性中，其他 js 文件无法访问。</p>
<p>那么，其他 js 文件如何使用这份模块 js 文件呢？</p>
<p>有三点要求：</p>
<ol>
<li>模块 js 文件内，需要通过 export 声明该模块对外开放的接口</li>
<li>当前 js 文件内，需要通过 import 来引入模块对外开放的接口，想使用哪些接口，就需要引入哪些</li>
<li>当前 js 也必须是模块脚本文件，即 type=module 才行</li>
</ol>
<p>import 命令和 export 命令是模块机制的关键，但只两个命令只能在 type=module 的 js 文件内生效，如果某个 js  文件声明了 type=text/javascript，然后代码里又使用到 import 或 export，那么运行期间会报错。</p>
<ul>
<li>对外提供功能的模块</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.js</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//以上省略模块内部功能代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一般对外的接口可放在文件底部，方便一览无余</span></span><br><span class="line"><span class="comment">//第一种：</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">"dasu"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">"dasuAndroidTv"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种：</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"dasu"</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">"dasuAndroidTv"</span>&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;name, getName&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用其他模块功能的当前脚本</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种：from后跟js的相对路径或绝对路径</span></span><br><span class="line"><span class="keyword">import</span> &#123;name, getName&#125; <span class="keyword">from</span> <span class="string">'module.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种：</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Module <span class="keyword">from</span> <span class="string">'module.js'</span></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Module.name;</span><br><span class="line">Module.getName();</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>最后，记住，模块脚本文件中，自动以严格模式运行，限制也很多，更多用法、细节说明参考：</p>
<p><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">module 的语法</a></p>
<p><a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">module 的加载实现</a></p>
<h3 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a>变量解构</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>ES6 允许写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>
<p>这种特性可以带来很多便捷：</p>
<ul>
<li>函数可以返回多个值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>

<ul>
<li>对象取值时很方便</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析服务端返回的数据对象，提取其中的各字段值</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    code: <span class="number">1</span>,</span><br><span class="line">  	msg: <span class="string">"success"</span>,</span><br><span class="line">    content: &#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;code, msg, content&#125; = o;</span><br></pre></td></tr></table></figure>

<p>解构时，还可以设置默认值，更多用法，参考：<a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">变量的解构赋值</a></p>
<h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><p>ES6 中对字符串的处理扩展了很多新特性，让字符串的处理更加强大，下面看一个很强大的特性：</p>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(</span><br><span class="line">  <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</span><br><span class="line">  <span class="string">'items in your basket, '</span> +</span><br><span class="line">  <span class="string">'&lt;em&gt;'</span> + basket.onSale +</span><br><span class="line">  <span class="string">'&lt;/em&gt; are on sale!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure>

<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 </p>
<p>更多字符串扩展的特性介绍参见：<a href="http://es6.ruanyifeng.com/#docs/string" target="_blank" rel="noopener">字符串的扩展</a></p>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><p>ES6 中，对于函数的处理也增加了很多新特性，让函数变得更强大。</p>
<h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    x = x || <span class="string">'dasu'</span>;</span><br><span class="line">  	y = y || <span class="string">'Android'</span>;</span><br><span class="line">  	<span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x=<span class="string">"dasu"</span>, y=<span class="string">"Android"</span></span>) </span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，参数默认值还有更多细节，比如默认参数的作用域是单独的、有默认参数值的函数 length 属性含义会变化等等。</p>
<h4 id="剩余参数-reset"><a href="#剩余参数-reset" class="headerlink" title="剩余参数 reset"></a>剩余参数 reset</h4><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>箭头前面是参数，后面的函数体，如果超过 1 个参数，那么用圆括号将多个参数圈起，如果没有参数，就用一个空圆括号 () 表示，如果函数体超过 1 行语句，那么用 {} 大括号包住。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当函数作为另一个函数的参数时，箭头函数的写法会让代码变得很便捷，如：</p>
<ul>
<li>箭头函数的一个用处是简化回调函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure>

<ul>
<li>嵌套的箭头函数</li>
</ul>
<p>箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">into</span>: <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">after</span>: <span class="function"><span class="keyword">function</span> (<span class="params">afterValue</span>) </span>&#123;</span><br><span class="line">      array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>上面这个函数，可以使用箭头函数改写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> insert = <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="function">(<span class="params">&#123;into: (array</span>) =&gt;</span> <span class="function">(<span class="params">&#123;after: (afterValue</span>) =&gt;</span> &#123;</span><br><span class="line">  array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>但使用箭头函数有一些注意点：</p>
<ul>
<li>函数体内的 <code>this</code> 的指向，就是定义时所在的对象，而不是使用时所在的对象。 </li>
<li>不可以当作构造函数，也就是说，不可以使用 <code>new</code> 命令，否则会抛出一个错误。 </li>
<li>不可以使用 <code>arguments</code> 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 </li>
<li>不可以使用 <code>yield</code> 命令，因此箭头函数不能用作 Generator 函数。 </li>
</ul>
<p>其他还有很多扩展，包括在 ES5 中，函数有个 name 属性并在标准规范中，但在 ES6 中加入了标准规范中，还有其他新增的一些特性，具体参考：<a href="http://es6.ruanyifeng.com/#docs/function" target="_blank" rel="noopener">函数的扩展</a></p>
<h3 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a>class 类</h3><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>
<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p>
<p>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point();</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。也就是说，ES5 的构造函数<code>Point</code>，对应 ES6 的<code>Point</code>类的构造方法。</p>
<p><code>Point</code>类除了构造方法，还定义了一个<code>toString</code>方法。注意，定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<p>ES6 的类，完全可以看作构造函数的另一种写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  doStuff() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stuff'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Bar();</span><br><span class="line">b.doStuff() <span class="comment">// "stuff"</span></span><br></pre></td></tr></table></figure>

<p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类的实例上面调用方法，其实就是调用原型上的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>更多细节内容参考：</p>
<p><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">class 的基本语法</a></p>
<p><a href="http://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">class 的继承</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>阮一峰好歹专门为 ES6 新增的特性写了一整本书，想用一个章节来介绍太不可能了，很多我也没有去细看。</p>
<p>本篇的主旨就在于大体上列出一些新特性，知道原来 ES6 新增了这些东西，后续有时间再去细看这本书，或者当用到的时候再去查。</p>
<p>最后，就列举下，其他上面没有讲到的特性吧：</p>
<ul>
<li>ArrayBuffer：大概同于操作二进制数据</li>
<li>set 和 map：新增是数据结构，类似于数组，可以类比 Java 中的 Set 和 Map</li>
<li>Proxy：修改某些默认行为，等同于在语言层面做出修改，所以属于”元编程”，即对编程语言进行编程。</li>
<li>Reflect：同样是用于操作对象，修改默认行为。Proxy 更多是在原本行为上增加新的行为，而 Reflect 则是直接修改原本行为。</li>
<li>Iterator 和 for..of 循环：为不同的数据结构提供各自的遍历访问操作</li>
<li>Promise：异步编程的解决方案，比传统的解决方案（回调和事件）更合理强大</li>
<li>Generator 函数：异步编程的解决方案</li>
<li>async：Generator 函数的语法糖</li>
<li>正则的扩展、数组的扩展、数值的扩展、对象的扩展等</li>
</ul>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">x</span>) </span>{
   A.prototype.x = x;
   A.prototype.y = <span class="number">1</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>{}
B.prototype = <span class="keyword">new</span> A();

<span class="keyword">var</span> b = <span class="keyword">new</span> B();
b.y; <span class="comment">//1</span>


=
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>前端20-JavaScript异步回调的执行时机（进阶）</title>
    <url>/2018/11/04/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A820-JavaScript%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-异步回调的执行时机"><a href="#正文-异步回调的执行时机" class="headerlink" title="正文-异步回调的执行时机"></a>正文-异步回调的执行时机</h1><p>本篇会讲到一个单线程事件循环机制，但并不是网络上对于 js 执行引擎介绍中的单线程机制，也没有涉及宿主环境浏览器的各种线程，如渲染线程、js 引擎执行线程、后台线程等等这些内容。</p>
<p>严谨来讲，应该不属于 JavaScript 自身的单线程机制，而是宿主对象，如浏览器处理执行 js 代码的单线程事件循环机制。</p>
<p>回到正题，本篇所要讲的，就是<strong>类比于 Android 中的主线程消息队列循环机制，来讲讲在 JavaScript 中，如果设置了某个异步任务后，当异步任务执行完成需要回调通知时，这个回调任务的执行时机</strong>。</p>
<p>如果还不清楚要讲的是什么，那么先来看个问题：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"https://easy-mock.com/mock/5b592c01e4e04f38c7a55958/ywb/is/version/checkVersion"</span>,</span></span><br><span class="line"><span class="javascript">        data: &#123;<span class="string">"key"</span>: <span class="number">122</span>&#125;,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"POST"</span>,</span></span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"----------success-----------"</span>);  <span class="comment">//什么时候会执行回调</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        error: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"----------error-----------"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">	<span class="comment">//...</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是用 jQuery 写的 ajax 网络请求的示例，这条请求自然是异步进行的，但当请求结果回来后，会去触发 success 或 error 回调，那么，问题来了：</p>
<p><strong>Q：想过没有，如果请求结果回来后，这个回调的代码是在什么时机会被执行的？是立马就执行吗，不管当前是否正在执行某个函数内的代码？还是等当前的函数执行结束？又或者是？</strong></p>
<p>也许你还没看懂这个问题要问的是什么，没关系，下面举例分析时，会讲得更细，到时你就知道这个问题要问的是什么了。</p>
<h3 id="Android-消息队列循环机制"><a href="#Android-消息队列循环机制" class="headerlink" title="Android 消息队列循环机制"></a>Android 消息队列循环机制</h3><p>先来看看 Android 中的主线程消息队列循环机制，当然如果你不是从 Android 转前端，那可以跳过这趴：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/652037-8523323f2946a1d8.png" alt>  </p>
<blockquote>
<p>这张图来自 <a href="https://www.jianshu.com/p/8656bebc27cb" target="_blank" rel="noopener">Android消息机制（一）：概述设计架构 </a>这篇文章中，我懒得自己画了，借大佬图片一用，如果不允许使用，麻烦告知下，我再来自己画。</p>
</blockquote>
<p>在 Android 里有个主线程，因为只能在主线程中进行 UI 操作，所以也叫 UI 线程，这个主线程在应用启动时就进入一个死循环中，类似于执行了 <code>while(true){...}</code> 这样的代码，等到应用退出时，退出该死循环。而死循环之所以不会卡死 CPU，是因为利用了 Linux 的 epoll 机制，通俗的来将，就是，主线程会一直循环往消息队列中取消息执行，如果队列中没有消息，那么会进入阻塞状态，等有新的消息到来时，唤醒继续处理。而阻塞和唤醒就是利用了 Linux 的 epoll 机制。</p>
<p>所以，在 Android 中，打开页面是一个 message，触摸屏幕也是一个 message，message 中指示着当前应该执行的代码段，只有当前的 message 执行结束后，下会轮到下个 message 执行。</p>
<p>所以，在 Android 中的异步任务的回调工作，比如同样异步发起一个网络请求，请求结果回来后，需要回调到主线程中处理，那么这个回调工作的代码段会被封装到 message 中，发送到消息队列中排队，直到轮到它来执行。</p>
<p>而 message 发送到消息队列是基于 Handler 来传输，所以，在 Android 中，如果想要查看 message 是以什么为粒度，查找在哪里通过 Handler 发送了 message 即可。</p>
<h3 id="JavaScript-中的单线程事件循环机制"><a href="#JavaScript-中的单线程事件循环机制" class="headerlink" title="JavaScript 中的单线程事件循环机制"></a>JavaScript 中的单线程事件循环机制</h3><p>那么，在 JavaScript 中，又是如何处理异步工作的回调任务的呢？</p>
<p>查了一些相关的资料，发现讲的都是 JavaScript 的单线程，事件循环机制等之类理论，但却没看到，事件的粒度是什么？</p>
<p>看完我能理解，JavaScript 也是类似 Android，一样执行了某段类似 <code>while(true){...}</code> 的代码来循环处理事件，但看完我仍旧无法理解，这个事件的粒度是什么，怎么查看事件的粒度？</p>
<p>再举个例子来说明我的疑问好了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"----------1-----------"</span>);</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"https://easy-mock.com/mock/5b592c01e4e04f38c7a55958/ywb/is/version/checkVersion"</span>,</span></span><br><span class="line"><span class="javascript">        data: &#123;<span class="string">"key"</span>: <span class="number">122</span>&#125;,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"POST"</span>,</span></span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"----------success-----------"</span>);  <span class="comment">//什么时候会执行回调</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        error: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"----------error-----------"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"----------2-----------"</span>);</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">"2"</span>);  <span class="comment">//第一个卡点</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"----------2.1-----------"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"------------2.2-----------"</span>);</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">"A"</span>);  <span class="comment">//第二个卡点</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    A();</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"---------------2.3---------------"</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"----------3-----------"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>alert()</code> 会阻塞当前程序，当 js 执行到 <code>alert()</code> 的代码时卡在这里，后续代码不会被执行，直到取消弹窗。所以，我们可以通过注释上例中相对应的 <code>alert()</code> 来模拟异步请求的结果在什么时候接收到，而这个回调任务又是在哪个时机被执行的。</p>
<p>好，那么疑问来了：</p>
<p>假设，程序卡在 <code>alert(&quot;2&quot;)</code> 这里，这时候，异步的请求结果回来了，那么回调任务是会被接到哪个时机执行？等我取消 alert 的弹窗后就先执行回调任务然后再继续处理 <code>alert(&quot;2&quot;)</code> 后的代码吗？</p>
<p>我们将 <code>alert(&quot;A&quot;)</code> 注释掉，运行一下，测试看看：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-0028e6328d2f23f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>当前程序确实卡在 <code>alert(&quot;2&quot;)</code>，而且我们等到请求结果回来了，这时，我们把 alert 弹窗取消掉，看看日志：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-890bdc61aa8a1c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>回调任务中输出的 success 在 <code>alert(&quot;2&quot;)</code> 后续代码输出的 2.1 下面，那么就是先继续执行 <code>alert(&quot;2&quot;)</code> 后面的代码，然后才会执行回调任务的代码了，那么这个后面的代码究竟包括哪些代码？</p>
<p>好，这个时候，我们把 <code>alert(&quot;2&quot;)</code> 代码注释掉，让程序卡在 <code>alert(&quot;A&quot;)</code> 这行代码。</p>
<p>假设，当前程序正在执行某个函数内的代码，这个时候异步请求的结果回来了，那么这个回调任务会接在这个函数执行结束后吗？也就是，我们现在来验证下事件的粒度是否是以函数为粒度？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-05f8354f1cd853ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-2287621ae0801726.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>程序确实卡在函数 A 内部的代码 <code>alert(&quot;A&quot;)</code>，输出的日志上也能看到现在已经输出到 2.2，且异步请求的结果也回来了，那么这个回调任务的代码会在函数调用执行结束后，就被处理吗？如果是的话，那么日志 2.2 接下去应该要输出 success 才对，如果不是，那么就会输出 2.3，看看日志：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6ca6ff8ed9b74334.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>也就是说，即使异步请求结果回来了，回调任务也不能在当前函数执行完后立马被处理，它还是得继续等待，等到函数后面的代码也执行完了，那这个后面的代码到底是什么呢？也就是事件的粒度到底是什么呢？</p>
<p>我们试过了以每行代码为粒度做测试，也试过了以函数为粒度做测试，那还能以什么作为粒度呢？或者是以 &lt;script&gt; 为粒度，只有等当前 &lt;script&gt; 标签内的代码都执行完，才轮到下个代码段执行？ </p>
<p>从上面两种场景下，所得到的日志来看，似乎确实也是这么个结论，success 的日志都是在 2.3 和 3 之间输出，2.3 表示当前 &lt;script&gt; 标签里的最后一行代码，而 3 表示下个 &lt;script&gt; 标签内的第一行代码。</p>
<p>既然这样，我们再来做个测试：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"----------1-----------"</span>);</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"https://easy-mock.com/mock/5b592c01e4e04f38c7a55958/ywb/is/version/checkVersion"</span>,</span></span><br><span class="line"><span class="javascript">        data: &#123;<span class="string">"key"</span>: <span class="number">122</span>&#125;,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"POST"</span>,</span></span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"----------success-----------"</span>);  <span class="comment">//什么时候会执行回调</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        error: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"----------error-----------"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    /*</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"----------2-----------"</span>);</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">"2"</span>);  <span class="comment">//第一个卡点</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"----------2.1-----------"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"------------2.2-----------"</span>);</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">"A"</span>);  <span class="comment">//第二个卡点</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    A();</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"---------------2.3---------------"</span>) *<span class="regexp">/</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"----------3-----------"</span>);</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">"3"</span>); <span class="comment">//第三个卡点</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"----------3.1---------"</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们把第一个 &lt;script&gt; 标签内那些用于上面两种场景测试的代码注释掉，只留一个异步请求的代码，然后在第二个 &lt;script&gt; 标签内，加个 <code>alert(&quot;3&quot;)</code> 来模拟程序是在第一个 &lt;script&gt; 中发起异步请求，但直到程序运行到第二个 &lt;script&gt; 时，异步请求结果才回来，这种场景下回调任务的执行时机会是在哪？</p>
<p>如果当程序卡在 <code>alert(&quot;3&quot;)</code>，异步请求结果回来了，这时候还没有取消 alert 弹窗，或者一取消的时候，就先输出 success，再输出 3.1，则表示，回调任务的代码块是被安排到发起异步请求的这个 &lt;script&gt; 里代码都执行结束就去处理。</p>
<p>如果 success 是在 3.1 之后才输出，那么，就可以说明，浏览器处理 js 代码，是以 &lt;script&gt; 作为事件粒度，放入事件循环队列中去处理。看看日志：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-4f03da685302f2cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>好了，现在可以确认了，success 是在 3.1 之后才输出的，那么来整理下结论吧。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>看到这里的话，你一定要继续看最后的一小节的内容，一定！</strong></p>
<p>之后问了一些前端同学，然后我基于对 Android 那边的类似理解，我自行梳理了下面的这些结论，因为涉及底层运行机制、浏览器行为的这些知识我还没开始去看，所以下面结论不保证正确，只能说是，基于我目前的能力，针对于做实验所得到的现象，我梳理出一些可以解释得通的结论。</p>
<ul>
<li>浏览器解析 html 文档时，是按顺序一行一行进行解析，当处理到 &lt;script&gt; 标签时，会暂停当前页面的渲染，进入 js 代码的执行。</li>
<li>在执行当前 &lt;script&gt; 标签内的代码时，是以整个标签内的代码块作为事件粒度，放入事件队列中进行处理。</li>
<li>如果在当前 &lt;script&gt; 标签里的代码发起了某些异步工作，如异步网络请求，并设置了回调，那么回调任务的代码块会被单独作为一个事件，等到异步工作结束后，插入当前事件队列中。</li>
<li>所以，如果回调任务在执行当前 &lt;script&gt; 标签内的代码时就已经加入队列了，那么等到当前 &lt;script&gt; 里的代码都执行结束后，就可以轮到回调任务的执行。</li>
<li>如果回调任务直到当前 &lt;script&gt; 里的代码都执行结束也还没被加入事件队列，那么这时浏览器会接着去解析 html 文档，如果又碰到下个 &lt;script&gt; 标签，那么会将这个 &lt;script&gt; 标签内的代码块放入事件队列中处理。</li>
<li>所以，如果这时候第一个 &lt;script&gt; 标签内的代码发起的异步任务才结束，才将回调工作加入事件队列中，那么这个回调工作的代码只能等到第二个 &lt;script&gt; 标签内的代码都执行结束后才会被处理。</li>
</ul>
<h3 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h3><p>为啥会想要梳理这个结论呢，是因为我碰到这么一种场景：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.location.href = <span class="string">"http://www.baidu.com"</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//...</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之前有个 h5 项目中，有类似的代码，就是满足一定条件下，需要将页面跳转至其他页面。</p>
<p>修改 <code>location.href</code> 貌似不是同步操作，我猜测应该是这行跳转代码会告诉浏览器，当前页面准备跳转，这时候，浏览器再生成一个跳转事件，接入事件队列中等待执行的吧。</p>
<p>因为，最初我以为这是个同步操作，所以我认为当程序执行到 <code>document.location.href = xx</code> 这行代码之后，页面就会发生跳转，然后这行代码下面的那些代码都不会被执行，但最后实际运行时，却发现，这行代码下面的代码也都被执行了。</p>
<p>后来经过测试，发现，跳转语句这行代码所在的 &lt;script&gt; 里的代码会被全部执行完，然后才发起页面跳转，下个 &lt;script&gt; 里的代码不会被执行，所以，那个时候，就有个疑惑了，在 js 中发起一个异步操作的话，这个异步工作的回调任务的执行时机到底在哪里？ </p>
<p>后来稍微查了相关资料，发现了个词说 JavaScript 是单线程机制，联想到 Android 中的主线程消息循环机制，这才想来理一理。</p>
<h3 id="卧槽"><a href="#卧槽" class="headerlink" title="卧槽"></a>卧槽</h3><p>卧槽，卧槽，卧槽~</p>
<p>不要怪我连骂粗话，这篇文章是挺早之前就写好的了，只是一直还没发表，待在草稿箱中。而最后这一小节，是等到我差不多要发表时才新增的内容。</p>
<p>为什么要骂粗话，因为我发现，我上面所梳理的结论，好像全部都是错误的了，但也不能说全部错误，我实在不想把辛辛苦苦写好的都删掉，也不想直接就发出来误导大伙，所以我在最后加了这一小节，来说明情况，大伙看这篇的结论时，看看就好，讨论讨论一下就好，不要太当真哈。</p>
<p>事情是这样的，我一些前端同学觉得我的理解有误，所以尝试将我上文中的例子在他的电脑上运行测试了下，结果你们看一下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-617ee21406a6fd11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>这是对应上文中第一个测试，即让程序卡在 <code>alert(&quot;2&quot;)</code> 这里，然后等到请求结果回来后，取消 alert 弹窗，这种场景，按照我们上面梳理的结论，回调任务在当前 &lt;script&gt; 执行结束之前就被插入事件队列中了，所以回调任务应该会在第二个 &lt;script&gt; 代码之前先被处理，但我同学的情况却是，回调任务等到所有 &lt;script&gt; 都处理完才被执行？？？</p>
<p>一脸懵逼？？？</p>
<p>然后，我怀疑是不是不同浏览器会有不同的行为，所以同样的测试步骤我在 IE 浏览器上测试了一下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-da3ecbbdf1bdcbbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>是不是更懵逼，明明程序卡在 <code>alert(&quot;2&quot;)</code> 这行代码这里，但异步请求回来后，回调任务居然直接被处理了，不等当前 &lt;script&gt; 代码块执行结束就先行处理了回调任务？</p>
<p>最后，我让我一些同事帮忙测试了一下，在 chrome 上测试、在 jsfiddle 上测试，测试结果，基本上全部都是我上文中梳理的结论。</p>
<p>只有个别情况，行为比较特异，对前端我才刚入门，为什么会有这种情况发生，有两个猜想：</p>
<ul>
<li>不同浏览器对于执行 js 代码块的行为不一致？</li>
<li>不同浏览器对于 <code>alert()</code> 的处理不一致？</li>
</ul>
<p>总之，最后，我还是觉得我本篇梳理出的结论比较符合大多数情况下的解释，当然，没有能力保证结论是正确的，大伙当个例子看就好，后续等能力有了，搞懂了相关的原理，再来重新梳理。</p>
<p>最后，如果你有不同的看法，欢迎指点一下哈~  </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>前端19-JavaScript闭包（进阶）</title>
    <url>/2018/11/03/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A819-JavaScript%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-闭包"><a href="#正文-闭包" class="headerlink" title="正文-闭包"></a>正文-闭包</h1><p>在作用域链那篇中，稍微留了个闭包的念想，那么这篇就来讲讲什么是闭包。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>这个闭包的概念蛮不好理解的，我在阮一峰的某篇文章中看过大概这么句话，闭包是对英文单词的直译，在中文里没有与之对应的句子解释，因此很难理解闭包究竟指的是什么。</p>
<p>看过很多解释，有说闭包就是函数；也有说闭包就是代码块；还有说函数内的函数就称闭包；还有说当函数返回内部某个函数时，返回的这个函数叫闭包，也有说闭包就是能够读取其他函数内部数据（变量/函数）的函数。</p>
<p>MDN 网站里不同文章里出现过多种解释：</p>
<blockquote>
<ol>
<li>一个闭包是一个可以自己拥有独立的环境与变量的表达式（通常是函数） </li>
<li>闭包是函数和声明该函数的词法环境的组合，这个环境包含了这个闭包创建时所能访问的所有局部变量 </li>
</ol>
</blockquote>
<p>另外，在某篇文章中，看过这么段话：</p>
<blockquote>
<p>2009年发布了ECMAScript-262-5th第五版，不同的是取消了变量对象和活动对象等概念，引入了词法环境（Lexical Environments）、环境记录（EnviromentRecord）等新的概念 </p>
</blockquote>
<p>所以如果对词法环境这个词不理解的，可以将其理解成执行上下文，或者作用域链。在开头声明给的第四个链接中，是有几篇很早很早之前大佬们翻译的国外的文章，里面对闭包的解释刚好和 MDN 的解释也很类似：</p>
<blockquote>
<p>闭包是代码块和创建该代码块的上下文中数据的结合</p>
</blockquote>
<p>如果这个代码块是函数，那么利用作用域链那篇中介绍的相关原理，从本质上看闭包：</p>
<blockquote>
<p>函数代码，和函数的内部属性 [[Scope]] 两者的结合可称为闭包。 :</p>
</blockquote>
<p>对于这么多文章中对闭包的这么多种解释，先不做评价，先来想想，为什么会有闭包，理清了后，你会发现，其实理解闭包没那么难。</p>
<h3 id="闭包意义"><a href="#闭包意义" class="headerlink" title="闭包意义"></a>闭包意义</h3><p>先看个例子： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = a();</span><br><span class="line">c();</span><br></pre></td></tr></table></figure>

<p>调用 <code>c()</code> 输出的是 1，这点在作用域链那节已经讲解过了，这里再稍微说下：</p>
<p>调用 <code>c()</code>，会为 c 函数创建一个函数执行上下文，其中作用域链为：</p>
<p><code>c函数EC.VO –&gt; a函数EC.VO -&gt; 全局EC.VO</code></p>
<p>VO 是变量对象，表示存储着当前上下文中所有变量的对象，所以如果以 VO 的实际对象表示作用域链：</p>
<p><code>c函数{} –&gt; a函数{num:1} -&gt; 全局{num:0}</code></p>
<p>（忽略 VO 中其他与此例无关变量）</p>
<p>所以，函数 c 内的代码输出 num 时，到作用域链上寻找时，发现最后使用的是 a 函数内部的 num 变量，最终输出 1。</p>
<p>但当时也提了个疑问，当代码执行到 <code>c()</code> 时，a 函数已经执行结束，那么 a 函数的 EC 已经从执行环境栈 ECS 中被移出了，c 函数的 EC 里的作用域链为何还会有 <code>a函数EC.VO</code> 存在？</p>
<p>这就是闭包的典型场景了，闭包的意义之一就是解决这种场景。</p>
<p>通过作用域链一篇后，我们知道，函数内的变量依赖于函数执行上下文 EC，一般来说，当调用函数时，创建函数执行上下文 EC，并入栈 ECS，当函数执行结束时，就将 EC 从 ECS 中移出，并释放内存空间。</p>
<p>通常函数的行为的确是这样，但当函数如果有返回值时，情况就不一样了。虽然函数执行结束后它的 EC 确实被移出 ECS，但并没有被回收，JavaScript 解释器的垃圾回收机制也有引用计数的处理。</p>
<p>既然内存没被回收，那么 EC 就还存在，那么当调用 <code>c()</code> 时，虽然 C 的函数执行上下文是新创建的，上下文的作用域链也是新创建的，但作用域链的取值是当前执行上下文的 VO 拼接上函数对象的内部属性 [[Scope]]。</p>
<p>这个函数对象的内部属性 [[Scope]] 存储的就是这个函数的外层函数的执行上下文里的作用域链，它的值并不是新创建的，一直保存着外层函数调用时生成的外层函数上下文中的作用域链，通过它可以访问到外层函数变量。</p>
<h3 id="再谈闭包概念"><a href="#再谈闭包概念" class="headerlink" title="再谈闭包概念"></a>再谈闭包概念</h3><p>所以，实际上，网络上这么多文章里对闭包的各种解释，其实都没错。如果对作用域链的原理理解清楚后，你会发现，其实函数就是闭包，因为由于作用域的机制，让函数内部也持有创建函数的上下文的数据集合，所以函数符合闭包的特性。</p>
<p>只是在大部分场景下，函数执行结束，函数的 EC 就可以被回收，那么这种场景闭包并没有什么实际应用意义。</p>
<p>除了函数，如果你可以让某部分代码块持有创建它的上下文的数据集合，那么这也可以称为闭包。</p>
<p>常见的一种就是在函数内返回一个对象，对象的某些属性使用了对象外层的数据，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> model = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        num:num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line">model.num;</span><br></pre></td></tr></table></figure>

<p>此时，也可以称返回的这个对象是闭包。</p>
<p>对于闭包，我对它的理解，更倾向于，闭包并不是一种机制，也不是一种具体的事物（如执行上下文），反而，闭包是对原本存在的事物满足某种场景下的一种称呼。</p>
<p>也就是说，闭包，它其实是在原有机制，原有事物上的另一种称呼。所以，网上也才有人会说，闭包是函数、闭包是内嵌的函数等等说法。其实，也不是说这是错的，他们有的是从闭包特性角度解释，有的是从闭包现象。</p>
<p>只是，这原本就存在的事物，你本可以就用它原本的称呼，既然想要用闭包来称呼它，那么自然是这个时候，称呼它为闭包有区别于原本事物的实际意义，所以也才有人会说当函数返回内部函数时，称为闭包，因为这种时候，返回的这个函数就是用到闭包的特性来解决某些问题，所以称这种现象为闭包当然就有实际应用场景意义了。</p>
<p>所以，我对闭包的理解，它并不是某个固定不变的东西，也不是某个具体的事物，只要符合闭包特性的原有事物，你都可以称它为闭包。所以，对于网上那些对闭包的解释，我的建议是，主谓互换一下，不要说闭包是函数，闭包是内嵌的函数等等，我们可以说，函数是闭包，内嵌的函数也是闭包。只要符合闭包特性的我们都可以称它为闭包，当然如果还有闭包的实际应用意义，那么称它为闭包更可以被人接受。</p>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><h4 id="作为外部和函数内部变量通信的桥梁"><a href="#作为外部和函数内部变量通信的桥梁" class="headerlink" title="作为外部和函数内部变量通信的桥梁"></a>作为外部和函数内部变量通信的桥梁</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> model = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        num:num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line">model.num;</span><br></pre></td></tr></table></figure>

<p>外部是访问不了函数内部的信息，而闭包是指代码块持有创建它的上下文的数据集合。那么，如果在函数内部创建一个闭包，将这个闭包返回给外部，外部是否就可以通过这个闭包作为桥梁来间接与函数内部通信了。 </p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        privateCounter += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            changeBy(<span class="number">1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            changeBy(<span class="number">-1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> privateCounter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>还是同样的原因，外部是访问不了函数内部的信息，而闭包是指代码块持有创建它的上下文的数据集合。</p>
<p>那么，是否就可以借助闭包的特性，将一些实现封装在函数内部，通过闭包给外部提供有限的接口使用。</p>
<p>但要注意，函数本来执行结束，它的 EC 从 ECS 栈内移出时，通常就可被回收了，但如果用到了闭包的特性，导致外部持有着函数内部某个引用，此时函数的 EC 就不会被回收，那么就会占用着内存，使用不当，还会有可能造成内存泄漏。  </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>前端18-JavaScript作用域链（进阶）</title>
    <url>/2018/11/03/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A818-JavaScript%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-作用域链"><a href="#正文-作用域链" class="headerlink" title="正文-作用域链"></a>正文-作用域链</h1><p>作用域一节中，我们介绍了变量的作用域分两种：全局和函数内，且函数内部可以访问外部函数和全局的变量。</p>
<p>我们也介绍了，每个函数被调用时，会创建一个函数执行上下文 EC，EC 里有个变量对象 VO 属性，函数内部操作的局部变量就是来源于 VO，但 VO 只保存当前上下文的变量，那么函数内部又是如何可以访问到外部函数的变量以及全局变量的呢？</p>
<p>本篇就是来讲讲作用域链的原理，理清楚这些理所当然的基础知识的底层原理。</p>
<p>先来看个例子，再看些理论，最后结合理论再回过头分析例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);  <span class="comment">//1. 输出什么</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">    b();  <span class="comment">//2. 输出什么</span></span><br><span class="line">    <span class="built_in">console</span>.log(sum); <span class="comment">//3. 输出什么</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d = a();</span><br><span class="line">    d();  <span class="comment">//4. 输出什么</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>当执行了最后一行代码时，会有四次输出，每次都会输出什么，可以先想想，然后再继续看下去，对比下你的答案是否正确。</p>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>作用域链的原理还是跟执行上下文 EC 有关，执行上下文 EC 有个作用域链属性（Scope chain），作用域链是个链表结构，链表中每个节点是一个 VO，在函数内部嵌套定义新函数就会多产生一个节点，节点越多，函数嵌套定义越深。</p>
<p>由于作用域链本质上类似于 VO，也是执行上下文的一个属性，那么，它的创建时机自然跟 EC 是一样的，即：全局代码执行时的解析阶段，或者函数代码执行时的解析阶段。</p>
<p>每调用一次函数执行函数体时，js 解释器会经过两个阶段：解析阶段和执行阶段；</p>
<p>调用函数进入解析阶段时主要负责下面的工作：</p>
<ol>
<li>创建函数上下文 </li>
<li>创建变量对象</li>
<li>创建作用域链</li>
</ol>
<p>创建变量对象的过程在作用域一节中讲过了，主要就是解析函数体中的声明语句，创建一个活动对象 AO，并将函数的形参列表、局部变量、arguments、this、函数对象自身引用添加为活动对象 AO 的属性，以便函数体代码对这些变量的使用。</p>
<p>而创建作用域链的过程，主要做了两件事：</p>
<ol>
<li>将当前函数执行上下文的 VO 放到链表头部</li>
<li>将函数的内部属性 [[Scope]] 存储的 VO 链表拼接到 VO 后面 </li>
</ol>
<p>ps:[[]] 表示 js 解释器为对象创建的内部属性，我们访问不了，也操作不了。</p>
<p>两个步骤创建了当前函数的作用域链，而当函数体的代码操作变量时，优先到作用域链的表头指向的 VO 寻找，找不到时，才到作用域链的每个节点的 VO 中寻找。</p>
<p>那么，函数的内部属性 [[Scope]] 存储的 VO 链表是哪里赋值的？</p>
<p>这部分工作也是在解析阶段进行的，只不过是外层函数被调用时的解析阶段。解析阶段会去解析当前上下文的代码，如果碰到是变量声明语句，那么将该变量添加到上下文的 VO 对象中，如果碰到的是函数声明语句，那么会将当前上下文的作用域链对象引用赋值给函数的内部属性 [[Scope]]。但如果碰到是函数表达式，那 [[Scope]] 的赋值操作需要等到执行阶段。</p>
<p>所以，函数的内部属性 [[Scope]] 存储着外层函数的作用域链，那么当每次调用函数时，创建函数执行上下文的作用域链属性时，直接拼接外层函数的作用域链和当前函数的 VO，就可以达到以函数内部变量优先，依照嵌套层次寻找外层函数变量的规则。</p>
<p>这也是为什么，明明函数的作用域链是当函数调用时才创建，但却依赖于函数定义的位置的原因。因为函数调用时，创建的只是当前函数执行上下文的 VO。而函数即使没被调用，只要它的外层函数被调用，那么外层函数创建执行上下文的阶段就会顺便将其作用域链赋值给在它内部定义的函数。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);  <span class="comment">//1. 输出：undefined </span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">    b();  <span class="comment">//2. 输出：1 </span></span><br><span class="line">    <span class="built_in">console</span>.log(sum); <span class="comment">//3.输出：-1 </span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d = a();</span><br><span class="line">    d();  <span class="comment">//4. 输出：2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>当第一次执行全局代码时，首先创建全局执行上下文EC： </li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-0cd23c3f0eb7636b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>所以，当进入执行阶段，开始执行全局代码时，全局变量已经全部添加到全局 EC 的 VO 里的，这也就是变量的提前声明行为，而且对于全局 EC 来说，它的作用域链就是它的 VO，同时，因为解析过程中遇到了函数声明语句，所以在解析阶段就创建了函数 a 对象（a:&lt;function&gt; 表示 a 是一个函数对象），也为函数 a 的内部属性 [[Scope]] 赋值了全局 EC 的作用域对象。  </p>
<ol start="2">
<li>全局代码执行到 <code>var c = function(num)</code> 语句时：</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-0b20f49b1a3e5f3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>相应的全局变量在执行阶段进行了赋值操作，那么，赋值操作实际操作的变量就是对全局 EC 的 VO 里的相对应变量的操作。</p>
<ol start="3">
<li>当全局代码执行到 <code>c(10)</code>，调用了函数 c 时：</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a2b4e9a9f0cfbdae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>也就是说，在 c 函数内部代码执行之前，就为 c 函数的执行创建了 c 函数执行上下文 EC，这个过程中，会将形参变量，函数体声明的变量都添加到 AO 中（在函数执行上下文中，VO 的具体表现为 AO），同时创建 arguments 对象，确定函数内 this 的指向，由于这里的普通函数调用，所以 this 为全局对象。</p>
<p>最后，会创建作用域链，赋值逻辑用伪代码表示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope chain = c函数EC.VO -&gt; c函数内部属性[[Scope]]</span><br><span class="line"></span><br><span class="line">           = c函数EC.VO -&gt; 全局EC.VO</span><br></pre></td></tr></table></figure>

<p>图中用数组形式来表示作用域链，实际数据结构并非数组，所以，对于函数 c 内部代码来说，变量的来源依照优先级在作用域链中寻找。</p>
<ol start="4">
<li>当函数 c 内部执行到 <code>var d = a();</code> 调用了 a 函数时：</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-3f774c53b74ba453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>同样，调用 a 函数时，也会为函数 a 的执行创建一个函数执行上下文，a 函数跟 c 函数一样定义在全局代码中，所以在全局 EC 的创建过程中，已经为 a 函数的内部属性 [[Scope]] 赋值了全局 EC.VO，所以 a 函数 EC 的作用域链同样是：a函数EC.VO -&gt; 全局EC.VO。</p>
<p>也就是作用域链跟函数在哪被调用无关，只与函数被定义的地方有关。</p>
<ol start="5">
<li>执行 a 函数内部代码</li>
</ol>
<p>接下去开始执行 a 函数内部代码，所以第一行执行 console.log(num) 时，需要访问到 num 变量，去作用域链中依次寻找，首先在 a函数EC.VO 中找到 num:undefined，所以直接使用这个变量，输出就是 undefined。 </p>
<ol start="6">
<li>执行 <code>var b = function()</code></li>
</ol>
<p>接下去执行了 <code>var b = function ()</code>，创建了一个函数对象赋值给 b，同时对 b 函数的内部属性 [[Scope]] 赋值为当前执行上下文的作用域链，所以 b 函数的内部属性 [[Scope]]值为：a函数EC.VO -&gt; 全局EC.VO </p>
<ol start="7">
<li>接下去执行到 <code>b()</code>，调用了b函数，所以此时： </li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-2cc82c2562a97739.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>同样，也为 b 函数的执行创建了函数执行上下文，而作用域链的取值为当前上下文的 VO 拼接上当前函数的内部属性 [[Scope]] 值，这个值在第 6 步中计算出来。所以，最终 b 函数 EC 的作用域：</p>
<p>b函数EC.VO -&gt; a函数EC.VO -&gt; 全局EC.VO</p>
<ol start="8">
<li>接下去开始执行函数b的内部代码：<code>console.log(num++);</code></li>
</ol>
<p>由于使用到 num 变量，开始从作用域链中寻找，首先在 <code>b函数EC.VO</code> 中寻找，没找到；接着到下个作用域节点 <code>a函数EC.VO</code> 中寻找，发现存在 num 这个变量，所以 b 函数内使用的 num 变量是来自于 a 函数内部，而这个变量的取值在上述介绍的第 7 步时已经被赋值为 1 了，所以这里输出1。</p>
<p>同时，它还对 num 进行累加1操作，所以当这行代码执行结束，a 函数 EC.VO 中的 num 变量已经被赋值为 2 了。</p>
<ol start="9">
<li>b 函数执行结束，将 b 函数 EC 移出 ECS 栈，继续执行栈顶a函数的代码：<code>console.log(sum);</code>：</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-af8c6f58fc6ce0a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>所以这里需要使用 sum 变量，同样去作用域链中寻找，首先在 <code>a函数EC.VO</code> 中并没有找到，继续去 <code>全局EC.VO</code> 中寻找，发现 sum 变量取值为 -1，所以这里输出-1. </p>
<ol start="10">
<li>a 函数也执行结束，将 a 函数 EC 移出 ECS 栈，继续执行 c 函数内的代码：<code>d()</code></li>
</ol>
<p>由于 a 函数将函数 b 作为返回值，所以 <code>d()</code> 实际上是调用的 b 函数。此时：</p>
<p> <img src="https://upload-images.jianshu.io/upload_images/1924341-a9235e8a599aad56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>这里又为 d 函数创建了执行上下文，所以到执行阶段执行代码：<code>console.log(num++);</code> 用到的 num 变量沿着作用域链寻找，最后发现是在 <code>a函数EC.VO</code> 中找到，且此时 num 的值为第 8 步结束后的值 2，这里就输出 2.</p>
<p>到这里你可能会疑惑，此时 ECS 栈内，<code>a函数EC</code> 不是被移出掉了吗，为何 d 函数创建 EC 的作用域链中还包括了 <code>a函数EC</code>。</p>
<p>这里就涉及到闭包的概念了，留待下节闭包讲解。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果要从原理角度理解： </p>
<ul>
<li>变量的作用域机制依赖于执行上下文，全局代码对应全局执行上下文，函数代码对应函数执行上下文</li>
<li>每调用一次函数，会创建一次函数执行上下文，这过程中，会解析函数代码，创建活动对象 AO，将函数内声明的变量、形参、arguments、this、函数自身引用都添加到AO中</li>
<li>函数内对各变量的操作实际上是对上个步骤添加到 AO 对象内的这些属性的操作</li>
<li>创建执行上下文阶段中，还会创建上下文的另一个属性：作用域链。对于函数执行上下文，其值为当前上下文的 VO 拼接上当前函数的内部属性 [[Scope]]，对于全局执行上下文，其值为上下文的 VO。</li>
<li>函数内部属性 [[Scope]] 存储着它外层函数的作用域链，是在外层函数创建函数对象时，从外层函数的执行上下文的作用域链复制过来的值。</li>
<li>总之，JavaScript 中的变量之所以可以在定义后被使用，是因为定义的这些变量都被添加到当前执行上下文 EC 的变量对象 VO 中了，而之所以有全局和函数内两种作用域，是因为当前执行上下文 EC 的作用域链属性的支持。也可以说一切都依赖于执行上下文机制。</li>
</ul>
<p>那么，如果想通俗的理解：</p>
<ul>
<li>函数内操作的变量，如果在其内部没定义，那么在其外层函数内寻找，如果还没有找到，继续往外层的外层函数内寻找，直到外层是全局对象为止。</li>
<li>这里的外层函数，指的是针对于函数声明位置的外层函数，而不是函数调用位置的外层函数。作用域链只与函数声明的位置有关系。  </li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>前端17-JavaScript作用域（进阶）</title>
    <url>/2018/11/02/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A817-JavaScript%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-作用域"><a href="#正文-作用域" class="headerlink" title="正文-作用域"></a>正文-作用域</h1><p>在 ES5 中，变量的作用域只有两类：</p>
<ul>
<li><p>全局作用域</p>
</li>
<li><p>函数作用域</p>
</li>
</ul>
<p>只要不是在函数内部定义的变量，作用域都是全局的，全局的变量在哪里都可以被访问到，即使跨 js 文件。</p>
<p>函数作用域是指在函数体定义的变量，不管有没有在函数体的开头定义，在函数体的任何地方都可以被使用，因为 JavaScript 中的变量有声明提前的行为。</p>
<p>函数作用域需要区别于 Java 语言中的块级作用域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">//输出undefined</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">//输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 中，类似的代码，在 for 循环前后输出的 i 都会是 0，因为都会使用成员变量 i，for循环内定义的 i 由于块级作用域限制，只在for 循环的 {} 大括号中的代码有效。</p>
<p>但在 JavaScript 中，变量作用域只分函数作用域，而且变量有声明提前的特性，所以在函数体内部第一次输出 i 时，此时变量已经提前声明，但还没初始化，所以会是 undefined。而函数内定义的变量的作用域或者说生命周期是整个函数内，所以即使 for 循环体语句结束，仍旧可以访问到 i 变量。</p>
<p>由于允许变量的重复定义，所以全局变量很容易起冲突，因为无法确保多份 js 文件中是否已经在全局中定义了该变量，一旦起冲突，浏览器行为仅仅是将后定义的覆盖掉前定义的而已，这对于浏览器角度没什么大问题，但对于程序而已，很容易出现不可控的问题。而且，极难排查。</p>
<p>所以，实际编程中，建议不要过多的使用全局变量，有多种方法可以避免：</p>
<ul>
<li>使用一个全局对象来作为命名空间，将其余不在函数体内部定义的变量，作为该全局对象的属性来定义使用。</li>
<li>使用一个立即执行的函数来作为临时命名空间，函数执行结束释放临时命名空间。</li>
<li>如果临时命名空间内的部分变量需要供外部使用，一可以将这部分变量添加到作为命名空间的全局对象上的属性，二可以利用闭包的特性，返回一个新建的对象，为该对象添加一些接口可访问这部分变量。</li>
</ul>
<h3 id="全局对象作为命名空间"><a href="#全局对象作为命名空间" class="headerlink" title="全局对象作为命名空间"></a>全局对象作为命名空间</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DASU = &#123;&#125;;</span><br><span class="line">DASU.num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(DASU.num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的全局对象意思是说，数据类型为对象的全局变量，简称全局对象，与前端里说的全局对象window是两个不同概念，区分一下。</p>
<p>其实也就是一种思想，将所有函数外需要定义的变量，都替换成对指定对象的属性来操作。</p>
<h3 id="立即执行的函数作为临时命名空间"><a href="#立即执行的函数作为临时命名空间" class="headerlink" title="立即执行的函数作为临时命名空间"></a>立即执行的函数作为临时命名空间</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    a();</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>

<p>当引入 js 文件到 HTML 时，js 文件中的代码就会被执行，或者声明了 &lt;script&gt; 标签后，在标签内的代码也会立马被执行。但函数只有被调用的时候才会执行，所以，如果我们使用一个立即执行的函数，那这个函数体内部的代码行为就跟正常的 js 文件代码被执行的行为一致了。</p>
<p>而且，还可以利用函数内作用域这一特点，来保证，在这个立即执行的函数内部定义的变量不会影响到全局变量。</p>
<p>缺点就是函数内部代码执行结束后，这些在函数内定义的变量就被回收了。所以，如果有些信息需要跨 js 文件通信，此时要么通过全局对象方式，要么通过闭包特性来辅助实现。</p>
<h3 id="临时命名空间内的变量共享方式"><a href="#临时命名空间内的变量共享方式" class="headerlink" title="临时命名空间内的变量共享方式"></a>临时命名空间内的变量共享方式</h3><p>全局变量可以在任何地方被访问，所以可以将那些需要共享给外部使用的临时命名空间内的变量赋值给全局对象的属性，即结合第一种：全局对象做命名空间方式。</p>
<p>或者，通过闭包的特性，作为临时命名空间的立即执行的函数需要有一个返回值，当外部持有这个返回值时，这个函数内的变量就不会被回收。</p>
<p>然后，返回值可以是一个对象，公开一些接口来获取这些需要共享的变量，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> model = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getNum: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line">model.getNum();</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者：</span></span><br><span class="line"><span class="keyword">var</span> model = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        num:num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line">model.num;</span><br></pre></td></tr></table></figure>

<h3 id="变量的声明提前原理"><a href="#变量的声明提前原理" class="headerlink" title="变量的声明提前原理"></a>变量的声明提前原理</h3><p>看个例子： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">//输出undefined</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">//输出1</span></span><br><span class="line">&#125;</span><br><span class="line">A();</span><br></pre></td></tr></table></figure>

<p>函数内第一个输出 undefined 是因为变量的声明提前，第二个输出 1 是因为变量作用域为函数作用域，而不是块级作用域。</p>
<p>那么，有想过，这些似乎理所当然的基础常识原理是什么吗？</p>
<p>我们先来看些理论，再结合理论返回来分析这个例子，但只分析变量的声明提前原理，至于作用域的原理留着作用域链一节分析。</p>
<h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p>我们之前有介绍过执行上下文 EC，和变量对象 VO，执行上下文分全局执行上下文和函数执行上下文。在全局执行上下文中，VO 的具体表现是全局对象；在函数执行上下文中，VO 的具体表现是 AO，AO 存储着函数内的变量：形参、局部变量、函数自身引用、this、arguments。</p>
<p>不管是执行函数代码还是全局代码，js 解释器会分两个过程，有的文章翻译成：进入执行上下文阶段、执行代码阶段（我不怎么喜欢这个翻译）。</p>
<p>进入执行上下文阶段：其实本质上就是创建一个执行上下文，这个阶段会解析当前上下文内的代码，将声明的变量都保存到 VO 对象上。</p>
<p>执行代码阶段：就是代码实际运行期，当运行到相对应的变量的赋值语句时，就会将具体的属性值写入 VO 对象上保存的对应变量。</p>
<p>也就是说，在执行代码阶段，代码实际运行时，js 解释器已经解析了一遍上下文内的代码，并创建了执行上下文，且为其添加了一个 VO 属性，在 VO 对象上添加了上下文内声明的所有变量，这就是变量的声明提前行为。而之后函数体内对各变量的操作，其实是对 VO 上保存的变量进行操作了。</p>
<p>我看过一篇文章对这两个过程的翻译是：解析阶段、执行阶段。</p>
<p>我比较喜欢这种翻译，解析阶段主要的工作就是解析上下文内的代码，创建执行上下文，创建变量对象 VO 等，为执行阶段做准备；而执行阶段就是代码实际运行过程。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">//输出undefined</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">//输出1</span></span><br><span class="line">&#125;</span><br><span class="line">A();</span><br></pre></td></tr></table></figure>

<p>再回过头来看这个简单的例子，假设这段代码放在一份单独的 js 文件中，解释器第一次执行这份代码，那么当执行全局代码时，首先进入全局执行上下文的解析阶段： </p>
<ol>
<li>解析代码创建全局执行上下文</li>
<li>创建VO，并为其添加属性 i、A </li>
<li>省略该过程其他工作</li>
<li>将创建的全局EC放入ECS栈内</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-0b70791ca5fd5fca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>当实际开始执行第一行全局代码时，js解释器经过了解析阶段已经做了如上的工作，得到了一些基本的信息。之后便是执行全局代码，如果执行的代码是访问全局变量，那么直接读取全局 EC 中 VO 里的对应变量；如果是对全局变量赋值操作，那么写入全局 EC 中的 VO 里对应变量的属性值。</p>
<p>如果执行的代码是调用某个函数，此时就会为这个函数的执行创建一个函数执行上下文，那么这个过程同样需要两个阶段：解析阶段和执行阶段。</p>
<p>所以当代码执行到最后一行 <code>A()</code> 时，此时新的函数执行上下文的解析阶段做的工作：</p>
<ol>
<li>解析 A() 函数内代码，并创建函数执行上下文 A函数EC</li>
<li>创建 AO，并为其添加属性</li>
<li>省略其他工作介绍</li>
<li>将创建的A函数EC放入ECS栈内</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-936ac1b48ae4f098.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>所以当执行函数 A 内的代码时，第一行输出才会输出 undefined，因为变量的声明提前特性在调用函数时创建函数执行上下文的过程中，已经解析了函数内的声明语句，并将这些变量添加到函数上下文 EC 的 AO 中了。</p>
<p>AO 就是变量对象 VO 在函数执行上下文中的具体表现。</p>
<p>而当执行完 for 循环语句，A 函数 EC 中的 AO 里的i属性已经被赋值为 1 了，而 A 函数 EC 是直到函数执行结束才销毁，所以即使在 for 语句内定义的 i 变量也可以在后面继续使用。</p>
<p>以上，就是变量声明提前的原理，当然，创建执行上下文的过程中，还涉及到其他很多工作，用来实现例如作用域链等机制，留待后续来说。  </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>前端15-JavaScript原型链（进阶）</title>
    <url>/2018/11/02/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A815-JavaScript%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-原型链"><a href="#正文-原型链" class="headerlink" title="正文-原型链"></a>正文-原型链</h1><p>原型链也就是对象的继承结构，举个例子： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []</span><br></pre></td></tr></table></figure>

<p>那么 a 对象的原型链： </p>
<p><code>a -&gt; Array.prototype -&gt; Object.prototype -&gt; null</code></p>
<p>基本所有对象的原型链顶部都是 Object.prototype，而 Object.prototype 没有原型，手动通过 Object.create(null) 创建的对象也没有原型。但这两点是特例。</p>
<p>原型的用途在于让对象可继承原型上的属性，达到功能复用、代码复用的目的。</p>
<p>面向对象的编程语言中，继承是一大特性，所以在编写 JavaScript 代码时，要能够很明确所创建的对象的一个原型链结构，这样才便于更好的设计，更好的编写代码。</p>
<p>在编写代码过程中，使用的无非就是内置对象，或者自定义对象，所以下面来看看两者的原型链结构：</p>
<h3 id="内置对象的原型链结构"><a href="#内置对象的原型链结构" class="headerlink" title="内置对象的原型链结构"></a>内置对象的原型链结构</h3><p>其实也就是之前有讲过的默认的原型链结构： </p>
<ul>
<li><p>声明的每个函数 -&gt; Function.prototype –&gt; Object.prototype -&gt; null</p>
</li>
<li><p>数组对象 -&gt; Array.prototype -&gt; Object.prototype -&gt; null </p>
</li>
<li><p>对象直接量创建的对象 -&gt; Object.prototype -&gt; null</p>
</li>
<li><p>日期对象 -&gt; Date.prototype -&gt; Object.prototype -&gt; null</p>
</li>
<li><p>正则对象 -&gt; RegExp.prototype -&gt; Object.prototype -&gt; null</p>
<p>可以用对象的 _<em>proto_</em>.constructor.name 来测试：</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-ddecdb4e8c5ba6be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>Object.prototype 已经内置定义了一些属性，如：toString()，isPrototypeOf()，hasOwnProperty() 等等；</p>
<p>同样，Array.prototype 内置了如：forEach()，map() 等等。</p>
<p>其他内置原型也都有相对应的一些属性。</p>
<p>所以使用内置对象时，才可以直接使用内置提供的一些属性。</p>
<h3 id="自定义对象的原型链结构"><a href="#自定义对象的原型链结构" class="headerlink" title="自定义对象的原型链结构"></a>自定义对象的原型链结构</h3><p>不手动修改自定义构造函数的 prototype 属性的话，默认创建的对象的原型链结构：</p>
<ul>
<li>自定义构造函数创建的对象 -&gt; {} -&gt; Object.prototype -&gt; null</li>
</ul>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<p>在首次使用构造函数 A 时，内部会去对 prototype 属性赋值，所进行的工作类似于：A.prototype = new Object();</p>
<p>所以 A.prototype 会指向一个空对象，但这个空对象继承了 Object.prototype。</p>
<p>那么不修改这条原型链的话，默认通过自定义构造函数创建的对象的继承结构也就是：{} –&gt; Object.prototype –&gt; null。</p>
<p>虽然这条原型链也可以这么表示：A.prototype –&gt; Object.prototype -&gt; null</p>
<p>a 虽然确实继承自 A.prototype，但我不倾向于这种写法来表示，因为自定义构造函数的 prototype 属性值会有很大的可能性被修改掉，当它的属性值重新指向另一个对象后，此时也仍旧可以说 a 对象继承自 A.prototype，个人感觉理解上会有点别扭，无法区别前后原型的不同，毕竟 A.prototype 只是一个 key 值，所以我倾向于直接说 a 继承的实际对象，也就是 key 值对应的 value 值。</p>
<p>虽然 Object.prototype 也是一个 key 值，实际指向的一个内置的对象，但手动修改这些内置构造函数的 prototype 的可能性不高，所以个人觉得对于内置构造函数，可以直接用类似 Object.prototype 来表示。</p>
<p>那么这个时候，如果为这个构造函数的 prototype 添加一些属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">A.prototype.num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<p>那么，对于对象 a 而言，它的原型链：</p>
<p>a -&gt; {num:0} -&gt; Object.prototype -&gt; null</p>
<p>这是不修改原型链的场景，那么如果手动破坏了默认的原型链呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> B = [];</span><br><span class="line">B.num = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;   </span><br><span class="line">A.prototype.num = <span class="number">222</span>; </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();  <span class="comment">//a 的原型链</span></span><br><span class="line">A.prototype = B;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A();  <span class="comment">//b 的原型链</span></span><br></pre></td></tr></table></figure>

<p>此时对象 b 的原型链又是什么呢？</p>
<p>首先看看对象 B，是一个数组对象，所以 B 对象的原型链：</p>
<p>B –&gt; Array.prototype -&gt; Object.prototype -&gt; null</p>
<p>再来看看对象 a，创建它时，还并没有修改构造函数的 prototype，所以它的原型链：</p>
<p>a -&gt; {num:222} -&gt; Object.prototype -&gt; null</p>
<p>那么这个时候，手动修改掉了构造函数的 prototype 指向，这之后再通过构造函数 A 创建的对象的原型链也就会跟随着变化，所以对象 b 的原型链：</p>
<p>b -&gt; B –&gt; Array.prototype -&gt; Object.prototype -&gt; null</p>
<p>所以，修改构造函数的 prototype，其实相当于将另外一条原型链拿来替换掉原本的原型链。</p>
<h3 id="原型链用途"><a href="#原型链用途" class="headerlink" title="原型链用途"></a>原型链用途</h3><p>对于对象，它的本质其实也就是一堆属性的集合，所以对象的用途是用来操作对象内的属性的，而当操作对象的属性时，会有一种类似于作用域链机制来寻找属性。</p>
<p>操作无非分两种场景，一是读取对象属性，二是写对象属性，两种所涉及的处理不一样。</p>
<p>当读取对象属性时，是依靠对象的原型链来辅助工作，如果对象内部含有该属性，则直接读取，否则沿着原型链去寻找这个属性。</p>
<p>也就是说，对象继承原型的机制，并不是说，将原型的所有属性拷贝一份到对象内部，而只是简单对对象建立一条原型链而已。这条原型链中保存着各个原型对象的引用，当读取继承的属性时，就可以根据这条原型链上的引用访问到其他原型对象内的属性了。</p>
<p>因为读取继承属性，本质上是读取其他对象的属性，那么，这些原型属性发生变化时，也才会影响到继承他们的子对象。</p>
<p>那么，对于写对象属性的操作：</p>
<p>这点就由对象的特性决定了：当对一个对象的属性进行赋值操作时，如果对象内没有该属性，那么会动态为该对象添加一个属性，如果对象内部有该属性，那么修改属性值。</p>
<p>对象的属性写操作会影响到后续的读操作，因为如果是读取对象的某个继承属性，本来对象内部没有该属性，所以是去读取的原型内的属性值。但经过写操作后，对象内部创建了同名的内部属性，之后再读取时，发现内部已经有了，自然不会再去原型链中读取。</p>
<h3 id="获取对象的原型链"><a href="#获取对象的原型链" class="headerlink" title="获取对象的原型链"></a>获取对象的原型链</h3><p>掌握了原型链的相关理论，对于代码中某个对象的原型链也就能够很清楚的知道了。无外乎内置对象的默认原型链，或者自定义构造函数手动修改的原型链。</p>
<p>但，初学阶段，如果想借助浏览器的开发者工具的 console 来测试、查看对象的原型链以便验证猜想，可以这么处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-ba5f0add9a4e9dac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>虽然 _<em>proto_</em> 可以获取原型，但拿到的是对象，所以可以借助对象的某些标识，比如原型的 constructor 的 name 函数名属性标识。 </p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://upload-images.jianshu.io/upload_images/1924341-a789905075da24dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p> 网上关于原型链的文章经常会出现这么一张图片，首先我承认，这张图很高级，也基本把原型链的相关理论表示出来了，但我很不喜欢它。因为对于新手来说，很难看懂这张图，我第一次看到也一脸懵逼。</p>
<p>就算现在能够看懂了，我也还是不喜欢它，因为这张图表达的内容太多了：它不仅表示了某个对象的原型链结构，同时，也表示出了实例对象、原型、构造函数三者间的函数，而构造函数本质上也是对象，所以也顺便表示它的原型链结构。</p>
<p>我们一步步来看，它首先定义了一个构造函数 Foo，然后通过它创建了 f1,f2对象，然后从 f1,f2开始出发，先求他们的原型链。 </p>
<p>用代码来说，其实也就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="comment">//求f1对象的原型链</span></span><br></pre></td></tr></table></figure>

<p>根据我们上述梳理的理论，很简单了吧，原型链其实也就是：</p>
<p>f1 -&gt; {} -&gt; Object.prototype -&gt; null</p>
<p>接着，它表达了可以用 _<em>proto_</em> 获取对象的原型，然后每个原型、构造函数、实例对象三者间的关系它也表达出来了，原型的constructor指向构造函数，而构造函数的prototype指向原型。</p>
<p>而这三个角色本质上也都是对象，既然是对象，那么它们本身也有原型，所以也再顺便画出它们的原型链。</p>
<p>总之，就是从 f1 实例对象出发，先找它的原型，通过原型再找构造函数，然后再分别将原型和构造函数看成实例对象，重复之前f1的工作。</p>
<p>另外，又通过 new Object() 创建了对象 o1，求它的原型链。</p>
<p>所以，这张图上，其实表达了一共 5 条原型链，分别是:</p>
<ul>
<li>f1 的原型链</li>
<li>f1 的原型的constructor指向的构造函数Foo对象的原型链</li>
<li>函数对象Foo的原型的constructor指向的构造函数Function对象的原型链</li>
<li>f1 的原型的原型即Object.prototype的constructor指向的构造函数Object 对象的原型链。</li>
<li>o1 的原型链</li>
</ul>
<p>如果你能从这张图看出这5条原型链，那么原型链的理论你就基本掌握了。</p>
<p>而且，建议看这张图时，每次都将某条原型链跟踪到底，再去看另一条，这过程不要过多关注在分支上，否则很容易混乱。</p>
<p>对于新手，如果能够对这张稍作备注，而不是直接将这张图放出来，我觉得会更好，如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-ed3572ea96c33df5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>前端16-JavaScript执行上下文EC和变量对象VO（进阶）</title>
    <url>/2018/11/02/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A816-JavaScript%E8%BF%9B%E9%98%B6%E4%B9%8BEC%E5%92%8CVO/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-执行上下文EC和变量对象VO"><a href="#正文-执行上下文EC和变量对象VO" class="headerlink" title="正文-执行上下文EC和变量对象VO"></a>正文-执行上下文EC和变量对象VO</h1><p>EC：Execution Context，中文翻译执行上下文，也有翻译成执行环境的。</p>
<p>VO：Variable object，中文翻译变量对象。</p>
<p>这两个概念很重要，涉及到作用域以及作用域链的原理。</p>
<h3 id="执行上下文-EC"><a href="#执行上下文-EC" class="headerlink" title="执行上下文 EC"></a>执行上下文 EC</h3><p>先说说Android中的上下文： </p>
<ul>
<li>Android</li>
</ul>
<p>Android 中也有上下文：Context，四大组件都是上下文，还有一个全局的 Application上下文。在 Android 中基本是以四大组件为界限，每创建一个四大组件，都会产生一个上下文，比如每个 Activity 都是独立的上下文。</p>
<p>在 Android 中，上下文 Context 的作用大体上用于标识各种资源的所属，要加载一张图片、创建一个 View、弹一个 Dialog 等等，你需要告诉系统，这些是谁发出的指令，要挂载到哪个上下文，这些资源依赖于上下文的生命周期。</p>
<p>所以才会出现，有时弹 Dialog 或者更新某个 View 时抛异常说 Context 已销毁，因为它需要挂载的上下文已经销毁了，那么就没有上下文来统筹管理这些资源了，自然会抛异常。</p>
<ul>
<li>JavaScript</li>
</ul>
<p>在 JavaScript 中，上下文是指执行上下文，通俗点理解，代码执行的上下文，所以也有翻译成执行环境，可以通俗的把它理解成一个对象，对象名 EC，表示代码的执行上下文。</p>
<p>既然理解成一个对象，那么就有它创建的时机，在 JavaScript 中，每当要执行不同类型的代码时，就会创建一个执行上下文 EC。</p>
<p>而代码的类型分三种：</p>
<ul>
<li>全局代码</li>
<li>函数代码</li>
<li>eval()执行的代码</li>
</ul>
<p>最后一种不讨论，全局代码就是指写在函数外的代码，在前端里，当 HTML 加载一个 js 文件时，全局代码就会被执行，那么在全局代码执行前就会先创建一个全局的执行上下文 EC，之后每调用一次函数，要执行函数内的代码时，会再创建一个函数执行上下文 EC。</p>
<p>也就是说，不讨论 eval 的话，那么在 JavaScript 有两种执行上下文，一种是全局执行上下文，一种是函数执行上下文。</p>
<p>而每次创建一个执行上下文时，都会将其放入一个栈结构，这个栈就称为执行上下文栈（ECS），也有翻译成执行环境栈。</p>
<p>所以执行 js 文件代码期间，这个栈底一直是全局执行上下文，直到 js 文件代码执行结束。全局代码执行过程中，每调用一次函数，新创建一个函数执行上下文，就放入栈内。</p>
<p>因此，栈顶就表示当前执行的代码，如果栈顶是全局执行上下文，表示正在执行全局代码；如果栈顶是函数执行上下文，表示正在执行函数内的代码。当函数执行结束时，这个函数执行上下文就从栈中移出。</p>
<p>那么执行上下文（EC）有什么用呢？</p>
<p>用途可多了，跟 Android 不一样，Android 里由于是各种资源的组合使用，但在 JavaScript 中更多的是嵌套函数的变量使用。所以，用途之一就是保存各个变量。</p>
<p>将 EC 理解成一个对象的话，它有两个属性，一个是变量对象（VO），另一个是作用域链（Scope Chain）。对于全局执行上下文，当 HTML 加载一个 js 文件时，就会创建一个全局 EC，此时会创建它的两个属性：变量对象和作用域链。之后，每调用一次函数，创建这次函数执行的上下文，函数内部的变量的使用就依赖于这个函数执行上下文中的变量对象和作用域链。</p>
<p>也就是说，内部函数之所以可以使用外部函数内的变量，之所以可以使用全局变量，都是依赖于当前这个内部函数的执行上下文。</p>
<p>而且，变量之所以会提前声明也是因为执行上下文的因素。这些当讲解了执行上下文 EC 的创建过程就清楚了。</p>
<h3 id="变量对象-VO"><a href="#变量对象-VO" class="headerlink" title="变量对象 VO"></a>变量对象 VO</h3><p>变量对象只是一个抽象的概念，可以通俗的理解成保存当前上下文所有变量的对象。</p>
<p>在不同的执行上下文中，它有不同的具体表现。</p>
<p>在全局执行上下文中，变量对象 VO 的具体表现就是全局对象，因为所有的全局变量其实都是全局对象的属性，而变量对象 VO 的作用是要保存当前上下文中的所有变量，所以此时的变量对象 VO 实际上是指向的全局对象。</p>
<p>尤其在前端中，全局对象就是 window，所以全局执行上下文的变量对象 VO = window。</p>
<p>在函数执行上下文中，因为变量对象 VO 是要保存当前上下文中所有的变量，一个函数内的变量包括：形参变量、局部变量、自身函数对象引用变量、arguments、this。</p>
<p>针对函数执行上下文，为了保存这些变量，特意创建了一个对象，称它为活动对象 AO，函数内所需的变量就都保存在 AO 中，所以在函数执行上下文中，变量对象 VO 的具体表现也就是 AO。</p>
<p>小结：变量对象 VO 是一个抽象概念，用于保存当前执行上下文中所有的变量。所以在全局执行上下文中，因为全局对象已经保存着当前上下文所有的变量，所以 VO 在这里的具体实现就是全局对象。在函数执行上下文中，由于要保存函数形参、局部变量、自身函数对象引用变量、arguments、this，所以新创建了一个叫活动对象 AO 来保存，此时 VO 的具体实现就是 AO。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>每次函数调用时，都会创建一个函数执行上下文 EC，但其中的变量对象 VO 只保存着当前上下文中的变量而已，那么函数内如果需要使用到外部函数的变量，甚至是使用全局的变量时，此时就需要依赖于执行上下文的另一个属性：作用域链。</p>
<p>作用域链本质上，其实是将有嵌套层次关系的执行上下文的 VO 拼接起来。</p>
<p>所以大部分场景作用域链只有两个节点：当前函数执行上下文的 VO –&gt; 全局执行上下文的 VO。所以函数内才可以根据作用域链访问全局内的变量。</p>
<p>当出现函数内再嵌套函数时，此时作用域链就会比较长：</p>
<p>内层函数执行上下文的 VO –&gt; 外层函数执行上下文的 VO –&gt; 全局执行上下文 VO。</p>
<p>至于作用域链是如何将有嵌套层次的执行上下文的 VO 拼接起来，需要借助函数对象的内部属性 [[Scope]]，[[]]表示执行引擎为对象创建的内部属性，我们访问不了，也操作不了。具体原理在作用域链一节中讲解。  </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>前端14-JavaScript继承（进阶）</title>
    <url>/2018/11/01/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A814-JavaScript%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-继承"><a href="#正文-继承" class="headerlink" title="正文-继承"></a>正文-继承</h1><p>继承是面向对象编程语言中一大特性，Java 中的继承是静态的，通过在编写 class 代码过程中指定，一旦继承关系确定了，就无法在运行期间去修改了。</p>
<p>子类默认继承父类的所有非私有的属性和方法。</p>
<p>但在 JavaScript 中，由于并不存在类的机制，而且它是动态的基于原型的继承，所以在很多方面与 Java 的继承并不一样。</p>
<p>下面从多个方面来进行比较：</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JavaScript</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(&#123;<span class="attr">b</span>:<span class="number">1</span>&#125;);<span class="comment">//Object.create方式指定继承的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">A.prototype.b = <span class="number">2</span>;  <span class="comment">//构造函数的prototype方式指定继承的对象</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<p>在 Java 中只能通过 extends 关键字声明继承的关系。</p>
<p>在 JavaScript 中有两种方式指定继承的原型对象，一种用 Object.create()，一种通过构造函数的 prototype 属性。</p>
<p>当在声明一个自定义的构造函数时，内部会自动创建一个空的对象（new Object()），然后赋值给构造函数的 prototype 属性，之后通过该构造函数创建的对象，就都默认继承自 prototype 指向的空对象，所以可在这个空对象上直接动态的添加属性，以便让创建的对象都可以继承这些属性。</p>
<h3 id="继承的内容"><a href="#继承的内容" class="headerlink" title="继承的内容"></a>继承的内容</h3><ul>
<li>Java</li>
</ul>
<p>在 Java 中，存在：类，实例对象两种概念。</p>
<p>因此，也就有了类属性、类方法、对象属性、对象方法的说法，这些的区别在于是否有 static 关键字声明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age; <span class="comment">//对象属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//对象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dead</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//类方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">growUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">	eat();<span class="comment">//子类可直接使用父类的非私有方法</span></span><br><span class="line">        dead();<span class="comment">//包括类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">dog.age = <span class="number">15</span>; <span class="comment">//对象属性和方法需通过实例对象才可进行操作</span></span><br><span class="line">dog.eat();</span><br><span class="line">dog.dead();<span class="comment">//类属性和类方法不实例化对象也可使用，通过对象也可使用</span></span><br><span class="line">Dog.dead();</span><br></pre></td></tr></table></figure>

<p>对象属性和对象方法必须经过类的实例化操作，创建出一个对象来时，才可以通过对象操作这些属性和方法。</p>
<p>而类属性和类方法在子类中可以直接使用，子类实例化的对象也可直接调用。</p>
<ul>
<li>JavaScript</li>
</ul>
<p>在 JavaScript 中只有对象的概念，被继承的对象称为原型。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Animal.prototype.age = <span class="number">0</span>; <span class="comment">//为原型添加属性</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">"eat"</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">//Dog构造函数的prototype继承自Animal.prototype</span></span><br><span class="line">Dog.prototype = <span class="built_in">Object</span>.create(Animal.prototype); </span><br><span class="line">Dog.prototype.constructor = Dog; <span class="comment">//由于手动修改了原型链，破坏了默认的三者关联，手动修补</span></span><br><span class="line">Dog.prototype.growUp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">"growUp"</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dog 对象的原型链：dog -&gt; Dog.prototype -&gt; Animal.prototype -&gt; Object.prototype -&gt; null</span></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line">dog.age;</span><br><span class="line">dog.eat();</span><br><span class="line">dog.growUp();</span><br></pre></td></tr></table></figure>

<p>先定义个 Animal 构造函数，然后注意，JavaScript 是基于原型继承的，此时如果要定义一些可继承的属性，需要在 Animal.prototype 对象上添加，不可在构造函数本身上添加。</p>
<p>然后再定义一个 Dog 构造函数，让它继承自 Animal.prototype，注意，因为在这里手动修改了原型链，所以最好手动补上 Dog.prototype.constructor = Dog 这行代码，让构造函数、实例对象、原型三者间仍旧可以保持默认的关联关系。</p>
<p>最后，通过构造函数 Dog 创建的对象，就可使用继承而来的属性。</p>
<p>还有另一种写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">"eat"</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Dog.prototype = <span class="built_in">Object</span>.create(<span class="keyword">new</span> Animal());</span><br></pre></td></tr></table></figure>

<p>可以直接在构造函数 Animal 中添加相关属性，但涉及要继承时，需要使用 new Animal() 作为原型参数，如果直接使用 Animal，那么将会误认将函数对象本身作为原型。</p>
<p>不过这种方式，需要注意，当涉及多个对象需要继承自同一个原型时，原型对象的实例应该只有一个，这样才能保证对原型对象动态修改的属性能同步到所有继承的子对象上。</p>
<h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>Java 中有权限修饰符，子类可以使用父类中非私有的属性和方法。</p>
<p>但在 JavaScript 中，没有公有、私有权限之说，所有定义在原型中的属性，子对象中都可以使用。但可以利用对象属性的特性，在原型中控制它的属性的可枚举性、可配置性、可写性，以此来达到控制子对象访问原型属性的一些限制。</p>
<p>修改对象属性的特性用：Object.defineProperty()</p>
<p>同理，对象本身也有一些特性可利用，比如 Object.freeze()，Object.seal() 这类方法可以限制对原型对象进行扩展等操作。</p>
<h3 id="动态同步"><a href="#动态同步" class="headerlink" title="动态同步"></a>动态同步</h3><p>Java 中，每个从类实例化出来的对象之间都是相互独立的，不会相互影响，而类属性，类方法只是它们可以用来共享、通信的渠道而已。</p>
<p>而且，类机制是静态的，在Java中，并不会存在在运行期，修改类相关属性而影响子类的场景。</p>
<p>但在 JavaScript 中，由于继承的两者都是对象，而 JavaScript 的对象又具有运行期动态添加属性等特性，所以，如果修改原型上的属性，是会同步到继承该原型的子对象上的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">A.prototype.num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A();</span><br><span class="line">a.num;  <span class="comment">//输出1</span></span><br><span class="line">b.num;  <span class="comment">//输出1，因为都是继承的 A.prototype</span></span><br><span class="line">A.prototype.num = <span class="number">5</span>;</span><br><span class="line">a.num;   <span class="comment">//输出5，原型的属性动态的变化可同步到子对象上</span></span><br><span class="line">b.__proto__.num = <span class="number">0</span>;</span><br><span class="line">a.num;   <span class="comment">//输出0，因为可通过b对象获取原型对象，对原型的操作会同步到子对象上</span></span><br></pre></td></tr></table></figure>

<p>以上代码，首先定义了一个构造函数A，通过它创建了两个新的子对象a,b，这两个子对象都继承自A.prototype，所以当访问 a.num 时会输出 1。</p>
<p>然后动态修改 A.prototype 对象的 num 属性，将其改成5，这时会发现，子对象 a 和 b 访问 num 时都输出 5 了，也就是说对原型对象的动态修改属性可同步到它的子对象上。</p>
<p>而子对象又可以通过 _<em>proto_</em> 属性或者符合默认关系下 constructor.prototype 来获取原型对象，之后对原型对象的操作也可影响到所有继承该原型的子对象。</p>
<p>这点就是 JavaScript 与 Java 这种有类机制语言的很大不同之处。</p>
<p>另外，对原型对象的修改之所以可以同步到子对象上，其实是因为原型链的原理。a，b对象虽然继承自 A.prototype，但其实它们两内部中并没有 num 这个属性，而当访问 num 属性时，在它们内部没找到时，会去沿着原型链中寻找，所以原型对象的属性发生变化时才会影响到子对象。</p>
<p>清楚这点原理后，应该就能理解，有些文章说，原型对象的属性只有读操作会同步到子对象上，写操作无效的原因了吧。</p>
<p>看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">A.prototype.num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A();</span><br><span class="line">a.num = <span class="number">5</span>;  </span><br><span class="line">b.num;    <span class="comment">//输出1</span></span><br></pre></td></tr></table></figure>

<p>上面说过，虽然 a 对象继承自 A.prototype，但其实 a 对象内部并没有 num 属性，使用 a.num 时其实会去原型链上寻找这个 num 属性是否存在。</p>
<p>现在，执行了 a.num = 5，因为 a 对象内部没有这个 num 属性，所以这行代码作用等效于动态给 a 对象添加了 num 属性，那这个属性自然也就只属于 a 对象，自然不会对 b 对象造成任何影响，b.num 还是去b的原型链上寻找 num。 </p>
<h3 id="改变继承关系"><a href="#改变继承关系" class="headerlink" title="改变继承关系"></a>改变继承关系</h3><p>Java 中，类是继承结构一旦编写完毕，在运行期间是不可改变的了。</p>
<p>但在 JavaScript 中，由于对象的属性是可运行期间动态添加、修改的，所以在运行期间是可改变对象的继承结构的。</p>
<p>有两种不同的场景，一是修改构造函数的 prototype 属性，二是修改对象的 _<em>proto_</em> 属性。</p>
<h4 id="修改构造函数-prototype"><a href="#修改构造函数-prototype" class="headerlink" title="修改构造函数 prototype"></a>修改构造函数 prototype</h4><p>对象的创建大部分都是通过构造函数，所以，在构造函数创建这个对象时，它的继承关系就确定了。</p>
<p>看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> B = [];  <span class="comment">//定义一个数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;  <span class="comment">//定义构造函数</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A(); <span class="comment">//创建一个对象，该对象继承自 A.prototype </span></span><br><span class="line">a.__proto__.constructor.name;  <span class="comment">//应该输出什么</span></span><br></pre></td></tr></table></figure>

<p>默认不手动破坏原型链的话，构造函数、原型两者间是相关关联的关系，所以通过实例对象 a 的原型 _<em>proto_</em> 访问与它关联的构造函数，输出函数名，这里就应该是 “A”。</p>
<p>这也是之前讲过，可用来获取对象的标识—构造函数名的方法，但有前提，就是构造函数、原型、实例对象三者关系满足默认的关联关系。</p>
<p>那么，如果这个时候再手动修改 A 的 prototype 属性呢？</p>
<p>举个例子，在上面代码基础上，继续执行下述代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> C = A.prototype;   <span class="comment">//先将 A.prototype 保存下来</span></span><br><span class="line">A.prototype = B;       <span class="comment">//手动修改A.prototype</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A();</span><br><span class="line">b.__proto__.constructor.name;  <span class="comment">//应该输出什么</span></span><br><span class="line">a.__proto__.constructor.name; <span class="comment">//应该输出什么</span></span><br></pre></td></tr></table></figure>

<p>手动修改了构造函数的 prototype 属性，然后又新创建了 b 对象，那么此时 a 对象和 b 对象都是通过构造函数 A 创建的。</p>
<p> 但 a 对象创建时是继承自 A.prototype，这是一个继承自 Object.prototype 的空对象，后续手动修改了构造函数 A 的 prototype，会让 a 对象的继承关系自动跟随着发生变化吗？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5ee9c18d8473a687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改构造函数prototype">  </p>
<p>我们看一下输出，a 对象仍旧是之前的继承结构，它的原型链并没有因为构造函数的 prototype 发生变化而跟随着变化。</p>
<p>而 b 对象则是在修改了构造函数 prototype 属性后创建的，所以它的原型链就是新的结构了，跟 a 就会有所不同了。这里之所以会输出 Array，是因为 b 的原型是数组对象 B，而数组对象 B 是由 new Array() 创建的，所以 B 继承了 Array.prototype 的 constructor 属性指向了 Array。这也是之前有说过，不建议手动修改原型链结构，否则会破坏默认的构造函数、原型、实例对象三者间的关系。</p>
<p>如果对原型和构造函数的概念还不是很理解，那么我们换个方式验证：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-9bda1e35adb049d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验证">  </p>
<p>instanceof 表示如果左边的对象是继承自右边构造函数的 prototype 的话，表达式为 true。</p>
<p>isPrototypeOf 表示，左边的对象如果在右边对象的原型链上的话，表达式为 true。</p>
<p>所以，修改构造函数的 prototype 属性，并不会对原本从构造函数创建的对象的原型链，继承结构有所影响。这其实也再次验证，构造函数在 JavaScript 中的角色类似于作为第三方牵手原型和实例对象，修改原型会影响实例对象，但修改构造函数并不会对原本的实例对象有何影响。</p>
<p>但构造函数之后创建的对象，新对象的继承结构跟之前的就不一样了。</p>
<h4 id="修改对象的-proto-属性"><a href="#修改对象的-proto-属性" class="headerlink" title="修改对象的 _proto_ 属性"></a>修改对象的 _<em>proto_</em> 属性</h4><p>对象有办法直接获取到它的原型对象，一种是通过 __proto__，这是通用方式，所有对象都有，唯一的弊端在于 ES5 中并不是标准规范中的属性，虽然基本所有浏览器中都有实现，所以在一些开发工具中可能不会提示对象含有这个属性。</p>
<p>另一种获取对象原型的方式是，通过 constructor 的 prototype，这也是通用方式，弊端在于，对象的 constructor 属性可能指向的并不是创建它的构造函数，因为这个属性其实是继承自原型对象的属性，所以关键还取决于原型和构造函数之间是否满足默认的相互引用关系。另外，有些对象可能并没有 constructor 属性。</p>
<p>既然对象有属性是指向它的原型，那么手动修改这个属性的指向，会有怎样的影响？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> B = &#123;<span class="attr">num</span>:<span class="number">0</span>&#125;   <span class="comment">//定义一个对象，含有 num 属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;   <span class="comment">//定义一个构造函数</span></span><br><span class="line">A.prototype.num = <span class="number">222</span>; <span class="comment">//为构造函数prototype添加一个 num 属性</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">a.num;    <span class="comment">//应该输出什么</span></span><br><span class="line"></span><br><span class="line">a.__proto__ = B;  <span class="comment">//手动修改了 a 对象的原型对象</span></span><br><span class="line">a.num;   <span class="comment">//此时应该输出什么</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A();  <span class="comment">//b对象跟 a 对象一样通过构造函数 A 创建</span></span><br><span class="line">b.num;  <span class="comment">//这里又应该输出什么</span></span><br></pre></td></tr></table></figure>

<p>a 对象刚被创建来时，是继承的构造函数 A.prototype，所以第一次 a.num 输出 A.prototype.num 的值：222，这里应该没疑问。</p>
<p> 然后手动修改了对象 a 的原型，让它的原型指向了 B 对象，那么此时对象 a 的原型链会发生变化吗？它的继承结构会发生变化吗？测试一下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-28830e388b592116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>所以，手动修改对象的 _<em>proto_</em> 属性是会影响到对象的原型链的，虽然对象在创建时会根据构造函数的 prototype 生成一条原型链，但运行期间，手动修改对象的原型指向，会重新让对象推翻原本原型链，再重新生成一条新的原型链的。</p>
<p> 那么，会影响到之后构造函数创建的新对象的原型链吗？测试一下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-b2134240a1e4698b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>所以，手动修改某个对象的原型指向，只会让这个对象的原型链重建，并不会影响到创建它的构造函数之后创建的新对象的继承关系。 </p>
<p><strong>最后来小结一下：</strong></p>
<ul>
<li>在 JavaScript 中，由于对象继承自原型，但原型本质上也是对象，所以，如果在运行期间动态修改原型对象上的属性，会影响到继承它的子对象们读取相关原型属性的结果。</li>
<li>由于继承关系通常是在构造函数创建新对象时，由构造函数的 prototype 属性值决定，而构造函数本质上也是对象，也可在运行期间，动态修改属性值。但如果运行期间，手动修改构造函数的 prototype 属性值，并不会影响到原先通过该构造函数创建的对象的继承结构（原型链），但之后通过该构造函数创建的新对象的继承结构（原型链）就跟之前的不一样了。</li>
<li>也就是即使同一个构造函数，但如果有修改过构造函数的 prototype 指向，那么该构造函数前后创建的对象的继承结构（原型链）也是会不一样的。</li>
<li>对象有相关的属性指向它的原型，比如 _<em>proto_</em> ，当运行期间，手动修改对象的原型指向，那么会让这个对象的继承结构（原型链）重建，但不会影响到创建该对象的构造函数原本的行为。</li>
<li>总之，对象的继承结构（原型链）可动态发生变化。</li>
</ul>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写：子类覆盖父类的同名方法称为重写。</p>
<p>在JavaScript中，重写跟 Java 很类似，使用某个属性时，先在当前对象内部寻找，如果没找到，才往它的原型链上寻找。</p>
<p>但 JavaScript 中并没有 Java 中的类静态机制，所以定义对象的某个属性时，通常都是动态的写操作来进行，一旦在对象中出现对某个原型属性的写操作，那么就会在该对象内部创建一个同名的属性，之后对这个属性的读写，都是对对象内部这个属性的操作，原型上的同名属性的变化也不会影响到它了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;   <span class="comment">//定义一个构造函数</span></span><br><span class="line">A.prototype.num = <span class="number">222</span>; <span class="comment">//为构造函数prototype添加一个 num 属性</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">a.num;    <span class="comment">//输出222,</span></span><br><span class="line">a.num = <span class="number">0</span>;</span><br><span class="line">A.prototype.num = <span class="number">5</span>;</span><br><span class="line">a.num; <span class="comment">//输出0, 因为num属性已经被重写了</span></span><br></pre></td></tr></table></figure>

<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>在 Java 中可以定义抽象类，接口，在其中定义一些抽象的方法，子类必须实现这些抽象方法。</p>
<p>但在 JavaScript 中并没有相关的机制，但可以自己通过 throw Error 抛异常形式来模拟这种机制。</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不允许使用该构造函数创建对象，来模拟抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AbstractClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"u can't instantiate abstract class"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有实现的抽象方法，通过抛异常来模拟</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abstractMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"abstract method,u should implement it"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义抽象方法，子类继承之后，如果不自己实现，直接使用会抛异常</span></span><br><span class="line">AbstractClass.prototype.onMearsure = abstractMethod;</span><br><span class="line">AbstractClass.prototype.onLayout = abstractMethod;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-8159fcf06d6b58a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个继承抽象构造函数的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(AbstractClass.prototype);</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-559216cb50361b88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-31dcc74fc0edb1d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>子类继承后，如果不实现直接调用这些方法，会抛异常。</p>
<p>说白了，就是通过抛异常方式来模拟 Java 中的抽象方法机制，这种方式无法让开发工具在编写代码期间就检测出来，需要代码实际运行期间才能发现。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>前端13-JavaScript原型（进阶）</title>
    <url>/2018/11/01/%E5%89%8D%E7%AB%AF/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A813-JavaScript%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-原型"><a href="#正文-原型" class="headerlink" title="正文-原型"></a>正文-原型</h1><p>JavaScript 中并没有 Java 里的类，但它有构造函数，也有继承，只是它是动态的基于原型的继承。所以，原型有点类似于 Java 中父类的概念。</p>
<p>但是，JavaScript 中的关于实例、继承等这些跟 Java 还是有很大的区别。</p>
<p>先来说说在 Java 里面：</p>
<p>类是静态的，类是可继承的，是对象的抽象模型的表现，每个具体的对象都是从类上实例化出来的，一个类中定义了这类对象的属性和行为，一旦定义完了运行时就无法改变了。</p>
<p>但对于 JavaScript 来说，它并没有类的存在，在 JavaScript 里，除了原始类型外，其余皆是对象。</p>
<p>它是动态的基于原型的继承机制，原型本质上也是对象，也就是说对象是继承自对象而来的。</p>
<p>而对象这个概念是实例化后的每一个具体个体代表，它是运行期动态生成的，再加上 JavaScript 里对象的特性，如可动态添加属性，这就让 JavaScript 里的继承机制非常强大，因为这样一来，它是可动态继承的，原型对象上发生的变化能够同步让继承它的子对象都跟随着变化。</p>
<h3 id="原型概念"><a href="#原型概念" class="headerlink" title="原型概念"></a>原型概念</h3><p>函数和构造函数的区别就在于，所有的函数，当和 new 关键字一起使用时，此时称它为构造函数。类似的关系，所有的对象，当它被设置为某个构造函数的 prototype 属性值时，此时称它为原型。</p>
<p>也就是说，任何对象都可以当做其他对象的原型。</p>
<p>在 Java 中，对象一般通过 super 关键字指向它的父类，而在 JavaScript 中，对象可通过 _<em>proto_</em> 来指向它的原型对象，或者通过构造函数的 prototype 指向对象的原型。</p>
<h3 id="prototype-amp-proto"><a href="#prototype-amp-proto" class="headerlink" title="prototype &amp; _proto_"></a>prototype &amp; _<em>proto_</em></h3><p>这两个虽然指向的是同一个原型对象，但它们的宿主却不一样，需要区分一下，prototype 是构造函数的属性，_<em>proto_</em> 是通过构造函数创建出来的对象的属性。</p>
<p>_<em>proto_</em> 属性并不在 ES5 标准规范中，但基本大部分浏览器都为引用类型实现了这么一个属性，用于查看当前对象所继承的原型，它的值等于该对象的构造函数的 prototype 属性值。</p>
<p>prototype 是每个函数对象的一个属性，其他对象并没有这个属性，因为基本所有的对象其实都是通过构造函数创建出来的，所以也只有函数才能来实现继承的机制。这个属性值表示着从这个构造函数创建的对象的原型是什么。</p>
<p>对象一节学习过，创建一个对象的三种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象直接量：</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;<span class="comment">//其实是 var a = new Object(); 的语法糖</span></span><br><span class="line"><span class="keyword">var</span> a = [];<span class="comment">//其实是 var a = new Array(); 的语法糖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Object.crate()</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.crate(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>所以，对象直接量的方式本质上也是通过构造函数的方式创建对象。</p>
<p>这也是为什么会在对象一节中说，所有通过直接量方式创建的对象都继承自 Object.prototype 的理由。</p>
<p>而通过 Object.create() 方式创建的对象，其原型就是参数指定的对象，可手动传入 null，表示创建的对象没有原型。</p>
<p>所以，在 JavaScript 中，绝大部分的对象都有原型，即使不手动指定，也会有默认的内置原型对象。之所以说绝大部分，是因为原型链顶部的 Object.prototype 对象的原型是 null，或者通过 Object.create() 创建对象时手动指定 null。</p>
<h3 id="默认的继承结构"><a href="#默认的继承结构" class="headerlink" title="默认的继承结构"></a>默认的继承结构</h3><p>如果不手动指定继承关系，默认的几种引用类型的继承关系（原型链）如下： </p>
<ul>
<li>声明的每个函数 -&gt; Function.prototype –&gt; Object.prototype -&gt; null</li>
<li>数组对象 -&gt; Array.prototype -&gt; Object.prototype -&gt; null </li>
<li>对象直接量创建的对象 -&gt; Object.prototype -&gt; null</li>
<li>自定义构造函数创建的对象 -&gt; {} -&gt; Object.prototype -&gt; null</li>
</ul>
<p>所有对象继承的顶层原型是 Object.prototype。</p>
<p>这也是为什么函数对象、数组对象、普通对象都可以使用一些内置的方法，因为创建这些对象的时候，默认就会有一些继承关系，跟 Java 中所有的类都继承自 Object 的机制类似。</p>
<h3 id="构造函数和原型的关系"><a href="#构造函数和原型的关系" class="headerlink" title="构造函数和原型的关系"></a>构造函数和原型的关系</h3><p>构造函数本身是一个函数对象，它的属性 prototype 指向的是另一个对象，所以这两个概念本身就是两个不同的东西。</p>
<p>通过一个构造函数创建一个新的对象，不能说，这个对象继承自构造函数，而是应该说，这对象继承自构造函数的属性 prototype 指向的对象。</p>
<p>所以，可以通俗的理解，构造函数只是作为第三方类似于工具的角色，用来创建一个新对象，然后让这个新对象继承自 prototype 属性指向的对象。</p>
<p>不过构造函数和原型之间是相互引用的关联关系，构造函数有个属性 prototype 指向原型，而原型也有一个属性 constructor 指向构造函数。</p>
<p>所以，所有从这个构造函数创建的新对象，都继承了原型的属性，那么这些新对象也就可以通过继承而来的 constructor 的属性访问构造函数。</p>
<p> 如果不手动破坏原型链，那么通过构造函数创建新对象时，三者间的关系：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-1ed763fe92c0ff3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三者关系">  </p>
<p>而更多的时候，我们需要借助原型来让对象继承一些公有行为，有两种做法，一种是通过直接在原型对象上动态添加相关属性，这种方式不破坏原型链，比较推荐。</p>
<p>还有一种，定义一个新的原型对象，然后重新赋值构造函数的 prototype 属性值，将它指向新的原型对象。但这种方式会破坏默认的原型链，同时也会破坏构造函数、原型、实例化对象三者间的默认关联关系。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;   <span class="comment">//定义构造函数A</span></span><br><span class="line">A.prototype.c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A(); <span class="comment">//通过构造函数创建对象b</span></span><br></pre></td></tr></table></figure>

<p>  通过构造函数创建一个新对象b，且在构造函数的 prototype 上手动添加新的属性c，会被 b 继承，由于这种方式是没有破坏原型链的，所以三者间关系如下： </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-79b8440c64a946c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构造函数示例">    </p>
<p>b._<em>proto_</em> 表示 b 的原型，原型对象的 constructor 属性指向构造函数 A，name 是函数对象的属性，用于输出函数名。</p>
<p>而且对象 b 由于继承自原型 A.prototype，所以也继承它的 constructor 属性，所以也指向构造函数 A。</p>
<p>此时对象 b 的继承关系：b -&gt; {} -&gt; Object.prototype</p>
<p>以上是默认的不破坏原型链下三者的关系，但如果手动破坏了原型链呢：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;   <span class="comment">//定义构造函数A</span></span><br><span class="line">A.prototype.c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = [];      <span class="comment">//创建数组对象a</span></span><br><span class="line">a.c = <span class="number">0</span>;</span><br><span class="line">A.prototype = a; <span class="comment">//手动修改构造函数A的prototype，让其指向 a</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A(); <span class="comment">//通过构造函数创建对象b，b继承自原型a</span></span><br></pre></td></tr></table></figure>

<p>上面的代码手动修改了 A.prototype 的属性值，让 b 是继承自手动创建的对象 a，所以这里就破坏了默认的原型链，同时，三者间的关系也被破坏了： </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-e27c1d5f0e5e94df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改原型示例">  </p>
<p>首先，c 属性验证了 b 是继承自对象 a了。</p>
<p>而我们说过，b._<em>proto_</em> 指向 b 的原型，在这里，b 的原型就是对象 a 了。而对象 a 是手动创建的，所以它的 constructor 属性是继承自它的原型对象。数组直接量创建的数组对象，本质上是通过 new Array()，所以a的构造函数是 Array()，对象 a 继承自 Array.prototype。</p>
<p>对于对象 a，我们创建它的方式并没有手动去修改它的原型链，所以按默认的三者间的关系，Array.prototype 的 constructor 属性指向构造函数 Array()，这就是为什么 b._<em>proto_</em>.constructor.name 的值会是 Array 了。</p>
<p>而，对象 b 继承自对象 a，所以 b.constructor 的值也才会是 Array。</p>
<p>此时，对象 b 的继承关系： b-&gt; a -&gt; Array.prototype -&gt; Object.prototype</p>
<p>所以，在这个例子中，虽然对象 b 是从构造函数 A 创建的，但它的 constructor 其实并不指向 A，这点也可以稍微说明，构造函数的作用其实更类似于作为第三方协调原型和实例对象两者的角色。</p>
<p>通常是不建议通过这种方式来实现继承，因为这样会破坏默认的三者间的联系，除非手动修复，手动对 a 的 constructor 属性赋值为 A，这样可以手动修复三者间默认的关联。</p>
<p><strong>来稍微小结一下</strong>：</p>
<p>因为原型本质上也是对象，所以它也具有对象的特性，同时它也有自己的一些特性，总结下： </p>
<ul>
<li>所有的引用类型（数组、对象、函数），都具有对象特性，都可以自由扩展属性，null除外。</li>
<li>所有的引用类型（数组、对象、函数），都有一个 _<em>proto_</em> 属性，属性值的数据类型是对象，含义是隐式原型，指向这个对象的原型。</li>
<li>所有的函数（不包括数组、对象），都有一个 prototype 属性，属性值的数据类型是对象，含义是显式原型。因为函数都可以当做构造函数来使用，当被用于构造函数创建新对象时，新对象的原型就是指向构造函数的 prototype 值。</li>
<li>所有的内置构造函数（Array、Function、Object…），它的 prototype 属性值都是定义好的内置原型对象，所以从这些内置构造函数创建的对象都默认继承自内置原型，可使用内置的属性。</li>
<li>所有的自定义函数，它的 prototype 属性值都是 new Object()，所以所有从自定义构造函数创建的对象，默认的原型链为 （空对象）{} —- Object.prototype。</li>
<li>所有的引用类型（数组、对象、函数），_<em>proto_</em> 属性指向它的构造函数的prototype值，不手动破坏构造函数、原型之间的默认关系时</li>
<li>所有的引用类型（数组、对象、函数），如果不手动破坏原型链，构造函数、原型、实例对象三者之间有默认的关联。</li>
</ul>
<h3 id="对象的标识"><a href="#对象的标识" class="headerlink" title="对象的标识"></a>对象的标识</h3><p>在 Java 中，由于对象都是从对应的类实例化出来的，因此类本身就可以做为对象的标识，用于区分不同对象是否同属一个类的实例。运算符是 instanceof。</p>
<p>在 JavaScript 中，虽然也有 instanceof 运算符，但由于并没有类的概念，虽然有类似的构造函数、原型的概念存在，但由于这些本质上也都是对象，所以很难有某个唯一的标识可以来区分 JavaScript 的对象。</p>
<p>下面从多种思路着手，讲解如何区分对象:</p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>在 Java 中，可以通过 instanceof 运算符来判断某个对象是否是从指定类实例化出来的，也可以用于判断一群对象是否属于同一个类的实例。</p>
<p>在 JavaScript 中有些区别，但也有些类似：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">A.prototype = b;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> A) &#123; <span class="comment">//符合，因为 a 是从A实例化的，继承自A.prototype即b</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">B.prototype = b;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> B();</span><br><span class="line"><span class="keyword">if</span> (c <span class="keyword">instanceof</span> A) &#123;<span class="comment">//符合，虽然c是从B实例化的，但c也同样继承自b，而A.prototype指向b，所以满足</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;<span class="comment">//符合，虽然 c 是继承自 b，但 b 继承自 Object.prototype，所以c的原型链中有 Object.prototype</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中，instanceof 运算符的左侧是对象，右侧是构造函数。但他们的判断是，只要左侧对象的原型链中包括右侧构造函数的 prototype 指向的原型，那么条件就满足，即使左侧对象不是从右侧构造函数实例化的对象。</p>
<p>也就是说，在 JavaScript 中，判断某些对象是否属于同一个类的实例，不是根据他们是否是从同一个构造函数实例化的，而是根据他们的构造函数的 prototype 指向是不是相同的。</p>
<p>通过这种方式来区分对象有点局限是：在浏览器中多个窗口里，每个窗口的上下文都是相互独立的，无法相互比较。</p>
<h4 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf"></a>isPrototypeOf</h4><p>instanceof 是判断的对象和构造函数两者间的关系，但本质上是判断对象与原型的关系，只是刚好通过构造函数的 prototype 属性值做中转。</p>
<p>那么，是否有可以直接判断对象和原型两者的操作呢？</p>
<p>这个就是 isPrototypeOf 的用法了：左边是原型对象，右边是实例对象，用于判断左边的原型是否在右边实例对象的原型链当中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(b);</span><br></pre></td></tr></table></figure>

<p>但它跟 instanceof 有个本质上的区别，instanceof 是运算符，而 isPrototypeOf 是 Object.prototype 中的方法，由于基本所有对象都继承自这个，所以基本所有对象都可以使用这个方法。</p>
<p>instanceof 和 isPrototypeOf 更多使用的场景是用于判断语句中，如果需要主动对某个对象获取它的一些标识，可以使用接下来介绍的几种方式：</p>
<h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>在 JavaScript 中数据类型大体上分两类：原始类型和引用类型。</p>
<p>原始类型对应的值是原始值，引用类型对应的值为对象。</p>
<p>对于原始值而言，使用 typeof 运算符可以获取原始值所属的原始类型。</p>
<p>对于函数对象，也可以使用 typeof 运算符来区分：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-83e46b310e8e88a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="typeof">  </p>
<p>所以它的局限也很大，基本只能用于区分原始值的标识，对于对象，自定义对象，它的结果都是 object，无法进行区分。 </p>
<h4 id="对象的类属性"><a href="#对象的类属性" class="headerlink" title="对象的类属性"></a>对象的类属性</h4><p>在对象一节中，介绍过，对象有一个类属性，其实也就是通过 Object.prototype.toString() 方法可以获取包含原始类型和引用类型名称的字符串，对其进行截取可以获取类属性。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-89cac527cb8924f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象类属性">  </p>
<p>相比于 typeof，它的好处在于可以区别所有的数据类型的本质，包括内置引用对象（数组、函数、正则等），也可以区分 null。</p>
<p>局限在于，需要自己封装个工具方法获取类属性，但这不是难点，问题在于，对于自定义的构造函数，都是返回 Function，而很多对象其实是通过构造函数创建出来的，所以无法区分不同的构造函数所创建的对象。</p>
<h4 id="constructor-的-name-属性"><a href="#constructor-的-name-属性" class="headerlink" title="constructor 的 name 属性"></a>constructor 的 name 属性</h4><p>constructor 是对象的一个属性，它的值是继承自原型的取值。而原型该属性的取值，在不手动破坏对象的原型链情况下，为创建对象的构造函数。</p>
<p>即，默认情况下，构造函数的 prototype 指向原型，原型的 constructor 指向构造函数，那么从该构造函数创建的对象都继承了原型的这个属性可指向构造函数。</p>
<p>所以，在这些场景下，可用对象的 constructor.name 来获取构造函数的函数名，用函数名作为对象的标识。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;   <span class="comment">//定义构造函数A</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5af3808f4d7c8784.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="函数名">  </p>
<p>这种方式有个局限，如果手动修改构造函数的 prototype，破坏了对象的原型链，那么此时，新创建的对象的 constructor 就不是指向创建它的构造函数了，此时，这种方式就无法处理了。</p>
<p>由于 JavaScript 不像 Java 这种静态的类结构语言，所以没有一种完美的方式适用于各自场景中来区分对象的标识，只能是在适用的场景选择适合的方式。</p>
<p>所以，在 JavaScript 有一种编程理念：鸭式辩型</p>
<h3 id="鸭式辩型"><a href="#鸭式辩型" class="headerlink" title="鸭式辩型"></a>鸭式辩型</h3><p>我不是很理解中文翻译为什么是这个词，应该是某个英文词直译过来的。</p>
<p>它的理念是：像鸭子一样走路、游泳、嘎嘎叫的鸟就称它为鸭子。</p>
<p>通俗点说，编程时，不关心对象所属的标识，不关心对象继承自哪个原型、由哪个构造函数创建，只要这个对象含有相同的属性、行为，那么就认为它们归属于同一类。</p>
<p>有个例子就是：类数组对象，它本质并不是数组对象，但由于具有数组对象的特征，所以基本上可以把它当做数组来使用。</p>
<p>对应到编程中，不应用判断对象是否拥有相同的标识来区分对象，而是应该判断对象是否含有期望的属性即可。  </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>进阶</category>
      </categories>
  </entry>
  <entry>
    <title>前端12-JavaScript语法之函数（入门）</title>
    <url>/2018/11/01/%E5%89%8D%E7%AB%AF/%E5%85%A5%E9%97%A8/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A812-JavaScript%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-函数"><a href="#正文-函数" class="headerlink" title="正文-函数"></a>正文-函数</h1><p>在 JavaScript 里用 function 声明的就是函数，函数本质上也是一个对象，不同的函数调用方式有着不同的用途，下面就来讲讲函数。</p>
<p>函数有一些相关术语： function 关键字、函数名、函数体、形参、实参、构造函数；</p>
<p>其中，大部分的术语用 Java 的基础来理解即可，就构造函数需要注意一下，跟 Java 里不大一样。在 JavaScript 中，所有的函数，只要它和 new 关键字一起使用的，此时，就可称这个函数为构造函数。</p>
<p>因为，为了能够在程序中辨别普通函数和构造函数，书中建议需要有一种良好的编程规范，比如构造函数首字母都用大写，普通函数或方法的首字母小写，以人为的手段来良好的区分它们。这是因为，通常用来当做构造函数就很少会再以普通函数形式使用它。</p>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>函数的定义大体上包含以下几部分：function 关键字、函数对象的变量标识符、形参列表、函数体、返回语句。</p>
<p>如果函数没有 return 语句，则函数返回的是 undefined。</p>
<p>函数定义有三种方式：</p>
<h4 id="函数声明式"><a href="#函数声明式" class="headerlink" title="函数声明式"></a>函数声明式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//由于函数声明被提前了，不会出错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add 是函数名，由于 JavaScript 有声明提前的处理，以这种方式定义的函数，可以在它之前调用。</p>
<h4 id="函数定义表达式"><a href="#函数定义表达式" class="headerlink" title="函数定义表达式"></a>函数定义表达式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式其实是定义了匿名函数，然后将函数对象赋值给 add 变量，JavaScript 的声明提前处理只将 add 变量的声明提前，赋值操作仍在原位置，因此这种方式的声明，函数的调用需要在声明之后才不会报错。 </p>
<p>注意，即使 function 后跟随了一个函数名，不使用匿名函数方式，但在外部仍旧只能使用 add 来调用函数，无法通过函数名，这是由于 JavaScript 中作用域机制原理导致，在后续讲作用域时会来讲讲。</p>
<h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"return x*y;"</span>);</span><br><span class="line"><span class="comment">//基本等价于</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Function 构造函数接收不定数量的参数，最后一个参数表示函数体，前面的都作为函数参数处理。</p>
<p>注意：以这种方式声明的函数作用域是全局作用域，即使这句代码是放在某个函数内部，相当于全局作用域下执行 eval()，而且对性能有所影响，不建议使用这种方式。</p>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>跟 Java 不一样的地方，在 JavaScript 中函数也是对象，既然是对象，那么对于函数对象这个变量是可以随意使用的，比如作为赋值语句的右值，作为参数等。</p>
<p>当被作为函数对象看待时，函数体的语句代码并不会被执行，只有明确是函数调用时，才会触发函数体内的语句代码的执行。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a;    <span class="comment">//将函数对象a的引用赋值给b</span></span><br><span class="line"><span class="keyword">var</span> c = a();  <span class="comment">//调用a函数，并将返回值赋值给c</span></span><br></pre></td></tr></table></figure>

<p>函数的调用可分为四种场景：</p>
<ul>
<li>作为普通函数被调用</li>
<li>作为对象的方法被调用</li>
<li>作为构造函数被调用</li>
<li>通过 call() 或 apply() 间接的调用</li>
</ul>
<p>不同场景的调用所造成的区别就是，函数调用时的上下文（this）区别、作用域链的区别；</p>
<h4 id="作为普通函数被调用"><a href="#作为普通函数被调用" class="headerlink" title="作为普通函数被调用"></a>作为普通函数被调用</h4><p>通常来说，直接使用函数名+() 的形式调用，就可以认为这是作为函数被调用。如果有借助 <code>bind()</code> 时会是个例外的场景，但一般都可以这么理解。</p>
<p>如果只是单纯作为函数被调用，那么通常是不用去考虑它的上下文、它的this值，因为这个时候，函数的用途倾向于处理一些通用的工作，而不是特定对象的特定行为，所以需要使用 this 的场景不多。</p>
<p>普通函数被调用时的作用域链的影响因素取决于这个函数被定义的位置，作用域链是给变量的作用域使用的，变量的作用域分两种：全局变量、函数内变量，作用域链决定着函数内的变量取值来源于哪里；</p>
<p>普通函数被调用时的上下文在非严格模式下，一直都是全局对象，不管这个函数是在嵌套函数内被调用或定义还是在全局内被定义或调用。但在严格模式下，上下文是 undefined。</p>
<h4 id="作为对象的方法被调用"><a href="#作为对象的方法被调用" class="headerlink" title="作为对象的方法被调用"></a>作为对象的方法被调用</h4><p>普通的函数如果挂载在某个对象内，作为对象的属性存在时，此时可从对象角度称这个函数为对象的方法，而通过对象的引用访问这个函数类型的属性并调用它时，此时称为方法调用。</p>
<p>方法调用的上下文（this）会指向挂载的这个对象，作用域链仍旧是按照函数定义的位置生成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.c();  <span class="comment">//输出1，a.c() 称为对象的方法调用</span></span><br><span class="line">a[<span class="string">"c"</span>](); <span class="comment">//对象的属性也可通过[]访问，此种写法也是调用对象a的c方法</span></span><br></pre></td></tr></table></figure>

<p>只有明确通过对象的引用访问函数类型的属性并调用它的行为才称为对象的方法调用，并不是函数挂载在对象上，它的调用就是方法调用，需要注意下这点，看个例子： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = a.c;</span><br><span class="line">d();  <span class="comment">//将对象的c函数引用赋值给d，调用d，此时d()是普调的函数调用，上下文在非严格模式下是全局对象，不是对象a</span></span><br></pre></td></tr></table></figure>

<p>下面通过一个例子来说明普通函数调用和对象的方法调用： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); </span><br><span class="line">        f();  <span class="comment">//f() 是函数调用</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.m(); <span class="comment">//输出 1 0，因为0.m()是方法调用，m中的this指向对象o，所以输出</span></span><br></pre></td></tr></table></figure>

<p>输出1 0，因为 <code>o.m()</code> 是方法调用，m 中的 this 指向对象 o，所以输出的 a 是对象 o 中 a 属性的值 1；</p>
<p>而 m 中虽然内嵌了一个函数 f，它并不挂载在哪个对象像，<code>f()</code> 是对函数 f 的调用，那么它的上下文 this 指向的是全局对象。</p>
<p>所以，对于函数的不同场景的调用，重要的区别就是上下文。</p>
<h4 id="作为构造函数被调用"><a href="#作为构造函数被调用" class="headerlink" title="作为构造函数被调用"></a>作为构造函数被调用</h4><p>普通函数挂载在对象中，通过对象来调用称方法；而当普通函数结合 new 关键字一起使用时，被称为构造函数。</p>
<p>构造函数的场景跟其他场景比较不同，区别也比较大一些，除了调用上下文的区别外，在实参处理、返回值方面都有不同。</p>
<p>如果不需要给构造函数传入参数，是可以省略圆括号的，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure>

<p>对于方法调用或函数调用圆括号是不能省略的，一旦省略，就只会将它们当做对象处理，并不会调用函数。</p>
<p>构造函数调用时，是会创建一个新的空对象，继承自构造函数的 prototype 属性，并且这个新创建的空对象会作为构造函数的上下文，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    f:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.f();  <span class="comment">//输出1</span></span><br><span class="line"><span class="keyword">new</span> o.f();  <span class="comment">//输出undefined</span></span><br></pre></td></tr></table></figure>

<p>如果是 <code>o.f()</code> 时，此时是方法调用，输出 1;</p>
<p>而如果是 <code>new o.f()</code> 时，此时 f 被当做构造函数处理，this 指向的是新创建的空对象，空对象没有 a 这个属性，所以输出 undefined。</p>
<p>构造函数通常不使用 return 语句，默认会创建继承自构造函数 prototype 的新对象返回。但如果硬要使用 return 语句时，如果 return 的是个对象类型，那么会覆盖掉构造函数创建的新对象返回，如果 return 的是原始值时，return 语句无效。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    f:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> o.f();  <span class="comment">//b是[] 空数组对象，而不是f</span></span><br></pre></td></tr></table></figure>

<h4 id="间接调用"><a href="#间接调用" class="headerlink" title="间接调用"></a>间接调用</h4><p><code>call()</code> 和 <code>apply()</code> 是 Function.prototype 提供的函数，所有的函数对象都继承自 Function.prototype，所有都可以使用这两个函数。它们的作用是可以间接的调用此函数。</p>
<p>什么意思，也就是说，任何函数可以作为任何对象的方法来调用，即使这个函数并不是那个对象的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    f:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.f(); <span class="comment">//输出1</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">o.f.call(o1); <span class="comment">//输出2</span></span><br></pre></td></tr></table></figure>

<p>函数 f 原本是对象 o 的方法，但可以通过 call 来间接让函数 f 作为其他对象如 o1 的方法调用。</p>
<p>所以间接调用本质上也还是对象的方法调用。应用场景可以是子类用来调用父类的方法。</p>
<p>那么函数的调用其实按场景来分可以分为三类：作为普通函数被调用，作为对象方法被调用，作为构造函数被调用。</p>
<p>普通函数和对象方法这两种区别在于上下文不一样，而构造函数与前两者区别更多，在参数处理、上下文、返回值上都有所区别。</p>
<p>如果硬要类比于 Java 的函数方面，我觉得可以这么类比：</p>
<ul>
<li>普通函数的调用 VS 公开权限的静态方法</li>
<li>对象方法的调用 VS 对象的公开权限的方法</li>
<li>构造函数的调用 VS 构造函数的调用</li>
</ul>
<p>左边 JavaScript，右边 Java，具体实现细节很多不一样，但大体上可以这么类比理解。</p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>参数分形参和实参两个概念，形参是定义时指定的参数列表，期望调用时函数所需传入的参数，实参是实际调用时传入的参数列表。</p>
<p>在 JavaScript 中，不存在 Java 里方法重载的场景，因为 JavaScript 不限制参数的个数，如果实参比形参多，多的省略，如果实参比形参少，少的参数值就是 undefined。</p>
<p>这种特性让函数的用法变得很灵活，调用过程中，根据需要传入所需的参数个数。但同样的，也带来一些问题，比如调用时没有按照形参规定的参数列表来传入，那么函数体内部就要自己做相对应的处理，防止程序因参数问题而异常。</p>
<p>同样需要处理的还有参数的类型，因为 JavaScript 是弱类型语言，函数定义时无需指定参数类型，但在函数体内部处理时，如果所期望的参数类型与传入的不一致，比如希望数组，传入的是字符串，这种类型不一致的场景JavaScript虽然会自动根据类型转换规则进行转换，但有时转换结果也不是我们所期望的。</p>
<p>所以，有些时候，函数体内部除了要处理形参个数和实参个数不匹配的场景外，最好也需要处理参数的类型检查，来避免因类型错误而导致的程序异常。</p>
<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>函数也是个对象，当定义了一个函数后，它继承自 Function.prototype 原型，在这个原型中定义了所有函数共有的基础方法和属性，其中一个属性就是 arguments。</p>
<p>这个属性是一个类数组对象，按数组序号顺序存储着实参列表，所以在函数内使用参数时，除了可以使用形参定义的变量，也可以使用 arguments。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//x 和 arguments[0]等效</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(<span class="number">5</span>); <span class="comment">//输出 5 5 undefined undefined</span></span><br><span class="line">a(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">//输出 5 5 4 3</span></span><br></pre></td></tr></table></figure>

<p>所以，虽然函数定义时声明了三个参数，但使用的时候，并不一定需要传入三个，当传入的实参个数少于定义的形参个数时，相应形参变量对应的值为 undefined；</p>
<p>相反，当传入实参个数超过形参个数时，可用 arguments 来取得这些参数使用。</p>
<h4 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h4><p>因为函数不对参数个数、类型做限制，使用时可以传入任意数量的任意类型的实参，所以在函数内部通常需要做一些处理，大体上从三个方面进行考虑：</p>
<ul>
<li>形参个数与实参个数不符时处理</li>
<li>参数默认值处理</li>
<li>参数类型处理</li>
</ul>
<p>下面分别来讲讲：</p>
<h5 id="形参个数与实参个数不符时处理"><a href="#形参个数与实参个数不符时处理" class="headerlink" title="形参个数与实参个数不符时处理"></a>形参个数与实参个数不符时处理</h5><p>通过 argument.length 可以获取实参的个数，通过函数属性 length 可以获取到形参个数，知道形参个数和实参个数就可以做一些处理。如： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length !== <span class="built_in">arguments</span>.callee.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码表示当传入的实参个数不等于形参个数时，抛异常。</p>
<p>形参个数用：arguments.callee.length 获取，callee 是一个指向函数本身对象的引用。这里不能直接用 length 或 this.length，因为在函数调用一节说过，当以不同场景使用函数时，上下文 this 的值是不同的，不一定指向函数对象本身。</p>
<p>在函数体内部要获取一个指向函数本身对象的引用有三种方式：</p>
<ul>
<li>函数名</li>
<li>arguments.callee</li>
<li>作用域下的一个指向该函数的变量名</li>
</ul>
<h5 id="参数默认值处理"><a href="#参数默认值处理" class="headerlink" title="参数默认值处理"></a>参数默认值处理</h5><p>通常是因为实参个数少于形参的个数，导致某些参数并没有被定义，函数内使用这些参数时，参数值将会是 undefined，为了避免会造成一些逻辑异常，可以做一些默认值处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//根据形参实参个数做处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length !== <span class="built_in">arguments</span>.callee.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理参数默认值</span></span><br><span class="line">    x = x || <span class="string">"default"</span>; <span class="comment">// 等效于 if(x === undefined) x = "default";</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="参数类型处理"><a href="#参数类型处理" class="headerlink" title="参数类型处理"></a>参数类型处理</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//根据形参实参个数做处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length !== <span class="built_in">arguments</span>.callee.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理参数默认值</span></span><br><span class="line">    x = x || <span class="string">"default"</span>; <span class="comment">// 等效于 if(x === undefined) x = "default";</span></span><br><span class="line">    <span class="comment">//参数类型处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(x)) &#123;</span><br><span class="line">        <span class="comment">//...   </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">        <span class="comment">//...   </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数类型的处理可能比较常见，通过各种辅助手段，确认所需的参数类型究竟是不是期望的类型。 </p>
<h5 id="多个参数时将其封装在对象内"><a href="#多个参数时将其封装在对象内" class="headerlink" title="多个参数时将其封装在对象内"></a>多个参数时将其封装在对象内</h5><p>当函数的形参个数比较多的时候，对于这个函数的调用是比较令人头疼的，因为必须要记住这么多参数，每个位置应该传哪个。这个时候，就可以通过将这些参数都封装到对象上，函数调用传参时，就不必关心各个参数的顺序，都添加到对象的属性中即可。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数用于复制原始数组指定起点位置开始的n个元素到目标数组指定的开始位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayCopy</span>(<span class="params">fromArray, fromStart, toArray, toStart, length</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部调用时，传入对象内只要有这5个属性即可，不必考虑参数顺序，同时这种方式也可以实现给参数设置默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayCopyWrapper</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    arrayCopy(args.fromArray,</span><br><span class="line">                args.fromStart || <span class="number">0</span>, </span><br><span class="line">                args.toArray,</span><br><span class="line">                args.toStart || <span class="number">0</span>,</span><br><span class="line">                args.length);</span><br><span class="line">&#125;</span><br><span class="line">arrayCopyWrapper(&#123;<span class="attr">fromArray</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="attr">fromStart</span>:<span class="number">0</span>, <span class="attr">toArray</span>:a, <span class="attr">length</span>:<span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>第二种方式相比第一种方式会更方便使用。</p>
<h3 id="函数特性"><a href="#函数特性" class="headerlink" title="函数特性"></a>函数特性</h3><p>函数既是函数，也是对象。它拥有类似其他语言中函数的角色功能，同时，它本身也属于一个对象，同样拥有对象的相关功能。</p>
<p>当作为函数来对待时，它的主要特性也就是函数的定义和调用：如何定义、如何调用、不同定义方式有和区别、不同调用方式适用哪些场景等等。</p>
<p>而当作为对象来看待时，对象上的特性此时也就适用于这个函数对象，如：动态为其添加或删除属性、方法，作为值被传递使用等。</p>
<p>所以，函数的参数类型也可以是函数，函数对象也可以拥有类型为函数的属性，此时称它为这个对象的方法。</p>
<p>如果某些场景下，函数的每次调用时，函数体内部都需要一个唯一变量，此时通过给函数添加属性的方式，可以避免在全局作用域内定义全局变量，这是 Java 这类语言做不到的地方。</p>
<p>类似需要跟踪函数每次的调用这种场景，就都可以通过对函数添加一些属性来实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniqueCounter.counter++;</span><br><span class="line">&#125;</span><br><span class="line">uniqueCounter.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = uniqueCounter();  <span class="comment">//a = 0;</span></span><br><span class="line"><span class="keyword">var</span> b = uniqueCounter();  <span class="comment">//b = 1;</span></span><br><span class="line"><span class="keyword">var</span> c = uniqueCounter();  <span class="comment">//c = 2;</span></span><br></pre></td></tr></table></figure>

<p>虽然定义全局变量的方式也可以实现，但容易污染全局空间的变量。 </p>
<h3 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h3><p>除了可动态对函数添加属性外，由于函数都是继承自 Function.prototype 原型，因此每个函数其实已经自带了一些属性，包括常用的方法和变量，比如上述介绍过的 arguments。</p>
<p>这里就来学下，一个函数本身自带了哪些属性，不过函数比较特别，下面介绍的一些属性并没有被纳入标准规范中，但各大浏览器却都有实现，不过使用这类属性还是要注意下：</p>
<h4 id="arguments-1"><a href="#arguments-1" class="headerlink" title="arguments"></a>arguments</h4><p>上述介绍过，这个属性是个类数组对象，用于存储函数调用时传入的实参列表。</p>
<p>但有一点需要注意，在严格模式下，不允许使用这个属性了，这个变量被作为一个保留字了。</p>
<h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><p>上述也提过，这个属性表示函数声明时的形参个数，也可以说是函数期望的参数个数。</p>
<p>有一点也需要注意，在函数体内不能直接通过 length 或 this.length 来访问这个属性，因为函数会跟随着不同的调用方式有不同的上下文 this，并不一定都指向函数对象本身。</p>
<p>而 arguments 对象中还有一个属性 callee，它指向当前正在执行的函数，在函数体内部可以通过 arguments.callee 来获取函数对象本身，然后访问它的 length 属性。</p>
<p>在函数外部，就可以直接通过访问函数对象的属性方式直接获取 length。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(<span class="number">1</span>); <span class="comment">// 输出 1 2，实参个数1个，形参个数2个</span></span><br><span class="line">a.length;  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>但需要注意一点，在严格模式下，函数体内部就不能通过 arguments.callee.length 来使用了。</p>
<h4 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h4><p>caller 属性表示指向当前正在执行的函数的函数，也就是当前在执行的函数是在哪个函数内执行的。这个是非标准的，但大多浏览器都有实现。</p>
<p>在严格模式下，不能使用。</p>
<p>还有一点需要注意的是，有的书里是说这个 caller 属性是函数的参数对象 arguments 里的一个属性，但某些浏览器中，caller 是直接作为函数对象的属性。</p>
<p>总之，arguments，caller，callee 这三个属性如果要使用的话，需要注意一下。</p>
<h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>返回函数名，这个属性是 ES6 新增的属性，但某些浏览器在 ES6 出来前也实现了这个属性。即使不通过这个属性，也可以通过函数的 <code>toSring()</code> 来获取函数名。</p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>用于将当前函数绑定至指定对象，也就是作为指定对象的方法存在。同时，这个函数会返回一个函数类型的返回值，所以通过 <code>bind()</code> 方式，可以实现以函数调用的方式来调用对象的方法。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f.bind(o);</span><br><span class="line">g(<span class="number">2</span>);  <span class="comment">//输出 3</span></span><br></pre></td></tr></table></figure>

<p>此时 g 虽然是个函数，但它表示的是对象 o 的方法 f，所以 <code>g()</code> 这种形式虽然是函数调用，但实际上却是调用 o 对象的方法 f，所以方法 f 函数体中的 this 才会指向对象 o。</p>
<p>另外，如果调用 <code>bind()</code> 时传入了多个参数，第一个参数表示需要到的对象，剩余参数会被使用到当前函数的参数列表。</p>
<h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><p>该属性名直译就是原型，当函数被当做构造函数使用时才有它的意义，用于当某个对象是从构造函数实例化出来的，那么这个对象会继承自这个构造函数的 prototype 所指向的对象。</p>
<p>虽然这个属性的中文直译就是原型，但我不喜欢这么称呼它，因为原型应该是指从子对象的角度来看，它们继承的那个对象，称作它们的原型，因为原型就是类似于 Java 里父类的概念。</p>
<p>虽然，子对象的原型确实由构造函数的 prototype 决定，但如果将这个词直接翻译成原型的话，那先来看下这样的一句表述：通过构造函数创建的新对象继承自构造函数的原型。</p>
<p>没觉得这句话会有一点儿歧义吗？构造函数本质上也是一个对象，它也有继承结构，它也有它继承的原型，那么上面那句表述究竟是指新对象继承自构造函数的原型，还是构造函数的 prototype 属性值所指向的那个对象？</p>
<p>所以，你可以看看，在我写的这系列文章中，但凡出现需要描述新对象的原型来源，我都是说，新对象继承自构造函数的 prototype 所指向的那个对象，我不对这个属性名进行直译，因为我觉得它会混淆我的理解。</p>
<p>另外，在 prototype 指向的原型对象中添加的属性，会被所有从它关联的构造函数创建出来的对象所继承。所有，数组内置提供的一些属性方法、函数内置提供的相关属性方法，实际上都是在 Array.prototype 或 Function.prototype 中定义的。</p>
<h4 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call() 和 apply()"></a>call() 和 apply()</h4><p>这两个方法在函数调用一小节中介绍过了，因为在 JavaScript 中的函数的动态的，任意函数都可以作为任意对象的方法被调用，即使这个函数声明在其他对象中。此时，就需要通过间接调用实现，也就是通过 <code>call()</code> 和 <code>apply()</code>。</p>
<p>一种很常见的应用场景，就是用于调用原型中的方法，类似于 Java 中的 super 调用父类的方法。因为子类可能重写了父类的方法，但有时又需要调用父类的方法，那么可通过这个实现。</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>Function.prototype 重写了 Object.prototype 中提供的 toString 方法，自定义的函数会通常会返回函数的完整源码，而内置的函数通常返回 [native code] 字符串。 </p>
<p>借助这个可以获取到自定义的函数名。</p>
<h3 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h3><p>嵌套函数就是在函数体中继续定义函数，需要跟函数的方法定义区别开来。</p>
<p>函数的方法定义，是将函数看成对象，定义它的属性，类型为函数，这个函数只是该函数对象的方法，并不是它的嵌套函数。</p>
<p>而嵌套函数需要在函数体部分再用 function 定义的函数，这些函数称为嵌套函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b();  <span class="comment">//输出：1</span></span><br><span class="line">    c();  <span class="comment">//输出：1</span></span><br><span class="line">    a.d();<span class="comment">//输出：0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.d = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 b 和 c 是嵌套在函数 a 中的函数，称它们为嵌套函数。其实本质就是函数体内部的局部变量。</p>
<p>函数 d 是函数 a 的方法。</p>
<p>嵌套函数有些类似于 Java 中的非静态内部类，它们都可以访问外部的变量，Java 的内部类本质上是隐式的持有外部类的引用，而 JavaScript 的嵌套函数，其实是由于作用域链的生成规则形成了一个闭包，以此才能嵌套函数内部可以直接访问外部函数的变量。</p>
<p>闭包涉及到了作用域链，而继承涉及到了原型链，这些概念后面会专门来讲述。</p>
<p>这里稍微提下，闭包通俗点理解也就是函数将其外部的词法作用域包起来，以便函数内部能够访问外部的相关变量。</p>
<p>通常有大括号出现都会有闭包，所以函数都会对应着一个闭包。</p>
<h3 id="高级应用场景"><a href="#高级应用场景" class="headerlink" title="高级应用场景"></a>高级应用场景</h3><p>利用函数的特性、闭包特性、继承等，能够将函数应用到各种场景。 </p>
<h4 id="使用函数作为临时命名空间"><a href="#使用函数作为临时命名空间" class="headerlink" title="使用函数作为临时命名空间"></a>使用函数作为临时命名空间</h4><p>JavaScript 中的变量作用域大概就两种：全局作用域和函数内作用域，函数内定义的变量只能内部访问，外部无法访问。函数外定义的变量，任何地方均能访问。</p>
<p>基于这点，为了保护全局命名空间不被污染，常常利用函数来实现一个临时的命名空间，两种写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">//输出1</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//输出undefined</span></span><br></pre></td></tr></table></figure>

<p>简单说就是定义一个函数，定义的同时末尾加上 () 顺便调用执行函数体内容，那么这个函数的作用其实也就是创建一个临时的命名空间，在函数体内部定义的变量不用担心与其他人起冲突。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>外层括号不能漏掉，末尾函数调用的括号也不能漏掉，这样就可以了，至于末尾的括号是放在外层括号内，还是外都可以。 </p>
<h4 id="使用函数封装内部信息"><a href="#使用函数封装内部信息" class="headerlink" title="使用函数封装内部信息"></a>使用函数封装内部信息</h4><p>闭包的特性，让 JavaScript 虽然没有类似 Java 的权限控制机制，但也能近似的模拟实现。</p>
<p>因为函数内的变量外部访问不到，而函数又有闭包的特性，嵌套函数可以包裹外部函数的局部变量，那么外部函数的这些局部变量，只有在嵌套函数内可以访问，这样就可以实现对外隐藏内部一些实现细节。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getB: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c.b); <span class="comment">//输出 undefined</span></span><br><span class="line"><span class="keyword">var</span> c = a();   <span class="comment">//输出 1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>前端11-JavaScript语法之数组（入门）</title>
    <url>/2018/11/01/%E5%89%8D%E7%AB%AF/%E5%85%A5%E9%97%A8/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A811-JavaScript%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-数组"><a href="#正文-数组" class="headerlink" title="正文-数组"></a>正文-数组</h1><p>数据的有序集合称为数组。</p>
<p>其实也就是个容器，但与 Java 中的数组不同的是，JavaScript 里的数组不限制元素类型、本身就是个对象，因此不管在使用方面、语法方面、概念上都会一些区别。</p>
<p>那么本章其实也就是学习 JavaScript 中数组的用法：</p>
<h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><h4 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h4><p>稀疏数组就是指不连续索引的数组，数组容器中某些索引是空的、无值。相反，正常的连续索引的数组就是非稀疏数组，容器中各元素紧密堆放，如：</p>
<p>稀疏数组：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-05fc0ee50d65e82a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="稀疏数组">  </p>
<p>非稀疏数组：</p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/1924341-40a22a29d1264791.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非稀疏数组">  </p>
<p>数组内每个元素紧密排列。 </p>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>JavaScript 不支持真正的多维数组，但可以用数组的数组来近似。</p>
<p>以二维数组举例，在 Java 中可直接声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>但在 JavaScript 中无法定义二维数据，会报语法错误：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-4abf875af9df9b3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多维数组定义">  </p>
<p>但由于数组在 JavaScript 中也是对象，数组中的元素也可以是数组，因此可以用数组的数组来实现多维数组：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a27a49fbaa6187e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多维数组定义1">  </p>
<h4 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h4><p>理解类数组对象概念可以将这个词补充解释完整，即：类似数组的对象。</p>
<p>所以，这个概念的主语是对象，而对象如果是通过 [] 来操作它的属性时，属性值可以很灵活，不是必须满足标识符规定，只要最后能计算出一个字符串值即可。因此，当如果定义了某个对象，其属性值是非负整数：0,1,2,3…，此外再给这个对象定义了一个 length 属性，那么此时就可称这个对象为类数组对象。</p>
<p>因为对这种对象的操作，跟数组很类似，而且 Array.prototype 中提供的很多操作数组的方法都可以直接用来操作这些类数组对象。  </p>
<h3 id="数组属性-length"><a href="#数组属性-length" class="headerlink" title="数组属性-length"></a>数组属性-length</h3><p>每个数组都有一个 length 属性，这个属性是使数组区别于常规的 JavaScript 对象的关键。</p>
<p>需要注意，length 并不是表示数组的元素个数。</p>
<p>length 表示的是数组里最大索引 + 1，因为 JavaScript 分稀疏数组和非稀疏数组。</p>
<p>如果是非稀疏数组，各元素都紧密堆放，那么此时 length = 最大索引 + 1，能够表示数组元素的个数。</p>
<p>但如果是稀疏数组，由于中间有些索引位置其实是空的，并没有元素，索引 length = 最大索引 + 1，此时并不表示数组元素个数。</p>
<p>而且，数组索引是基于 32 位数值的，所以 length 的取值范围：</p>
<p>0 ~ 2^32 - 1  =&gt;  0 ~ 4294967295 </p>
<p>另外，由于 length 属性默认是可读可写的，所以它有一些特殊功能：</p>
<ul>
<li>当添加或删除数组元素时，length 会自动更新。</li>
<li>并不是所有删除数组元素的操作都会让 length 更新，有些删除操作只是移除索引里保存数据，并不移除数组这个索引所占的坑位。</li>
<li>length 可写性，当设置 length 比当前数组长度小的值时，会自动删除那些索引值大于等于 length 的元素。</li>
<li>反过来将 length 设置比当前数组长度大，会让数组变成稀疏数组，并不会实际添加一些元素进去。</li>
</ul>
<h3 id="数组特性"><a href="#数组特性" class="headerlink" title="数组特性"></a>数组特性</h3><p>虽然数组也是对象，但它有一些特性是其他对象所没有的： </p>
<ul>
<li>当有新元素添加到数组中时，自动更新 length 属性</li>
<li>设置 length 为一个较小值将截断数组</li>
<li>继承了 Array.prototype 一些操作数组的便捷方法</li>
<li>类属性为 “Array”</li>
<li>不限制元素类型，一个数组中可以同时存储各种类型的数据</li>
</ul>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>数组的创建，或者说定义数组，初始化数组一共有两种方式： </p>
<h4 id="数组直接量"><a href="#数组直接量" class="headerlink" title="数组直接量"></a>数组直接量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];  <span class="comment">//空数组</span></span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>, <span class="string">"2"</span>, <span class="literal">true</span>, [<span class="number">1</span>+<span class="number">2</span>, &#123;&#125;]]; <span class="comment">//不同类型的数组元素，数组直接量中甚至可以是表达式</span></span><br><span class="line"><span class="keyword">var</span> c = [,,,<span class="number">3</span>];  <span class="comment">//省略的索引，读取时为 undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="构造函数-Array"><a href="#构造函数-Array" class="headerlink" title="构造函数 Array()"></a>构造函数 Array()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();  <span class="comment">//通过构造函数创建数组</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数组元素的读写"><a href="#数组元素的读写" class="headerlink" title="数组元素的读写"></a>数组元素的读写</h3><p>跟 Java 语言的数组读写一样，同是通过 [] 中括号来操作。</p>
<p>但 JavaScript 更灵活，[] 里可以是任何表达式，不限制于非负整数，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>] = <span class="number">0</span>;    <span class="comment">//常规操作</span></span><br><span class="line">a[<span class="string">"23"</span>] = <span class="number">0</span>; <span class="comment">//自动将 "23" 字符串转成数值类型 23，等效于 a[23]=0</span></span><br><span class="line">a[<span class="number">-23</span>] = <span class="number">0</span>;  <span class="comment">//当[]中不是非负整数时，此操作变成对象的属性读写，因为数组也是对象</span></span><br><span class="line">a[<span class="number">5</span>+<span class="number">6</span>];      <span class="comment">//[] 中可以是表达式，先计算表达式值后，再操纵数组，等效于 a[11]</span></span><br></pre></td></tr></table></figure>

<p>因为数组也是对象，所以 JavaScript 中的数组操作不存在越界的场景，当试图查询不存在的属性时，只会返回 undefinded。</p>
<h3 id="数组元素的添加"><a href="#数组元素的添加" class="headerlink" title="数组元素的添加"></a>数组元素的添加</h3><p>添加元素都数组最简单的方式是通过 [] 操作符，另外也可借助 Array.prototype 的一些方法： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];  <span class="comment">//a 是空数组</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">//指定索引位置添加元素</span></span><br><span class="line">a.push(<span class="number">1</span>);   <span class="comment">//等效于 a[length] = 1，在数组末尾添加元素</span></span><br><span class="line">a.unshift(<span class="number">-1</span>); <span class="comment">//在数组头部添加元素，原本数组中的元素依次向后移</span></span><br><span class="line">a.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"0"</span>, <span class="string">"1"</span>);  <span class="comment">//插入删除操作通用的方法，这里等效于 a.unshift("0", "1");</span></span><br></pre></td></tr></table></figure>

<p>[] 方式来添加元素的前提是，中括号里的索引位置原先并没有元素存在，如果索引位置有元素存在，则该操作变成赋值操作。</p>
<p>如果想在末尾添加元素，直接使用 push 即可；</p>
<p>如果想在开头添加元素，并让其他元素自动后移，可用 unshift；</p>
<p>splice 是个通用的方法，可在数组指定的任何位置添加元素，并让这位置之后的元素自动后移，同时它也可用来删除指定位置元素，并让后续元素自动前移补上被删除的位置。具体参数含义后面介绍。</p>
<h3 id="数组元素的删除"><a href="#数组元素的删除" class="headerlink" title="数组元素的删除"></a>数组元素的删除</h3><p>数组元素的删除分两种场景：</p>
<ol>
<li>单纯将指定位置的元素删除，不会触发高索引元素往下移的填充行为，也不会触发 length 的长度减少；</li>
<li>删除指定位置的元素，同时后面元素会往前移来填充被删除元素留下的空白位置，同时 length 会跟随着减少。</li>
</ol>
<p>所以，当有涉及数组元素删除操作时，需特别注意下，根据自己的需求场景，选择对应的方法进行操作。</p>
<h4 id="场景1对应的删除操作"><a href="#场景1对应的删除操作" class="headerlink" title="场景1对应的删除操作"></a>场景1对应的删除操作</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];  <span class="comment">//数组 length = 3;</span></span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];      <span class="comment">//此时数组：[1,,3]，length 仍旧=3</span></span><br></pre></td></tr></table></figure>

<p>使用 delete 可用于删除数组内的元素内容，但并不影响数组的长度。</p>
<h4 id="场景2对应的删除操作"><a href="#场景2对应的删除操作" class="headerlink" title="场景2对应的删除操作"></a>场景2对应的删除操作</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];  <span class="comment">//数组 length = 8;</span></span><br><span class="line">a.pop();          <span class="comment">//数组：[1,2,3,4,5,6,7]  length = 7;</span></span><br><span class="line">a.shift();        <span class="comment">//数组：[2,3,4,5,6,7]  length = 6</span></span><br><span class="line">a.splice(<span class="number">2</span>, <span class="number">2</span>);   <span class="comment">//数组：[2,3,6,7]  length = 4</span></span><br><span class="line">a.length = <span class="number">2</span>;     <span class="comment">//数组：[2,3]  length = 2</span></span><br></pre></td></tr></table></figure>

<p>除了使用 Array.prototype 内置的方法来删除元素，对 length 的赋值操作也可以达到删除末尾的多个元素，超过 length 的索引位置的元素就都被清空掉。</p>
<h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><h4 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h4><p>数组的遍历也是很常见的场景，常规的用法类似 Java 的 for 循环语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,,,,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];  <span class="comment">//数组 length = 8;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数组是稀疏数组时，那些索引位置没有元素存在的也仍旧需要遍历，读取的值是 undefined，所以需要根据需要做相应判断处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,,,,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];  <span class="comment">//数组 length = 8;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a[i]) <span class="keyword">continue</span>; <span class="comment">//跳过 null，undefined 和不存在的元素</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] === <span class="literal">undefined</span>) <span class="keyword">continue</span>; <span class="comment">//跳过undefined 和不存在的元素</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(i <span class="keyword">in</span> a)) <span class="keyword">continue</span>; <span class="comment">//跳过不存在的元素</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for-in-循环语句"><a href="#for-in-循环语句" class="headerlink" title="for-in 循环语句"></a>for-in 循环语句</h4><p>除了使用常规的 for 循环外，还可以使用 for-in 的方式： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,,,,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];  <span class="comment">//数组 length = 8;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组实际上也是对象，数组的索引从对象角度来看，其实也就是属性，那么就可以用 for-in 这种方式遍历属性，这种方式可以跳过稀疏数组中那些不存在的元素，但有个缺点，它也会遍历那些继承属性，所以如果需要，可做一些过滤判断： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,,,,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];  <span class="comment">//数组 length = 8;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a.hasOwnProperty(i)) <span class="keyword">continue</span>;  <span class="comment">//跳过继承的属性 </span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：虽然 for-in 也可以达到遍历的效果，但不建议使用在遍历数组的场景，因为遍历顺序并不一定按照索引顺序。 </p>
<h4 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach 方法"></a>forEach 方法</h4><p>上述两种遍历方案都需要自行处理很多情况，那么，有没有一种方便一点的遍历方法，有的：forEach</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,,,,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];  <span class="comment">//数组 length = 8;</span></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="comment">//x即数组a中存在的元素</span></span><br><span class="line">    <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种方式可以遍历数组中存在的元素，不需做额外的判断处理。如果函数中需要数组元素的索引信息、数组本身的对象引用信息，此时，可增加额外参数实现: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x:数组元素, i:元素的索引, a:数组的引用</span></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">x, i, a</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(a[i] + <span class="string">" = "</span> + x); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>Array.prototype 中定义了一些很有用的操作数组的函数，可用于作为数组的方法调用，足够满足开发中所需的数组相关的操作需求，列举一些常见的，更多可参考 API：</p>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>将数组各元素按照指定字符串拼接起来后输出字符串： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.join();    <span class="comment">//输出：1,,2,3  没有参数默认以逗号,拼接</span></span><br><span class="line">a.join(<span class="string">" "</span>)  <span class="comment">//输出：1  2 3  以空格拼接</span></span><br></pre></td></tr></table></figure>

<p>不存在的元素也会占据一个拼接符，所以可以结合其他方法过滤使用，后续介绍。 </p>
<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p>颠倒数组，将原数组进行逆序操作： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.reverse();</span><br><span class="line">a.join();    <span class="comment">//输出：3,2,,1  原数组被逆序</span></span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>将原数组按照指定规则对元素进行排序，默认以字母表顺序排序： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">22</span>,,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">a.sort();</span><br><span class="line">a.join();    <span class="comment">//输出：0,1,22,3,,</span></span><br></pre></td></tr></table></figure>

<p>注意：默认排序行为是将所有元素按照字符串形式处理，一个字符一个字符的排序，所有 22 的首字符 2 在 3 前面，排序结果才会是 22 在 3 前面，因为它并不是按照数值的大小来排序。</p>
<p>另外，不存的元素都排在末尾。</p>
<p>所以可以自行指定排序规则，如从小大到排序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">22</span>,,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> a - b; <span class="comment">//根据顺序返回：负数，0，正数</span></span><br><span class="line">&#125;);</span><br><span class="line">a.join();    <span class="comment">//输出：0,1,3,22,</span></span><br></pre></td></tr></table></figure>

<h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p>将参数传入的数值拼接到数组末尾，但不是在原数组上操作，而是会新建一个数组，此方法的拼接操作不会影响到原数组内容。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.concat(<span class="number">4</span>,<span class="number">5</span>);   <span class="comment">//返回 [1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>,<span class="number">5</span>]); <span class="comment">//返回 [1,2,3,4,5]  因为上述操作没有影响到原数组</span></span><br><span class="line">a.concat([<span class="number">4</span>,<span class="number">5</span>], [<span class="number">6</span>,[<span class="number">7</span>,<span class="number">8</span>]]); <span class="comment">//返回 [1,2,3,4,5,6,[7,8]]</span></span><br></pre></td></tr></table></figure>

<p>注意：如果传入的参数是数组，那么会解析一层数组，拼接数组的元素内容，那如果数组是多维数组，也只拼接第一维的数组元素，不会进一步解析数组。</p>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><p>截取原数组的某个片段，返回一个子数组，不会在原数组上操作，返回的是新数组： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.slice(<span class="number">0</span>, <span class="number">3</span>);  <span class="comment">//返回 [1,2,3] 两个参数指定起始和终点位置，关系是[),即左包含右不包含</span></span><br><span class="line">a.slice(<span class="number">3</span>);    <span class="comment">//返回 [4,5] 只有一个参数时，表示指定起点到末尾    </span></span><br><span class="line">a.slice(<span class="number">1</span>, <span class="number">-1</span>);<span class="comment">//返回 [2,3,4] 负数表示倒数第n个元素，</span></span><br></pre></td></tr></table></figure>

<h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p>通用的在数组的指定位置插入或删除元素，插入会让后面的元素自动往后移空出位置，删除会让后面的元素自动往前移填补空白，length 会跟随着变化。</p>
<p>如果有包含删除操作，那么删除的数组会被返回，否则返回空数组；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]; <span class="comment">//第一个参数选择操作的起始位置，第二个参数指定要删除的个数</span></span><br><span class="line">a.splice(<span class="number">4</span>);   <span class="comment">//返回 [5,6,7,8]  原数组 a：[1,2,3,4]</span></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//返回 [2,3]  原数组 a：[1,4]</span></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">1</span>); <span class="comment">//返回 [4]  原数组 a：[1]</span></span><br></pre></td></tr></table></figure>

<p>第一个参数选择要操作的起始位置，第二个参数指定要删除的元素个数，如果只有一个参数，那么就删除从起始位置到末尾的元素。被删除的元素会组成新数组返回，删除操作是直接在原数组上进行的。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];  <span class="comment">//第三个参数开始之后的任意参数都会被插入到指定的位置</span></span><br><span class="line">a.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">'a'</span>,<span class="string">'b'</span>);  <span class="comment">//返回 []  原数组 a：[1,2,'a','b',3,4,5]</span></span><br><span class="line">a.splice(<span class="number">2</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>],<span class="number">3</span>);  <span class="comment">//返回 ['a','b'] 原数组 a：[1,2,[1,2],3,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p>第三个参数开始之后的任意数量的参数都会被插入的第一个参数指定的位置，先进行删除操作，再进行添加操作。 </p>
<h4 id="push-和-pop"><a href="#push-和-pop" class="headerlink" title="push() 和 pop()"></a>push() 和 pop()</h4><p>在数组末尾添加或移除元素，<code>pop()</code> 时，被移除的元素会返回。 </p>
<h4 id="unshift-和-shift"><a href="#unshift-和-shift" class="headerlink" title="unshift() 和 shift()"></a>unshift() 和 shift()</h4><p>在数组开头添加或移除元素，都会触发数组元素进行迁移行为。</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>数组的 <code>toString()</code> 行为跟 <code>join()</code> 输出的一致。</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>遍历数组内每个元素，每遍历一个元素，会调用一次指定的函数，并将元素的相关信息通过参数传入函数内。 </p>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>原数组按照指定规则映射到新数组的操作，跟 <code>forEach()</code> 很类似，遍历数组内的每个元素时，都会调用一次指定的函数，并将元素相关信息通过参数传入函数内。但这个函数需要有一个返回值，用于生产新的数组的元素。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.map(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value + index;</span><br><span class="line">&#125;); <span class="comment">//b：[1,3,5]</span></span><br></pre></td></tr></table></figure>

<p>新数组与原数组的映射关系为：新数组元素 = 原数组元素 + 元素索引；</p>
<p>当有需要对原数组根据某种规则换算出新数组时，可用此方法。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>原数组元素根据某种规则进行过滤操作，过滤完后的元素作为新数组返回。跟 <code>forEach()</code> 也类似，都一样是在遍历每个元素时调用指定的方法，并将元素进行传入。这个方法需要一个 boolean 返回值，用来表示是否可以加入新数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">3</span>;</span><br><span class="line">&#125;); <span class="comment">//b：[4,5]</span></span><br></pre></td></tr></table></figure>

<p>用此方法也将稀疏数组转成非稀疏数组，函数内默认返回 true 即可，因为这些方法的遍历是只遍历数组内存在的元素。 </p>
<h4 id="every-和-some"><a href="#every-和-some" class="headerlink" title="every() 和 some()"></a>every() 和 some()</h4><p>用于检测数组的元素是否满足指定的条件，这两个方法都返回 boolean 值。检测行为就命名表示的意思，<code>every()</code> 表示数组里每个元素都需要满足条件，最终才会返回 true，一旦某个元素不满足，后续元素不会再进行检测，方法直接返回 false。<code>some()</code> 则刚好相反，只要有一个元素满足条件，后续元素不用检测，方法直接返回 true。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.some(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">3</span>;  <span class="comment">//返回 true，因为存在大于3的元素</span></span><br><span class="line">&#125;);</span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">3</span>;  <span class="comment">//返回false，因为不是所有元素都大于3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="reduce-和-reduceRight"><a href="#reduce-和-reduceRight" class="headerlink" title="reduce() 和 reduceRight()"></a>reduce() 和 reduceRight()</h4><p>依次对数组里每个元素按照指定规则进行计算，计算之后的结果继续跟下一个元素按照规则计算，常用于求和，最大值之类的场景。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;  <span class="comment">//数组求和</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>区别上述几个方法，这个的参数需要有两个参数，第一参数是函数，用于指定按照某种规则计算，这个函数也需要有两个参数，以及返回值，它的返回值会和下一个元素再一次传入该函数中计算。reduce 的第二个参数会和数组第一个元素被传入函数内计算，这里是求和，所以初始值传 0，求积可以传1，以此类推。</p>
<p>如果不传第二个参数，那么默认以数组第一个元素的值作为第二个参数的值。</p>
<p>reduceRight 和 reduce 用途，用法一致，唯一的区别，它是从数组的末尾往前一个个处理元素的。一个左到右处理数组，一个右到左。</p>
<h4 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf() 和 lastIndexOf()"></a>indexOf() 和 lastIndexOf()</h4><p>在数组内搜索指定元素，返回找到的第一个元素的索引位置，没有找到返回 -1</p>
<p>两个方法，一个从左往右寻找，一个从右往左寻找。</p>
<h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h4><p>用于判断某个对象是否是数组类型。   </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>前端10-JavaScript语法之对象（入门）</title>
    <url>/2018/10/31/%E5%89%8D%E7%AB%AF/%E5%85%A5%E9%97%A8/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A810-JavaScript%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-对象"><a href="#正文-对象" class="headerlink" title="正文-对象"></a>正文-对象</h1><p>在 JavaScript 除了原始数据类型外，其余均是对象，函数是对象，数组也是对象；继承通过对象来实现，构造函数也通过对象来实现，所以对象在 JavaScript 里有着很重要的角色，理解和掌握对象的一些特性，对于掌握 JavaScript 这门语言有着很大的帮助。</p>
<p>Java 里对象有属性和方法之分，但在 JavaScript 中，只存在属性，变量是属性，方法也是属性，对于 JavaScript 来说，对象，其实只是一堆属性的无序集合而已，外部可通过对象来操作各种属性，只不过有的属性，它的值是函数类型，所以这时可叫它为对象的方法。</p>
<p>对象的每个属性，都是一个 key-value 的形式，属性名和属性值。而属性，又分自有属性和继承属性，自有属性是指对象本身自己拥有的属性，而继承属性是指继承的属性。</p>
<h3 id="对象分类"><a href="#对象分类" class="headerlink" title="对象分类"></a>对象分类</h3><p>一般来说，有三类对象，分别是内置对象、宿主对象、自定义对象：</p>
<ul>
<li>内置对象：是指语法标准规范中内置实现的一些对象，例如函数、数组、正则、日期等这些内置对象；</li>
<li>宿主对象：是指 JavaScript 解释器所嵌入的宿主环境，在前端里，一般来说宿主环境就是浏览器，浏览器也会定义一些内置对象，比如 HTMLElement 等；</li>
<li>自定义对象：开发人员自行实现的对象。</li>
</ul>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>创建对象有三种方式：对象直接量、构造函数、Object.create() </p>
<h4 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h4><p>这是最简单的一种创建对象的方式，在代码中，直接通过 {} 形式创建一个对象，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="string">"main title"</span>: <span class="string">"JavaScript"</span>,</span><br><span class="line">    <span class="string">'sub-title'</span>: <span class="string">"The Definitive Guide"</span>,</span><br><span class="line">    <span class="string">"pages"</span>: <span class="number">900</span>,</span><br><span class="line">    author: &#123;</span><br><span class="line">        firstname: <span class="string">"David"</span>,</span><br><span class="line">        surname: <span class="string">"Flanagan"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码中，等号右侧 {} 代码块形式定义的对象方式，就叫对象直接量。代码中，每出现一次对象直接量，会直接创建一个新的对象，对象的属性就是对象直接量中定义的。</p>
<p>定义属性时，有几点需要注意一下，属性名也就是 key 值，可加引号也可不加引号，但如果属性名使用到一些保留字时，就肯定需要加引号。</p>
<p>属性值可以是 JavaScript 中的任意类型，原始类型、对象类型都可以。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数就是通过 <code>new</code> 关键字和函数一起使用时，此时的函数就称构造函数，用途在于创建一个新的对象。具体在后续讲函数时会详细讲解。</p>
<p>这里可以看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Book</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Book();</span><br></pre></td></tr></table></figure>

<p>通过 new 关键字和函数一起使用时，就可以创建新对象，例子中的 Object 和 Array 是内置的构造函数，也可以自定义构造函数，其实就是自定义一个函数，让它和 new 关键字一起使用就可以了。</p>
<p>通过构造函数方式如何给新创建的对象添加一些初始化的属性，这些细节和原理在函数一节中再讲，这里需要注意一点的就是，当不往构造函数传参数时，此时括号是允许可以省略的。</p>
<p>另外，第一种对象直接量的方式创建对象，其实，本质上也是通过构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"dasu"</span>&#125; </span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = <span class="string">"dasu"</span>;</span><br></pre></td></tr></table></figure>

<p>对象直接量其实是一种语法糖，可以通俗的理解，JavaScript 为方便我们创建对象，封装的一层工具，其内部的本质实现也是通过构造函数。</p>
<h4 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h4><p>你可以把 Object.create() 理解成 Java 中的静态方法。</p>
<p>通过这种方式，可以创建一个新的对象，参数是指定对象要继承的目标对象，这个被继承的对象，在 JavaScript 里被称为原型。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Object</span>());  <span class="comment">//创建一个新对象，让它继承自一个空对象</span></span><br></pre></td></tr></table></figure>

<p>通过构造函数创建的对象，其继承关系是由构造函数决定的，而 Object.create() 方式，可自己手动指定继承关系。当然，并不是说，构造函数就无法自己指定继承关系。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>原型可以理解成 Java 中的父类概念。</p>
<p>在 JavaScript 中，对象也存在继承关系，继承的双方都是对象，对象是从对象上继承的，被继承的那个对象称作原型。所以，有一种描述说，JavaScript 是基于原型的继承。</p>
<p>在 Java 中，是通过 extends 关键字实现继承关系，那么在 JavaScript 里呢？</p>
<p>自然也有类似的用来指定对象的继承关系，这就取决于创建对象的方式，上面说过，创建对象有三种方式：对象直接量、构造函数、Object.create()，但由于对象直接量本质上也是通过构造函数，所以其实就两种。</p>
<p>对于构造函数创建的对象来说，因为每个函数都有一个 prototype 属性，prototype 是它的属性名，属性值是一个对象，这个对象就是原型，就是通过该构造函数创建出来的新对象的继承来源。</p>
<p>我们可以通过修改构造函数的 prototype 属性值来达到指定对象继承关系的目的，如果不修改，那么内置的构造函数如 Object 或 Array 这些都已经有默认指定的 prototype 属性值了，也就是创建内置对象时，这个对象已经具有一定的默认继承结构了。</p>
<p>对于 Object.create() 方式创建对象，参数传入的就是子对象的原型，想让创建出来的对象继承自哪里，就传入那个对象就可以了。这个方法必须传入一个参数，否则运行时会抛异常，但可以传入 null，表示不继承任何对象，所以，JavaScript 里，是允许对象没有原型，允许对象不具有继承结构的。</p>
<p>对于原型，在后续会专门有一篇来讲讲，这里大概清楚些概念即可。</p>
<h3 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h3><p>JavaScript 里的对象，其实可以通俗的理解成属性的集合，既然是作为容器的存在，那么其实创建完对象只是第一步，后续就是往这个集合中添加属性，所以 JavaScript 里，对象是允许在运行期间动态添加属性的。</p>
<p>添加属性的方式，可以通过对象直接量方式，在创建对象之时，就写在对象直接量中，或者运行期间动态添加，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"dasu"</span>&#125;</span><br><span class="line">o.age = <span class="number">24</span>;</span><br><span class="line">o.sex = <span class="string">"man"</span>;</span><br><span class="line">o.love = <span class="string">"girl"</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-e6e42a025ff67fcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加属性">  </p>
<p>但需要注意一点的是，不像 Java 中在编写类代码，为类添加成员变量时，可以只声明却初始化。在 JavaScript 中，是不允许这样的。</p>
<p>也就是说，为对象添加某个属性时，需要直接将属性名和属性值都设置好，其实想想也能明白，对象无非就是属性的集合，你见过对哪个集合进行添加数据时，是可以只对该集合设置一个 key 值的吗？</p>
<h3 id="查询属性"><a href="#查询属性" class="headerlink" title="查询属性"></a>查询属性</h3><p>访问对象的属性方式很简单，两种：<code>.</code> 运算符或 <code>[]</code> 运算符；</p>
<p>两种方式都可以访问对象的属性，但有一个区别：</p>
<ul>
<li><code>.</code> 运算符访问属性的话，后面跟着的是属性名</li>
<li><code>[]</code> 运算符访问属性的话，中括号内跟着的是属性名的<strong>字符串</strong></li>
</ul>
<p>仍旧以上面例子中的代码为例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-8163a1c99dbd078b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查询属性">  </p>
<p>由于通过 <code>[]</code> 运算符访问对象的属性，需要的是一个属性名的字符串形式，所以这种方式会特别灵活，你可以再 <code>[]</code> 内放一个表达式也可以，只要表达式最后的结果是字符串，或者说可以自动类型转换为属性名的字符串即可，特别灵活。</p>
<p>而 <code>.</code> 运算符可能会比较习惯，但它就只能明明确确的通过属性名来访问了，如果你想通过某种拼接规则来生成属性名，就只能用 <code>[]</code> 不能使用 <code>.</code>。</p>
<p>如果访问对象中某个不存在的属性时，并不会抛异常，会输出 undefined，但如果继续访问不存在的属性的属性时，等价于访问 undefined 原始类型值的属性，这就会抛异常了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-feafbdc52fe83374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查询不存在的属性">  </p>
<p>ps：是不是发现，对对象的操作很像 Java 中对集合的操作？所以，有人解释说对象是属性的集合，这不是没根据的。</p>
<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><p>delete 是用来删除对象上的属性的，但它只是将该属性名从对象上移除，并不删除属性值，举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"dasu"</span>, <span class="attr">arr</span>:a&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> o.arr;</span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">0</span>]);  <span class="comment">//输出 =&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(o.arr); <span class="comment">//输出 =&gt; undefined</span></span><br></pre></td></tr></table></figure>

<p>新键一个对象 o，它有个属性 aar 存储着数组 a，当通过 delete 删除对象 o 上的 aar 属性后，再去访问这个 aar 属性，获取的是 undefined，表明这个属性确实被删除了，但本质上只是将其与这个对象 o 的关联删除掉，并不会删除属性值，所以输出数组 a 的值时还是可以访问到的。</p>
<p>不过，delete 有一些局限，它并不是什么属性都可以删除：</p>
<ul>
<li>只能删除自由属性，无法删除继承属性</li>
<li>不能删除那些可配置性为 false 的属性</li>
</ul>
<p>属性拥有一些特性，在下面会讲，其中有一个是可配置性，当将这个特性设置为 false 时，就无法通过 delete 来删除。</p>
<p>而之前说过的，通过 var 声明的全局变量，虽然它最后是作为全局对象的属性存在，但它的可配置性被设为 false，所以这些全局变量才无法通过 delete 被删除。</p>
<p>尝试删除那些无法删除的属性，并不会让程序出问题，delete 表达式有一个返回值，true 表示删除成功，false 表示删除失败，仅此而已，没有其他什么副作用。</p>
<h3 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h3><p>因为 JavaScript 中对象的属性太过动态性了，在运行期间，都无法确定某个属性到底存不存在，某个到底是不是指定对象的属性，所以这种场景，一般都需要进行属性的检测。</p>
<p>也就是检测对象内是否含有某个属性，有多种方式，下面分别来介绍：</p>
<h4 id="查询属性的方式"><a href="#查询属性的方式" class="headerlink" title="查询属性的方式"></a>查询属性的方式</h4><p>之前说过，访问对象内不存在的属性时，会返回 undefined，可以利用这点来判断对象是否含有要访问的属性。</p>
<p>这种方式有个缺点，如果属性值刚好被人为的手动设置成 undefined 时，就无法区别对象究竟有没有这个属性。</p>
<h4 id="in-运算符方式"><a href="#in-运算符方式" class="headerlink" title="in 运算符方式"></a>in 运算符方式</h4><p>in 运算符左侧是属性名的字符串格式，右侧是对象，当右侧对象含有左侧字符串同名的属性时，返回 true，用这种方式就可以很好的判断对象是否含有某个属性。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-94131cc6cfd87924.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="检测属性">  </p>
<p>注意，左侧必须是属性名的字符串格式，跟 <code>[]</code> 运算符访问对象属性一样的限制要求。</p>
<p>但这种方式有个局限，就是无法区分这个属性究竟是自有属性还是继承属性，也就是说，继承自原型的属性通过该操作符同样会返回 true。</p>
<h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h4><p>上面说过，通过构造函数创建的对象，默认都会存在内置的继承结构，不管什么对象，这个默认的继承结构顶端都是构造函数 Object 的 prototype 属性值，由于它的属性值是一个内置的匿名对象，所以，通常都直接这么表达，对象都会继承自 Object.prototype，直接用 Object.prototype 的描述来代表这个属性所指向的具体对象。</p>
<p>所以，以后在看到诸如某某对象继承自 Function.prototype 或 Array.prototype 之类的描述，我们要能够清楚，它表示的是，对象的原型是 xxxx.prototype 这属性所指向的具体对象。</p>
<p>Object.prototype 属性值指向的对象中，定义了一个 <code>hasOwnProperty()</code> 方法，所以基本所有对象都可以使用，它是用来判断，对象是否含有指定的自有属性的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-b27735c8b4bbf681.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="检测属性">  </p>
<p>首先利用上小节介绍的 in 方式来检测，o 对象的默认继承结构顶端是 Object.prototype，所以 o 对象继承了它的 hasOwnProperty 属性，第一行代码返回 true。</p>
<p>这个 hasOwnProperty 属性是个方法，调用它可以来检测对象是否含有指定的自有属性，参数也需要传入属性名的字符串格式，所以第二行代码返回 false，第三行返回 true。</p>
<p>hasOwnProperty  是继承自 Object.prototype 的属性，由于 <code>hasOwnProperty()</code> 方法只能检测自有属性，所以第四行返回 false。</p>
<h4 id="propertyIsEnumerable-NaN"><a href="#propertyIsEnumerable-NaN" class="headerlink" title="propertyIsEnumerable()"></a>propertyIsEnumerable()</h4><p>这个方法同样是 Object.prototype 中所定义的方法，所以，同样基本所有对象都能够使用。</p>
<p>它是 <code>hasOwnProperty()</code> 的增强版，也就是，用于检测对象的自有属性且该属性是可枚举性的，才会返回 true。</p>
<p>可枚举性是属性的另一个特性，用来标识该属性是否允许被遍历，下面会讲解。</p>
<p>因为有一些内置属性是不希望被枚举出来的，所以可通过该方法来判断。</p>
<h3 id="遍历属性"><a href="#遍历属性" class="headerlink" title="遍历属性"></a>遍历属性</h3><p>遍历属性也称枚举属性，也就是类似于对集合进行遍历操作，将其所含有的属性一个个读取出来。</p>
<p>遍历对象属性的方式也有多种，也一一来介绍：</p>
<h4 id="for-in-遍历"><a href="#for-in-遍历" class="headerlink" title="for-in 遍历"></a>for-in 遍历</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"dasu"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(o);  <span class="comment">//o1 继承自 o</span></span><br><span class="line">o1.age = <span class="number">24</span>;</span><br><span class="line">o1.sex = <span class="string">"man"</span>;</span><br><span class="line">o1.love = <span class="string">"girl"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(p <span class="keyword">in</span> o1) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(p);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看输出的结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-d794f2c34ddaa11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="遍历属性">  </p>
<p>o1 继承自 o，在 o1 内有三个自有属性，有一个继承属性，通过 for-in 方式遍历对象 o1 的属性时，不管是自有属性，还是继承属性，都会被输出。</p>
<p>同时，输出的是属性名，并不是属性值，所以 for-in 方式只是遍历对象的属性（包括继承属性），并返回属性名，注意是属性名。</p>
<p>通常 for-in 这种方式，可以结合 <code>hasOwnProperty()</code> 方法一起使用，来过滤掉继承的属性。</p>
<h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p>这又是一个类似静态方法的存在，注意这个方法跟上述 Object.create() 都是构造函数 Object 上的方法，而普通对象继承的是构造函数 Object.prototype 属性值所指向的那个原型对象，这是两个相互独立的对象，也就是说，通过构造函数创建出来的子对象并不是继承构造函数对象本身。</p>
<p>所以在子对象中，无法使用 Object.keys() 这类构造函数对象本身的属性，这点需要注意一下，在后续专门讲继承时会再拿出来讲讲。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-8a1df1551b7080d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Object.keys()">  </p>
<p> 参数传入需要遍历属性的对象，通过该方法，可以获得一个数组对象，数组内就存储着参数传入的对象的自有属性且属性是可枚举性的，相当于 for-in 方式结合 <code>hasOwnProperty()</code> 的效果。</p>
<h4 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h4><p>该方法也是遍历对象的自有属性，只是它是将参数传入的对象所拥有的所有属性都输出，包括那些被设置为不可枚举的属性，看个例子：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-70bac64732196a20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Object.getOwnPropertyNames">  </p>
<p>Object.prototype 指向了一个内置的对象，内置对象中定义了很多属性，继承这个原型的子对象们都可以使用这些属性，但这些属性都被设置为不可枚举性，所以通过 Object.keys() 遍历它时，得到的是一个空数组，子对象通过 for-in 方式遍历时也读取不到这些属性。</p>
<p>这种设计是好的，但考虑到如果有某些场景是需要读取对象自身的所有属性，包括那些不可枚举的，此时，就可通过 Object.getOwnPropertyNames() 来达到目的了。</p>
<h3 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h3><p>上面介绍中，或多或少有提到属性的特性，属性特性是指，属性的一些特有行为。</p>
<p>属性的特性一共有三个：可写性、可配置性、可枚举性</p>
<ul>
<li>可写性：表示这个属性是否允许被更改，当设置成 false 时，这就是一个只读属性</li>
<li>可配置性：表示这个属性是否允许被动态的添加或删除，当设置成 false 时，就不允许通过 delete 来删除</li>
<li>可枚举性：表示这个属性是否允许在遍历属性过程中被读取，当设置成 false 时，通过 for-in 或 Object.keys 都无法遍历到这个属性</li>
</ul>
<p>那么，如果知道对象的某个属性的这三种特性都是什么配置呢？</p>
<p>针对这种情况，内置了一个叫做属性描述符的对象，这个对象本身含有四个属性来描述属性：value、writable、enumerable、configurable。</p>
<ul>
<li>value：描述属性值，即 key-value 中的 value</li>
<li>writable：描述属性的可写性</li>
<li>enumerable：描述属性的可枚举性</li>
<li>configurable：描述属性的可配置性</li>
</ul>
<p>用来描述属性的数据结构有了，接下去就是如何操作了，先看一下，如果获取对象某个属性的描述信息：</p>
<h4 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h4><p>还是通过Object 的一个方法，接收两个参数，第一个参数是对象，第二个参数是对象内的某个自有属性，将会返回一个属性描述符对象：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-52c1683d86e34258.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Object.getOwnPropertyDescriptor">  </p>
<p>内置对象的很多属性都会针对属性的使用场景进行了不同的配置了，比如 Object.prototype 中所有属性的 enumerable 可枚举性都配置成 false。</p>
<p>但对于在代码中，通过对象直接量创建的对象，或者自定义构造函数创建的对象等，对这些非内置对象添加的属性，默认这三个特性都为 true，即对象添加的属性默认都是可写、可枚举、可配置的。</p>
<h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h4><p>这个方法也是用来获取对象属性的描述信息的，只是它只需一个参数即可，就是对象，然后会输出所有自有属性的描述信息：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6a71633ded56e3d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Object.getOwnPropertyDescriptors">  </p>
<p>这两个方法都是只能获取对象的自有属性的描述信息，如果想要获取继承属性的描述信息，需要先获取原型对象，再调用这两个方法处理原型。获取原型对象后续讲原型时会介绍，这里知道思路就可以了。</p>
<h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h4><p>有获取对象属性的描述信息的方法，自然有设置对象属性的描述信息方法，所以与上面两个方法相对应的就是 Object.defineProperty() 方法和 Object.definproperties()。</p>
<p>Object.defineProperty() 接收三个参数，第一参数是对象，第二个参数是需要修改属性描述信息的属性，第三个参数是含有属性描述符结构的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"dasu"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(o);  <span class="comment">//o1 继承自 o</span></span><br><span class="line">o1.age = <span class="number">24</span>;</span><br><span class="line">o1.sex = <span class="string">"man"</span>;</span><br><span class="line">o1.love = <span class="string">"girl"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o1, <span class="string">"age"</span>, &#123;<span class="attr">writable</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o1, <span class="string">"love"</span>, &#123;<span class="attr">enumerable</span>:<span class="literal">false</span>, <span class="attr">configurable</span>:<span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>第三个参数，你可以将四个属性值都指定，没指定的仍旧会使用默认的配置，再用 Object.getOwnPropertyDescriptors() 看下修改后的配置：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-3ab9658894cf819a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Object.defineProperty">  </p>
<h4 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h4><p>这方法作用跟上面一样，只是它是批量处理的方法，接收两个参数，第一个是对象，第二个是需要修改的属性集合，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"dasu"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(o);  <span class="comment">//o1 继承自 o</span></span><br><span class="line">o1.age = <span class="number">24</span>;</span><br><span class="line">o1.sex = <span class="string">"man"</span>;</span><br><span class="line">o1.love = <span class="string">"girl"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(o1, &#123;</span><br><span class="line">    age: &#123;<span class="attr">writable</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">    love:  &#123;<span class="attr">enumerable</span>:<span class="literal">false</span>, <span class="attr">configurable</span>:<span class="literal">false</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>有一些规则需要注意一下：</p>
<ul>
<li>如果属性是不可配置的，那么不能修改它的可配置性和可枚举性，对于可写性，只能将 true 改为 false，不能将 false 改为 true</li>
<li>如果属性是不可配置且不可写的，那么不能修改这个属性的值</li>
<li>如果属性是可配置但不可写的，那么可以先将属性修改成可写，这时就可以修改属性值</li>
</ul>
<p>###属性的setter和getter</p>
<p>正常来说，对象的属性由属性的三种特性来控制属性的操纵限制，但有一种情况是例外的，那就是通过 setter 和 getter 添加的属性，这类属性通常叫做存取器属性，为了区分，将正常使用的那些属性叫做数据属性。</p>
<p>之所以叫做存取器属性，是因为，通过这种方式添加的属性，它的读写是交由 setter 和 getter 控制，并不是由属性描述符的三种特性控制。</p>
<p>先来看下，如何定义一个存取器属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="keyword">set</span> name(value) &#123;&#125;,</span><br><span class="line">    <span class="keyword">get</span> name() &#123;<span class="keyword">return</span> <span class="string">"dasu"</span>&#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">get</span> age() &#123;<span class="keyword">return</span> <span class="number">24</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然看起来有点像 Java 中的 set 方法和 get 方法，但完全是两种不一样的东西，首先，这里的 set 和 get 虽然类似方法，但外部是不能通过方法来调用，第二，外部访问这些存取器属性，仍旧是使用 <code>.</code> 或 <code>[]</code> ，如 o.age 或 o[“name”]。</p>
<p>相比于数据属性，存取器属性的区别就在于，读和写是通过 set 和 get 控制，在定义存取器属性时，如果没有定义 get，那么这个属性就是无法读取的，如果没有定义 set，那么这个属性就是不可写的。其余的，可枚举性和可配置性都跟数据属性一样。</p>
<p>也一样是通过 Object.defineProperty() 和 Object.getOwnPropertyDescriptor() 来设置或查看存取器属性的描述信息，唯一需要注意的是，对于数据属性，描述符对象有四个属性：value，writable，enumerable，configurable；但对于存取器属性来说，没有 value 和 writable 属性，与之替换的是 get 和 set 两个属性，所以看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="keyword">set</span> name(value) &#123;&#125;,</span><br><span class="line">    <span class="keyword">get</span> name() &#123;<span class="keyword">return</span> <span class="string">"dasu"</span>&#125;,  <span class="comment">//存取器属性，可读，可写，但读写逻辑得自己实现</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">get</span> age() &#123;<span class="keyword">return</span> <span class="number">24</span>&#125;,  <span class="comment">//存取器属性，只读，读的逻辑得自己写</span></span><br><span class="line">    </span><br><span class="line">    sex: <span class="string">"man"</span>  <span class="comment">//数据属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设定义了这么个对象，有两个存取器属性，一个数据属性，通过 Object.getOwnPropertyDescriptors() 看一下这些属性的描述：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f4f405f946c58724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="存取器属性">  </p>
<p>所以存取器属性和数据属性就在于读和写这两方面的不同，看下修改描述的方式：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6e8a7667bf08a93d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="存取器属性.png"></p>
<p>存取器属性是可以换成数据属性，同样，数据属性也是可以换成存取器属性的，通过 Object.defineProperty() 在修改属性描述信息时，使用的如果是 set 和 get，那就将数据属性换成存取器属性了，使用的如果是 value 和 writable，原本如果是存取器属性，就将存取器属性转换成数据属性了。</p>
<p>另外，它也有一些规则需要注意一下：</p>
<ul>
<li>如果存取器属性是不可配置的，则不能修改 set 和 get 方法，也不能将它转换为数据属性</li>
<li>如果数据属性是不可配置的，则不能将它转换为存取器属性</li>
</ul>
<h3 id="对象的特性"><a href="#对象的特性" class="headerlink" title="对象的特性"></a>对象的特性</h3><p>对象的属性有它的几种特性，而对象本身也有一些特性，主要是三个：原型属性、类属性、可扩展性</p>
<p>原型属性：表示对象继承自哪个对象，被继承的对象称为子对象们的原型</p>
<p>类属性：表示对象的类型信息，是一个字符串，比如数字的类属性为 Number</p>
<p>可扩展性：表示是否允许对象可动态的添加属性</p>
<p>原型留着后续讲原型时再来细讲，大概清楚对象是有继承结构，被他继承的对象称作它的原型，所以通常说 JavaScript 是基于原型的继承这些概念即可。</p>
<h4 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h4><p>类属性，本质上就是通过调用 Object.toString() 方法来输出对象的一些信息，这些信息中，包括了对象所属类型的信息，对这串文本信息进行截取处理，就可以只获取对象所属类型的信息，所以称这些信息为对象的类属性。</p>
<p>类属性所呈现的信息很类似于 typeOf 运算符所获取的信息，只是类属性会比 typeOf 更有用一些，它能够区分所有的内置对象，以及区分 null，这些是 typeOf 所做不到的，如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5b25a754fad5b582.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类属性">  </p>
<h4 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h4><p>类似于属性有可配置性、可写性、可枚举性来控制属性的操纵限制，对象也具有可扩展性来限制对象的一些行为。</p>
<p>当将对象的可扩展性设置为 false 时，就无法再动态的为对象添加属性。默认创建的新对象，都是具有可扩展性的。</p>
<p>不像属性的特性那样，还专门定义了一个属性描述符对象来控制属性的特性，对于对象的可扩展性，操作很简单：</p>
<h4 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible()"></a>Object.isExtensible()</h4><p>使用 Object.isExtensible() 来获取对象的可扩展性描述，返回 true，表示对象是可扩展的，即可动态添加属性。</p>
<h4 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions()"></a>Object.preventExtensions()</h4><p>同样，可使用 Object.preventExtensions() 来设置对象的不可扩展，参数传入对象即可。这样，这个对象就不可动态添加属性了。</p>
<p>但有几点需要注意：</p>
<ul>
<li>一旦将对象设置为不可扩展，就无法再将其转换回可扩展了</li>
<li>可扩展性只限制于对象本身，对对象的原型并不影响，在原型上添加的属性仍可动态同步到子对象上</li>
</ul>
<p>针对于对象的可扩展性，对象属性的可写性、可配置性、可枚举性这些操作，Object 内封装了一些便捷的方法，如：</p>
<ul>
<li>Object.seal()：将对象设置为不可扩展，同时，将对象所有自有属性都设置为不可配置，通常称封闭对象。可用 Object.isSealed() 来检测对象是否被封闭。</li>
<li>Object.freeze()：将对象设置为不可扩展，同时，将对象所有自有属性不可配置且只读，通常称冻结对象。可用 Object.isFrozen() 来检测对象是否被冻结。  </li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>前端09-JavaScript语法之运算符（入门）</title>
    <url>/2018/10/31/%E5%89%8D%E7%AB%AF/%E5%85%A5%E9%97%A8/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A89-JavaScript%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-运算符"><a href="#正文-运算符" class="headerlink" title="正文-运算符"></a>正文-运算符</h1><p>程序中的代码其实就是利用各种运算符来辅助完成各种指令功能，在 JavaScript 中，有一些不同于 Java 中的运算符处理，这次就来讲讲这些运算符。 </p>
<p>由于我已经有了 Java 的基础了，本节不会讲基础的运算符介绍，比如算术表达式中的加减乘除取余等、关系表达式中的大于小于等、逻辑表示式中的自增、自减、移位等等，这些基础运算符的含义、用法、优先级这些跟 Java 基本没有区别，所以就不介绍了。</p>
<p>下面着重讲一些在 JavaScript 比较不同的行为的一些运算符：</p>
<h3 id="“-”-运算符"><a href="#“-”-运算符" class="headerlink" title="“+” 运算符"></a>“+” 运算符</h3><p>任何数据类型的变量都可以通过 “+” 运算符来进行计算，所以它有一套处理规则，通常要么就是按数字的加法运算处理、要么就是按照字符串的拼接处理，处理规则如下：</p>
<ol>
<li>如果操作数中存在对象类型，先将其按照上节介绍的转换规则，转成原始值；</li>
<li>如果操作数已经全部是原始值，此时如果有字符串类型的原始值，那么将两个原始值都转为字符串后，按字符串拼接操作处理；</li>
<li>如果操作数已经全部是原始值且没有字符串类型的，那么将操作数都转为数字类型后，按数字的加法处理;</li>
<li>NaN 加上任意类型的值后都是 NaN.</li>
</ol>
<p>以上的处理规则是针对于通过 “+” 运算符处理两个操作数的场景，如果一个表达式中存在多个 “+” 运算符，那么分别以优先级计算过程中，每一次计算 “+” 运算符的两个操作数使用上述规则进行处理。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>    <span class="comment">// =&gt; 3, 因为操作数都是数字类型的原始值</span></span><br><span class="line"><span class="number">1</span> + <span class="string">"2"</span>  <span class="comment">// =&gt; "12"，因为操作数中存在字符串类型的原始值，所以是按字符串拼接来处理</span></span><br><span class="line"><span class="number">1</span> + &#123;&#125;   <span class="comment">// =&gt; "1[object Object]"，因为有操作是对象类型，先将其转为原始值，&#123;&#125; 转为原始值为字符串 "[object Object]"，所以将操作数都转为字符串后，按字符串拼接处理</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">true</span> <span class="comment">// =&gt; 2，因为两个都是原始值，且没有字符串类型，所以将 true 转为数字类型后是 1，按加法处理</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">undefined</span> <span class="comment">// =&gt; NaN，因为 undefined 转为数字类型后为 NaN，NaN 与任何数运算结果都为 NaN </span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="string">" dasu"</span>  <span class="comment">// =&gt; "3 dasu"， 因为先计算 1+2=3，然后再计算 3 + " dasu"，所以是 "3 dasu"</span></span><br><span class="line"><span class="number">1</span> + (<span class="number">2</span> + <span class="string">" dasu"</span>) <span class="comment">// =&gt; "12 dasu"，因为先计算 2 + " dasu" = "2 dasu"，再计算 1 + "2 dasu" = "12 dasu"</span></span><br></pre></td></tr></table></figure>

<p>因为 “+” 运算符在编程中很常见，也很常用，而 JavaScript 又是弱类型语言，变量无需声明类型，那么程序中，”+” 运算符的两个操作数究竟是哪两种类型在进行计算，结果又会是什么，这点在心里至少是要明确的。</p>
<h3 id="“-”-和-“-”-相等运算符"><a href="#“-”-和-“-”-相等运算符" class="headerlink" title="“==” 和 “===” 相等运算符"></a>“==” 和 “===” 相等运算符</h3><p>“==” 和 “===” 都是用于判断两个操作数是否相等的运算符，但它们是有区别的。</p>
<p>“==” 比较相等的两个操作数会自动进行一些隐式的类型转换后，再进行比较，俗称不严格相等。</p>
<p>“===” 比较相等的两个操作数，不会进行任何类型转换，相等的条件就是类型一样，数值也一样，所以俗称严格相等。</p>
<p>而 “!=” 和 “!==” 自然就是这两个相等运算符的求反运算。下面分别来看看：</p>
<h4 id="“-”"><a href="#“-”" class="headerlink" title="“===”"></a>“===”</h4><p>当通过这个运算符来比较两个操作数是否严格相等时，具体规则如下：</p>
<ul>
<li>如果两个操作数的类型不相同，则它们不相等</li>
<li>如果其中一个操作数是 NaN 时，则它们不相等（因为 NaN 跟任何数包括它本身都不相等）</li>
<li>如果两个操作数都是对象类型，那么只有当两个操作数都指向同一个对象，即它们的引用一样时，它们才相等</li>
<li>如果两个操作数都是字符串类型时，当字符串一致时，在某些特殊场景下，比如具有不同编码的 16 位值时，它们也不相等，但大部分情况下，字符串一致是会相等，但要至少清楚不是百分百</li>
<li>如果两个操作数都是布尔类型、数字类型、null、undefined，且值都一致时，那它们相等</li>
</ul>
<p>总之，这里的规则跟 Java 里的相等比较类似，Java 里没有严格不严格之分，它处理的规则就是按照 JavaScript 这里的严格相等来处理，所以大部分比较逻辑可参考 Java。</p>
<p>需要注意的就是，NaN 与任何数包括它本身也不相等、同一个字符串内容可能会有不同的编码值，所以并不是百分百相等。</p>
<h4 id="“-”-1"><a href="#“-”-1" class="headerlink" title="“==”"></a>“==”</h4><p>这个通常称为不严格相等，当比较是否相等的两个操作数的数据类型不一样时，会尝试先进行转换，然后再进行比较，相比于上面的 “===” 严格相等运算符来说，它其实就是放宽了比较的条件，具体规则如下：</p>
<ul>
<li>如果两个操作数的类型一样，那么规则跟 “===” 一样</li>
<li>如果一个类型是 null，另一个类型是 undefined，此时，它们也是相等的</li>
<li>如果一个类型是数字，另一个类型是字符串，那么先将字符串转为数字，再进行比较</li>
<li>如果一个类型是布尔，先将布尔转成 1（true）或 0（false），然后再根据当前两个类型是否需要再进一步处理再比较</li>
<li>如果一个类型是对象，那么先将对象转换成原始值，然后再根据当前两个类型是否需要再进一步处理再比较</li>
</ul>
<p>总之，”==” 的比较相对于 “===” 会将条件放宽，下面可以看些例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>    <span class="comment">// =&gt; false，两个类型不一样</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>     <span class="comment">// =&gt; true，不严格情况下两者可认为相等   </span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> == <span class="string">"1"</span>              <span class="comment">// =&gt; true，"1" 转为数字 1 后，再比较</span></span><br><span class="line"><span class="number">1</span> == [<span class="number">1</span>]              <span class="comment">// =&gt; true，[1] 先转为字符串 "1"，此时等效于比较 1 == "1"，所以相等</span></span><br><span class="line"><span class="number">2</span> == <span class="literal">true</span>             <span class="comment">// =&gt; false，因为 true 先转为数字 1，此时等效于比较 2 == 1</span></span><br></pre></td></tr></table></figure>

<h3 id="“-amp-amp-”-逻辑与"><a href="#“-amp-amp-”-逻辑与" class="headerlink" title="“&amp;&amp;” 逻辑与"></a>“&amp;&amp;” 逻辑与</h3><p>逻辑与就是两个条件都要满足，这点跟 Java 里的逻辑与操作 &amp;&amp; 没有任何区别。</p>
<p>但 JavaScript 里的逻辑与 &amp;&amp; 操作会更强大，在 Java 里，逻辑与 &amp;&amp; 运算符的两个操作数都必须是关系表达式才行，而且整个逻辑与表达式最终的结果只返回 true 或 false。</p>
<p>但在 JavaScript 里，允许逻辑与 &amp;&amp; 运算符的两个操作数是任意的表达式，而且整个逻辑与 &amp;&amp; 表达式最终返回的值并不是 true 或 false，而是其中某个操作数的值。</p>
<p>什么意思，来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这是最基本的用法，跟 Java 没有任何区别，当且仅当 x 和 y 都为 0 时，返回 true，否则返回 false。</p>
<p>上面那句话，是从这个例子以及延用 Java 那边对逻辑与 &amp;&amp; 运算符的理解所进行的解释。</p>
<p>但实际上，在 JavaScript 里，它是这么处理逻辑与 &amp;&amp; 运算符的：</p>
<ul>
<li>如果左操作数的值是假值，那么不会触发右操作数的计算，且整个逻辑与 &amp;&amp; 表达式返回左操作数的值</li>
<li>如果左操作数的值是真值，那么整个逻辑与 &amp;&amp; 表达式返回右操作数的值</li>
<li>假值真值可以通俗的理解成，上节介绍各种数据类型间的转换规则中，各类型转换为布尔类型的值，转为布尔后为 true，表示这个值为真值。反之，为假值。</li>
</ul>
<p>所以，按照这种理论，我们再来看看上面那个例子，首先左操作数是个关系表达式：<code>x == 0</code>，如果 x 为 0，这个表达式等于 true，所以它为真值，那么整个逻辑与 &amp;&amp; 表达式返回右操作数的值。右操作数也是个关系表达式：<code>y == 0</code>，如果 y 也等于 0，右操作数的值就为 true，所以整个逻辑与 &amp;&amp; 表达式就返回 true。</p>
<p>虽然结果一样，但在 JavaScript 里对于逻辑与 &amp;&amp; 表达式的解释应该按照第二种，而不是按照第一种的 Java 里的解释。如果还不理解，那么再来看几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"dasu"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> &amp;&amp; getName()   <span class="comment">//输出 =&gt; null，因为左操作数 null 转成布尔是 false，所以它是假值，所以逻辑与 &amp;&amp; 直接返回左操作数的值 null</span></span><br><span class="line"></span><br><span class="line">getName &amp;&amp; getName()  <span class="comment">//输出 =&gt; "dasu"，因为左操作数是一个函数对象，如果该函数对象被声明定义了，那么转为布尔值就是 true，所以逻辑与 &amp;&amp; 表达式返回右操作数的值，右操作数是 getName()，调用了函数，返回了 "dasu"，所以这个就是这个逻辑与 &amp;&amp; 表达式的值。</span></span><br></pre></td></tr></table></figure>

<p>第一个逻辑与表达式：<code>null &amp;&amp; getName()</code> 会输出 null，是因为左操作数 null 转成布尔是 false，所以它是假值，所以逻辑与 &amp;&amp; 直接返回左操作数的值 null。</p>
<p>第二个逻辑与表达式：<code>getName &amp;&amp; getName()</code> 会输出 “dasu”，是因为左操作数是一个函数对象，如果该函数对象被声明定义了，那么转为布尔值就是 true，所以逻辑与 &amp;&amp; 表达式返回右操作数的值，右操作数是 getName()，调用了函数，返回了 “dasu”，所以这个就是这个逻辑与 &amp;&amp; 表达式的值。</p>
<p>所以 JavaScript 里的逻辑与 &amp;&amp; 表达式会比 Java 更强大，它有一种应用场景：</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryName</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//回调处理</span></span><br><span class="line">    callback &amp;&amp; callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 中，我们提供回调机制的处理通常是定义了一个接口，然后接口作为函数的参数，如果调用的时候，传入了这个接口的具体实现，那么在内部会去判断如果传入的接口参数不为空，就调用接口里的方法实现通知回调的效果。</p>
<p>在 JavaScript 里实现这种回调机制就特别简单，通过逻辑与 &amp;&amp; 表达式，一行代码就搞定了，如果有传入 callback 函数，那么 callback 就会是真值，逻辑与 &amp;&amp; 表达式就会去执行右操作数的 callback()。</p>
<p>当然，如果你想严谨点，你可以多加几个逻辑与 &amp;&amp; 表达式来验证传入的 callback 参数是否是函数类型。</p>
<h3 id="“-”-逻辑或"><a href="#“-”-逻辑或" class="headerlink" title="“||” 逻辑或"></a>“||” 逻辑或</h3><p>逻辑或 || 跟逻辑与 &amp;&amp; 就基本是一个东西了，理解了上面讲的逻辑与 &amp;&amp; 运算符的理论，那么自然也就能够理解逻辑或 || 运算符了。</p>
<p>它们的区别，仅在于对表达式的处理，逻辑或 || 表达式是这么处理的：</p>
<ul>
<li>如果左操作数的值是真值，那么不会触发右操作数的计算，且整个逻辑或 || 表达式返回左操作数的值</li>
<li>如果左操作数的值是假值，那么整个逻辑或 || 表达式返回右操作数的值</li>
<li>假值真值可以通俗的理解成，上节介绍各种数据类型间的转换规则中，各类型转换为布尔类型的值，转为布尔后为 true，表示这个值为真值。反之，为假值。</li>
</ul>
<p>这里就直接来说下它的一个应用场景了：</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryNameById</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//参数的默认值</span></span><br><span class="line">    id = id || <span class="number">10086</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理参数的默认值，如果调用函数时，没有传入指定的参数时。</p>
<p>当然，还有其他很多应用场景。总之，善用逻辑与 &amp;&amp; 和逻辑或 || 运算符，可以节省很多编程量，同时实现很多功能。</p>
<h2 id="“-”-逗号运算符"><a href="#“-”-逗号运算符" class="headerlink" title="“,” 逗号运算符"></a>“,” 逗号运算符</h2><p>在 Java 中，”,” 逗号只用于在声明同一类型变量时，可同时声明，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c;</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 里，”,” 逗号运算符同样具有这个功能，但它更强大，因为带有 “,” 逗号运算符的表达式会有一个返回值，返回值是逗号最后一项操作数的值。</p>
<p>逗号运算符跟逻辑与和逻辑或唯一的区别，就在于：逗号运算符会将每一项的操作数都进行计算，而且表示式一直返回最后一项的操作数的值，它不管每个操作数究竟是真值还是假值，也不管后续操作数是否可以不用计算了。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"dasu"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryNameById</span>(<span class="params">id, callback</span>) </span>&#123;</span><br><span class="line">    id = id || <span class="number">10086</span>;</span><br><span class="line">    callback &amp;&amp; callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCallback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I am dasu"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = (queryNameById(<span class="number">0</span>, myCallback), getName()) <span class="comment">//me会被赋值为 "dasu",且控制台输出 "I am dasu"</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5e1f6e7688a10452.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="逗号运算符">  </p>
<p>变量 me 会被赋值为 “dasu”，且控制台输出 “I am dasu”。  </p>
<h3 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h3><p>返回指定操作数的数据类型，例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-7e4ae9891a2780a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="typeOf">  </p>
<p>在 JavaScript 中数据类型大体上分两类：原始类型和引用类型。</p>
<p>原始类型对应的值是原始值，引用类型对应的值为对象。</p>
<p>对于原始值而言，使用 typeof 运算符可以获取原始值所属的原始类型，对于函数对象，也可以使用 typeof 运算符来获取它的数据类型，但对于其他自定义对象、数组对象、以及 null，它返回的都是 object，所以它的局限性也很大。</p>
<h3 id="delete-运算符"><a href="#delete-运算符" class="headerlink" title="delete 运算符"></a>delete 运算符</h3><p>delete 是用来删除对象上的属性的，因为 JavaScript 里的对象有个特性，允许在运行期间，动态的为对象添加某个属性，那么，自然也允许动态的删除属性，就是通过这个运算符来操作。</p>
<p>这个在对象一节还会拿出来讲，因为并不是所有的属性都可以成功被删除的，属性可以设置为不可配置，此时就无法通过 delete 来删除。</p>
<p>另外，之前也说过，在函数外声明的全局变量，本质上都是以属性的形式被存在在全局对象上的，但这些通过 var 或 function 声明的全局变量，无法通过 delete 来进行删除。</p>
<p>之前也说过，如果在声明变量时，不小心漏掉了 var 关键字，此时程序并不会出异常，因为漏掉 var 关键字对一个不存在的变量进行赋值操作，会被 js 解释器认为这行代码是要动态的为全局对象添加一个属性，这个动态添加的属性就可以通过 delete 来进行删除，因为动态添加的属性默认都是可配置的。</p>
<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>在 Java 中，可以通过 instanceof 运算符来判断某个对象是否是从指定类实例化出来的，也可以用于判断一群对象是否属于同一个类的实例。</p>
<p>在 JavaScript 中有些区别，但也有些类似。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">A.prototype = b;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> A) &#123; <span class="comment">//符合，因为 a 是从A实例化的，继承自A.prototype即b</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">B.prototype = b;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> B();</span><br><span class="line"><span class="keyword">if</span> (c <span class="keyword">instanceof</span> A) &#123;<span class="comment">//符合，虽然c是从B实例化的，但c也同样继承自b，而A.prototype指向b，所以满足</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;<span class="comment">//符合，虽然 c 是继承自 b，但 b 继承自 Object.prototype，所以c的原型链中有 Object.prototype</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中，instanceof 运算符的左侧是对象，右侧是构造函数。但他们的判断是，只要左侧对象的原型链中包括右侧构造函数的 prototype 指向的原型，那么条件就满足，即使左侧对象不是从右侧构造函数实例化的对象。 </p>
<p>例子代码看不懂么事，这个在后续介绍原型时，还会再拿出来说，先清楚有这么个运算符，运算符大概的作用是什么就可以了。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>前端08-JavaScript语法之数据类型和变量（入门）</title>
    <url>/2018/10/30/%E5%89%8D%E7%AB%AF/%E5%85%A5%E9%97%A8/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A88-JavaScript%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-数据类型、变量"><a href="#正文-数据类型、变量" class="headerlink" title="正文-数据类型、变量"></a>正文-数据类型、变量</h1><p>JavaScript 里有两种数据类型：原始类型和对象类型</p>
<h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p>原始类型里包括：</p>
<ul>
<li>数字（Number）</li>
<li>布尔（Boolean）</li>
<li>字符串（String）</li>
<li>null</li>
<li>undefined</li>
</ul>
<p>布尔类型和字符串类型跟 Java 没多大区别，主要就讲一下数字类型、null 和 undefined。</p>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>JavaScript 里不像 Java 一样会区分 int，float，long 等之类的数字类型，全部都归属于一个 Number 数字类型中。之所以不加区分，是因为，在 JavaScript 里，所有的数字，不管整数还是小数，都用浮点数来表示，采用的是 <a href="https://blog.csdn.net/abcdu1/article/details/75095781" target="_blank" rel="noopener">IEEE 754标准定义的 64 位浮点格式</a>表示数字。</p>
<p>那么，它所能表示的数值范围就是有限的，除了正常数值外，还有一些关键字表示特殊场景：</p>
<ul>
<li>Infinity（正无穷）</li>
<li>-Infinity（负无穷）</li>
<li>NaN（非数值）</li>
</ul>
<p>对于小数，支持的浮动小数表示法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14</span>      </span><br><span class="line"><span class="number">-.2345789</span> <span class="comment">// -0.23456789</span></span><br><span class="line"><span class="number">-3.12e+12</span>  <span class="comment">// -3.12*1012</span></span><br><span class="line"><span class="number">.1e-23</span>    <span class="comment">// 0.1*10-23=10-24=1e-24</span></span><br></pre></td></tr></table></figure>

<p>另外，因为浮点表示法只能精确的表示如：1/2, 1/8, 1/1024 这类分数，对于 1/10 这种小数只能取近视值表示，因此在 JavaScript 里有个经典的有趣现象：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-fe3908760efa474a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浮点精度缺失">    </p>
<p>0.1 + 0.2 在 JavaScript 里是不等于 0.3 的，因为用浮点表示法，无法精确表示 0.1 和 0.2，所以会舍弃一些精度，两个近似值相加，计算结果跟实际算术运算结果自然有些偏差。</p>
<p>上图里也显示了，在 JavaScript 里，0.1 + 0.2 的运算结果是 0.30000000000000004。</p>
<p>那么，是否所有非 1/2, 1/4, 1/8 这类 1/2^n 小数的相加结果最后都不会等于实际运算结果呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f548ba2fdeec0827.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浮点精度缺失">    </p>
<p>0.1, 0.2, 0.3 都是浮点数无法精确表示的数值，所以在 JavaScript 里都是以近似值存储在内存中，那么，为何 <code>0.1 + 0.2 ！= 0.3</code>，但 <code>0.1 + 0.3 == 0.4</code> ？ </p>
<p>这是因为，JavaScript 里在处理这类小数时，允许一定程度的误差，比如 0.10000000000000001 在允许的误差中，所以在 JavaScript 里就将这个值当做 0.1 来看待处理。</p>
<p>所以如果两个是以近似值存储的小数运算之后的结果，在误差允许范围内，那么计算结果会按实际算术运算结果来呈现。</p>
<p>总之，不要用 JavaScript 来计算一些小数计算且有精度要求，如果非要不可，那么建议先将小数都按比例扩展到整数运算后，再按比例缩小，如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-bde7ab59fe415b0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浮点精度缺失3">  </p>
<p>还有另外一点，由于 JavaScript 的变量是不区分类型的，那么当有需要区分某个变量是不是数字时，可用内置的全局函数来处理：</p>
<ul>
<li><code>isNaN()</code> – 如果参数是 NaN 或者非数字值（如字符串或对象），返回 true</li>
<li><code>isFinite()</code> – 如果参数不是 NaN，或 Infinity 或 -Infinity 时返回 true，通俗理解，参数是正常的数字 </li>
</ul>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>跟 Java 一样，JavaScript 里也有 null 关键字，但它的含义和用法却跟 Java 里的 null 不太一样。</p>
<p>在 Java 里，声明一个对象类型的变量后，如果没有对该变量进行赋值操作，默认值为 null，所以在程序中经常需要对变量进行判空处理，这是 Java 里 null 的场景。</p>
<p>但在 JavaScript 中，声明一个变量却没有进行赋值操作的话，默认值不是 null，而是 undefined。</p>
<p>那么，什么场景下，变量的值会是 null 呢？我可以告诉你，没有，没有任何场景下某个变量或某个属性的值默认会是 null，除非你在程序中手动将某个变量赋值为 null，那么此时这个变量的值才会是 null。</p>
<p>所以，才有些书本中会说，null 是表示程序级、正常的或在意料之中的值的空缺。意思就是说，null 是 JavaScript 设计出来的一个表示空值含义的数据类型，用来给你在程序中当有需要给某个变量手动设置为空值的场景时使用。</p>
<p>举个通俗的例子，对于数字类型变量，你可以用 0 表示它的初始值；对于字符串类型变量，你可以用 “” 表示它的初始值；那么对于对象类型，当你也需要给它一个表示空值无具体含义的初始值时，你就可以给它赋值为 null。</p>
<p>这也是为什么用 typeof 运算符获取 null 的数据类型时，会发现输出的是 Object。因为 null 实际上是个实际存在的数据值，只是它的含义是空值的意思，用于赋值给对象类型的变量。</p>
<p>那么，也就是说，不能沿用 Java 里使用 null 的思维应用到 JavaScript 中了，null 可以作为初始值赋值给变量，但变量如果没有进行初始化，默认值不再是 null 了，这点是 JavaScript 有区别于 Java 的地方，需要注意一下。</p>
<p>不然再继续挪用 Java 的使用 null 思维，可能在编程中，会遇到一些意料外，没想通的问题。</p>
<h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>如果声明了一个变量，缺没有对这个变量进行赋值操作，那么这个值默认就是 undefined。</p>
<p>那么在 Java 中的判空操作来判断变量是否有进行初始化的行为在这里就是对应判断变量的值是否为 undefined 的，但实际上，在 JavaScript 里，由于 if 判断语句接收的为真值，而不像 Java 只支持布尔类型，所以基本没有类似 Java 的判空的编程场景。</p>
<p>undefined 还有另外一种场景：</p>
<p>当访问对象中不存在的属性时，此时会输出 undefined，表示这个属性并未在对象中定义。</p>
<p>针对这种场景，undefined 可用于判断对象中是否含有某些指定的属性。</p>
<p>总结一下 null 和 undefined：</p>
<ul>
<li>null 是用于在程序中，如果有场景需要，如某个变量在某种条件下需要有一个表示为空值含义的取值，此时，可手动为该变量赋值为 null；</li>
<li>当声明某个变量，却没有对其进行赋值初始化操作时，这个变量默认为 undefined</li>
<li>当访问对象某个不存在的属性时，会输出 undefined，可用于判断对象中是否含有指定属性</li>
</ul>
<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>除了原始类型外，其余都是对象类型，但有一些内置的对象类型，所以大概可以这么表示</p>
<ul>
<li>对象类型（Object）<ul>
<li>函数（Function）</li>
<li>数组（Array）</li>
<li>日期（Date）</li>
<li>正则（RegExp）</li>
<li>…</li>
</ul>
</li>
</ul>
<p>也就是，在 JavaScript 里，函数和数组，本质上也是对象。</p>
<h3 id="变量相关"><a href="#变量相关" class="headerlink" title="变量相关"></a>变量相关</h3><p> 由于我本身有 Java 的基础了，所以 JavaScript 一些很基础的语法我可能会漏掉了，但影响不大。</p>
<h4 id="弱类型"><a href="#弱类型" class="headerlink" title="弱类型"></a>弱类型</h4><p>虽然 JavaScript 中有原始类型和对象类型，而且每个分类下又有很多细分的数据类型，但它实际上是一门弱类型语言，也叫动态语言。也就是说，使用变量时，无需指明变量是何种类型，运行期间会自动确定。</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>既然使用变量时不必指明变量的数据类型，那么自然没有类似于 Java 中那么多种的变量声明方式，在 JavaScript 中声明变量很简单，都是通过 var 来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = dasu;</span><br></pre></td></tr></table></figure>

<p>ES5 中，声明变量的方式就是通过 <code>var</code> 关键字，而且同一变量重复声明不会出问题，会以后面声明的为主。</p>
<h4 id="变量的提前声明"><a href="#变量的提前声明" class="headerlink" title="变量的提前声明"></a>变量的提前声明</h4><p>先看段代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(a);  <span class="comment">//输出 undefined</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> a = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(a);  <span class="comment">//输出 1</span></span></span><br><span class="line">    b();</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(a); <span class="comment">//输出 undefined</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> a = <span class="number">2</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(a); <span class="comment">//输出 2</span></span></span><br><span class="line">    &#125;   </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 中有变量的提前声明特性，也就是在代码开始执行前，所有通过 var 或 function 声明的变量和函数都已经提前声明了（下面统称变量），所以在声明语句之前访问声明的这个变量并不会抛异常。</p>
<p>但提前的只有变量的声明，变量的赋值初始化操作并没有提前，所以第一行代码输出变量 a 的值时，因为变量已经被提前声明了，但没赋值，按照上面介绍的，此时变量 a 值为 undefined，当赋值语句执行完，输出自然就是赋值的 1 了。</p>
<p>同样，由于 b 函数已经被提前声明了，所以可以在声明它的位置之前就调用函数了，而函数调用后，开始执行函数内的代码时，也同样会有变量提前声明的特性。</p>
<p>因此，在执行函数内第一行代码时，输出的变量 a 是函数内声明的局部变量，而不是函数外部的变量，这点行为跟 Java 不一样，需要注意一下。</p>
<p>有些脚本语言并没有变量声明提前的特性，使用的变量或函数只能在声明了它的位置之后才能使用，这是 JavaScript 区别它们的一点。</p>
<h4 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h4><p>上面说过，声明变量时是通过 <code>var</code> 关键字声明，那如果漏掉 var 呢，看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="comment">//console.log(a);  //抛异常，因为没有找到a变量</span></span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">//输出 1</span></span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">//输出 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//输出 2</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一行代码如果不注释掉，那么它执行的结果会是抛出一个异常，因为没有找到 a 变量。</p>
<p>接着执行了 <code>a = 1</code>，a 是一个不存在的变量，直接对不存在的变量进行赋值语句，其实是会自动对全局对象 window 动态添加了一个 a 属性并赋值，所以后续调用了 b 函数，函数里操作的 a 其实都是来自全局对象 window 的属性 a，所以在函数内对 a 进行的操作结果，当函数执行结束后，最后再次输出 a 才会是 2。</p>
<p>这其实是因为对象的特性导致的，在对象一节会来讲讲，但这里要清楚一点，切记声明使用变量时，不要忘记在前面要使用 <code>var</code>。</p>
<p>另外，顺便提一下，第一行被注释掉的代码，如果换成输出 this.a，那么此时程序是不会抛异常的，而是输出 undefined，这是因为前面也有稍微提过，访问对象不存在的属性时，会输出 undefined，都是在讲对象时会来说说。</p>
<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>ES5 中，变量有两种作用域，全局作用域和函数内作用域。</p>
<p>在函数外声明的变量都具有全局作用域，即使跨 js 文件都能够访问；而在函数内声明的变量，不管声明变量的语句在哪个位置，整个函数内都可以访问该变量，因为有变量的提前声明特性，所以是函数内作用域。</p>
<p>由于在 JavaScript 中，同一变量的重复声明不会出问题，所以对于全局变量而言，在多人协作，多模块编程中，很容易造成全局变量冲突，即我在我写的 js 文件中声明的 a 全局变量，其他人在其他 js 文件中，又声明了 a 全局变量，对于浏览器而言，它就只是简单的以后声明的为主。</p>
<p>但对于程序而已，就会发生不可控的问题，而且极难排查，所以要慎用全局变量。当然针对这种情况也有很多解决方案，后续讲到函数一节中会来讲讲。</p>
<h3 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h3><p>JavaScript 里的对象具有很多特性，比如可以动态为其添加属性等等。但原始类型都不具有对象的这些特性，那么当需要对原始类型也使用类似对象的特性行为时，这时候包装对象就出现了。</p>
<p>包装对象跟 Java 中的包装类基本是类似的概念，原始数据类似对应的对象类型的值称为包装对象：</p>
<ul>
<li>数字类型 -&gt; Number 包装对象</li>
<li>布尔类型 -&gt; Boolean 包装对象</li>
<li>字符串类型 -&gt; String 包装对象</li>
<li>null 和 undefined 没有包装对象，所以不允许对 null 和 undefined 的变量进行属性操作</li>
</ul>
<p>接下来就讲讲原始类型和包装对象之间的转换，存在两种场景，程序运行期间自动转换，或者手动显示的进行转换。</p>
<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>因为属性是对象才有的特性，所以当对某个原始类型的变量进行属性操作时，此时会临时创建一个包装对象，属性操作结束后销毁包装对象。</p>
<p>看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"test"</span>;   <span class="comment">//创建一个字符串，s是原始类型的变量</span></span><br><span class="line">s.len = <span class="number">4</span>;   <span class="comment">//对s动态添加一个属性len并赋值，执行这行代码时，会临时创建一个包装对象，所以这里的s已经不是上面的原生类型变量，进行了一次自动转换</span></span><br><span class="line"><span class="built_in">console</span>.log(s.len);  <span class="comment">//输出 undefined，上一行虽然进行了一次包装对象的自动转换，但是是临时的，那一行代码执行结束，包装对象就销毁了。所以这一行又对s原始类型变量进行属性操作，又再一次创建一个临时的包装对象</span></span><br></pre></td></tr></table></figure>

<p>需要注意一点，当对原始类型的操作进行属性操作时，会创建一个临时的包装对象，注意是临时的，属性操作完毕，包装对象就销毁了。下一次再继续对原始类型进行属性操作时，创建的又是新的一个临时包装对象。</p>
<h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><p>除了隐式的自动转换外，也可以显示的手动转换。</p>
<p>如果是原始类型 -&gt; 包装类型的转换，可使用相对应的包装对象的构造函数方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"dasu"</span>);</span><br></pre></td></tr></table></figure>

<p>此时，a, b, s 都是对象类型的变量了，可以对它们进行一些属性操作。</p>
<p>如果是包装类型 -&gt; 原始类型的转换，使用不加 new 的调用全局函数的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aa = <span class="built_in">Number</span>(a);</span><br><span class="line"><span class="keyword">var</span> bb = <span class="built_in">Boolean</span>(b);</span><br><span class="line"><span class="keyword">var</span> ss = <span class="built_in">String</span>(s);</span><br></pre></td></tr></table></figure>

<p>在后续讲函数时会讲到，一个函数被调用的方式有多种：其中，有跟 new 关键字一起使用，此时叫这个函数为构造函数；如果只是简单的调用，此时叫函数调用；如果是作为对象的属性被调用，此时称方法调用；不同的调用方式会有一些区别。</p>
<p>所以，这里当包装对象使用构造函数方式使用时，可以显示的将原始类型数据转换为包装对象；但如果不作为构造函数，只是简单的函数调用，其实就是将传入的参数转换为原始类型，参数不单可以是包装对象类型，也可以是其他类型。</p>
<h3 id="数据类型间相互转换"><a href="#数据类型间相互转换" class="headerlink" title="数据类型间相互转换"></a>数据类型间相互转换</h3><p>上面讲了原始类型与包装对象间的相互转换，其实本质上也就是不同数据类型间的相互转换。</p>
<p>按数据类型细分来讲的话，一共包括：数字、布尔、字符串、null、undefined、对象（函数、数组等），由于 JavaScript 是弱类型语言，运行期间自动确定变量类型，所以，其实这些不同数据类型之间都存在相互转换的规则。</p>
<p>先看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="string">" objects"</span>;    <span class="comment">// =&gt; "10 objects",这里的 10 自动转换成 "10"</span></span><br><span class="line"><span class="string">"7"</span> * <span class="string">"4"</span>;          <span class="comment">// =&gt; 28, 这里的两个字符串都自动转换为数字</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span> - <span class="string">"x"</span>;    <span class="comment">// =&gt; NaN，字符串 "x" 无法转换为数字</span></span><br><span class="line">n + <span class="string">" objects"</span>;     <span class="comment">// =&gt; "NaN objects", NaN 转换为字符串 "NaN"</span></span><br></pre></td></tr></table></figure>

<p>数字可以转换成字符串，字符串也可以转换为数字，原始类型也可以转换为对象类型等等，反正不同类似之间都可以相互转换。</p>
<h4 id="基本转换规则"><a href="#基本转换规则" class="headerlink" title="基本转换规则"></a>基本转换规则</h4><p>具体的规则，可以参见下表：</p>
<table>
<thead>
<tr>
<th>待转换值</th>
<th>转换为字符串</th>
<th>转换为数字</th>
<th>转换为布尔值</th>
<th>转换为对象</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>“undefined”</td>
<td>NaN</td>
<td>false</td>
<td>throws TypeError</td>
</tr>
<tr>
<td>null</td>
<td>“null”</td>
<td>0</td>
<td>false</td>
<td>throws TypeError</td>
</tr>
<tr>
<td>true（布尔-&gt;其他）</td>
<td>“true”</td>
<td>1</td>
<td>–</td>
<td>new Boolean(true)</td>
</tr>
<tr>
<td>false（布尔-&gt;其他）</td>
<td>“false”</td>
<td>0</td>
<td>–</td>
<td>new Boolean(false)</td>
</tr>
<tr>
<td>“”（空字符串-&gt;其他）</td>
<td>–</td>
<td>0</td>
<td>false</td>
<td>new String(“”)</td>
</tr>
<tr>
<td>“1.2”（字符串内容为数字-&gt;其他）</td>
<td>–</td>
<td>1.2</td>
<td>true</td>
<td>new String(“1.2”)</td>
</tr>
<tr>
<td>“dasu”（字符串内容非数字-&gt;其他）</td>
<td>–</td>
<td>NaN</td>
<td>true</td>
<td>new String(“dasu”)</td>
</tr>
<tr>
<td>0（数字-&gt;其他）</td>
<td>“0”</td>
<td>–</td>
<td>false</td>
<td>new Number(0)</td>
</tr>
<tr>
<td>-0（数字-&gt;其他）</td>
<td>“0”</td>
<td>–</td>
<td>false</td>
<td>new Number(-0)</td>
</tr>
<tr>
<td>1（数字-&gt;其他）</td>
<td>“1”</td>
<td>–</td>
<td>true</td>
<td>new Number(1)</td>
</tr>
<tr>
<td>NaN</td>
<td>“NaN”</td>
<td>–</td>
<td>false</td>
<td>new Number(NaN)</td>
</tr>
<tr>
<td>Infinity</td>
<td>“Infinity”</td>
<td>–</td>
<td>true</td>
<td>new Number(Infinity)</td>
</tr>
<tr>
<td>-Infinity</td>
<td>“-Infinity”</td>
<td>–</td>
<td>true</td>
<td>new Number(-Infinity)</td>
</tr>
<tr>
<td>{}（对象 -&gt; 其他）</td>
<td>单独讲</td>
<td>单独讲</td>
<td>true</td>
<td>–</td>
</tr>
<tr>
<td>[] （数组 -&gt; 其他）</td>
<td>“”</td>
<td>0</td>
<td>true</td>
<td>–</td>
</tr>
<tr>
<td>[1] （一个数字元素的数值 -&gt; 其他）</td>
<td>“1”</td>
<td>1</td>
<td>true</td>
<td>–</td>
</tr>
<tr>
<td>[‘a’] （普通数组 -&gt; 其他）</td>
<td>使用join()方法</td>
<td>NaN</td>
<td>true</td>
<td>–</td>
</tr>
<tr>
<td>function(){} （函数 -&gt; 其他）</td>
<td>单独讲</td>
<td>NaN</td>
<td>true</td>
<td>–</td>
</tr>
</tbody></table>
<p>总之不同类型之间都可以相互转换，除了 null 和 undefined 不能转换为对象之外，其余都可以。</p>
<p>那么什么时候会进行这些转换呢？</p>
<p>其实在程序运行期间，就不断的在隐式的进行着各种类型转换，比如 if 语句中不是布尔类型时，比如算术表达式两边是不同类型时等等。</p>
<p>那么，如何进行手动的显示转换呢？</p>
<p>在上一小节中，其实有稍微提过了，就是使用：</p>
<ul>
<li>Number()</li>
<li>String()</li>
<li>Boolean()</li>
<li>Object()</li>
</ul>
<p>注意是以函数调用方式使用，即不加 new 关键字的使用方式。参数传入的值就是表示上表中第一列待转换的值，而四种不同的函数，就对应着上表中右边四列的转换规则。如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">"dasu"</span>)  <span class="comment">// =&gt; NaN，表示待转换值为字符串 "dasu"，需要转换为数字类型，按照上表规则，转换结果NaN</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>)    <span class="comment">// =&gt; "true"，同理，将布尔类型true转为字符串类型</span></span><br><span class="line"><span class="built_in">Boolean</span>([])     <span class="comment">// =&gt; true，将空数组转为布尔类型</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="number">3</span>)       <span class="comment">// =&gt; new Number(3)，将数字类型转为包装对象</span></span><br></pre></td></tr></table></figure>

<p>换句话说，这四个函数，其实就是用于将任意类型转换为函数对应的类型，比如 Number() 函数就是用于将任意类型转为数字类型，至于具体转换规则，就是按照表中的规则来进行转换。</p>
<p>一般来说，应该可以不用将表中所有的转换规则都详记，需要自己手动转换的场景应该也不多，记住一些常用基本的就行了，至于哪些是常见的，写多了就清楚了，比如数字类型 -&gt; 布尔类型，对象类型 -&gt; 布尔类型等。</p>
<h4 id="对象转换为原始值规则"><a href="#对象转换为原始值规则" class="headerlink" title="对象转换为原始值规则"></a>对象转换为原始值规则</h4><p>所有的数据类型之间的转换，就对象转换到原始值的规则会复杂点，其余的需要的时候，看一下表就行了。</p>
<ul>
<li>对象 -&gt; 布尔</li>
</ul>
<p>首先，所有的对象，不管的函数、数组还是普通对象，只要这个对象是定义后存在的，那么它转换为布尔值都是 true，所以对象转布尔也很简单。反正就记住，对象存在，那么转布尔就为 true。</p>
<p>所以，即使一个布尔值 false，先转成包装对象 new Boolean(false)，再从包装对象转为布尔值，那么此时，包装对象转布尔后是 true，因为包装对象存在，就这么简单，不关心这个包装对象原本是从布尔 false 转来的。</p>
<ul>
<li>对象 -&gt; 字符串</li>
</ul>
<p>对象转字符串，主要是需要借助两个方法：</p>
<ol>
<li>如果对象具有 <code>toString()</code>，则调用这个方法，如果调用后返回了一个原始值，那么就将这个原始值转为字符串，转换结束。</li>
<li>如果对象没有 <code>toString()</code> 方法，或者调用该方法返回的并不是一个原始值，那么调用对象的 <code>valueOf()</code> 方法，同样，如果调用后返回一个原始值，那么将原始值转为字符串后，转换结束。</li>
<li>否则，抛类型错误异常。 </li>
</ol>
<p>这就是对象转字符串的规则，有些内置的对象，比如函数对象，或数组对象就可能会对这两个方法进行重写，对于自定义的对象，也可以重写这两个方法，来手动控制它转成字符串的规则。</p>
<ul>
<li>对象 -&gt; 数字</li>
</ul>
<p>对象转数字的规则，也是需要用到这两个方法，只是它将步骤替换了下：</p>
<ol>
<li>如果对象具有 <code>valueOf()</code> 方法，且调用后返回一个原始值，那么将这个原始值转为数字，转换结束。</li>
<li>如果对象没有 <code>valueOf()</code> 方法，或者调用后返回的不是原始值，那么看对象是否具有 <code>toSring()</code> 方法，且调用它后返回一个原始值，那么将原始值转为数字，转换结束。</li>
<li>否则，抛类型错误异常。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>前端07-JavaScript语法之相关术语（入门）</title>
    <url>/2018/10/30/%E5%89%8D%E7%AB%AF/%E5%85%A5%E9%97%A8/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A87-JavaScript%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下几个来源：</p>
<ul>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
<li><a href="https://github.com/goddyZhao/Translation/tree/master/JavaScript" target="_blank" rel="noopener">Github:goddyZhao/Translation/JavaScript</a></li>
</ul>
<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p>
<h1 id="正文-相关术语"><a href="#正文-相关术语" class="headerlink" title="正文-相关术语"></a>正文-相关术语</h1><p>对于从 Java 或 C++ 转过来的开发人员来说 JavaScript 会有点让人困惑，因为它全部都是动态的，都是运行时，而且不存在类机制。所有的都是实例对象。所以，学习一些 JavaScript 的语言特性时，最好不要试图从 Java 中寻找相关概念硬套过来，类比可以。 </p>
<p>接下去一系列关于 JavaScript 语法的文章中，将会出现很多在 Java 里出现或者没出现过的专业术语，所以第一篇就先来罗列一下，每个术语先给一定的解释。</p>
<p>有的理解不了没关系，等这系列文章看完，再回过头来看这一张基本也都能理解了。先罗列出来，至少有个印象，不至于到时看到一脸懵逼。</p>
<h3 id="直接量"><a href="#直接量" class="headerlink" title="直接量"></a>直接量</h3><p>可以直接使用的数据值，即在程序中直接出现的数据值，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">123</span><br><span class="line"></span><br><span class="line">&#123;name:dasu&#125;</span><br><span class="line"></span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>等等这些直接出现可直接使用的数据值称为直接量，不同数据类型有不同的叫法，常见的有：数字直接量、字符串直接量、正则表达式直接量、对象直接量、数组直接量等。</p>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>跟直接量没什么区别，都是同一个单词 literals 的不同翻译而已，所以直接量也就是字面量，字面量就是直接量，不同书可能用的不同翻译而已。</p>
<h3 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h3><p>原始类型的值称为原始值，原始值是不可变的。在 JavaScript 中，有两种数据类型：原始类型和对象类型。</p>
<p>原始类型包括：数字（Number）、字符串（String）、布尔（Boolean）、null、undefined。</p>
<h3 id="表达式-amp-语句"><a href="#表达式-amp-语句" class="headerlink" title="表达式&amp;语句"></a>表达式&amp;语句</h3><p>表达式可以理解成方程式，用于计算某个结果值或某种行为的代码可称为表达式，通常它们并不会改变程序状态，也不会影响程序后续执行流程，如算术表达式: x+1。</p>
<p>语句表示一个完整的行为，可以是多个表达式与关键字、运算符等的组合。 </p>
<h3 id="函数-amp-方法"><a href="#函数-amp-方法" class="headerlink" title="函数&amp;方法"></a>函数&amp;方法</h3><p>function 关键字声明的称为函数，但将函数置于对象内时，此时称它为对象的方法。</p>
<p>简单的理解，从不同的角度看待，如果是从函数本身，那么它就是个函数，如果是从对象角度看待，那么称某个函数是对象的方法，本质上没什么区别。但当调用时会有所区别。</p>
<p>另外，函数本质上也是一个对象。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>JavaScript 没有类似于 Java 的 class 机制，一个函数，当和 new 关键字一起使用时，此时称这个函数为构造函数。</p>
<p>也就是所有的函数都可以作为构造函数，当它和 new 关键字一起使用时，此时它的行为有区别于普通的函数调用。</p>
<h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>在前端里，当 js 的宿主是浏览器时，全局对象是 window。全局对象有几点特性：</p>
<ol>
<li>js 文件中不在函数内声明的所有变量和函数都是作为全局对象的属性存在。</li>
<li>全局对象的属性使用时，可以直接通过属性名访问，不必添加前缀，也就是不必像 window.name 这么使用。</li>
<li>js 文件中，函数外出现的 this 都指向全局对象 window。</li>
</ol>
<h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>全局对象的属性就称全局属性，但这里的全局属性，更多的是在表示这种场景下为全局对象创建的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">     weixin = dasuAndroidTv;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当我们在函数外部直接对一个不存在的变量赋值操作时，此时等价于执行 <code>this.weixin = dasuAndroidTv</code>，而 this 指向全局对象，所以会自动为全局对象添加一个属性，属性名为 weixin。</p>
<p>所以，有时候，全局属性是特指这种场景下为全局对象创建的属性。之所以会用全局属性来称呼这种场景，是为了跟下面的全局变量和全局函数区分开。</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">     var weixin = dasuAndroidTv;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>像这种不在函数内声明的变量，称为全局变量。虽然，它们最终也都是作为全局对象 window 的属性而存在，但由于这种方式为 window 创建的属性和上述介绍的不加 var 关键字为全局对象添加属性的方式有本质上的区别。</p>
<p>所以，为了和上述介绍的全局属性概念区别开来，通常称这种通过 var 为全局对象创建的属性为全局变量。</p>
<p>既然全局对象的属性在任何地方都可以不加前缀的直接访问使用，所以全局变量在任何地方都可以被使用。</p>
<p>对于上述介绍的那种直接对不存在的属性进行赋值操作行为而创建的全局属性，是可通过 delete 动态删除的；</p>
<p>而通过 var 或 function 这种声明全局变量的方式为全局对象创建的属性，是不可通过 delete 删除的。</p>
<h3 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">     function add() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>像这种不在函数内声明的函数，称为全局函数。它跟全局变量的特性、用意一模一样，区别只在于一个是变量、一个是函数而言。</p>
<h3 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h3><p>原始类型所对应的对象类型，类似于 Java 中的包装类。</p>
<p>因为原始类型不是对象，不可操作方法和属性，但可将其转换为对应的对象类型，此时称为包装对象，即可像操作对象一样操作这些转成包装对象的原始类型数据。</p>
<p>包装对象有：Number, Boolean, String</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>由于在 JavaScript 中，除了原始类型，其余的皆为对象，所以它的继承双方只能都是对象，也就是说，对象也是继承自对象的，那么作为父类角色，作为被继承的那个对象，此时称它为原型。</p>
<p>所以，才说 JavaScript 是基于原型的继承语言。</p>
<p>原型就是类似于 Java 中父类的概念。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>既然涉及继承，那么自然就有继承结构，这个结构在 JavaScript 中就称为原型链。</p>
<p>比如对象 a 继承自对象 b，对象 b 继承自对象 c，那么 a 的原型链就表示为：a -&gt; b -&gt; c（省略掉内置的继承关系）。</p>
<p>原型链用于当操作对象某个属性时，寻找该属性的来源。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域指的是变量和函数的作用域，下面统称变量，在 JavaScript 中，变量分两种：全局变量和局部变量。</p>
<p>全局变量指的是在函数外定义的变量，作用域是全局，在任何地方都可以使用，即使跨 js 文件中也可以使用，因为它们实际上是作为全局对象的属性存在，在前端里就是作为 window 的属性，而多个 &lt;script&gt; 中的不同 js 文件，都是共用同一个全局对象 window，自然就可以跨文件使用它的属性。</p>
<p>局部变量指函数内部定义的变量，或者函数形参，作用域为函数内。需要区别于 Java 中的局部变量，Java 里的局部变量的作用域为块级作用域：只能在局部变量声明的代码块且声明位置之后使用；但在 JavaScript 中，变量都有声明提前的特性，局部变量在函数内不管哪里都可以访问，即使声明的位置在末尾，或内嵌的代码块中。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>在 JavaScript 中，允许在函数内部继续定义函数，所以函数可以存在很深的嵌套层次，这里的嵌套层次不是指调用的嵌套，而是指函数声明的嵌套，A 函数在 B 函数中定义，作为 B 函数的局部变量存在这种。</p>
<p>而内部函数是可以访问外部函数内的变量的，也可以访问全局的变量，那么当内部函数使用了某个外部变量，就会借助作用域链，沿着作用域链中寻找这个外部变量究竟是外部函数内的变量，还是全局变量。</p>
<p>从原理上解释，每个函数调用时，都会创建一个函数执行上下文，执行上下文中存储着当前上下文中的所有变量，作用域链，就是将具有嵌套层次的函数的上下文中的变量串接起来的存在。</p>
<p>还是要反复强调，上面的嵌套层次指的不是函数调用时的嵌套层次，而是函数定义时的嵌套层次。可以将这里有嵌套层次关系的函数理解成 Java 中的内部类。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>MDN 中的文章对其的解释为：闭包是函数和声明该函数的词法环境的组合，这个环境包含了这个闭包创建时所能访问的所有局部变量。</p>
<p>某篇文章中看到过这么一种解释：闭包是代码块和创建该代码块的上下文中数据的结合。</p>
<p>闭包的概念不怎么好理解，有的文章里会说，函数就是闭包，有的说内嵌的函数是闭包，这里先不做评价，先尝试着从上面两种解释中去理解一下，看能否理解，后续会专门写一篇来讲讲。  </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>前端06-JavaScript客户端API&jQuery（入门）</title>
    <url>/2018/10/30/%E5%89%8D%E7%AB%AF/%E5%85%A5%E9%97%A8/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A86-JavaScript%E5%AE%A2%E6%88%B7%E7%AB%AFapi&amp;jQuery/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下四个来源：</p>
<ul>
<li>《HTML5权威指南》</li>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
</ul>
<p>作为一个前端小白，入门跟着这四个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<h1 id="正文-JavaScript-客户端API-amp-jQuery"><a href="#正文-JavaScript-客户端API-amp-jQuery" class="headerlink" title="正文-JavaScript-客户端API &amp; jQuery"></a>正文-JavaScript-客户端API &amp; jQuery</h1><p>JavaScript 是用来丰富网站的内容的，让网站支持各种交互行为功能等等。</p>
<p>JavaScript 是一门脚本语言，自然有它自己的语法标准，这个标准由 ECMAScript 发布，因此相对应的版本标准通常都简写成 ES5、ES6。</p>
<p>这次入门系列，并不打算先从语法入手学习，而是打算先学学客户端 API，也就是浏览器提供的相关 JS API，用来操作 HTML 文档，毕竟入门学习的话，并不会涉及很多复杂的业务逻辑，相反，大多都是 JS 操作 DOM 的相关操作，因此，先从这方面进行学习。</p>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>如果有一定的 Java 基础，那么，只需了解下一些基础的 JS 语法，便可开始学习相关的客户端 API，熟悉后，足够编写 JS 代码来操作 DOM，达到动态网页的效果了。</p>
<ul>
<li><strong>弱语言类型</strong></li>
</ul>
<p>所谓的弱语言类型，就是说，声明变量类型时不必明确声明其类型，只需用 var 声明即可：</p>
<p>比如 Java 中需要定义如下变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;     </span><br><span class="line"><span class="keyword">float</span> a;</span><br><span class="line"><span class="keyword">double</span> a;</span><br><span class="line">String a;</span><br><span class="line"><span class="keyword">boolean</span> a;</span><br></pre></td></tr></table></figure>

<p>而 JavaScript 中，统一用 var 定义一个变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>变量的数据类型</strong></li>
</ul>
<p>虽然声明变量时，不必指出变量的类型，但也要清楚下，JS 中的基本数据类型 :</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f00ee7cbc68cca59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据类型">  </p>
<p>在 JavaScript 中，只要是数，就是 Number 数值型的。无论整浮、浮点数、无论大小、无论正负，都是 Number 类型的。</p>
<p>可以使用内置方法：isNaN()，来判断某个变量是否是数值类型。</p>
<p>关键字 typeof 可以打出变量的类型，如果需要查看某个变量的类型时。</p>
<ul>
<li><strong>类型的强制转换</strong></li>
</ul>
<p>转 String:</p>
<ul>
<li>变量 +  “”</li>
<li>变量.toString()</li>
<li>String(变量)</li>
</ul>
<p>转 Number:</p>
<ul>
<li>parseInt/Float(变量)</li>
</ul>
<p>跟 Java 有些类似。</p>
<ul>
<li><strong>函数</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数声明有两种方式，这两种方式的声明是有一定的区别的，在于 JS 中的声明提前的影响，这部分先不用过多了解，后续详细讲语法时再来讨论。在其他方面，这两种声明方式基本等效。</p>
<p>当需要有返回值时，直接在最后一行代码里加上 return。函数名也可以省略，此时称匿名函数。</p>
<p>当定义了函数之后，需要调用函数的时候，直接用函数名()，如 sum(1,2)</p>
<p>但如果只是想把函数跟某一事件绑定时，此时只需要函数名，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">button.onclick() = sum;</span><br></pre></td></tr></table></figure>

<p>如果此时 sum 也带上括号: sum()，那么函数就会被调用，这里需要注意。</p>
<ul>
<li><strong>对象</strong></li>
</ul>
<p>在 Js 中可以不必像 Java 那样新建个类，然后从这个类 new 出对象。在 Js 中，需要对象时，直接 new Object()，然后赋予想要的属性和行为即可。</p>
<p>首先创建一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>

<p>向对象中添加属性:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.name = <span class="string">"dasu"</span>;</span><br><span class="line">obj.age = <span class="number">25</span>;</span><br></pre></td></tr></table></figure>

<p>对象的属性值可以是任何的数据类型，也可以是个函数： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dasu'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建对象的方式也可以用另外一种方式： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">            name: <span class="string">"dasu"</span>,</span><br><span class="line">            age: <span class="number">25</span>,</span><br><span class="line">            sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>当然也可以使用类似于 Java 定义类，实例化对象的方式。 </p>
<ul>
<li><strong>相等比较</strong></li>
</ul>
<p>Js 中比较分两种，严格和非严格，对应的操作符：<code>===&amp;!==</code> 和 <code>==&amp;!=</code></p>
<p>两个等号的比较时，比较的两个变量只要数值上相等，那么就返回 true，三个等号的比较时，需要同时满足类型和数值相等两个条件才会返回 true。</p>
<p>以上基本的语法了解后，至少就知道如何声明变量、函数、对象，如何使用了，这就足够了，那么接下去就是熟悉下客户端 API，也可以说是浏览器按照标准提供的各 API 的使用。</p>
<h3 id="DOM-概念"><a href="#DOM-概念" class="headerlink" title="DOM 概念"></a>DOM 概念</h3><p>DOM（document object model）：文档对象模型</p>
<p>了解 JavaScript 基本语法后，就要接着了解 DOM 概念。类似于 CSS 通过选择器来操作 HTML 文档中的元素。那么，同样的道理，js 也需要有个中间媒介来操作 HTML 文档中的元素，这个媒介就是 DOM。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>那么，什么是 DOM 呢，其实就是浏览器根据 HTML 文档构建出的一颗 DOM 树，树中每个节点对应着 HTML 文档中的每个元素标签，因此树的结构可以很好的表现出各个元素之间的层级关系。</p>
<p>另外，每个节点都携带着当前元素的所有信息，包括 CSS 作用的样式属性表，设置的类型，id 等等，这些信息可以通过节点的各种属性方法获取到。</p>
<p>但有一点需要注意下，元素修饰的文本内容也会被创建成一个节点，作为这个元素的子元素加入 DOM 树中。</p>
<p>这种 DOM 树的概念跟 Android 中的视图树很类似。所以，每份 HTML 文档都会对应一颗 DOM 树。</p>
<p>JavaScript 可以通过全局变量 document 拿到这个 DOM 树对象，那么之后就可以根据 DOM 提供的各种 API 接口来操纵这颗 DOM 树，包括获取指定节点的元素，动态修改该节点元素的信息，给这个节点元素绑定上事件操作等等。</p>
<h4 id="模型示例"><a href="#模型示例" class="headerlink" title="模型示例"></a>模型示例</h4><p>一颗DOM树究竟长什么样子呢？看个例子： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>博雅<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>这里<span class="tag">&lt;<span class="name">span</span>&gt;</span>行内<span class="tag">&lt;/<span class="name">span</span>&gt;</span>不行<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述是一份特别简单的 HTML 文档，看看它相对应的 DOM 树 :</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-644928b460e66903.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DOM">  </p>
<p>这就是对应的 DOM 树，层次分明，各节点都表示相对应的元素信息。但有一点需要注意下，橘色框都是相对应元素的文本内容，它也是 DOM 树中的节点，类型是 Text 对象。并且，并不是一个元素的所有文本内容作为一个 Text 对象，如果文本内容被其他元素标签分割开了，那么这些文本内容会被分割成多份节点，都作为元素的子元素拼接在 DOM 树中。 </p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>想想，这颗 DOM 树是谁来建模生成的呢？很明显，是浏览器吧，浏览器解析 HTML 文档以及 CSS 后，根据当前的视图建模出一颗 DOM 树出来。并提供了各种 API 接口供 JavaScript 来操纵。</p>
<p>那么，不同的浏览器厂商实现可能就会有所不同，比如 W3C 规定了一系列操纵 DOM 的 API 接口，但浏览器不想全部实现，就实现了其中核心部分，或者就算实现了，具体表现也有可能有所不同。</p>
<p>那么，这时就会存在一个问题了，也就是我们通过 JavaScript，然后根据 W3C 规范的 API 接口来操纵 DOM 时，可能在不同浏览器上有不同的变现行为。所以，这时就需要考虑兼容性处理了。</p>
<p>但有一个更方便的解决方案，那就是使用jQuery，这是一个基于 JavaScript 的框架库，它封装了操纵 DOM 的各种功能，内部对不同浏览器进行了兼容性处理，那么我们使用的时候就可以不用再去考虑那么兼容性的处理了。</p>
<p>所以，下面会分别介绍 W3C 规范的标准 API 和 jQuery 的使用：</p>
<h3 id="DOM-API"><a href="#DOM-API" class="headerlink" title="DOM API"></a>DOM API</h3><h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><p>document 是内置的全局变量，在 JavaScript 可以直接通过该关键字使用，使用时会获取到当前 HTML 文档对应的 Document 对象。</p>
<p>拿到这个对象后，就可以调用它的一些属性和方法来获取或修改我们想要的数据。</p>
<table>
<thead>
<tr>
<th>readyState</th>
<th>查看当前文档的被浏览器加载的状态（加载中等）</th>
</tr>
</thead>
<tbody><tr>
<td>body/head/title</td>
<td>直接获取文档的相关元素标签信息</td>
</tr>
<tr>
<td>getElementByXXX()</td>
<td>根据id，class，tag等在文档中查找指定元素</td>
</tr>
<tr>
<td>createElement(tag)</td>
<td>创建指定标签的元素节点</td>
</tr>
<tr>
<td>craeteTextNode(text)</td>
<td>创建指定文本内容的Text对象</td>
</tr>
<tr>
<td>location</td>
<td>返回当前文档地址的Location对象</td>
</tr>
</tbody></table>
<p>API很多，需要的时候再查就行，主要清楚下，document 是 JavaScript 操纵 DOM 树的入口，从这里开始，可以获取一些关于文档的元数据方面的属性信息，也可以来查找指定的文档中某个节点的元素对象。</p>
<h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p>Location 对象提供了细粒度的文档地址信息，也支持导航到其他文档上。当打开新文档在 URL 中有携带了一些信息时，可以通过这个来获取这些信息。</p>
<table>
<thead>
<tr>
<th>protocol</th>
<th>获取或设置文档URL的协议部分</th>
</tr>
</thead>
<tbody><tr>
<td>host</td>
<td>获取或设置文档URL的主机和端口部分</td>
</tr>
<tr>
<td>href</td>
<td>获取或设置当前文档的地址</td>
</tr>
<tr>
<td>hostname</td>
<td>获取或设置文档URL的主机名部分</td>
</tr>
<tr>
<td>port</td>
<td>获取或设置文档URL的端口部分</td>
</tr>
<tr>
<td>pathname</td>
<td>获取或设置文档URL的路径部分</td>
</tr>
<tr>
<td>search</td>
<td>获取或设置文档URL的查询（问号串）部分</td>
</tr>
<tr>
<td>hash</td>
<td>获取或设置文档URL的锚（#号串）部分</td>
</tr>
<tr>
<td>assign(url)</td>
<td>导航到指定的URL</td>
</tr>
<tr>
<td>replace(url)</td>
<td>清除当前文档并导航到新的URL</td>
</tr>
<tr>
<td>reload()</td>
<td>重新载入当前文档</td>
</tr>
<tr>
<td>resolveURL(url)</td>
<td>将指定的相对URL解析成绝对URL</td>
</tr>
</tbody></table>
<h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><p>window 直译过来就是窗口，其实也就是表示文档当前所显示的窗口对象，所以一些窗口性的功能都可以通过这个对象来调用。</p>
<p>比如：调用浏览器弹框、定时器的使用、获取窗口信息包括窗口宽高，屏幕宽高等等、窗口的滑动、操纵浏览器窗口的历史记录、向其他窗口发送消息等等。</p>
<ul>
<li>获取窗口相关信息：</li>
</ul>
<table>
<thead>
<tr>
<th>innerHeight/Width</th>
<th>获取窗口内容区域的宽高</th>
</tr>
</thead>
<tbody><tr>
<td>outerHeight/Width</td>
<td>获取窗口的宽高，包括边框和菜单栏等等</td>
</tr>
<tr>
<td>screen</td>
<td>获取描述屏幕的Screen对象</td>
</tr>
<tr>
<td>Screen.width/height</td>
<td>Screen对象获取屏幕宽高</td>
</tr>
<tr>
<td>Screen.availWidth/Height</td>
<td>获取屏幕可用的宽高，去掉工具栏菜单栏</td>
</tr>
<tr>
<td>pageX/Yoffset</td>
<td>获取窗口在水平/垂直方向已滚动过的像素</td>
</tr>
<tr>
<td>document</td>
<td>获取次窗口关联的Document对象</td>
</tr>
<tr>
<td>history</td>
<td>访问浏览器历史</td>
</tr>
<tr>
<td>location</td>
<td>获取当前文档地址的详细信息</td>
</tr>
</tbody></table>
<ul>
<li>与窗口交互：</li>
</ul>
<table>
<thead>
<tr>
<th>blur()</th>
<th>让窗口失去键盘焦点</th>
</tr>
</thead>
<tbody><tr>
<td>close()</td>
<td>关闭窗口（不是所有浏览器都允许js关闭窗口）</td>
</tr>
<tr>
<td>focus()</td>
<td>让窗口获得键盘焦点</td>
</tr>
<tr>
<td>scrollBy(x, y)</td>
<td>让文档相对于当前位置进行滚动</td>
</tr>
<tr>
<td>scrollTo(x, y)</td>
<td>滚动到指定位置</td>
</tr>
<tr>
<td>alert(msg)</td>
<td>弹出一个对话框</td>
</tr>
<tr>
<td>confirm(msg)</td>
<td>弹出一个带有确认和取消的对话框</td>
</tr>
<tr>
<td>showModalDialog(url)</td>
<td>弹出窗口，显示指定的URL</td>
</tr>
<tr>
<td>postMessage(msg, origin)</td>
<td>给另一个文档发送消息</td>
</tr>
<tr>
<td>set/clearInterval(fun, time)</td>
<td>创建/撤销周期性的任务</td>
</tr>
<tr>
<td>set/clearTimeout(fun, time)</td>
<td>创建/撤销延时任务</td>
</tr>
</tbody></table>
<h4 id="HTMLElement"><a href="#HTMLElement" class="headerlink" title="HTMLElement"></a>HTMLElement</h4><p>通过 document 获取到 Document 对象，以此来获取操纵 DOM 的入口，根据需要获取所需的文档相关信息，或者搜索指定的 DOM 中节点的元素，此时这个节点的元素对象就是 HTMLElement 对象。</p>
<p>所有的标签元素的基类对象都是 HTMLElement，这个类定义的公共的、基础的操作元素节点的方法和属性。</p>
<p>但每个标签实际上都有具体的实现类，比如 body 对应 HTMLBodyElement，script 对应 HTMLScriptElement，具体实现类由这个标签独有的属性和方法。</p>
<p>基类 HTMLElement 对象定义的基础的方法、属性包括：获取或修改元素的指定属性，添加或移除元素某个 class，查看或修改该标签包装的内容等等。</p>
<ul>
<li>元素的元数据属性：</li>
</ul>
<table>
<thead>
<tr>
<th>classList</th>
<th>获取元素设置的class列表，返回DOMTokenList对象，可直接add,remove等操作</th>
</tr>
</thead>
<tbody><tr>
<td>className</td>
<td>获取元素设置的class列表，返回字符串</td>
</tr>
<tr>
<td>disabled/hidden/id</td>
<td>获取或设置disable/hidden/id…</td>
</tr>
<tr>
<td>attributes</td>
<td>获取元素设置的属性值列表，返回Attr[]对象</td>
</tr>
<tr>
<td>innerHTML</td>
<td>获取元素标签包装的内容，包括文本内容及子元素</td>
</tr>
<tr>
<td>outerHTML</td>
<td>获取元素整个内容</td>
</tr>
</tbody></table>
<ul>
<li>节点元素操纵</li>
</ul>
<table>
<thead>
<tr>
<th>get/has/removeAttribute(name)</th>
<th>获取/判断/移除元素的某个属性</th>
</tr>
</thead>
<tbody><tr>
<td>setAttribute(name, value)</td>
<td>设置元素的某个属性</td>
</tr>
<tr>
<td>appendChild(HTMLElement)</td>
<td>为当前元素添加子元素</td>
</tr>
<tr>
<td>cloneNode(boolean)</td>
<td>拷贝一份当前的元素，返回新的HTMElement对象，参数设置是否拷贝当前元素的子元素</td>
</tr>
<tr>
<td>isEqualNode(HTMLElement)</td>
<td>判断指定元素与当前是否相同，具有相同的class，相同的属性，相同的子元素</td>
</tr>
<tr>
<td>isSameNode(HTMLElement)</td>
<td>判断是否是同一个元素</td>
</tr>
<tr>
<td>removeChild(HTMLElement)</td>
<td>移除指定的子元素</td>
</tr>
<tr>
<td>replaceChild(HTMLElement, H.)</td>
<td>替换指定的子元素</td>
</tr>
</tbody></table>
<h3 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a>DOM 事件</h3><p>通过上述一些方法，JavaScript 可以定位找到所需的元素，然后也可以动态的修改相关数据，但通常，这些动态修改的操作都是用户操作了某些事件后去触发的。</p>
<p>所以，即使找到了元素后，还需要将元素与一些事件进行绑定，比如点击事件等等。</p>
<p>有两种方式让元素绑定事件和处理的方法：</p>
<h4 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aElems = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; aElems.length; i++) &#123;</span><br><span class="line">    aElems[i].addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"addEventListener:"</span> +  <span class="keyword">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 HTMLElement 对象的 <code>addEventListener()</code> 方法，第一个参数传入需要监听的事件名称，第二个参数为事件触发时的响应方法。</p>
<p>相对应的，还有一个 <code>removeEventListener()</code> 方法，同样接收这两个参数。</p>
<h4 id="onXXX"><a href="#onXXX" class="headerlink" title="onXXX"></a>onXXX</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aElems = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; aElems.length; i++) &#123;</span><br><span class="line">    aElems[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"onclick:"</span> +  <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式，是在需要注册的事件类型前面加 on 作为元素的属性来注册事件的监听，这种比较常见。 </p>
<h4 id="所有事件类型"><a href="#所有事件类型" class="headerlink" title="所有事件类型"></a>所有事件类型</h4><ul>
<li>document 的事件</li>
</ul>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>readystatechange</td>
<td>readyState属性值发生变化时触发，也就是文档加载的不同阶段触发</td>
</tr>
</tbody></table>
<ul>
<li>window 的事件</li>
</ul>
<table>
<thead>
<tr>
<th>onabort</th>
<th>在文档或资源加载过程中被终止时触发</th>
</tr>
</thead>
<tbody><tr>
<td>onerror</td>
<td>在文档或资源加载发生错误时触发</td>
</tr>
<tr>
<td>onhaschange</td>
<td>在锚部分发生变化时触发</td>
</tr>
<tr>
<td>onload</td>
<td>在文档或资源加载完成时触发</td>
</tr>
<tr>
<td>onresize</td>
<td>在窗口缩放时触发</td>
</tr>
<tr>
<td>onunload</td>
<td>在文档从窗口或浏览器中卸载时触发</td>
</tr>
</tbody></table>
<ul>
<li>鼠标事件</li>
</ul>
<table>
<thead>
<tr>
<th>click</th>
<th>单击，释放时触发</th>
</tr>
</thead>
<tbody><tr>
<td>dblclick</td>
<td>双击，释放时触发</td>
</tr>
<tr>
<td>mousedown</td>
<td>点击鼠标键时触发</td>
</tr>
<tr>
<td>mouseenter</td>
<td>在光标移入元素或某个后代元素所占据的屏幕区域时触发</td>
</tr>
<tr>
<td>mouseleave</td>
<td>在光标移出元素及所有后代元素所占据的屏幕区域时触发</td>
</tr>
<tr>
<td>mousemove</td>
<td>光标在元素上移动时触发</td>
</tr>
<tr>
<td>mouseout</td>
<td>与mouseleave基本相同，除了当光标仍然在某个后代元素上时也会触发</td>
</tr>
<tr>
<td>mouseenter</td>
<td>与mouseenter基本相同，除了当光标仍然在某个后代元素上时也会触发</td>
</tr>
<tr>
<td>mouseup</td>
<td>当释放鼠标时触发</td>
</tr>
</tbody></table>
<p>鼠标事件被触发时，指定的处理方法都会传入一个 MouseEvent 对象，该对象携带一些额外的属性和方法供处理。</p>
<ul>
<li>MouseEvent</li>
</ul>
<table>
<thead>
<tr>
<th>button</th>
<th>标明点击的是哪个键，0：鼠标主键，1：中键，2：次键</th>
</tr>
</thead>
<tbody><tr>
<td>altkey</td>
<td>事件触发时是否有点击alt键</td>
</tr>
<tr>
<td>clientX</td>
<td>事件触发时鼠标相对于元素视口的X坐标</td>
</tr>
<tr>
<td>clientY</td>
<td>事件触发时鼠标相对于元素视口的Y坐标</td>
</tr>
<tr>
<td>screenX</td>
<td>事件触发时鼠标相对于屏幕坐标系的X坐标</td>
</tr>
<tr>
<td>screenY</td>
<td>事件触发时鼠标相对于屏幕坐标系的Y坐标</td>
</tr>
<tr>
<td>shiftKey</td>
<td>事件触发时是否有点击shift键</td>
</tr>
<tr>
<td>ctrlKey</td>
<td>事件触发时是否有点击ctrl键</td>
</tr>
</tbody></table>
<ul>
<li>键盘焦点事件</li>
</ul>
<table>
<thead>
<tr>
<th>blur</th>
<th>在元素失去焦点时触发</th>
</tr>
</thead>
<tbody><tr>
<td>focus</td>
<td>在元素获得焦点时触发</td>
</tr>
<tr>
<td>focusin</td>
<td>在元素即将获得焦点时触发</td>
</tr>
<tr>
<td>focusout</td>
<td>在元素即将失去焦点时触发</td>
</tr>
</tbody></table>
<p>键盘焦点事件传入的是 FocusEvent 对象。</p>
<ul>
<li>键盘点击事件</li>
</ul>
<table>
<thead>
<tr>
<th>keydown</th>
<th>在用户按下某个键时触发</th>
</tr>
</thead>
<tbody><tr>
<td>keypress</td>
<td>在用户按下并释放某个键时触发</td>
</tr>
<tr>
<td>keyup</td>
<td>在用户释放某个键时触发</td>
</tr>
</tbody></table>
<p>键盘点击事件传入的是 KeyboardEvent 对象。</p>
<h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><h4 id="为什么使用-jQuery"><a href="#为什么使用-jQuery" class="headerlink" title="为什么使用 jQuery"></a>为什么使用 jQuery</h4><p>类似于 JVM 隐藏了不同操作系统之间的差异，让开发能够更专注于功能的实现，而不必花费过多时间适配不同操作系统。jQuery 隐藏了不同浏览器之间的差异，减少开发者花费在适配不同浏览器之间的精力。</p>
<p>举个例子：float 属性</p>
<p>原生 js 的话，ie 需要通过 styleFloat 获取对象修改，W3C 标准为 cssFloat，jQuery 统一封装成 float，内部会自动根据不同浏览器的实现进行处理。</p>
<p>同时，它封装了很多基本实用的功能，如 ajax，基本动画等。</p>
<h4 id="API-中文文档"><a href="#API-中文文档" class="headerlink" title="API 中文文档"></a>API 中文文档</h4><p><a href="http://www.css88.com/jqapi-1.9/css/" target="_blank" rel="noopener">http://www.css88.com/jqapi-1.9/css/</a>  </p>
<h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"https://easy-mock.com/mock/5b592c01e4e04f38c7a55958/ywb/is/version/checkVersion"</span>,</span><br><span class="line">    data: &#123;<span class="string">"key"</span>: <span class="number">122</span>&#125;,</span><br><span class="line">    type: <span class="string">"POST"</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        logUtils(data.content);</span><br><span class="line">        <span class="keyword">var</span> con = <span class="built_in">JSON</span>.parse(data.content);</span><br><span class="line">        callback &amp;&amp; callback(con);<span class="comment">//通知回调</span></span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        logUtils(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><ul>
<li>修改 display 样式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"display"</span>, <span class="string">"none"</span>);</span><br><span class="line">$(<span class="string">"span"</span>).css(&#123;<span class="attr">display</span>:<span class="string">"block"</span>, <span class="attr">background</span>: <span class="string">"#f2f"</span>&#125;);<span class="comment">//好用</span></span><br><span class="line">$(<span class="string">"span"</span>).css(&#123;<span class="string">"display"</span>:<span class="string">"block"</span>, <span class="string">"background"</span>: <span class="string">"#f2f"</span>&#125;);<span class="comment">//这种也可以</span></span><br><span class="line"><span class="comment">//第2种方式</span></span><br><span class="line">$(<span class="string">"div"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.style.display = <span class="string">"none"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">"div"</span>)[<span class="number">0</span>].style.display = <span class="string">"none"</span>;</span><br><span class="line"><span class="comment">//第3种方式</span></span><br><span class="line">$(<span class="string">"div"</span>).show();<span class="comment">//等效于display:block(inline)</span></span><br><span class="line">$(<span class="string">"div"</span>).hide();<span class="comment">//等效于display:none</span></span><br><span class="line">$(<span class="string">"div"</span>).toggle();<span class="comment">//取相反的值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>读取样式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"display"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><ul>
<li>添加 class</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).addClass(<span class="string">"liItem"</span>);  <span class="comment">//为指定元素添加类className</span></span><br></pre></td></tr></table></figure>

<ul>
<li>移除 class</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).removeClass(<span class="string">"liItem"</span>);  <span class="comment">//为指定元素移除类 className</span></span><br><span class="line">$(selector).removeClass();          <span class="comment">//不指定参数，表示移除被选中元素的所有类</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断有没有指定 class</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).hasClass(<span class="string">"liItem"</span>);   <span class="comment">//判断指定元素是否包含类 className</span></span><br></pre></td></tr></table></figure>

<ul>
<li>切换 class</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).toggleClass(<span class="string">"liItem"</span>);    <span class="comment">//为指定元素切换类 className，该元素有类则移除，没有指定类则添加</span></span><br></pre></td></tr></table></figure>

<ul>
<li>应用场景</li>
</ul>
<p>当 js 动态修改的样式较少时，可直接通过 .css() 实现。 </p>
<p>当 js 动态修改的样式比较多时，选择 class 操作较方便，事件将需要的样式写在 css 中，在 js 里直接添加或移除指定 class 实现。</p>
<p>如果考虑以后维护方便（把 CSS 从 js 中分离出来）的话，推荐使用类的方式来操作。</p>
<h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><ul>
<li>创建元素 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类似于js中: document.createElement("标签名")</span></span><br><span class="line"><span class="keyword">var</span> node1 = $(<span class="string">"&lt;span&gt;我是一个span元素&lt;/span&gt;"</span>);<span class="comment">//返回的是jQuery对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加子元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1:在.main元素的子元素末尾加入新的子元素</span></span><br><span class="line">$(<span class="string">".main"</span>).append(node1);</span><br><span class="line">$(<span class="string">".main"</span>).append(<span class="string">"&lt;span&gt;我是一个span元素&lt;/span&gt;"</span>);</span><br><span class="line"><span class="comment">//方式2:在.main元素的子元素开头加入新的子元素</span></span><br><span class="line">$(<span class="string">".main"</span>).prepend(<span class="string">"&lt;span&gt;我是第一个span元素&lt;/span&gt;"</span>);</span><br><span class="line"><span class="comment">//方式3：替换掉所有子元素内容</span></span><br><span class="line">$(<span class="string">".main"</span>).html(<span class="string">"&lt;span&gt;我把所有子元素都替换掉了&lt;/span&gt;"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>添加兄弟元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">".main"</span>).after(<span class="string">"&lt;span&gt;我是兄弟后span元素&lt;/span&gt;"</span>);</span><br><span class="line">$(<span class="string">".main"</span>).before(<span class="string">"&lt;span&gt;我是兄弟前span元素&lt;/span&gt;"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>移除 html</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//移除所有子元素</span></span><br><span class="line">$(<span class="string">".main"</span>).html(<span class="string">""</span>);</span><br><span class="line"><span class="comment">//移除自已，自然子元素也被跟着移除</span></span><br><span class="line">$(<span class="string">".main"</span>).remove();</span><br></pre></td></tr></table></figure>

<ul>
<li>查看元素内容（包括标签）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log($(<span class="string">".main"</span>).html());<span class="comment">//下面是元素标签和打出的日志</span></span><br><span class="line">$(<span class="string">".main"</span>).prepend(<span class="string">"&lt;span&gt;我是第&lt;a&gt;dsfds&lt;span&gt;23543&lt;/span&gt;&lt;/a&gt;一个span元素&lt;/span&gt;"</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5b6fd09f655b28b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="jquery1">  </p>
<ul>
<li>查看元素的纯文本内容</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log($(<span class="string">".main"</span>).text());<span class="comment">//下面是元素标签和打出的日志</span></span><br><span class="line">$(<span class="string">".main"</span>).prepend(<span class="string">"&lt;span&gt;我是第&lt;a&gt;dsfds&lt;span&gt;23543&lt;/span&gt;&lt;/a&gt;一个span元素&lt;/span&gt;"</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-068ee7907828bde2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="jquery2">  </p>
<p>text() 会返回当前元素内的所有文本内容，包括子孙后代元素所包装的文本内容。 </p>
<ul>
<li>小结</li>
</ul>
<p>获取元素的内容（包括标签）可用 <code>html()</code>，创建元素时用 <code>$ (&quot;xxx&quot;)</code>，如果元素只有一个子元素，那么获取文本内容时可直接用 <code>text()</code>，添加子元素时用 <code>append()</code>。 </p>
<h4 id="attr"><a href="#attr" class="headerlink" title="attr"></a>attr</h4><ul>
<li>设置属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).attr(<span class="string">"title"</span>, <span class="string">"生命壹号"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>获取属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).attr(<span class="string">"title"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>移除属性</li>
</ul>
<pre><code class="javascript">$(selector).removeAttr(<span class="string">"title"</span>);</code></pre>
]]></content>
      <categories>
        <category>前端</category>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>前端05-CSS弹性布局flex（入门）</title>
    <url>/2018/10/29/%E5%89%8D%E7%AB%AF/%E5%85%A5%E9%97%A8/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A85-CSS%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80flex/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下四个来源：</p>
<ul>
<li>《HTML5权威指南》</li>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
</ul>
<p>作为一个前端小白，入门跟着这四个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<h1 id="正文-弹性布局flex"><a href="#正文-弹性布局flex" class="headerlink" title="正文-弹性布局flex"></a>正文-弹性布局flex</h1><p>弹性布局的作用有点儿类似 Android 中 LinearLayout 和 RelativeLayout 两者的合成版，即：支持横向布局，纵向布局，start，end，center 布局，宽高按比例瓜分等等，当然它还有很多其他功能，比如自动换行，按指定 order 排列等。总之有了 Android 基础，理解弹性布局 flex 蛮容易的。</p>
<p>可以这么的理解，传统的网页布局方式是通过 display 和 position 以及 float 三者完成的，借助块级元素，行内元素特性，结合 position 指定的相对布局、绝对布局、固定布局方式来实现各种排版效果。如果需要浮动，则借助 float。</p>
<p>但这种传统的方式，一来使用较复杂，二来某些排版效果不好实现，如列表、居中、响应式布局等效果。</p>
<p>而 flex 则能够很好的完成传统的布局工作，而且，它还可以支持响应式布局。</p>
<h3 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h3><h4 id="两根轴线"><a href="#两根轴线" class="headerlink" title="两根轴线"></a>两根轴线</h4><p>当使用 flex 布局时，首先想到的是两根轴线：主轴和交叉轴。主轴由 flex-direction 定义，另一根轴垂直于它。我们使用 flexbox 的所有属性都跟这两根轴线有关, 所以有必要在一开始首先理解它。 </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-08cdf2e794ab15ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flex">  </p>
<p>理解主轴和交叉轴的概念对于对齐 flexbox 里面的元素是很重要的；因为 flexbox 的特性是沿着主轴或者交叉轴对齐之中的元素。 </p>
<h4 id="布局空白"><a href="#布局空白" class="headerlink" title="布局空白"></a>布局空白</h4><p>布局空白：available space，大概来说，flex 容器大小扣掉 items 的 flex-basis 指定的占据的空间大小之外剩余的区域，flex-basis 通常是指 item 本身的大小，当然也可以手动设置。</p>
<p>flex 的一些属性就是通过改变 flex 容器中的布局空白分配来达到对齐等效果的。</p>
<p>比如 items 的 flex-grow 拉伸或者 flex 容器的 justify-content 主轴对齐等，其实就是将这些布局空白按照不同算法分配给各个 item，分给 item 时，是要直接填充进 item 的内容里达到拉伸效果，还是就简单的将空白围绕在 item 周围达到类似 margin 效果来实现 item 的居中、靠左、靠右、均分等对齐方式。</p>
<p>具体属性不了解没关系，下面的章节会讲，知道概念即可。</p>
<h3 id="2-flex相关属性"><a href="#2-flex相关属性" class="headerlink" title="2.flex相关属性"></a>2.flex相关属性</h3><p>对任意块级元素标签设置 display: flex 即可让这个元素作为 flex 容器存在，也就可以使用 flex 的相关属性了。</p>
<p>flex 的属性并不多，目前只有 13 个，其中有 7 个是 flex 弹性盒子容器本身所使用的属性，6 个是 flex-item 弹性盒子的子项使用的属性。其中，有些属性只是将其他属性的集中简化使用，因此，真正具有布局用途的属性并不多，很好掌握。</p>
<p>作用于 flex 弹性盒子容器身上的属性：</p>
<h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-direction: row(default) | row-reverse | column | column-reverse</span><br></pre></td></tr></table></figure>

<p>用于设置主轴的方向，flex 分主轴和交叉轴两个概念，items 布局时，默认延主轴方向进行，因此通过设置主轴是水平方向还是垂直方向就可以实现 items 的水平或垂直布局。</p>
<ul>
<li>row：默认值，设置主轴为水平方向</li>
<li>column：设置主轴为垂直方向</li>
</ul>
<p>其他属性就不介绍了，因为主轴方向就两个，要么水平，要么垂直，其他的区别仅在于水平时是从左到右，还是从右到左，所以这个属性的影响因素之一的 LTR 和 RTL，但没必要考虑这么多，这些场景应该不多，知道这个是用来设置主轴方向就够了，我觉得。</p>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-fc89a44d228d398d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flex-direction">  </p>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-wrap: nowrap(default) | wrap | wrap-reverse</span><br></pre></td></tr></table></figure>

<p>用于设置是否允许换行，默认值 nowrap。</p>
<p>当设置了 wrap 时，允许 items 在主轴方向溢出时自动进行换行布局，这点可以很好的用来实现响应式布局，比如当空间逐渐缩小时，原本水平排列的控件换成垂直方向排版。</p>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-9a74643008a31410.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flex-wrap">  </p>
<h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-flow: &lt;&apos;flex-direction&apos;&gt; || &lt;&apos;flex-wrap&apos;&gt;</span><br></pre></td></tr></table></figure>

<p>这个属性并没有另外的含义，它只是 flex-direction 和 flex-wrap 的简写用法而已。</p>
<p>如果你不想单独使用上述两个属性，可以将它们一起在 flex-flow 使用，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-flow: row wrap</span><br><span class="line">//等效于</span><br><span class="line">flex-direction: row;</span><br><span class="line">flex-wrap: wrap;</span><br></pre></td></tr></table></figure>

<h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">justify-content: normal(default) | &lt;content-distribution&gt; | &lt;overflow-position&gt;? [ &lt;content-position&gt; | left | right ]</span><br><span class="line">where </span><br><span class="line">&lt;content-distribution&gt; = space-between | space-around | space-evenly | stretch</span><br><span class="line">&lt;overflow-position&gt; = unsafe | safe</span><br><span class="line">&lt;content-position&gt; = center | start | end | flex-start | flex-end</span><br></pre></td></tr></table></figure>

<p>用于设置 items 在主轴方向上的对齐方式，可以靠左，靠右，居中或者按比例均分等效果。</p>
<p>需要先明确一点概念，对齐是指 items 在 flex 容器中的排版对齐方式，那么要想 flex 容器可以控制 items 的对齐方式，那主轴方向上自然就还需要有布局空白，如果都没有布局空白了，不就表明 items 已充满 flex 容器了，那谈何对齐。</p>
<p>那么，如果存在至少一个 item，它的 flex-grow 属性不等于 0，justify-content 这个属性就失效了，因为 flex-grow 表示允许 item 按照比例瓜分布局空白，这样一来布局空白被瓜分完了，flex 容器在主轴方向上已被 items 充满， 也就没有对齐一说了。</p>
<p>所以要能够正确的使用该属性来控制 items 在主轴方向的对齐方式，那么就需要注意 item 中会影响布局空白的属性，如 flex-grow，flex-basis 这些的使用。</p>
<p>下面看看各属性值介绍（下面的介绍不考虑 RTL 的情况，默认都以 LTR 为主）：</p>
<ul>
<li>start：主轴是水平方向的话，左对齐方式排版；主轴是垂直方向的话，上对齐方式排版；</li>
<li>end：主轴是水平方向的话，右对齐方式排版；主轴是垂直方向的话，下对齐方式排版； </li>
<li>center：居中方式排版；</li>
<li>space-between：等比例瓜分布局空白，每行首元素对齐，末元素对齐，每行各元素间距一致； </li>
<li>space-around：与上述的类似效果，区别仅在于，每行首元素并不是在 flex 容器内容区域左边就开始布局，它距离 flex 容器左边的距离等于各个元素之间间距的一半。说白点，就是行首元素和末尾元素的周边有类型 margin 值存在。 </li>
</ul>
<p>剩余的属性值不介绍了，因为我也还没有搞懂它们的含义和应用场景。</p>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-196cce807ce5f660.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="justify-content">  </p>
<p>(ps：flex 容器设置了 padding，所以 start 和 end 才没有贴靠边界 )</p>
<h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">align-items: normal | stretch | &lt;baseline-position&gt; | [ &lt;overflow-position&gt;? &lt;self-position&gt; ]</span><br><span class="line">where </span><br><span class="line">&lt;baseline-position&gt; = [ first | last ]? baseline</span><br><span class="line">&lt;overflow-position&gt; = unsafe | safe</span><br><span class="line">&lt;self-position&gt; = center | start | end | self-start | self-end | flex-start | flex-end</span><br></pre></td></tr></table></figure>

<p>用于控制 items 在交叉轴方向上的排版布局方式，justify-content 是能控制主轴上的排版，而这个属性则是用于控制交叉轴，通常两个都会一起使用，相互结合，可以达到一些类似页面居中效果。</p>
<p>看看属性值：</p>
<ul>
<li>flex-start：交叉轴方向，从起点开始布局排版</li>
<li>flex-end：交叉轴方向，从末尾开始布局排版</li>
<li>center：交叉轴方向，从中间开始布局排版</li>
<li>stretch：交叉轴方向，如果 items 在交叉轴方向没有设置大小，那么让 items 在交叉轴的方向充满 flex 容器的高度。</li>
</ul>
<p>其他属性不介绍了，不熟悉。</p>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6ce0c20a2721cd63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="align-items">    </p>
<p>(ps：flex 容器设置了 padding，所以 start 和 end 才没有贴靠边界 )</p>
<p>stretch 要能够生效，需要在 items 在交叉轴方向的不设置大小，如上图中主轴是水平方向，那么 items 需要不设置 height，此时 stretch 才能够让 items 拉伸占据交叉轴的高度。</p>
<p>有一点需要注意，当 flex 容器的 items 在主轴方向上只有一行时，可以很明确的使用这个属性来控制在交叉轴的排版方式。但，如果 items 在主轴上超过一行，那么最终的效果可能就不是想要的了，比如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-bac610aee3b3dddc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="align-items2">  </p>
<p>如果是想实现多行的 items 都作为一个整体居中，那么用 align-items 就无法实现了，针对这种有多行的情况，需要用另外一个属性来控制：align-content。</p>
<h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">align-content: normal | &lt;baseline-position&gt; | &lt;content-distribution&gt; | &lt;overflow-position&gt;? &lt;content-position&gt;</span><br><span class="line">where </span><br><span class="line">&lt;baseline-position&gt; = [ first | last ]? baseline</span><br><span class="line">&lt;content-distribution&gt; = space-between | space-around | space-evenly | stretch</span><br><span class="line">&lt;overflow-position&gt; = unsafe | safe</span><br><span class="line">&lt;content-position&gt; = center | start | end | flex-start | flex-end</span><br></pre></td></tr></table></figure>

<p>当 flex 容器的 items 设置了溢出换行属性，且当前在交叉轴方向上存在多行 item 的情况下，该属性才会生效。</p>
<p>网上有种翻译，说这个属性是用于轴对齐，我不是很理解，我自己粗俗的分两种情况理解：</p>
<p>当需要进行 start, center, end 这些排版时，是将这些多行的 items 都看成一个整体，然后进行交叉轴方向上的排版控制。此时，将多行 item 看成一行之后，那么这个 align-content 之后的排版布局就跟 align-items 一样的效果了。</p>
<p>其他的 space-around，space-between 究竟是如何计算排版的，不熟悉。</p>
<p>属性值含义不看了，跟 align-items 一样的效果，直接看示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a4b4b11bb9799c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="align-content">  </p>
<p>(ps：flex 容器设置了 padding，所以 start 和 end 才没有贴靠边界 )</p>
<h4 id="place-content"><a href="#place-content" class="headerlink" title="place-content"></a>place-content</h4><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">place-content: &lt;&apos;align-content&apos;&gt; &lt;&apos;justify-content&apos;&gt;?</span><br></pre></td></tr></table></figure>

<p>这个属性并没有另外的含义，它只是 align-content 和 justify-content 的简写用法而已。</p>
<p>如果你不想单独使用上述两个属性，可以将它们一起在 place-content 使用，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">place-content: center center</span><br><span class="line">//等效于</span><br><span class="line">align-content: center;</span><br><span class="line">justify-content: center;</span><br></pre></td></tr></table></figure>

<p>作用于 flex-item 弹性盒子的子项身上的属性：</p>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-basis: content | &lt;&apos;width&apos;&gt;</span><br><span class="line"></span><br><span class="line">where </span><br><span class="line">&lt;&apos;width&apos;&gt; = [ &lt;length&gt; | &lt;percentage&gt; ] &amp;&amp; [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto</span><br></pre></td></tr></table></figure>

<p>用于设置 items 在主轴方向的大小，如果主轴是水平方向，相当于设置 width，此时，该属性值会覆盖掉 width 设置的大小。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-abb7feeb207f305d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ps">  </p>
<p>尝试了下，在 chorme 浏览器上 content 属性不生效，不清楚，可能不同浏览器行为还不一样，既然这样，就先暂时不深入了解这个属性了，大概知道用于设置主轴方向上的 item 大小即可。</p>
<p>就算要使用，先直接用指定数值大小的方式好了。</p>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-grow: &lt;number&gt;</span><br></pre></td></tr></table></figure>

<p>用于设置 item 在主轴方向上的拉伸因子，即如果 flex 容器还有剩余空间，会按照各 item 设置的拉伸因子比例关系分配。默认值为 0，即不拉伸。</p>
<p>作用很像 Andorid 中的 LinearLayout 的 child 里设置了 layout_weight 用途一样。</p>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-28701dfa2bfefc3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flex-grow">  </p>
<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-shrink: &lt;number&gt;</span><br></pre></td></tr></table></figure>

<p>用于设置 item 在主轴方向上的收缩因子，跟 flex-grow 刚好反着来。当 flex 容器空间不够，item 要溢出时，设置次属性可控制 item 按比例进行相应收缩，以便不让 item 溢出，默认 1，值越大收缩倍数越大，最后 item 就越小，0 表示不收缩，负值无效。</p>
<p>另外，如果设置了换行属性，那么这个就无效了。换行和收缩都是用于解决 item 在主轴方向上溢出的问题，既然是互斥，且换行优先级高，那么设置了换行，就不会再对 item 进行收缩了。</p>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-456ce486db29b432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flex-shrink">  </p>
<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex: none | auto | initial | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]</span><br></pre></td></tr></table></figure>

<p>这属性是 flex-grow，flex-shrink，flex-basis 三个属性的简化使用，有三种属性值：</p>
<ul>
<li>none：元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应flex容器。相当于将属性设置为 <code>flex: 0 0 auto</code>。 </li>
<li>auto：元素会根据自身的宽度与高度来确定尺寸，但是会自行伸长以吸收flex容器中额外的自由空间，也会缩短至自身最小尺寸以适应容器。这相当于将属性设置为 <code>flex: 1 1 auto</code>. </li>
<li>initial：属性默认值， 元素会根据自身宽高设置尺寸。它会缩短自身以适应容器，但不会伸长并吸收flex容器中的额外自由空间来适应容器 。相当于将属性设置为”<code>flex: 0 1 auto</code>“。 </li>
</ul>
<p>flex 属性可以指定 1 个，2 个或 3 个值。</p>
<p><strong>单值语法</strong>: 值必须为以下其中之一:</p>
<ul>
<li>一个无单位<strong>数(&lt;number&gt;)</strong>: 它会被当作 <code>&lt;flex-grow&gt;的值。</code></li>
<li>一个有效的<strong>宽度(width)</strong>值: 它会被当作 <code>&lt;flex-basis&gt;的值。</code></li>
<li>关键字 <code>none, auto</code>,或<code>initial</code>.</li>
</ul>
<p><strong>双值语法</strong>: 第一个值必须为一个无单位数，并且它会被当作<code>&lt;flex-grow&gt;的值。第二个值必须为以下之一：</code></p>
<ul>
<li>一个无单位数：它会被当作<code>&lt;flex-shrink&gt;的值。</code></li>
<li>一个有效的宽度值: 它会被当作<code>&lt;flex-basis&gt;的值。</code></li>
</ul>
<p><strong>三值语法:</strong></p>
<ul>
<li>第一个值必须为一个无单位数，并且它会被当作<code>&lt;flex-grow&gt;的值。</code></li>
<li>第二个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-shrink&gt;的值。</code></li>
<li>第三个值必须为一个有效的宽度值， 并且它会被当作<code>&lt;flex-basis&gt;的值。</code></li>
</ul>
<h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">align-self: auto | normal | stretch | &lt;baseline-position&gt; | &lt;overflow-position&gt;? &lt;self-position&gt;</span><br><span class="line">where </span><br><span class="line">&lt;baseline-position&gt; = [ first | last ]? baseline</span><br><span class="line">&lt;overflow-position&gt; = unsafe | safe</span><br><span class="line">&lt;self-position&gt; = center | start | end | self-start | self-end | flex-start | flex-end</span><br></pre></td></tr></table></figure>

<p>用于给单个 item 设置交叉轴方向上的排版布局方式，属性值和作用跟 align-items 一样，区别仅在于 align-items 是 flex 容器的属性，它会作用于所有的 items 上；而 align-self 允许对单个 item 设置，该值会覆盖 align-items 设置的属性值。</p>
<p>这样就可以实现控制交叉轴上的每个 item 的不同布局方式，如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5ee64d58ee132497.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="align-items"></p>
<h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">order: &lt;integer&gt;</span><br></pre></td></tr></table></figure>

<p>用于控制 items 的排版顺序，item 将按照 order 属性值的增序进行布局。拥有相同 order 属性值的元素按照它们在源代码中出现的顺序进行布局。默认值为 0，可设置负值，排序将在默认不设置的 item 前面。 </p>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-326dd86eb0d1ee85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="order"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我觉得，这些属性大体记得每个属性的主要用途即可，至于每个属性值如何设置，如何相互结合使用可以达到什么样的效果，写代码的时候再调就是了。</p>
<h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h3><p>以下场景中，如没有特别指明，flex 容器基本样式和 item 基本样式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.dot</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">28px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>长这个样子：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-9f2db5850a9a9d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本样式">  </p>
<p>白色区域是 flex 容器，黑色圆圈是 item。</p>
<h4 id="场景1"><a href="#场景1" class="headerlink" title="场景1:"></a>场景1:</h4><p>在页面中把一个元素居中：item 水平、垂直方向都居中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;<span class="comment">/* 声明这个元素作为 flex 容器 */</span></span><br><span class="line">    <span class="attribute">flex-direction</span>: row;<span class="comment">/*主轴为水平方向*/</span></span><br><span class="line">    <span class="attribute">justify-content</span>: center;<span class="comment">/*水平居中*/</span></span><br><span class="line">    <span class="attribute">align-items</span>: center;<span class="comment">/*垂直居中*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a51d6aced1b8644f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景1">  </p>
<h4 id="场景2："><a href="#场景2：" class="headerlink" title="场景2："></a>场景2：</h4><p>前后有固定大小 item，中间区域自动拉伸占据可用空间。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> &gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.flex</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="css">    <span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;<span class="comment">/* 声明这个元素作为 flex 容器 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">flex-direction</span>: <span class="selector-tag">row</span>;<span class="comment">/*主轴为水平方向*/</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dot"</span> &gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dot"</span> <span class="attr">style</span>=<span class="string">"flex-grow: 1"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dot"</span> &gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-bbf735fb6e50cfbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景2">  </p>
<h4 id="场景3："><a href="#场景3：" class="headerlink" title="场景3："></a>场景3：</h4><p>响应式布局，在屏幕尺寸允许的情况下呈水平布局，但是在屏幕不允许的情况下可以水平折叠。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.flex</span><br><span class="line">&#123;</span><br><span class="line">    display: flex;/* 声明这个元素作为 flex 容器 */</span><br><span class="line">    flex-direction: row;/*主轴为水平方向*/</span><br><span class="line">    flex-wrap: wrap;/*溢出时换行*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-2624d00b8b06428e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景3">  </p>
<h4 id="场景4："><a href="#场景4：" class="headerlink" title="场景4："></a>场景4：</h4><p>水平排列的一组 item 中，前几个左对齐，后几个右对齐。</p>
<p>这个需要结合块级元素的 margin 属性使用，当设置 margin: auto 时表示，将尽可能占据足够多的空间。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> &gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.flex</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="css">    <span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;<span class="comment">/* 声明这个元素作为 flex 容器 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">flex-direction</span>: <span class="selector-tag">row</span>;<span class="comment">/*主轴为水平方向*/</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dot"</span> &gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dot"</span> &gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dot"</span> <span class="attr">margin-left</span>=<span class="string">"auto"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-43f4d7ec238e1ad8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景4">  </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>前端04-CSS属性样式表（入门）</title>
    <url>/2018/10/29/%E5%89%8D%E7%AB%AF/%E5%85%A5%E9%97%A8/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A84-CSS%E5%B1%9E%E6%80%A7%E6%A0%B7%E5%BC%8F%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下四个来源：</p>
<ul>
<li>《HTML5权威指南》</li>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
</ul>
<p>作为一个前端小白，入门跟着这四个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<h1 id="正文-CSS属性样式表"><a href="#正文-CSS属性样式表" class="headerlink" title="正文-CSS属性样式表"></a>正文-CSS属性样式表</h1><p>了解了 CSS 具体的各种工作原理、使用方式、选择器规则、层叠算法等之后，那么该来学习的也就是 css 都支持哪些属性样式表了。</p>
<h3 id="1-单位"><a href="#1-单位" class="headerlink" title="1.单位"></a>1.单位</h3><p><strong>in，cm，mm，px，em，%</strong></p>
<p>绝对单位：1in（英寸） = 2.54cm（厘米） = 25.4mm（毫米） = 72pt（英镑points） = 6pc（皮卡picas）</p>
<p>相对单位：px（像素）， em（相对于font-size的大小）， %（百分比）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-35f6fd5d851c87a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单位">  </p>
<h3 id="2-字体-font-xxx"><a href="#2-字体-font-xxx" class="headerlink" title="2.字体 font-xxx"></a>2.字体 font-xxx</h3><table>
<thead>
<tr>
<th>font-size: 20px;</th>
<th>字体大小</th>
</tr>
</thead>
<tbody><tr>
<td>line-height: 30px;</td>
<td>行高</td>
</tr>
<tr>
<td>font-family: 微软雅黑;</td>
<td>字体</td>
</tr>
<tr>
<td>font-style: italic;</td>
<td>斜体，normal正常字体</td>
</tr>
<tr>
<td>font-weight: bold;</td>
<td>粗体</td>
</tr>
<tr>
<td>font-variant: small-caps;</td>
<td>小写变大写</td>
</tr>
</tbody></table>
<p>font-xxx, line-xxx 属性具有继承性，后代会继承祖先标签内的这些属性。</p>
<h3 id="3-文本-text-xxx"><a href="#3-文本-text-xxx" class="headerlink" title="3.文本 text-xxx"></a>3.文本 text-xxx</h3><table>
<thead>
<tr>
<th align="left">letter-spacing: 0.5cm;</th>
<th>单个字母之间的间距</th>
</tr>
</thead>
<tbody><tr>
<td align="left">word-spacing: 1cm;</td>
<td>单词之间的间距</td>
</tr>
<tr>
<td align="left">text-decoration: none;</td>
<td>字体修饰，none:去掉下划线，underline下划线，line-through中划线，overline上划线</td>
</tr>
<tr>
<td align="left">text-transform: lowercase;</td>
<td>单词小写，uppercase大写,   capitalize首字母大写</td>
</tr>
<tr>
<td align="left">color:red;</td>
<td>字体颜色</td>
</tr>
<tr>
<td align="left">text-align: center;</td>
<td>在当前容器中对齐方式，left,right,justify</td>
</tr>
</tbody></table>
<p>text-xxx具有继承性，后代标签会继承祖先中声明的这些属性，想让文本居中显示时，如果属性不生效，可自行计算，如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-13fa9f41375bdfd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字体">  </p>
<h3 id="4-背景-background-xxx"><a href="#4-背景-background-xxx" class="headerlink" title="4.背景 background-xxx"></a>4.背景 background-xxx</h3><h4 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a>background-color</h4><p>设置元素背景颜色，属性值有三种方式：red, rgb(255, 0, 0), #ff0000</p>
<p>以上三种均表示红色。以下是几种常见的颜色：</p>
<p>#000（黑） #fff（白） #f00（红） #222（深灰）#333（灰）#ccc（浅灰）</p>
<h4 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h4><p>设置背景图片是否重复，以及如何重复，默认平铺满。属性值如下：</p>
<ul>
<li>no-repear         不要平铺</li>
<li>repeat-x            横向平铺</li>
<li>repeat-y            纵向平铺</li>
</ul>
<p>应用场景：可以类似于 Android 中的 .9 图，设计一张 1px 的背景图，指定横向或者纵向平铺。</p>
<h4 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h4><p>指定背景图位置，几种格式如下：</p>
<p>background-position: 向右偏移量 向下偏移量;</p>
<p>属性值可以是正数，也可以是负数。比如：<code>100px 200px</code>，<code>-50px -120px</code></p>
<p>background-position: 描述左右的词 描述上下的词;</p>
<p>描述左右的词：left、center、right</p>
<p>描述上下的词：top 、center、bottom</p>
<p>比如说，right center表示将图片放到右边的中间；center center表示将图片放到正中间。</p>
<p>这个属性既可以用于在一张包含各种 icon 种只显示指定区域的 icon，也可用于在文本四周添加 icon。</p>
<h4 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h4><p>设置背景图片是否固定，属性值：</p>
<ul>
<li>fixed     背景固定住，不会被滚动条滚走</li>
<li>scroll    默认属性，背景跟随滚动条滑动</li>
</ul>
<h4 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h4><p>背景默认延伸到边界的外边缘，如果你只想背景扩展到内容区的边缘，可通过这个属性设置。 </p>
<h4 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h4><p>设置盒子的轮廓，它看起来像边界，但不是盒模型的一部分，是画在边界框之外，外边距之内，但不会修改盒子的大小。 </p>
<h4 id="background"><a href="#background" class="headerlink" title="background"></a>background</h4><p>以上属性的综合属性，如果不想一个个属性的去写，可以用这个属性集中写在一起。格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">-color</span> –<span class="selector-tag">image</span> –<span class="selector-tag">repeat</span> –<span class="selector-tag">position</span> –<span class="selector-tag">attachment</span></span><br><span class="line">//如</span><br><span class="line"><span class="selector-tag">background</span><span class="selector-pseudo">:red</span> <span class="selector-tag">url</span>(1<span class="selector-class">.jpg</span>) <span class="selector-tag">no-repeat</span> 100<span class="selector-tag">px</span> 100<span class="selector-tag">px</span> <span class="selector-tag">fixed</span>;</span><br></pre></td></tr></table></figure>

<p>等效于：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span><span class="selector-pseudo">:red</span>;</span><br><span class="line"><span class="selector-tag">background-image</span><span class="selector-pseudo">:url(1.jpg)</span>;</span><br><span class="line"><span class="selector-tag">background-repeat</span><span class="selector-pseudo">:no-repeat</span>;</span><br><span class="line"><span class="selector-tag">background-position</span><span class="selector-pseudo">:100px</span> 100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">background-attachment</span><span class="selector-pseudo">:fixed</span>;</span><br></pre></td></tr></table></figure>

<p>另外，背景是可以设置多个的，多个背景间会自动重叠在一起，并不是像 Android 中只能设置一个背景。</p>
<h3 id="5-盒子-width-height…"><a href="#5-盒子-width-height…" class="headerlink" title="5.盒子 width height…"></a>5.盒子 width height…</h3><h4 id="width-amp-height"><a href="#width-amp-height" class="headerlink" title="width&amp;height"></a>width&amp;height</h4><p>设置内容的宽高，并不是盒子的宽高，但可通过 box-sizing 来更改宽高的作用域。</p>
<p>Android 中必须给控件设置宽高，但在这里，宽高并不是必选像。当没有设置宽高时，会根据其显示模式 display 来决定其默认宽高。</p>
<p>比如，display: block 块级元素默认高度会霸占父节点 100% 宽度，而高度默认会由子内容决定，类似于 Android 中的 wrap_content。</p>
<p>display: inline 行内元素则是无法设置宽高，默认为文本内容的宽高。</p>
<p>除了正常宽高外，还有其他一些可选项配置：</p>
<p>min-width, min-height, max-width, max-height</p>
<p>借助这些配置，可以达到一些当窗口大小变化时，变化到一定程度改变原有元素的表现行为，比如某张图片本来居中显示，但当窗口缩小到比图片还小时，图片就根据窗口进行缩小，此时就可结合 max-width 来实现。</p>
<h4 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h4><p>padding：-top –right –bottom -left</p>
<p>设置内边距 </p>
<h4 id="border"><a href="#border" class="headerlink" title="border"></a>border</h4><p>border：-width –style –color </p>
<p>设置边框 </p>
<h4 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h4><p>margin：-top –right –bottom -left</p>
<p>设置外边距</p>
<p>注意一点，margin 跟 Android 中的 margin 有些不一样，对某个元素设置了 margin 后，margin 区域的大小也算在这个元素盒子的大小中。</p>
<p>另外，默认的文档流中，上下方向会存在 margin 塌陷的情况，也就是上一个元素设置了 margin-bottom: 10px，下一个元素设置了 margin-top: 20px，那么最终这两个元素其实间距为 20px，并不是叠加的。</p>
<p>另外，margin 通常是用于兄弟节点间设置间距，如果要设置儿子和父亲间的间距，建议使用 padding，否则如果父节点没有设置 border 时，可能效果并不是想要的。</p>
<p>margin: 0 auto;  可以达到水平居中的效果。</p>
<p>&lt;body&gt;标签，浏览器通常默认给了 margin: 8px</p>
<p>&lt;ul&gt; 默认有设置 margin-left 和 padding-top</p>
<p>所以，通常都会有一份 reset.css，来重置这些默认属性值。</p>
<h3 id="6-阴影-box-shadow-amp-text-shadow"><a href="#6-阴影-box-shadow-amp-text-shadow" class="headerlink" title="6.阴影 box-shadow&amp;text-shadow"></a>6.阴影 box-shadow&amp;text-shadow</h3><p><img src="https://upload-images.jianshu.io/upload_images/1924341-23fe37c79d07017c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="阴影">  </p>
<p>你会看到，我们在 box-shadow 属性值中有4个项：</p>
<ul>
<li>第一个长度值是水平偏移量（horizontal offset ）——即向右的距离，阴影被从原始的框中偏移(如果值为负的话则为左)。</li>
<li>第二个长度值是垂直偏移量（vertical offset）——即阴影从原始盒子中向下偏移的距离(或向上，如果值为负)。</li>
<li>第三个长度的值是模糊半径（blur radius）——在阴影中应用的模糊度。</li>
<li>颜色值是阴影的基本颜色（base color）。</li>
</ul>
<p>如果需要内部阴影，则是在上述属性值最前面加一个 inset 如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">inset</span> 2<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> <span class="selector-tag">black</span></span><br></pre></td></tr></table></figure>

<h3 id="7-显示模式-display"><a href="#7-显示模式-display" class="headerlink" title="7.显示模式 display"></a>7.显示模式 display</h3><h4 id="标准文档流布局方式"><a href="#标准文档流布局方式" class="headerlink" title="标准文档流布局方式"></a>标准文档流布局方式</h4><p>当没有进行任何 CSS 控制元素的排版布局时（float, position, flex）默认就是按照标准的文档流布局方式进行排版布局绘制元素。</p>
<p>而这个标准的文档流布局方式就是按照解析 HTML 文档元素的顺序，从页面顶部开始，从上到下，从左到右，解析一个元素就绘制一个元素，解析时碰到的是行内元素，就忽略宽高，允许并排布局绘制，碰到的是块级元素，就另一起一行，让这个元素霸占父元素中的这一整行。</p>
<p>所以，清楚了浏览器默认的文档流布局方式后，得再了解下所说的行内元素，块级元素是什么，怎么切换。</p>
<h4 id="inline-行内元素-amp-block-块级元素"><a href="#inline-行内元素-amp-block-块级元素" class="headerlink" title="inline(行内元素)&amp;block(块级元素)"></a>inline(行内元素)&amp;block(块级元素)</h4><p>display 有两个很基本的属性值：inline（行内元素） block（块级元素）</p>
<p>通常，容器类的标签默认值都是 block，而文本类的标签默认值是 inline。</p>
<p>比如：div, header, main, li, h 系列这类都是块级元素</p>
<p>p, span, I, a 这类都是行内元素。</p>
<p>区分以及理解行内元素和块级元素对于写网页布局非常重要，因为浏览器是按照文档流从上到下，从左到右来进行绘制网页的。</p>
<p>对于行内元素（inline），浏览器绘制时会忽略对它设置的宽高，并且如果相邻两个元素都是行内元素，则直接以并排方式从左到右对其进行布局绘制。</p>
<p>但对于块级元素，浏览器会强制让其霸占一整行，也就是这一行内，只能有这个块级元素存在，其他元素不能与其并排。如果没有设置宽度，那么就是充满整行。</p>
<p>这个整行是想对于父元素的区域而言，并不是浏览器页面的整行 。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5103ca8f7cc64f75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文档流布局方式">  </p>
<p>这种默认的标准文档流的布局绘制方式有些类似于 Android 中的 LinearLayout 容器，inline 就类似于水平方向， block 就类似于垂直方向，同一个方向内只能有一个元素霸占，不允许并排。</p>
<p>所以，我们在写 HTML，CSS 时，脑中就要有个大概的蓝图，这些元素大概会呈现怎样的排版布局。</p>
<p>一个元素是行内元素还是块级元素，可以通过 display 来设置，如果没有设置，那么就是默认值，不同元素的默认值不同。</p>
<p>如果行内元素不支持设置宽高，块级元素又不允许并排存在，那么很显然，很多布局我们就实现不了了。是吧，如果既要能够并排，还要支持可以设置宽高，这是该怎么办呢？</p>
<p>解决方法有很多种，说白了就是一点：脱离默认的文档流布局方式</p>
<p>方式有以下几种：</p>
<ul>
<li>display:inline-block（行内块元素）</li>
<li>浮动 float: left/right</li>
<li>绝对定位 position: absolute</li>
<li>固定定位 position: fixed</li>
</ul>
<h4 id="inline-block-行内块元素"><a href="#inline-block-行内块元素" class="headerlink" title="inline-block(行内块元素)"></a>inline-block(行内块元素)</h4><p>当设置了 display: inline-block 时，这时这个元素就不会霸占一整行了，而是根据设置的宽高来布局绘制，因此这种情况下，可以解决并排的场景。</p>
<p>但需要注意下，最好不要有这样的布局：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">”display:inline-block”</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">”display:block”</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">”display:inline-block</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也就是行内块元素嵌套了块级元素内部又嵌套了行内块元素，这样的话，布局方面会有些问题，原因不清楚。但把中间的块级元素也设置成行内块元素就没问题了。</p>
<p>另外，并不是说，不允许行内块元素内嵌块级元素，也是可以的。</p>
<h3 id="8-浮动-float"><a href="#8-浮动-float" class="headerlink" title="8.浮动 float"></a>8.浮动 float</h3><p>float 属性值通常会用到这两个：left  right</p>
<p>浏览器默认是按照标准文档流从上到下，从左到右布局绘制各个元素，此时这些元素可以说位于同一个层面，但当碰到元素设置了 float 属性时，会将这个元素以当前绘制的位置抽离到新的层面上进行布局。</p>
<p>就像单词直译过来：浮动</p>
<p>也就是让这个元素浮在标准文档流上面。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-0c5d6f9fe85a5403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="float">  </p>
<p>浏览器绘制这个网页时，按照文档流顺序，先在网页第一行左边开始处理 div1 元素，发现它的一个浮动元素，则将其抽离到另一个层面，浮动在文档流上面。</p>
<p>然后它继续处理 div2 元素，因为之前处理的 div1 元素是浮动元素，不占用文档流，所以此时仍旧是在第一行左边绘制 div2 元素，发现它是一个块级元素，所以让其霸占一整行。</p>
<p>所以，此时可以看到 div1 浮在 div2 上面的效果。</p>
<p>紧接着，继续处理 div3 元素，因此之前 div2 块级元素已经霸占了第一行了，所以此时是在第二行处理 div3 元素，发现它也是一个浮动元素，便以当前位置将其抽离到另一层面绘制。</p>
<p>所以此时看到的效果就是，浮动元素 div3 是在块级元素 div2 下。</p>
<p>继续往下处理，如果发现的还是浮动元素，因为所有的浮动元素都处理同一层面，所有的文档流元素都处于一个层面，所有浮动元素 div4 并不会跟 div3 发生重叠，而是贴着它。</p>
<p>如果接下去处理的元素是块级元素，那么此时的效果会是怎样的呢？</p>
<p>如果接下去是块级元素，那么它就会是绘制在浮动元素 div3 和 dive4 下面，呈现出重叠的效果。</p>
<p>但这里需要注意一点，<strong>虽然浮动元素会造成重叠的现象，但这只是正常的文档流的元素盒子被浮动元素压住了，但文档流元素的文本内容会自动围绕在浮动元素周围，就像上图中块级元素四个字并没有被覆盖住</strong>。</p>
<p>也就是说，浮动元素并不会造成文档流的内容被覆盖的情况，反而它会影响到它之后文档流中元素的内容区域的显示排版。如果不想让后面的元素受到浮动元素的影响，那么就要进行浮动清除处理。</p>
<p>另外，不考虑嵌套元素的话，兄弟元素之间，如果处于同一层面，是不会有重叠现象的。</p>
<h4 id="浮动清除"><a href="#浮动清除" class="headerlink" title="浮动清除"></a>浮动清除</h4><p>由于浮动最初设计是为了让文字可以围绕在图片周围，因此，浮动元素后面的非浮动元素会自动围绕着浮动元素进行包装。而如果我们想让浮动元素之后的元素另起一行，从新的位置开始布局，那么就要进行浮动的清除。</p>
<p>另外，浮动元素之后的浮动元素也会受到它的影响，比如设置了 float:left，那么这个元素要浮动的靠左的位置会受到前面已经靠左浮动的元素的影响。</p>
<p>如果不想让当前的浮动元素受到之前浮动元素的影响，那么也要进行浮动清除的处理，方式有几种，每种有自己的适用场景，了解下即可，后续写多了，自然就懂了。</p>
<ul>
<li>clear: both 表示当前元素不受之前浮动元素的影响</li>
<li>隔墙法（在两部分浮动元素中间，建一个墙。隔开两部分浮动，让后面的浮动元素，不去追前面的浮动元素。本质上也是clear:both）</li>
</ul>
<h4 id="浮动的不足"><a href="#浮动的不足" class="headerlink" title="浮动的不足"></a>浮动的不足</h4><p>浮动虽然好用，既可以实现文字围绕的效果，又可以实现多列并排的布局，但它也存在一些不足的地方，上面说的浮动清除是其中一点，还有一些问题，如下：</p>
<ul>
<li>整个宽度可能难以计算</li>
</ul>
<p>​       这是因为多个浮动元素之间并排显示的前提的有足够的空间让这些元素并排，所以<strong>通常对于浮动元素的宽度设置是通过百分比来设置</strong>，确保多个并排的元素即使窗口发生变化仍旧可以并排布局。</p>
<p>​       但，如果元素还需要进行内边距，外边距的设置，边框的设置，因为这些大小都算在盒子的总宽度中，那么最终盒子的大小就变得很难确定，有可能导致某个浮动元素被挤到下一行去。</p>
<p>​       有个方法可以解决，修改 box-sizing:border-box，让 width 就是盒子总宽度，当设置了边距时，会自动减少相应的内容区域。但如果页面使用不同类型的 box-sizing，会使 CSS 的代码阅读变得很杂乱。</p>
<ul>
<li>浮动元素之后的元素设置 margin 失效</li>
</ul>
<p>​       非浮动元素的外边距不能用于它们和浮动元素之间来创建空间，通常我们再浮动元素之后的非浮动元素会进行浮动清除，顺便设置外边距来创建间隔空间，但这时会发现这个间隔空间失效。解决方法可以在这中间插一个空的元素，在这个元素里清除浮动，也就是所说的隔墙法。 </p>
<h3 id="9-位置-position"><a href="#9-位置-position" class="headerlink" title="9.位置 position"></a>9.位置 position</h3><p>position 属性值有三个：absolute, relative, fixed</p>
<p>三种虽然是不同的定位模式，但其实说白了，就是参考点不同。</p>
<p>也都是通过 left, top, right, bottom 来根据参考掉调整位置。</p>
<h4 id="releative-相对定位"><a href="#releative-相对定位" class="headerlink" title="releative 相对定位"></a>releative 相对定位</h4><p>相对定位并不是相对于父元素，而是相对于该元素原本所应该在的位置作为参考点。</p>
<p>这点跟 Android 中的 ReleativeLayout 布局不一样，需要注意一下。</p>
<p>另外，相对定位并不会改变元素在文档流中的位置，也就是这个元素原本占据哪个坑，通过相对定位微调之后，仍占据那个坑，只是视觉上它发生了移动而已。有点类似 Android 中的 View 动画。</p>
<p>应用场景：</p>
<ul>
<li>微调</li>
<li>让后代元素可以使用绝对定位</li>
</ul>
<p>通常都是用来给后代使用绝对定位的，因为固定定位和绝对定位都会导致该元素从文档流中脱离，就像浮动元素那样，不再占用文档流的坑位。</p>
<p>而相对定位并不会，所以通常父类元素设置了相对定位，而让后代元素使用绝对定位，这样可以让后代元素可以脱离文档流，达到压盖的效果，同时还可以受限于父类元素的范围管控。</p>
<h4 id="absolute-绝对定位"><a href="#absolute-绝对定位" class="headerlink" title="absolute 绝对定位"></a>absolute 绝对定位</h4><p>参考的对象是父类或祖先元素中有使用了position的最近一个元素。也就是说在父类元素中，不管是使用了相对定位，绝对定位，固定定位之后，都可以用来作为后代绝对定位的参考元素。</p>
<p>但通常都是使用子绝父相的模式，其他模式并没有什么意义。</p>
<p>参考的元素决定了之后，参考点的选取还分两种情况，参考元素的左上角或者左下角。</p>
<p>如果使用了 top 来调整位置，那么参考点就是参考元素的左上角</p>
<p>如果使用了 bottom 来调整位置，那么参考点就是参考元素首屏页面的左下角</p>
<p>为什么强调首屏，因为参考元素的大小可能是超出一个屏幕的，bottom 并不是说参考元素的左下角坐标，也不是当前页面参考元素的左下角坐标，而是首屏状态时，也可以理解成，没有发生滑动前，参考元素在当前页面的左下角坐标作为参考点。</p>
<p>举个例子：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-34be36779784934b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="absolute">  </p>
<p>另外，有点需要注意下，绝对定位的元素，因为其已经从文档流中抽离，因此就不存在什么行内元素、块级元素的限制了。大小就是根据设置的宽高、位置就是根据参考点进行调整后进行布局绘制。</p>
<p>而如果没有使用 position 属性，元素默认是文档流处理的，此时的布局绘制方式就只能按照文档流的规则来，即行内元素、块级元素这些特性。</p>
<p>因为绝对定位是将元素脱离出标准文档流，那么绝对定位的元素显示与否，并不会影响到原本的文档流元素，所以，通常一些弹窗框，弹窗控制面板，可在页面上任意拖放的元素等都会通过绝对定位来做。</p>
<p>应用：</p>
<ul>
<li>弹窗框</li>
<li>压盖（角标之类）</li>
</ul>
<h4 id="fixed-固定定位"><a href="#fixed-固定定位" class="headerlink" title="fixed 固定定位"></a>fixed 固定定位</h4><p>固定定位参考点就是浏览器的左上角，不管页面如何发生滑动，元素显示的位置都没有发生改变。</p>
<p>应用：</p>
<ul>
<li><p>网页右下角的返回顶部按钮</p>
</li>
<li><p>顶部导航栏</p>
</li>
</ul>
<h4 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h4><p>这个属性只有当使用了 position 的元素才会生效，其他元素设置了这个属性没有什么意义。</p>
<p>这个属性其实就是用于当元素发生重叠时，决定由谁盖在上面，默认值为0，值越大，越上层。</p>
<p>而会发生元素重叠的现象也就只有使用了 position 调整了元素的位置，以及浮动元素两种场景。正常的文档流方式布局绘制元素是不会出现元素重叠，当然如果是嵌套的元素，层级关系也早就确定了，也没必要通过这个属性来调整了。</p>
<p>浮动元素造成的重叠只是盒子上的重叠，并不会造成元素内容上的重叠，那么也就没有使用 z-index 的必要，因为要呈现的内容并不会被覆盖。</p>
<p>总结一下，这个属性有几个特性：</p>
<ul>
<li>属性值大的位于上层，属性值小的位于下层</li>
<li>z-index 值没有单位，就是一个正整数。默认的 z-index 值是0</li>
<li>如果大家都没有 z-index 值，或者 z-index 值一样，那么在 HTML 代码里写在后面，谁就在上面能压住别人。定位了的元素，永远能够压住没有定位的元素</li>
<li>只有定位了的元素，才能有 z-index 值。也就是说，不管相对定位、绝对定位、固定定位，都可以使用 z-index 值。而浮动的元素不能用</li>
<li>从父现象：父亲怂了，儿子再牛逼也没用。意思是，如果父亲1比父亲2大，那么，即使儿子1比儿子2小，儿子1也能在最上层。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>前端03-CSS基础（入门）</title>
    <url>/2018/10/29/%E5%89%8D%E7%AB%AF/%E5%85%A5%E9%97%A8/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A83-CSS%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下四个来源：</p>
<ul>
<li>《HTML5权威指南》</li>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
</ul>
<p>作为一个前端小白，入门跟着这四个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<h1 id="正文-CSS基础"><a href="#正文-CSS基础" class="headerlink" title="正文-CSS基础"></a>正文-CSS基础</h1><h3 id="1-结构和语法"><a href="#1-结构和语法" class="headerlink" title="1.结构和语法"></a>1.结构和语法</h3><p>首先需要清楚，CSS 职责是控制 HTEM 文档里的文本内容在网页上样式呈现的效果，写的每一个样式最终是通过选择器作用到具体的元素上面。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://upload-images.jianshu.io/upload_images/1924341-a75e5029d8c9b8f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css工作原理">  </p>
<p>互联网其实都是通过网页相互连接组成的，每个网页都是一份 HTML 文档，因此浏览器与后端的首次通信是以 HTML 文档为基准，那么整个流程的第一步也就是解析 HTML 文档。</p>
<p>如果在解析 HTML 文档过程中发现有通过 &lt;link&gt; 标签引用了外部的 CSS 文件时，那么浏览器会去下载相对应的 CSS 文件。</p>
<p>当 HTML 文档解析完毕后会生成一个 DOM 文档结构，DOM 文档结构中记录着每个节点的元素，各元素之间的关系，有点类似于 Android 中的 View 树。</p>
<p>最后，通过 CSS 的选择器将相对应的样式作用到 DOM 中选择器找到的元素节点，然后浏览器渲染呈现在网页上。  </p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://upload-images.jianshu.io/upload_images/1924341-4afd57c67e255fb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css结构">  </p>
<p>以上是一个 CSS 的典型结构，总共由两部分组成：选择器 + 样式</p>
<p>{} 大括号内部的都是具体的某种样式，可用来控制元素的背景、大小、排版位置等样式效果。而 {} 左边的则是选择器，用来指定说后面跟随的样式列表要作用到 HTML 文档中的哪个元素上。</p>
<p>选择器类型很多，规则也很多，因此会有一种现象，就是某个元素被不止一个选择器匹配到，如果某个样式属性起冲突了，那么就会按照一定的优先级顺序处理。</p>
<p>样式属性也很多，具体也后面介绍，但有一点需要先明确一下，如果使用了未知的样式属性，或者给某个样式属性赋予了无效值，那么该样式属性会被视为无效，浏览器的 CSS 引擎会完全忽略它。</p>
<h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><p><img src="https://upload-images.jianshu.io/upload_images/1924341-011f28a0bd92932e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css盒模型">  </p>
<p>跟 Android 很类似，每个元素在页面上都是占据一个矩形区域，也分 margin 和 padding，唯一不同的就是这里的模型多了个 border，虽然在 Android 中也有 border 的概念，但它是在 padding 区域内的，不单独占据某块区域，所以这里需要区分一下。</p>
<p>因此，一个元素在页面上的宽高就是由四个部分共同影响的了：content 区域，padding 区域，border 区域，margin 区域。</p>
<p>需要注意的是，上图中的盒子模式的 box-sizing 属性为默认值 content-box 模式。</p>
<p>这种模式下，width 和 height 指的只是content区域的宽高。</p>
<p>box-sizing 属性的取值有：content-box, padding-box, border-box, margin-box。四种，对应的就是指明 width 和 height 表示的是包含哪些区域的宽高。</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>CSS 基本结构是由选择器和样式属性列表组成，那么如何跟 HTML 文档关联起来使用呢？一共有三种方式： </p>
<ul>
<li><strong>内嵌样式</strong></li>
</ul>
<p>使用 HTML 元素的全局属性 style 声明，仅影响一个元素，除非工作环境受限，比如只允许编辑 HTML 的 body，否则强烈不推荐这种方式。</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.html"</span> <span class="attr">style</span>=<span class="string">"background: gray; color: #6a90d9"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>内部样式表</strong></li>
</ul>
<p>在 HTML 中的  &lt;head&gt; 内使用  &lt;style&gt; 标签，在某些情况下很有用，比如当你不能直接修改 CSS 文件时。</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    a &#123;</span><br><span class="line">        background: gray;</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#6a90d9</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>外部样式表</strong></li>
</ul>
<p>将 CSS 保存在一个独立的扩展名为 .css 的文件中，并在 HTML 的 &lt;head&gt; 里使用  &lt;link&gt; 元素中引用它，这种方法可以说是最好的，因为你可以使用一个样式表来设置多个文档的样式，并且需要更新 CSS 的时候只要在一个地方更新。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/nms.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-选择器"><a href="#2-选择器" class="headerlink" title="2.选择器"></a>2.选择器</h3><p>选择器，顾名思义，就是将 css 代码选择到 HTML 文档中具体的元素对象，并作用在它身上。</p>
<h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><p>基本选择器其实是一些比较常用、简单的选择器，包括：元素选择器、id 选择器、class 选择器、属性选择器、组合选择器。这些在第一篇<a href="https://www.jianshu.com/p/2c374c3d0d39" target="_blank" rel="noopener">前端入门1-基础概念</a>中已经介绍过了，这里不就详细说了。</p>
<p>基本选择器规则很简单，选择器基本就是一两个条件，满足了即可匹配上，如 a.class，p#id 等，即使有稍微经过组合，但仍旧不复杂，但有些应用场景下需要通过复杂的规则，即需要满足多个条件下才能匹配上。</p>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><p>在第一篇中介绍的属性选择器其实是最基本用法的一种，而它还支持其他很多规则的用法，如下： </p>
<table>
<thead>
<tr>
<th>[attr]</th>
<th>选择定义attr属性的元素，不管属性的取值具体是什么</th>
</tr>
</thead>
<tbody><tr>
<td>[attr=”val”]</td>
<td>选择定义attr属性，且属性值为val的元素</td>
</tr>
<tr>
<td>[attr^=”val”]</td>
<td>选择定义attr属性，且属性值以字符串val打头的元素</td>
</tr>
<tr>
<td>[attr$=”val”]</td>
<td>选择定义attr属性，且属性值以字符串val结尾的元素</td>
</tr>
<tr>
<td>[attr*=”val”]</td>
<td>选择定义attr属性，且属性值包含字符串val的元素</td>
</tr>
<tr>
<td>[attr~=”val”]</td>
<td>选择定义attr属性，且属性值具有多个值，其中一个为字符串val的元素。</td>
</tr>
<tr>
<td>[attr|=”val”]</td>
<td>选择定义attr属性，且属性值为连字符(-)分割的多个值，其中第一个为字符串val的元素。</td>
</tr>
</tbody></table>
<p>也就是说，属性选择器不仅可以用来匹配那些具有指定属性的元素，还可以进一步根据不同属性值来匹配。 </p>
<h4 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h4><p>结构：&lt;选择器&gt;, &lt;选择器&gt;</p>
<p>并集选择器是通过 <code>，</code> 逗号将不同选择器组合使用的一种选择器，这种情况下，各个选择器之间是没有任何关系，都是相互独立的，就是他们具有相同的样式属性表而已。</p>
<p>这只是一种简便写法的用法而已，具有相同样式属性表的不同再复制粘贴，可以直接通过 ，逗号将不同选择器分开即可。只有 HTML 文档中的元素满足其中一个选择器即可。</p>
<p>示例:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">span</span>, <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中有四个选择器含有同样的样式属性，HTML 文档中只要满足其中一个选择器即可被匹配到。 </p>
<h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h4><p>结构：&lt;第一个选择器&gt; &lt;第二个选择器&gt;</p>
<p>多个选择器之间通过<code>空格</code>分隔开的话表示这是一个后代选择器，也就是说，需要先满足第一个选择器的前提下，在第一个选择器匹配到的元素的后代元素中去匹配第二个选择器。</p>
<p>这里的后代包括了子孙后代。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p span &#123;</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;第一个span&lt;/span&gt;</span><br><span class="line">&lt;p&gt;第二个&lt;span&gt;span&lt;/span&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>以上示例中，选择器要匹配的元素是位于 p 元素的后代元素中的 span 元素，因此第一个 span 元素就不符合规则，而第二个 span 则会被匹配到。 </p>
<h4 id="儿子选择器"><a href="#儿子选择器" class="headerlink" title="儿子选择器"></a>儿子选择器</h4><p>结构：&lt;第一个选择器&gt; &gt; &lt;第二个选择器&gt;</p>
<p>儿子选择器是多个选择器之间通过 <code>&gt;</code> 右箭头符号连接，表示的是在满足第一个选择器的前提下，从它匹配到的元素的直接子元素中寻找第二个选择器。</p>
<p>跟后代选择器的区别就在于它只能在直接子元素中匹配第二个选择器。</p>
<p>示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;第一个span&lt;/span&gt;</span><br><span class="line">&lt;p&gt;第二个&lt;span&gt;span&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;div&gt;第三个&lt;span&gt;span&lt;/span&gt;&lt;/div&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>第一个 span 元素不是 p 元素的后代，第二个 span 元素是 p 元素的直接子元素，第三个 span 元素是 p 元素的孙子元素，因此只有第二个 span 元素满足规则被匹配到。 </p>
<h4 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h4><p>结构：&lt;第一个选择器&gt; + &lt;第二个选择器&gt;</p>
<p>兄弟选择器是多个选择器之间通过 <code>+</code> 加号连接。表示的是，在满足第一个选择器的前提下，从它匹配到的元素的紧跟着的位于同一层级的下一个元素，看该元素是否符合第二个选择器。</p>
<p>也就是说，兄弟选择器，两个选择器所匹配的元素要求，位于同一层级，且相邻。</p>
<p>示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> + <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#6a90d9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;a&gt;第一个a&lt;/a&gt;</span><br><span class="line">&lt;p&gt;第二个&lt;a&gt;a&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&lt;a&gt;第三个a&lt;/a&gt;</span><br><span class="line">&lt;a&gt;第四个a&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>上述示例中，同时满足位于同一层级，且相邻，且需要先满足第一个选择器的前提下，还满足第二个选择器这四个条件的 a 元素就是第三个 a 元素了。 </p>
<h4 id="普通兄弟选择器"><a href="#普通兄弟选择器" class="headerlink" title="普通兄弟选择器"></a>普通兄弟选择器</h4><p>结构：&lt;第一个选择器&gt; ~ &lt;第二个选择器&gt;</p>
<p>普通兄弟选择器，是多个选择器之间通过 <code>~</code> 波浪符号连接。表示的是满足第一个选择器的前提下，从它匹配到的元素后，去寻找位于同一层级，且在该元素后面的所有满足第二个选择器的元素。</p>
<p>兄弟选择器只匹配相邻的一个元素，而普通兄弟选择器则是可以匹配位于元素后面的所有符合第二个选择器的元素。</p>
<p>示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> ~ <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#6a90d9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;a&gt;第一个a&lt;/a&gt;</span><br><span class="line">&lt;p&gt;第二个&lt;a&gt;a&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&lt;a&gt;第三个a&lt;/a&gt;</span><br><span class="line">&lt;a&gt;第四个a&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>同时满足同层级，且在 p 元素后面的兄弟元素有两个，第三个 a 元素和第四个 a 元素，因此这里可以匹配到这两个元素。 </p>
<h4 id="伪选择器"><a href="#伪选择器" class="headerlink" title="伪选择器"></a>伪选择器</h4><p>选择器的目的就是为了匹配到 HTML 文档中的满足条件的元素，然后将样式属性作用在元素上。</p>
<p>元素是什么，在基础一节中有介绍过，元素其实就是包含了标签以及文本内容的整块内容。因此被选择器匹配到的元素，都是直接将 CSS 样式作用到整个元素上，也就是作用到整个文本内容上。</p>
<p>那么，如果有一些需求并不是直接去匹配 HTML 文档中的具体元素，而是指定了一些状态、行为，然后让浏览器动态去根据当前情况选择符合这些状态、行为的元素。</p>
<p>或者有一些需求是并不想将 CSS 样式作用到整个元素上，而是只作用到元素标记的文本内容的某一部分。</p>
<p>这个时候，这种选择器就称作伪选择器，因为它有区别于普通选择器的行为</p>
<p>伪选择器总共分成两种：伪元素选择器，伪类选择器</p>
<h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><p>当伪选择器最终将 CSS 作用的对象并不是整个元素，而是满足条件的元素标记的文本内容的某一部分时，称伪元素选择器。</p>
<p>伪元素选择器不多，如下：</p>
<table>
<thead>
<tr>
<th>::first-line</th>
<th>匹配满足条件的元素标记的文本内容的首行部分</th>
</tr>
</thead>
<tbody><tr>
<td>::first-letter</td>
<td>匹配满足条件的元素标记的文本内容的首字母部分</td>
</tr>
<tr>
<td>:before</td>
<td>在满足条件的元素之前<strong>插入</strong>生成的内容</td>
</tr>
<tr>
<td>:after</td>
<td>在满足条件的元素之后<strong>插入</strong>生成的内容</td>
</tr>
</tbody></table>
<p>伪元素选择器的用法基本都是和其他选择器组合使用，比如 p::first-line 表示匹配 p 元素标记的文本内容的首行部分。</p>
<p>而 :before 和 :after 与之前的选择器都不大一样，因为之前介绍的选择器作用都只是用于匹配选择 HTML 文档中的元素或文本内容而已。但这两个伪元素选择器会生成内容，并插入到匹配到元素的文本内容中去。</p>
<p>因此，它们的基本用法通常都是这样：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"在文本内容之前插入"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"在文本内容之后插入"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一种应用场景很适合使用这两种伪元素选择器，当需要对列表动态的生成复杂的编号规则时，可以结合 :before 和 counter() 使用。在 CSS 中也是可以使用一些内置的方法功能。 </p>
<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><p>当不是通过 HTML 文档中元素的一些基本性质，比如 id，class，标签名，属性这些基本特征来匹配这些元素时，就可以称作伪类选择器。</p>
<p>伪类选择器是通过满足一些指定状态、行为下来匹配元素的一种选择器，比如满足是否获取焦点等等。</p>
<p>伪类选择器相对来说，比较多，如下：</p>
<table>
<thead>
<tr>
<th>:first-child</th>
<th>选择元素的第一个子元素</th>
</tr>
</thead>
<tbody><tr>
<td>:last-child</td>
<td>选择元素的最后一个子元素</td>
</tr>
<tr>
<td>:only-child</td>
<td>选取元素的唯一一个子元素</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>选取属于父元素的特定类型的唯一子元素</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>选取元素的第n个子元素</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>选取元素的倒数第n个子元素</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>选取属于父元素的特定类型的第n个子元素</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>选取属于父元素的特定类型的倒数第n个子元素</td>
</tr>
<tr>
<td>:enabled</td>
<td>选取启用状态的元素</td>
</tr>
<tr>
<td>:disable</td>
<td>选取被禁用状态的元素</td>
</tr>
<tr>
<td>:checked</td>
<td>选取所有选中的复选框和单选按钮元素</td>
</tr>
<tr>
<td>:default</td>
<td>选取默认的元素</td>
</tr>
<tr>
<td>:valid    :invalid</td>
<td>选取基于输入验证判定的有效或者无效的input元素</td>
</tr>
<tr>
<td>:in-range    :out-of-range</td>
<td>选取被限定在指定范围之内或之外的input元素</td>
</tr>
<tr>
<td>:required    :optional</td>
<td>根据是否允许使用required属性选取input元素</td>
</tr>
<tr>
<td>:link</td>
<td>选取未访问的链接元素</td>
</tr>
<tr>
<td>:visited</td>
<td>选取用户已访问的链接元素</td>
</tr>
<tr>
<td>:hover</td>
<td>选取鼠标指针悬停的元素</td>
</tr>
<tr>
<td>:active</td>
<td>选取当前被用户激活的元素，这通常意味着用户即将点击该元素</td>
</tr>
<tr>
<td>:focus</td>
<td>选取获得焦点的元素</td>
</tr>
<tr>
<td>:not(&lt;选择器&gt;)</td>
<td>否定选择，（如选择所有不匹配&lt;选择器&gt;的元素）</td>
</tr>
<tr>
<td>:empty</td>
<td>选取不包含任何子元素或文本的元素</td>
</tr>
<tr>
<td>:lang(&lt;语言&gt;)</td>
<td>选取lang属性为指定值的元素</td>
</tr>
<tr>
<td>:target</td>
<td>选取URL片段标识符指向的元素</td>
</tr>
</tbody></table>
<p>一些伪类选择器看下说明应该就清楚怎么使用，不明白的再具体去查找相关文档即可。</p>
<h3 id="3-层叠算法"><a href="#3-层叠算法" class="headerlink" title="3.层叠算法"></a>3.层叠算法</h3><p>由于一个元素通常会被多个选择器命中，而这些选择器又有可能是通过不同方式作用到元素上，因此这里存在了两种场景下的优先级问题，但请记住，只有当作用到同一个元素上的样式属性起了冲突时才会存在优先级问题。</p>
<p>如果不同选择器作用到同一个元素上，但它们各自的样式属性列表中没有重复的，那就不存在冲突，也就不存在优先级问题，都会一起合并作用到元素上。</p>
<h4 id="场景1：不同使用方式的优先级"><a href="#场景1：不同使用方式的优先级" class="headerlink" title="场景1：不同使用方式的优先级"></a>场景1：不同使用方式的优先级</h4><p>CSS 有三种使用方式，另外浏览器也有默认样式，因此这些构成了一个优先级顺序：</p>
<ol>
<li>元素内嵌样式（全局属性 style 定义的样式）</li>
<li>文档内嵌样式（style 标签定义的样式） 和 外部样式（link 标签引入的外部 CSS 文件）</li>
<li>浏览器中的用户样式</li>
<li>浏览器中的默认样式</li>
</ol>
<p>以上优先级从高到低，同层级之间，如果存在冲突的样式属性的话，以文档中最后出现的属性为准，采用覆盖规则。</p>
<h4 id="场景2：不同选择器之间的优先级"><a href="#场景2：不同选择器之间的优先级" class="headerlink" title="场景2：不同选择器之间的优先级"></a>场景2：不同选择器之间的优先级</h4><p>当作用到同一个元素上的不同选择器存在样式属性冲突时，优先以场景1考虑优先级，如果不存在场景1的情况，即起冲突的选择器在场景1中处于同一层优先级，那么才会考虑不同选择器之间的优先级。</p>
<ol>
<li>id 选择器</li>
<li>class 选择器，属性选择器，伪类选择器</li>
<li>元素选择器，伪元素选择器</li>
</ol>
<p>以上优先级从高到低，同层级之间，如果存在冲突的样式属性的话，以文档中最后出现的属性为准，采用覆盖规则。</p>
<p>但，有时候，使用的是组合选择器，那么这时候就需要依靠一定的算法来计算出谁的优先级高了，这个算法叫做层叠算法：</p>
<p>通过对以上不同选择器赋予某个数值来计算整个组合选择器的最终数值，然后比较大小。</p>
<p>比如，上面三个优先级的选择器中，1优先级的表示100，2优先级的表示10，3优先级的表示1，以此来计算一个组合选择器的数值大小。</p>
<p>通常来说，组合选择器不会过于离谱，长达十几个选择器的组合，因此以上述赋予每个优先级的数值足够覆盖绝大多数场景。</p>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-7f8aef19180729d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="层叠算法">  </p>
<p>h1，和 #indentifier 都只是简单选择器，不通过这种层叠算法计算也行。 </p>
<p>h1 + p::first-letter 和 li &gt; a[href*=”zh-CN”] &gt; .inline-warning 这种比较复杂的组合选择器，就可以根据赋予每一层级优先级对应的数值来进行计算，最终根据数值大小比较谁的优先级高。</p>
<p>这种赋予不同优先级某个具体数值具现化的思想叫做层叠算法，通常是用于比较复杂的组合选择器时。</p>
<p>但实际开发中，很少会需要用到层叠算法，掌握场景1和场景2下简单的优先级分辨理论基础足够了。实际开发过程中，没必要这么复杂，借助开发工具或者运行查看下效果就可以确认谁的优先级高低了。  </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>前端02-HTML标签（入门）</title>
    <url>/2018/10/29/%E5%89%8D%E7%AB%AF/%E5%85%A5%E9%97%A8/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A82-HTML%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下四个来源：</p>
<ul>
<li>《HTML5权威指南》</li>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
</ul>
<p>作为一个前端小白，入门跟着这四个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<h1 id="正文-HTML标签"><a href="#正文-HTML标签" class="headerlink" title="正文-HTML标签"></a>正文-HTML标签</h1><p>本文接着来学习 HTML 的基本标签，下面是我自己对标签进行的划分，《HTML权威指南》中将标签类别划分成了很多种，比如：内容分组，文档分节，表单七七八八等等。</p>
<p>但我按照自己个人的理解习惯，对总的标签划分成三类：修饰文档结构的标签、修饰文本内容标签、容器类标签。</p>
<p>修饰文档结构的标签大多用于表示一份标准、完整的HTML文档的一些标签，以及可放于&lt;head&gt; 内的一些标签。</p>
<p>修饰文本内容标签，大意是说，这些标签是直接用于标记文本内容，赋予文本内容某些语义行为，比如 &lt;a&gt; 赋予超链接语义，&lt;h1&gt; 赋予了一级标题语义等等。这个类别有些类似于 Android 中表示某个 View 的标签，通俗来讲，这些标签可直接使用在文本内容上了。</p>
<p>容器类标签，并不是真正意义上的容器，而是说，这类标签主要的作用是用来包含其他标签的，但并不是说，只能用来包含其他标签，也可直接对文本内容标记。如 &lt;nav&gt;, &lt;header&gt; 这类表示某一块区域的标签。</p>
<p>我自己个人将其常用的标签划分成三大类，当然不是很准确，书中划分得更细，但结合 Android 中一些共性的概念，我个人觉得划分成这三类后，我较容易理解各个标签用途：</p>
<h3 id="1-修饰文档结构"><a href="#1-修饰文档结构" class="headerlink" title="1. 修饰文档结构"></a>1. 修饰文档结构</h3><p>首先来看份 HTML 的大体上的基本结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span>   <span class="comment">&lt;!--声明这是一份H5文档--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> &gt;</span>           <span class="comment">&lt;!--HTML文档内容开始--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--在&lt;head&gt;标签中声明文档的各种元数据--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--该部分内容是给浏览器看的--&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--&lt;body&gt;标签内为文档的文本内容--&gt;</span>	</span><br><span class="line">	<span class="comment">&lt;!--该部分内容是给用户看的--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以，这些标签用途基本就是用于构建一份基本的 HTML 文档结构，下面看看具体介绍：</p>
<h4 id="lt-DOCTYPE-gt"><a href="#lt-DOCTYPE-gt" class="headerlink" title="&lt;!DOCTYPE&gt;"></a>&lt;!DOCTYPE&gt;</h4><p>准确的说，&lt;!DOCTYPE&gt; 并不是 HTML 标签，它是声明 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。</p>
<p>在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。</p>
<p><a href="https://www.html5tricks.com/" target="_blank" rel="noopener">HTML5</a> 不基于 SGML，所以不需要引用 DTD。</p>
<p>如 H5中用法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure>

<p>HTML 4 中用法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="lt-html-gt"><a href="#lt-html-gt" class="headerlink" title="&lt;html&gt;"></a>&lt;html&gt;</h4><p>每一份 HTML 文档内容的根节点，表示文档内容的开始</p>
<p>文档内容包括两部分：头部声明 &lt;head&gt; 和文本内容 &lt;body&gt;</p>
<h4 id="lt-head-gt"><a href="#lt-head-gt" class="headerlink" title="&lt;head&gt;"></a>&lt;head&gt;</h4><p>HTML 文档的头部声明，用于声明该文档的一些属性，以及一些元数据，&lt;head&gt; 内部的内容是用于给浏览器看的，并不是用于给用户看的，浏览器通过 &lt;head&gt; 信息，知晓这份文档引用了哪些外部资源文件，使用的哪些属性。</p>
<p>可在 &lt;head&gt; 中使用的标签并不多：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"http://www.dasu."</span>&gt;</span>         <span class="comment">&lt;!--设置基准URL--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span>             <span class="comment">&lt;!--声明文档所使用的编码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span>               <span class="comment">&lt;!--声明文档的标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span> <span class="comment">&lt;!--声明文档全局的基准URL--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>    <span class="comment">&lt;!--声明内嵌类型的css样式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/nms.css"</span>&gt;</span>   <span class="comment">&lt;!--外部css--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>          <span class="comment">&lt;!--JavaScript脚本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span>  <span class="comment">&lt;!--浏览器不支持JS情况下的处理--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="lt-body-gt"><a href="#lt-body-gt" class="headerlink" title="&lt;body&gt;"></a>&lt;body&gt;</h4><p>&lt;body&gt; 标签用于声明文本内容，该标签内的内容都是用于展示给用户看的，所以基本所有标签都可以在 &lt;body&gt; 内，浏览器解析相应的标签，并根据 CSS 作用到每个对象上，生成网页呈现给用户。 </p>
<h4 id="lt-meta-gt"><a href="#lt-meta-gt" class="headerlink" title="&lt;meta&gt;"></a>&lt;meta&gt;</h4><p>元数据标签，可用于声明文档所使用的一些元数据，用途蛮多，如下： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span>       <span class="comment">&lt;!--声明文档编码格式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"5"</span>/&gt;</span>   <span class="comment">&lt;!--往Http头部中增加key-value--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html charset=UTF-8"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="lt-link-gt"><a href="#lt-link-gt" class="headerlink" title="&lt;link&gt;"></a>&lt;link&gt;</h4><p>&lt;link&gt; 标签用于指定 HTML 文档使用了哪些外部资源文件，可以是外部的 CSS 文件，或者网页图标，或者说明文档等等，如下： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">”stylesheet”</span> <span class="attr">type</span>=<span class="string">”text/css”</span> <span class="attr">href</span>=<span class="string">”styles.css”/</span>&gt;</span> --外部CSS</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">”shortcut</span> <span class="attr">icon</span>” <span class="attr">href</span>=<span class="string">”favicon.ico”</span> <span class="attr">type</span>=<span class="string">”image/x-icon”/</span>&gt;</span>-网页图标</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">”prefetch”</span> <span class="attr">href</span>=<span class="string">”/page2.html”</span>&gt;</span> --预先加载page2.html文件</span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<h3 id="2-修饰文本内容"><a href="#2-修饰文本内容" class="headerlink" title="2. 修饰文本内容"></a>2. 修饰文本内容</h3><h4 id="lt-a-gt"><a href="#lt-a-gt" class="headerlink" title="&lt;a&gt;"></a>&lt;a&gt;</h4><p>&lt;a&gt; 标签的作用是引导用户从一张页面链接到另一张页面，互联网说到底就是一张张网页通过超链接 &lt;a&gt; 互相关联起来的。</p>
<p>所以，只要不是单个页面，只要页面支持跳转，那么 HTML 文档中就肯定有  &lt;a&gt; 标签的存在，用于指定下个页面的跳转。</p>
<ul>
<li><strong>用法</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.html"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#myId"</span>&gt;</span>标题5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上是 &lt;a&gt; 标签的三种用法，指定绝对路径的链接，指定相对路径的链接，指定文档内的链接。</p>
<p>也就是说，&lt;a&gt; 标签既可以用于指定页面间的跳转关联，也可以指定页面内的跳转。</p>
<p>&lt;base&gt; 标签设置的基准 url 会影响到相对路径的拼接，默认以当前 HTML 文档的路径作为基准路径。</p>
<p>另外新页面的打开方式也支持多种形式配置，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过 target 属性来声明新页面的打开方式，target可以取值如下： </p>
<table>
<thead>
<tr>
<th align="left">target</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_blank</td>
<td>在新页面或标签页中打开文档</td>
</tr>
<tr>
<td align="left">_parent</td>
<td>在父窗框组（frameset）中打开文档</td>
</tr>
<tr>
<td align="left">_self</td>
<td>在当前窗口中打开文档（默认行为）</td>
</tr>
<tr>
<td align="left">_top</td>
<td>在顶层窗口打开文档</td>
</tr>
<tr>
<td align="left">&lt;frame&gt;</td>
<td>在指定窗框中打开文档</td>
</tr>
</tbody></table>
<h4 id="lt-b-gt-amp-lt-wbr-gt"><a href="#lt-b-gt-amp-lt-wbr-gt" class="headerlink" title="&lt;b&gt; &amp; &lt;wbr&gt;"></a>&lt;b&gt; &amp; &lt;wbr&gt;</h4><p>换行标签</p>
<p>&lt;br&gt; :表示将后续内容转移到新行上</p>
<p>&lt;wbr&gt; :H5 新增的，表示当长度超过当前浏览器窗口的内容适合在此换行。</p>
<p>两者都是换行，前者是强制换行，后者是建议在这里换行，但什么时候换行，由浏览器根据当前窗口大小决定，后者通常用于指定单词的换行。</p>
<ul>
<li><strong>用法</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    I am dasu, <span class="tag">&lt;<span class="name">wbr</span>&gt;</span> and i am coding.<span class="tag">&lt;<span class="name">wbr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    I am ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="lt-p-gt"><a href="#lt-p-gt" class="headerlink" title="&lt;p&gt;"></a>&lt;p&gt;</h4><p>&lt;p&gt; 标签用于表示段落，标签围起来的文本内容表示一个段落。</p>
<p>因为浏览器会忽略所有的空格、缩进、换行，最多只会解析成一个空格，所以，即使文本内容的段落结构很好，但经由浏览器解析出来后的文本内容全部都挤到一堆。</p>
<p>因此，&lt;p&gt; 段落标签还是很有必要的。</p>
<p>可以用此来标记哪些文本内容作为一个段落。</p>
<p>用法见上例。</p>
<h4 id="lt-pre-gt-amp-lt-code-gt"><a href="#lt-pre-gt-amp-lt-code-gt" class="headerlink" title="&lt;pre&gt; &amp; &lt;code&gt;"></a>&lt;pre&gt; &amp; &lt;code&gt;</h4><p>&lt;pre&gt; 标签用于保留源文档中的格式。</p>
<p>&lt;code&gt; 标签用于表示代码块。</p>
<p>由于浏览器会合并空白字符，忽略掉换行，导致如果文档中含有代码块时显示不符合开发工具下的代码格式风格。</p>
<p>此时，可以借助 &lt;pre&gt; 标签和 &lt;code&gt; 一起使用，来阻止浏览器合并空白字符，达到保留代码格式的目的。</p>
<ul>
<li><strong>用法</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">	protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">        boolean optical = isLayoutModeOptical(this);</span><br><span class="line">        if (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">            Insets insets = getOpticalInsets();</span><br><span class="line">            int opticalWidth  = insets.left + insets.right;</span><br><span class="line">            int opticalHeight = insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">            measuredWidth  += optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">            measuredHeight += optical ? opticalHeight : -opticalHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="lt-ol-gt-amp-lt-li-gt"><a href="#lt-ol-gt-amp-lt-li-gt" class="headerlink" title="&lt;ol&gt; &amp; &lt;li&gt;"></a>&lt;ol&gt; &amp; &lt;li&gt;</h4><p>&lt;ol&gt; 标签用于表示有序列表，&lt;li&gt; 标签用于表示列表中的每一项。 </p>
<ul>
<li><strong>用法</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-40656ce80410b923.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ol1">  </p>
<p>既然是有序列表项，那么序号的起始以及样式是支持通过属性设定的，如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-c45c98cd7b3a9d53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ol2">  </p>
<p>通过 start 属性设置起始的编号，通过 type 属性设置编号的样式，可设置的 type 样式如下 :</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-c0afbbc16ea03ad5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ol3">  </p>
<p>如果要实现编号是非连续的，那么可以借助 &lt;li&gt; 标签的 value 属性实现 ：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a468692536faec94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ol4">  </p>
<p>注：每个 ol 列表项都是独立存在，编号默认都从 0 开始，如果想实现不同列表项的编号连贯，或者想以跨度 2 或其他数递增，那么只用标签属性实现局限很多。这时，可考虑通过 CSS 的 ::before 选择器实现，具体实现后续再说。</p>
<h4 id="lt-ul-gt-amp-lt-li-gt"><a href="#lt-ul-gt-amp-lt-li-gt" class="headerlink" title="&lt;ul&gt; &amp; &lt;li&gt;"></a>&lt;ul&gt; &amp; &lt;li&gt;</h4><p>&lt;ul&gt; 标签用于表示无序列表，&lt;li&gt; 标签表示列表里的每一项.</p>
<ul>
<li><strong>用法</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-514765765728f14d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ul">  </p>
<p>因为是无序列表，所以用法比起有序列表 &lt;ol&gt; 简单很多，无需使用任何属性，直接用无序标签 &lt;ul&gt; 包含一系列子项 &lt;li&gt; 即可。</p>
<p>至于，每一项前的样式，可通过 CSS 样式，通过 list-style-type 属性实现，以上样式对应的 CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123; <span class="attribute">list-style-type</span>: disc&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lt-h1-gt-lt-h6-gt"><a href="#lt-h1-gt-lt-h6-gt" class="headerlink" title="&lt;h1&gt; ~ &lt;h6&gt;"></a>&lt;h1&gt; ~ &lt;h6&gt;</h4><p>标题标签，对应一级到六级标题。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-81a791b20daa77e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p">  </p>
<p>至于每个标题具体字号样式如何，取决于各个浏览器或者网站。</p>
<h4 id="lt-table-gt"><a href="#lt-table-gt" class="headerlink" title="&lt;table&gt;"></a>&lt;table&gt;</h4><p>表格标签，但貌似现在不常用了。</p>
<p>HTML 文档做一个表格挺复杂的，涉及的标签很多，如 &lt;thead&gt;, &lt;tfoot&gt;, &lt;tbody&gt; 等等。</p>
<p>但根节点总是 &lt;table&gt;，一份表格无外乎就是各种单元格组成，而单元格标签为 &lt;td&gt;，另外，浏览器解析表格文本时，是以行为单位来构建表格，并不是列，所以每个单元格都需要指定位于哪一行中，行标签为 &lt;tr&gt;。而所有行的单元格都是表格的主要内容，因此都在 &lt;tbody&gt; 标签中。</p>
<p>以上是表格的最基本要素，因此一张最简单的表格，至少需要 &lt;table&gt;，&lt;tbody&gt;，&lt;tr&gt;，&lt;td&gt; 三种标签。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a3820a20db1e38e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="table">  </p>
<p>有时候，写表格标签时，如果没有其他表头 &lt;thead&gt; 部分，或者表脚 &lt;tfoot&gt; 时，会将 &lt;tbody&gt; 省略，但这并不是说就可以不用 &lt;tbody&gt; 标签，而是很多浏览器会自动将 &lt;tbody&gt; 填补上，所以如果有省略 &lt;tbody&gt; 的场景下，使用 css 选择器时得稍微注意一下。</p>
<ul>
<li><strong>&lt;tr&gt; &amp; &lt;th&gt; &amp; &lt;td&gt;</strong></li>
</ul>
<p>由于浏览器是以行为单位构建表格，所以一个表格有多少行就是通过 &lt;tr&gt; 标签来控制，哪些单元格属于哪一行，就放在那一行的 &lt;tr&gt; 标签中。</p>
<p>虽然说表格都是由一个个的单元格组成，但单元格之间还可以继续划分含义，有些单元格是表示内容，而有些单元格则是表示属性值，或者说列头或行头。</p>
<p>通常来说，这些标题类型的表格都是在第一行或第一列的单元格：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-02979bedc029609b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="table1">  </p>
<p>这是一个很常见的二维表格，通过 &lt;th&gt; 和 &lt;td&gt; 来将表格的单元格含义区分开。</p>
<p>&lt;th&gt; ：标签用于表示单元格的表头</p>
<p>&lt;td&gt; ：标签用于表格单元格的内容</p>
<p>既然是单元格，那么就会存在合并单元格的现象，通俗的讲也就是有些表格的大小并不是只占据一格，而是有可能多行多列。此时，可通过属性来实现：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>colspan</td>
<td>单位数值，如1表示占据1列</td>
</tr>
<tr>
<td>rowspan</td>
<td>单位数值，如2表示占据2行</td>
</tr>
</tbody></table>
<ul>
<li><strong>&lt;thead&gt; &amp; &lt;tfoot&gt; &amp; &lt;tbody&gt;</strong></li>
</ul>
<p>类似于 HTML 文档有一些专门用于表明文档结构的标签，表格同样有一些用于指示表格结构的标签。引入表格结构标签，是为了更好的区分出各个单元格的含义。</p>
<p>比如，&lt;th&gt; 标签用来表示表头类型的单元格，但不管是第一行的表头，还是第一列的表头，用的都是 &lt;th&gt;，那如果还想继续划分这个表头是属于第一行或者第一列时该怎么做呢？</p>
<p>所以，引入了一些结构性标签有便于对表格各个单元格更加具体的细分，以满足各种复杂场景。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-b85422526dd8e3e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="table2">  </p>
<p>&lt;table&gt; : 是表格的根节点</p>
<p>&lt;thead&gt; : 用来标记表格的标题行</p>
<p>&lt;tfoot&gt; : 用来标记组成脚的行。</p>
<p>不用 &lt;thead&gt;，表格最终效果也一样，但用了 &lt;thead&gt; 之后，如果 CSS 想分别作用第一行，或者第一列，这时就可以很容易的通过 thread th 以及 tbody th 来达到目的了。</p>
<p>所以，结合表格结构性标签的使用，可以让表格的结构更加明确。</p>
<ul>
<li><strong>&lt;caption&gt;</strong></li>
</ul>
<p>表格除了一张表格内容外，通常还会需要有表格的标题，此时用 &lt;caption&gt; 标签来标记。</p>
<ul>
<li><strong>完整示例</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a8b3371b647ae8cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="table示例">  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>工作记录表<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>日期<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>记录<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>2018-07-24<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>suxq<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>2018-07-25<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="lt-form-gt"><a href="#lt-form-gt" class="headerlink" title="&lt;form&gt;"></a>&lt;form&gt;</h4><p>表单标签。</p>
<p>表单在网页中的角色很重要，因为表单是用来接收用户输入的信息并提交发送给服务器的中间角色。</p>
<p>表单并不是说，流程器就呈现给用户一张表单，反而通常呈现给用户的只是各自输入控件，比如输入框，或者勾选控件之类的。</p>
<p>表单，我的理解是，浏览器会将用户输入的这些数据收集起来生成一张表单提交给服务端。</p>
<p>&lt;form&gt; 标签则是表单的根节点。</p>
<p>因为表单需要收集用户输入的信息，以及提交服务端的时机，因此，一般来说，表单还需要有 &lt;input&gt; 标签以及&lt;button&gt; 标签。</p>
<p>一份基本的表单如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-971b85c9d6ede5ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form1">  </p>
<p>&lt;form&gt; 标签的属性 method 用来指明发送表单数据时使用哪种方式，有两种 get, post。</p>
<p>action 属性用于指明表单数据要发送到哪里，如果没有设置，则默认发送到所在 HTML 文档的地址。</p>
<ul>
<li><strong>&lt;fieldset&gt;</strong></li>
</ul>
<p>如果表单过于复杂，需要将各个 &lt;input&gt; 收集的信息进行归类，可以使用 &lt;fieldset&gt; 标签。而 &lt;fieldset&gt; 有个子标签 &lt;legend&gt;，是用来对这个分组提供相关说明使用。 </p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">legend</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"name"</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>city: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"city"</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">legend</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>name2: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"name1"</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>city2: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"city1"</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5dee9603d9329ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form2">  </p>
<ul>
<li><strong>&lt;button&gt;</strong></li>
</ul>
<p>&lt;button&gt; 标签用来标记在表单中的按钮，但按钮的作用有三类，可通过属性值 type 来设置。如下： </p>
<table>
<thead>
<tr>
<th>type属性值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>submit</td>
<td>默认值，表示按钮的用途是提交表单</td>
</tr>
<tr>
<td>reset</td>
<td>表示按钮用途是重置表单</td>
</tr>
<tr>
<td>button</td>
<td>表示按钮是一个普通的按钮，没有任何语义</td>
</tr>
</tbody></table>
<p>如果 &lt;button&gt; 标签不放在 &lt;form&gt; 标签内，那么它就需要指定绑定的是哪个 &lt;form&gt; 表单，通过 form 属性绑定 form 表单的 id，所以这种场景下，form 表单必须设置 id 属性值。 </p>
<ul>
<li><strong>&lt;input&gt;</strong></li>
</ul>
<p>&lt;input&gt; 标签是用于收集用户输入的标签，因此它的形态有各自各样，可通过属性 type 来设置。</p>
<p>另外，它有很多属性，每个属性都有各自的含义，一些基本的属性需要了解一下。</p>
<p>name 属性，用于设置该 &lt;input&gt; 的 key 值，value 值就是用户的输入，key 和 value 组合成表单中的一项用于发送给服务端。如 :</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-e94a11e310f6b297.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="input">  </p>
<p>表明有两个 &lt;input&gt; 控件，一个 key 值为 name，一个 key 值为 city，收集用户输入后组成表单上传。</p>
<p>不同 type 的 &lt;input&gt; 作用不同，分别来看下：</p>
<ul>
<li><strong>type=”text”</strong></li>
</ul>
<p>默认的 &lt;input&gt; 的 type 值，在浏览器中呈现一个单行文本输入框。</p>
<p>这种类型下，还可以配合一些属性使用，如</p>
<p>placeholder: 数据提示，类似于 hint 功能</p>
<p>list: 结合 &lt;datalist&gt; 标签使用，用于给出一系列输入提示</p>
<p>其他还有一些属于用于设置 &lt;input&gt; 是否可用，是否聚焦，宽度，输入最大长度等等。</p>
<p>示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-b30f28628389921e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="input2">  </p>
<ul>
<li><strong>type=”password”</strong></li>
</ul>
<p>这类型的 &lt;input&gt; 在浏览器上的呈现跟 type=”text” 类型一致，功能也基本一致，唯一的区别就是这是个密码框，也就是当用户输入数据时，在浏览器上是以掩饰字符替换，如··· </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a0b2e974310216c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="input3">  </p>
<ul>
<li><strong>type=”submit”</strong></li>
<li><strong>type=”reset”</strong></li>
<li><strong>type=”button”</strong></li>
</ul>
<p>这三种类型的用途跟 &lt;button&gt; 标签一样，所以想要设置按钮，用 &lt;input&gt; 也可以，唯一的区别就是，&lt;input&gt; 是虚元素，也就是它没有标记任何文本内容，而 &lt;button&gt; 是可以标记文本内容的 。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f75bdfd0cd0bc213.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="input4">  </p>
<ul>
<li><strong>type=”hidden”</strong></li>
</ul>
<p>该类型 &lt;input&gt; 浏览器会将其隐藏，不显示在网页上。通常是用于一些需要传给服务端的数据，但又没有必要让用户知道的场景下的使用。如： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"name_id"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span>	</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"name"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上，用户只需输入名字信息，但提交给服务端时还需要一个 name_id 信息，这个数据没必要让用户知道，此时可以通过 hidden 来实现。 </p>
<ul>
<li><strong>type=”image”</strong></li>
</ul>
<p>该类型的 &lt;input&gt; 其实就是个图片按钮。跟 &lt;img&gt; 标签的区别也就是，这个是可点击的，&lt;img&gt; 只是将图片嵌入进来：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">"https://upload-images.jianshu.io/upload_images/5687349-d9d7ce1fec758d8c.png"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6c6b1fb10a9fd7cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="input5">  </p>
<p>当在 form 表单中有 type=”image” 类型的 &lt;input&gt; 时，点击这张图片，发送给服务端的信息是点击的坐标点。 </p>
<ul>
<li><strong>type=”file”</strong></li>
</ul>
<p>该类型的 &lt;input&gt; 可以让用户选择本地文件：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-98bb257ad98cef85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="input6">  </p>
<ul>
<li><strong>type=”checkbox”</strong></li>
</ul>
<p>复选框，示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-049314aab9d7639f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="input7">  </p>
<ul>
<li><strong>type=”radio”</strong></li>
</ul>
<p>多选框，通常配合 &lt;fieldset&gt; 一起使用，将同类型的集合管理在一起。当然，不用也可以。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-31f737ee406f88f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="input8">  </p>
<ul>
<li><strong>type=”number”</strong></li>
<li><strong>type=”email”</strong></li>
<li><strong>type=”tel”</strong></li>
<li><strong>type=”url”</strong></li>
<li><strong>type=”color”</strong></li>
<li>…</li>
</ul>
<p>这类 type 的 &lt;input&gt;，用途只是用于限定用户的输入格式，比如 number，这个输入框就只能输入数字。 </p>
<h4 id="lt-iframe-gt"><a href="#lt-iframe-gt" class="headerlink" title="&lt;iframe&gt;"></a>&lt;iframe&gt;</h4><p>HTML 文档中是可以嵌入其他 HTML 文档的，通过 &lt;iframe&gt; 标签标记。 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"index.html"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"500"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过src属性设定目标HTML文档地址，width,height设置区域大小。 </p>
<h4 id="lt-img-gt"><a href="#lt-img-gt" class="headerlink" title="&lt;img&gt;"></a>&lt;img&gt;</h4><p>基本每个网页都会有图片，在 HTML 中嵌入一张图片用 &lt;img&gt; 标签，跟 Android 中的 ImageView 控件很类似，同样需要指定图片来源，区域宽高。 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://upload-images.jianshu.io/upload_images/5687349-d9d7ce1fec758d8c.png"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-容器类"><a href="#3-容器类" class="headerlink" title="3. 容器类"></a>3. 容器类</h3><p>容器类标签是我自行对其进行的划分，并不是说，这类标签只能用于当容器使用，只能用于包含其他标签，而是说，常见的用法，这类标签基本都是表示具有某种含义的某一块区域，具体这块区域内既可以包含各种标签，也可以直接是文本内容。</p>
<h4 id="lt-span-gt-amp-lt-div-gt"><a href="#lt-span-gt-amp-lt-div-gt" class="headerlink" title="&lt;span&gt; &amp; &lt;div&gt;"></a>&lt;span&gt; &amp; &lt;div&gt;</h4><p>都是通用标签，没什么具体的语义</p>
<p>&lt;span&gt; : 标签通常用于标记段落中的某块文本内容，然后通过该标签，可以单独为这块文本内容增加 CSS 样式</p>
<p>&lt;div&gt; : 标签一般用于，将屏幕某块区域划分出来后，用该标签标记后可通过选择器作用自定义的 CSS 样式。</p>
<h4 id="lt-section-gt"><a href="#lt-section-gt" class="headerlink" title="&lt;section&gt;"></a>&lt;section&gt;</h4><p>&lt;section&gt; 标签用于表示文档中的某一节，其实也就是某一块区域，这块区域有自己单独独立的含义。通俗的理解，有些类似于第一节，第二节的概念。</p>
<p>每一节 &lt;section&gt; 都是相互独立的，因此方便各节里面独自使用 &lt;headler&gt; 和 &lt;footer&gt;。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-9abbb7b71aad550b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="section">  </p>
<h4 id="lt-header-gt-amp-lt-footer-gt"><a href="#lt-header-gt-amp-lt-footer-gt" class="headerlink" title="&lt;header&gt; &amp; &lt;footer&gt;"></a>&lt;header&gt; &amp; &lt;footer&gt;</h4><p>&lt;header&gt; : 标签表示某一节的首部，像某些网页通常会有一些 Logo 之类的首部信息。</p>
<p>&lt;footer&gt; : 标签表示某一节的尾部，最常见的基本每个网页尾部都会有版权信息，作者介绍，相关链接，免责声明等信息，这部分信息都适用于放在尾部标签 &lt;footer&gt; 里。</p>
<p>例如：&lt;header&gt;</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-0c8810920aadaeb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="header">  </p>
<p>&lt;footer&gt;</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-04f81df75431acca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="footer">  </p>
<h4 id="lt-nav-gt"><a href="#lt-nav-gt" class="headerlink" title="&lt;nav&gt;"></a>&lt;nav&gt;</h4><p>&lt;nav&gt; 标签表示文档中某一个区域，它包含着到其他页面或者同一页面的其他部分的链接。</p>
<p>直译其实也就是导航的作用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-19b2ce4990c394e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="nav">  </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>常见的标签基本就这些了，当然，这里并没有列出一些 HTML5 新增的标签，因为刚入门，对于那些标签的使用场景也不熟悉，总之，了解以上的标签，基本足够查看任意个网站的源代码了。</p>
<p>另外，如有需要，再去查找具体标签即可：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML</a>  </p>
]]></content>
      <categories>
        <category>前端</category>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>前端01-基础概念（入门）</title>
    <url>/2018/10/29/%E5%89%8D%E7%AB%AF/%E5%85%A5%E9%97%A8/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A81-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本系列文章内容全部梳理自以下四个来源：</p>
<ul>
<li>《HTML5权威指南》</li>
<li>《JavaScript权威指南》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN web docs</a></li>
<li><a href="https://github.com/smyhvae/Web" target="_blank" rel="noopener">Github:smyhvae/web</a></li>
</ul>
<p>作为一个前端小白，入门跟着这四个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="相关概念-HTML-CSS-JS"><a href="#相关概念-HTML-CSS-JS" class="headerlink" title="相关概念-HTML CSS JS"></a>相关概念-HTML CSS JS</h3><ul>
<li><strong>HTML</strong>: 内容层—表示某个标签在页面中是什么角色</li>
<li><strong>CSS</strong>: 样式层—表示某个标签在页面中该呈现什么样式</li>
<li><strong>JavaScript</strong>: 行为层—页面与用户的交互行为</li>
</ul>
<p>通俗的讲：Html 只负责文档的语义和结构，它描述了网页的内容和结构。</p>
<p>内容的呈现则由应用于元素上的 CSS 样式控制，它描述了网页的表现与展示效果。</p>
<p>JavaScript 则是负责网页的功能与行为，如与用户的交互。</p>
<h3 id="基础-HTML"><a href="#基础-HTML" class="headerlink" title="基础-HTML"></a>基础-HTML</h3><p>Html 是一种标记语言，不是编程语言，需要明确这点。</p>
<p>编程语言，通俗的理解就是向计算机发送指令，通过程序让计算机达到我们想要的功能。</p>
<p>而标记语言，可以通俗的理解成对文本增加一些标志信息，类似于批注信息来说明文本内容</p>
<p>更通俗点理解，一大段文本内容，毫无重点，毫无结构，让人不好理解。所以，Html 就通过大伙约定俗成的规范，利用一些标签，来指明，这一段文本是标题，这一段文本是个表格，这一段文本是个列表，这一段文本是导航菜单，这里需要分段，这里需要分行，这几个词是关键词，需要重点标记一下，等等等等。</p>
<p>Html 可以这么通俗的理解。那么这个大伙约定俗成的规范，其实也就是由 W3C 来作为官方发布的标准规范。</p>
<p>定了规范，自然是想要让人遵守才有意义。所以，在这里，W3C 所定义的标准规范，遵守方其实也就是各大浏览器。不同的浏览器厂商，根据 W3C 发布的标准规范来解析每一份 HTML 文档，那么相同的 HTML 文档在不同的浏览器上才会有相同的作用。</p>
<p>而一旦某些浏览器厂商没有遵守这些规范，那么前端开发人员就要为此做一些兼容适配工作，这就跟 Android 系统由 Google 开发并开源一样的道理，手机厂商都可以使用这开源的系统，但不同厂商都喜欢做一些自己的修改，这就导致了 Android 开发人员经常需要面对的适配工作问题。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"ddd"</span> <span class="attr">href</span>=<span class="string">"index.html"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>标签</strong>：&lt;&gt; 带有这种符号的称为标签，跟 Android 中的标签一样，分开始标签，结束标签</p>
<p><strong>内容</strong>：文本内容，上图中的点击跳转四字</p>
<p><strong>属性</strong>：跟 Android 中的 xml 里的标签一样，每个标签有自己的一些属性，另外，Html 有一些全局属性，比如上述的 class，这个属性所有标签都可以用。</p>
<p><strong>元素</strong>：标签 + 内容</p>
<h3 id="基础-CSS"><a href="#基础-CSS" class="headerlink" title="基础-CSS"></a>基础-CSS</h3><p>CSS 负责文本样式的呈现，既然将 HTML 和 CSS 分离开，各自只负责各自的职责，那么肯定需要某种方式将两者连接在一起。</p>
<p>更准确的说，是在 HTML 文档中该如何使用 CSS，因为 HTML 文档是互联网的基础，一个个网页就是一份份HTML 文档，既然 HTML 文档是基础，那么就是要明确在 HTML 文档中该如何使用 CSS。</p>
<p>总共有三种方式：全局属性 style，style 标签，link 标签</p>
<p>CSS 最终作用的对象其实就是 HTML 文档中的每个元素</p>
<h4 id="全局属性-style"><a href="#全局属性-style" class="headerlink" title="全局属性 style"></a>全局属性 style</h4><p>第一种方式：全局属性 style 是直接作用于指定的标签上了，用法就直接将需要的样式声明即可，如： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.html"</span> <span class="attr">style</span>=<span class="string">"background: gray; color: #6a90d9"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>style 是所有标签都具有的属性，称之为全局属性。</p>
<p>剩余两种方式，都是集中将所有的 CSS 样式管理存放，因此如果需要作用到具体元素上，要借助选择器来实现，选择器后面再说，先看这两种方式的使用：  </p>
<h4 id="style-标签内嵌方式"><a href="#style-标签内嵌方式" class="headerlink" title="style 标签内嵌方式"></a>style 标签内嵌方式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    a &#123;</span><br><span class="line">        background: gray;</span><br><span class="line">        color: #6a90d9;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="link-标签引用外部文件方式"><a href="#link-标签引用外部文件方式" class="headerlink" title="link 标签引用外部文件方式"></a>link 标签引用外部文件方式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/nms.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>style 标签和 link 标签都是 HTML 文档中的一种标签，两者都可以用来连接 css 代码，区别一种是将 css 代码内嵌在 HTML 文档中，一种是直接引用外部 css 文件。</p>
<p>但这两种相比较于第一种使用全局属性的方式，它们并没有直接在相关联的元素上书写，因此需要有一种机制，来将这些 css 代码关联到需要作用的元素对象上，这个机制就叫：<strong>选择器</strong>。</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>选择器是专门用来将 css 代码关联到指定的 HTML 文档中的元素对象上的，毕竟 css 已经被抽离出 HTML，各自负责各自的职责，但总归需要一种桥梁将两者关联在一起。</p>
<p>选择器很多，规则也很多，足够覆盖各种各样的场景，这里只列举几种常见的选择器： </p>
<h4 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"myClass"</span> <span class="attr">href</span>=<span class="string">"index.html"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"myClass"</span>&gt;</span>另一文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    a &#123;</span><br><span class="line">        background: gray;</span><br><span class="line">        color: #6a90d9;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：作用于 HTML 文档中的所有 a 标签的元素上 </p>
<h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"myId"</span> <span class="attr">href</span>=<span class="string">"index.html"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    #myId &#123;</span><br><span class="line">        background: gray;</span><br><span class="line">        color: #6a90d9;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>id 在 HTML 文档中需唯一存在，所有 id 选择器只作用于单个元素 </p>
<h4 id="class-选择器"><a href="#class-选择器" class="headerlink" title="class 选择器"></a>class 选择器</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"myClass"</span> <span class="attr">href</span>=<span class="string">"index.html"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"myClass"</span>&gt;</span>另一文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    .myClass &#123;</span><br><span class="line">        background: gray;</span><br><span class="line">        color: #6a90d9;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>HTML 文档中可对多个元素应用相同 class，所以 class 可同时作用于多个元素 </p>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"myClass"</span> <span class="attr">href</span>=<span class="string">"index.html"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"myClass"</span>&gt;</span>另一文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    [href] &#123;</span><br><span class="line">        background: gray;</span><br><span class="line">        color: #6a90d9;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>作用于所有具有 href 属性的元素，不管有没有使用</p>
<h4 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"myClass"</span> <span class="attr">href</span>=<span class="string">"index.html"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"myClass"</span>&gt;</span>另一文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    a.myClass &#123;</span><br><span class="line">        background: gray;</span><br><span class="line">        color: #6a90d9;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>元素选择器和 class 选择器组合使用，作用于 a 元素中有声明 myClass 类型的元素 </p>
<h4 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    * &#123;</span><br><span class="line">        background: gray;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>作用到所有元素上</p>
<h3 id="基础-JavaScript"><a href="#基础-JavaScript" class="headerlink" title="基础-JavaScript"></a>基础-JavaScript</h3><p>Js 是脚本语言，可用于增加网页的交互功能，及各种行为功能。</p>
<p>既然是一门语言，那么学习这么脚本语言自然需要先掌握其语法，以及运行方式。</p>
<p>浏览器解析 HTML 文档是按顺序解析的，也就是说，当遇到脚本语言时，也会按顺序一条条的解释执行，直至将脚本语言执行结束再继续解析文档。这就解释了，为什么一份 HTML 文档里，&lt;script&gt; 标签经常是在各种各样的位置出现的。</p>
<p>而 HTML 文档使用 js 的方式是通过 &lt;script&gt; 标签来实现，如：</p>
<h4 id="内嵌"><a href="#内嵌" class="headerlink" title="内嵌"></a>内嵌</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    console.log("hello world")</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="引用外部-js-文件"><a href="#引用外部-js-文件" class="headerlink" title="引用外部 js 文件"></a>引用外部 js 文件</h4><pre><code class="html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/hello.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre>
]]></content>
      <categories>
        <category>前端</category>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>系统应用集成过程中的一些坑</title>
    <url>/2018/10/26/Android%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E9%9B%86%E6%88%90%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>这次想来讲讲系统应用集成过程中遇到的一些坑，尤其是 so 文件相关的坑。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>埋这些坑的最初来源是由于测试人员在集成新终端设备时提了个 bug： app 在这个设备上无法启动。</p>
<p>随后抛来了一份日志，过滤了下，最重要的其实就一条，crash 日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError: No implementation found for long com.facebook.imagepipeline.memory.NativeMemoryChunk.nativeAllocate(int) (tried Java_com_facebook_imagepipeline_memory_NativeMemoryChunk_nativeAllocate and Java_com_facebook_imagepipeline_memory_NativeMemoryChunk_nativeAllocate__I)</span><br></pre></td></tr></table></figure>

<p>app 使用了 fresco 图片库，最初猜想是不是因为 so 文件没有 push，因为我们的 app 是系统应用，集成的时候是直接将 apk push 到 system/app 下的，因为没有 install 过程，所以 so 文件得自己 push 到 system/lib 下。</p>
<p>但把机子拿过来一看，so 文件有在啊，尝试将其删掉，再运行，又报出了如下异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/system/app/xxxx.apk&quot;],nativeLibraryDirectories=[/system/lib64/xxxx, /vendor/lib64, /system/lib64]]] couldn&apos;t find &quot;libimagepipeline.so&quot;</span><br></pre></td></tr></table></figure>

<p>看了下日志，它是说，在 system/lib64 目录下没有找到 so 文件，奇怪，以前都是只集成到 system/lib 下就可以了啊，怎么这次多出了个 system/lib64，难道这个机子支持的 CPUABI 不一样？试着运行了下 <code>getprop | get cpu</code>：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-cdf96c6094281c16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cpu.png">  </p>
<p>果然，这个机子支持的 CPUABI 多了个 arm64-v8a。</p>
<p>那这个机子既支持 arm64-v8a，又支持 armeabi-v7a，我怎么知道，我的 app 该将 so 文件集成在哪里，什么场景该放 system/lib 下，什么时候该集成到 system/lib64 中？还是说，两个地方都放？</p>
<p>应该不至于两个目录都得集成，因为三方应用安装时，从 apk 包中也只会解压一份 so 文件而已，并不会将 lib 下所有 abi 架构的 so 文件都解压。</p>
<p>后来，试着查找相关资料，发现可以在 data/system/packages.xml 文件中找到自己 app 的相关配置信息，这里有明确指出该去哪里加载 so 文件，以及 app 所运行的 CPU 架构，所以我们可以运行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /data/system/packages.xml | grep &#123;你自己app的包名&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f12da6d74dad2fa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="packages.png">  </p>
<p>后来有些疑惑，这里的 primaryCpuAbi 属性值，系统是如何确定的，因为遇到过，明明这次的值是 armeabi-v7a，但当重启之后，有时候居然变成 arm64-v8a 了，所以就又去查找了相关资料，发现，这个值确定的流程蛮复杂的，影响因素也很多。</p>
<p>那么，就没有办法根据某些条件确定某个场景来确定 so 文件是该放 system/lib，还是 system/lib64 了，只能两个都集成了。于是乎，尝试着直接将 system/lib 下的 so 文件拷贝了一份到 system/lib64，结果发现运行报了如下异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError: dlopen failed: &quot;libimagepipeline.so&quot; is 32-bit instead of 64-bit</span><br></pre></td></tr></table></figure>

<p>哎，想当然了，不同 CPU 架构的 so 文件肯定不一样，哪里可以直接将 armeabi-v7a 的 so 文件放到 system/lib64 里。因此，重新编译、打包了一份 arm64-v8a 架构的 so 文件，集成到 system/lib64 下，再运行，搞定。</p>
<p>但你以为事情到这里就结束了吗？年轻人，too yang.</p>
<p>由于以前 app 合作的机子，都只有 armabi-v7a 的，所以集成方式就一种，只需要集成到 system/lib 下就可以了，但由于新合作的机子有 arm64-v8a 的了，那么此时就需要修改以前的集成方式，分别将对应的 so 文件集成到对应的 system/lib 和 system/lib64 目录下。</p>
<p>但运维人员表示说，他不懂这些，他怎么判断说，什么时候该用旧的集成方式，什么时候用新的集成方式。我跟他说，你需要先执行 <code>getprop | grep cpu</code> 命令，查看当前机子支持的 CPUABI，然后再来决定你如何集成。但运维又说，这好复杂，能否有方法就统一一种集成方式，不必分场景考虑。</p>
<p>emmm，你们都是老大，你们说了算。只能又去瞎搞了，这次去开源库的 issue 里尝试寻找了下，结果发现，哈哈哈，原来这么多人碰到过这个问题： </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f21bb63a011b95af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="issus.png">  </p>
<p>要相信，你绝对不是第一个遇到问题的人。是吧，这么多人都来这里提问了，开源库的负责人肯定给出解决方案了，所以接下去继续在这些 issues 里过滤一下，找出那些跟你一样的问题就可以了。如下面这篇：</p>
<p><a href="https://github.com/facebook/fresco/issues/1552" target="_blank" rel="noopener">java.lang.UnsatisfiedLinkError #1552</a>  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6806a04f9a6795e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="issue.png">  </p>
<p>官方人员已经说了，可以尝试使用 Relinker 或 SoLoader 来解决。</p>
<p>最后，我选择了 ReLinker，发现它的源码并不多，直接将所有源码拷贝到项目中，修改了源码中某个流程的逻辑，用于解决我自己这种场景下的 so 文件加载问题，搞定，具体在下面的埋坑一节讲述。</p>
<p>这整个过程中，遇到了一个又一个问题，一个又一个坑，解决这个异常，出现另一个异常，但整个过程梳理过来，也掌握了很多干货知识点，下面就用自己的理解，将这些相关的知识点梳理一下：</p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>看完本篇，你能了解到哪些知识点呢，如下：</p>
<p><strong>P1：了解系统应用集成方式，大概清楚 apk 的 install 过程都做了些什么。</strong></p>
<p><strong>P2：知道如何判断系统应用是否安装成功，懂得查看 data/system/packages.xml 文件来得知应用的基础信息，如 so 库地址，primaryCpuAbi 等。</strong></p>
<p><strong>P3：掌握 System.load() 和 System.loadlibrary() 的区别。</strong></p>
<p><strong>P4：清楚系统寻找 so 文件的大体流程，知道系统什么时候会去 system/lib 下加载 so 文件，什么时候去 system/lib64。</strong></p>
<p><strong>P5：了解 ReLinker 和 SoLoder 库的用途和大体原理。</strong></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>ps: 由于接触尚浅，还看不懂源码，正文部分大多数是直接从各大神博客中梳理出的结论，再用以自己的理解表达出来，因为并没有结合源码来分析，因此给出的结论观点不保证百分百正确，如有错误，欢迎指点一下。  </p>
<p>ps: 以下知识点梳理基于的设备系统 Android 5.1.1，api 22，不同系统的设备，也许过程会有些许差别。</p>
<h3 id="1-install-过程"><a href="#1-install-过程" class="headerlink" title="1. install 过程"></a>1. install 过程</h3><p>要了解 apk 的 install 过程都干了哪些事，先要清楚一个 apk 文件中都有哪些东西，其实 apk 文件就是一个压缩包，后缀改为 zip 就可以直接打开查看内容了，或者 Android Studio 的 Analyze APK 功能也可以查看：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-ece742cb57173ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="apk结构.png">  </p>
<p>classes.dex 是源代码，到时候要加载进内存运行在机器上的；lib 是存放 so 文件；res 是存放资源文件，包括布局文件、图片资源等等；assert 同样存放一些资源文件；AndroidManifest.xml 是清单配置文件；</p>
<p>既然 apk 其实就是个压缩包，将程序运行所需要的东西，比如源代码，比如资源文件等等都打包在一起。那么，install 的过程，其实也就是解压&amp;拷贝&amp;解析的过程。</p>
<p>但不管是哪个过程，首先，这个 apk 文件得先传送到终端设备上，所以，我们开发期间使用的 <code>adb install</code> 命令，或者是直接点击 AndroidStudio 的 run 图标指令（本质上也是运行的 <code>adb install</code>），这个命令其实就干了两件事：</p>
<ol>
<li>adb push</li>
<li>pm install</li>
</ol>
<p>先将 apk push 到终端设备的临时目录，大多数场景下是：data/local/tmp</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-36511e0bf14d8e53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="adbinstall.png">  </p>
<p>如果你有注意执行完 <code>adb install</code> 命令后，会先有一个百分比的进度，这个进度其实并不是安装的进度，而是 <code>adb push</code> 的进度，你可以试着直接执行 <code>adb push</code> 命令，看一下是否会有一个进度提示。</p>
<p>先将 apk 从电脑上 push 到终端设备，然后调用 <code>pm install</code> 命令来安装 apk。</p>
<p>调用了 <code>pm install</code> 命令后就会通知系统去安装这个 apk 了，也就是上述说的拷贝、解压、解析这几个过程。</p>
<p>拷贝是因为，存放在 data/local/tmp 下的 apk 文件始终是位于临时目录下，随时可能被删掉，系统会先将这个 apk 拷贝一份到 data/app 目录下。所以，在 data/app 这个目录下，你基本可以看到所有三方 app 的 apk 包，如果三方 app 都没有另外指定安装到 SD 卡的话。</p>
<p>拷贝结束后，就是对这个 apk 文件进行解压操作，获取里面的文件，将相关文件解压到指定目录，如：</p>
<ul>
<li>创建 data/data/{包名} 目录，存放应用运行期间所需的数据</li>
<li>扫描 apk 包中 lib 目录的 so 文件结构，解压到应用自身存放 so 库的目录，不同版本系统路径有些不同，我设备的版本是 android 5.1.1，api 22，三方应用的 so 文件存放目录就在 data/app/{包名}-1/lib 下</li>
<li>class.dex 源代码转换成 odex 格式，缓存到 data/dalvik-cache 目录下，加快应用的代码运行效率</li>
<li>解析 AndroidManifext.xml 文件以及其他相关文件，将 app 的相关信息写入 data/system/packages.xml 注册表中    </li>
<li>还有其他我不清楚的安装工作</li>
</ul>
<p>梳理一下，安装 apk 过程中，就是解析 apk 中的内容，然后将不同作用的文件拷贝到指定目录中待用，涉及的目录有：</p>
<ul>
<li>data/data/{包名}</li>
<li>data/dalvik-cache</li>
<li>data/app/{包名}-1/lib (后缀有可能是 -1,-2)</li>
<li>data/system/packages.xml</li>
</ul>
<p>我没有找到存放 res，assert 这些资源文件的目录，所以我猜想，这些资源文件其实并没有解压出来，仍旧是存放在 apk 中。我是这么猜想的：</p>
<p>应用运行期间，类加载器所需的源代码是从 data/dalvik-cache 缓存中加载，如果这里没有缓存，则去 data/app/ 对应的 apk 中解压拿到 class.dex，转换成 odex，再次缓存到 data/dalvik-cache，然后让类加载器去加载。</p>
<p>而代码运行期间所需的数据库数据，xml 数据等则直接从 data/data/{包名} 中读取，如果代码需要 res 或 assert 资源文件，则再去 data/app 下的 apk 中拿取。</p>
<p>这是我的猜想，这也才能解释，为什么一旦将 data/app 下的 apk 删掉，应用就无法运行，而如果将 data/data/{包名} 以及 data/dalvik-cache 缓存的 odex 源代码文件删掉，应用仍旧可以照常运行。</p>
<p>正确性与否不清楚，只是我的猜想，以后有时间翻阅源码验证一下。</p>
<p><strong>小结一下</strong></p>
<p>一个三方 apk 的安装过程，不管是通过设备的有界面交互方式下的安装，还是没有交互界面直接通过 <code>adb install</code> 命令安装，还是通过 Android Studio 的 run (本质上是执行 adb install 命令) 安装。</p>
<p>这个过程，首先得先将 apk 文件传送到终端设备上，设备上有了这个 apk 后，系统安装应用的过程其实也就是先将这个 apk 拷贝一份到 data/app 目录下，然后对其进行解压工作，将 apk 包中的 so 文件解压出来，将 dex 文件解压之后对其进行优化处理缓存到 data/dalvik-cache 目录，以便加快之后应用的运行，最后解析 AndroidManifext.xml 文件，将这个应用的基本信息写入 data/system/packages.xml  文件中，然后创建 data/data/{包名} 目录供应用运行期间存放数据。</p>
<h3 id="2-系统应用安装"><a href="#2-系统应用安装" class="headerlink" title="2. 系统应用安装"></a>2. 系统应用安装</h3><p>系统应用的安装方式就不同于三方应用了，系统应用无法通过 install 命令来安装，其实也可以说，<code>adb install</code> 安装的都是三方应用，这些 apk 最后都被安装到了 data/app 目录下。</p>
<p>系统应用只能是在出 rom 包时集成，也就是你设备第一次买来开机时就已跟随着 rom 包自带的应用，除非你的应用有 root 权限。这些应用可以升级，但升级后权限会降为三方应用，将不在拥有系统权限，但将升级后的删掉，重启，就又会恢复初始版本的系统应用了。</p>
<p>这是因为，系统应用的安装过程基本都是在系统启动时才去进行的。</p>
<p>常见的集成方式是直接将 apk 手动 push 到 system/app 目录下，同时解压出 apk 里面的 so 文件，手动将其 push 到 system/lib 下（大部分场景，有的需要 push 到 system/lib64）。</p>
<p>当 push 完成时，如果是首次 push，那么 data/system/packages.xml 注册表中是没有这个系统应用的任何信息的，所以需要重启一下，才能够运行这个应用。 </p>
<p>系统在重启的时候，会去扫描 system/app 目录下的 apk 文件，如果发现这个 apk 没有安装，那么会去触发它的安装工作。这也是为什么重启有时候会很耗时，尤其是升级完 rom 包后，因为此时需要安装一些 apk。</p>
<p>而安装过程基本跟三方应用一样，只是因为 apk 已经在 system/app，所以不会将 apk 拷贝到 data/app。其余的，优化 class.dex 格式为 odex 源代码文件缓存到 data/dalvik-cache，写配置到 data/system/packages.xml 中等等过程仍旧一样。</p>
<p>但有一点，三方应用的 so 文件是直接解压到 data/app 目录下，但系统应用已不存在于 data/app 了，所以它并没有解压 so 文件这个过程，如果 apk 中有使用到 so 文件，那么需要自己手动 push 到 system/lib 或者 system/lib64 目录下。</p>
<p>当然，也可以另外一种集成方式：</p>
<ul>
<li>apk push 到 system/app/{自己创建的目录}/</li>
<li>so 文件 push 到 system/app/{自己创建的目录}/lib 中</li>
</ul>
<p>这种方式的说明，请看后面的后记一章节。</p>
<h3 id="3-packages-xml"><a href="#3-packages-xml" class="headerlink" title="3. packages.xml"></a>3. packages.xml</h3><p>这份配置文件在 data/system/ 目录下，不要小看这份文件，因为不管系统应用还是三方应用，安装过程中都会将其自身的基本信息写入这份文件中。所以，借助这份文件，可以获取到蛮多信息的。</p>
<p>比如，一般排查系统应用为什么启动不了，就可以借助这份文件。</p>
<p>碰到过这么一个问题，我们做的一些应用是没有界面的，就纯粹在后台干活。如果是三方，也许还可以通过手动去启动这个应用来查看相关日志，但偏偏还有些应用是设备开机时就自启的，所以最怕遇到的问题就是测试人员跟你说，这个应用在某个终端上起不来。</p>
<p>因为这时，不清楚这个应用到底是不是因为代码问题导致一直崩溃，起不来；还是因为根本就没安装成功；所以，遇到这类问题，第一点就是要先确认这一点，而确认这一点，就可以借助 packages.xml 这份配置文件了。</p>
<p>如果能够在这份 packages.xml 配置文件中找到应用的信息，那么说明安装成功了，接下去就往另一个方向排查问题了。</p>
<p>还有一种场景借助这份配置文件分析也是很有帮助的。</p>
<p>我们还遇到这种情况：</p>
<p>首先 system/app 下是系统应用，data/app 下是三方应用，但系统是允许 system/app 和 data/app 下存在相同包名的应用，因为允许系统应用进行升级操作，只是此时系统应用将变成三方应用权限。</p>
<p>某次，有反馈说，system/app 下已集成了最新版本的应用，但为什么，每次启动应用时，运行的都是旧版本。这时候怎么排查，就是根据 packages.xml 中这个应用的基本信息，它包括，这个应用的版本号，apk 的来源目录，so 文件的加载地址，所申请的权限等等。</p>
<p>有了这些信息，足够确认，此刻运行的应用是 data/app 下的 apk，还是 system/app 下的 apk。确认了之后，再进一步去排查。</p>
<h3 id="4-System-load-和-System-loadlibrary"><a href="#4-System-load-和-System-loadlibrary" class="headerlink" title="4. System.load 和 System.loadlibrary"></a>4. System.load 和 System.loadlibrary</h3><p><code>load()</code> 和 <code>loadlibrary()</code> 都是用来加载 so 文件的，区别仅在于 <code>load()</code> 接收的是绝对路径，比如 ”data/data/{包名}/lib/xxx.so“ 这样子，因为是绝对路径，所以最后跟着的是 so 文件全名，包括后缀名。</p>
<p>而 <code>loadlibrary()</code> 只需传入 so 文件去头截尾的名字就可以了，如 libblur.so，只需传入 blur 即可，内部会自动补全 so 文件可能存在的路径，以及补全 lib 前缀和 .so 后缀。</p>
<p>所以，下面要讲的，其实就是 <code>loadlibrary()</code> 加载 so 文件的流程。</p>
<p>因为之前碰到过这么个问题，有些不大理解：</p>
<p>我们的应用是系统应用，那么 so 文件也就是集成到 system/lib 或者 system/lib64 目录下，但不清楚，程序是根据什么决定是应该去 system/lib 目录下加载 so 文件，还是去 system/lib64 下加载，或者两处都会去？</p>
<p>所以，下个小节就是讲这个。</p>
<h3 id="5-so-文件加载流程"><a href="#5-so-文件加载流程" class="headerlink" title="5. so 文件加载流程"></a>5. so 文件加载流程</h3><p>这节是本篇的重点，打算亲自过下源码来梳理，但这样篇幅会特别长，基于此，就另起一篇来专门写从源码中梳理 so 文件的加载流程吧，这里就只给出链接和几点结论，感兴趣的可以去看看。</p>
<p><a href="https://www.jianshu.com/p/f243117766f1" target="_blank" rel="noopener">Android 的 so 文件加载机制</a>  </p>
<ul>
<li>一个应用在安装过程中，系统会经过一系列复杂的逻辑确定两个跟 so 文件加载相关的 app 属性值：nativeLibraryDirectories ，primaryCpuAbi ；</li>
<li>nativeLibraryDirectories 表示应用自身存放 so 文件的目录地址，影响着 so 文件的加载流程；</li>
<li>primaryCpuAbi 表示应用应该运行在哪种 abi 上，如（armeabi-v7a），它影响着应用是运行在 32 位还是 64 位的进程上，进而影响到寻找系统指定的 so 文件目录的流程；</li>
<li>以上两个属性，在应用安装结束后，可在 data/system/packages.xml 中查看；</li>
<li>当调用 System 的 <code>loadLibrary()</code> 加载 so 文件时，流程如下：</li>
<li>先到 nativeLibraryDirectories 指向的目录中寻找，是否存在且可用的 so 文件，有则直接加载这里的 so 文件；</li>
<li>上一步没找到的话，则根据当前进程如果是 32 位的，那么依次去 vendor/lib 和 system/lib 目录中寻找；</li>
<li>同样，如果当前进程是 64 位的，那么依次去 vendor/lib64 和 system/lib64 目录中寻找；</li>
<li>当前应用是运行在 32 位还是 64 位的进程上，取决于系统的 ro.zygote 属性和应用的 primaryCpuAbi 属性值，系统的 ro.zygote 可通过执行 getprop 命令查看；</li>
<li>如果 ro.zygote 属性为 zygote64_32，那么应用启动时，会先在 ro.product.cpu.abilist64 列表中寻找是否支持 primaryCpuAbi 属性，有，则该应用运行在 64 位的进程上；</li>
<li>如果上一步不支持，那么会在 ro.product.cpu.abilist32 列表中寻找是否支持 primaryCpuAbi 属性，有，则该应用运行在 32 位的进程上；</li>
<li>如果 ro.zygote 属性为 zygote32_64，则上述两个步骤互换；</li>
<li>如果应用的 primaryCpuAbi 属性为空，那么以 ro.product.cpu.abilist 列表中第一个 abi 值作为应用的 primaryCpuAbi；</li>
<li>运行在 64 位的 abi 有：arm64-v8a，mips64，x86_64</li>
<li>运行在 32 位的 abi 有：armeabi-v7a，armeabi，mips，x86</li>
<li>通常支持 arm64-v8a 的 64 位设备，都会向下兼容支持 32 位的 abi 运行；</li>
<li>但应用运行期间，不能混合着使用不同 abi 的 so 文件；</li>
<li>比如，当应用运行在 64 位进程中时，无法使用 32 位 abi 的 so 文件，同样，应用运行在 32 位进程中时，也无法使用 64 位 abi 的 so 文件；</li>
</ul>
<h3 id="6-三方库-ReLinker-和-Soloder"><a href="#6-三方库-ReLinker-和-Soloder" class="headerlink" title="6. 三方库 ReLinker 和 Soloder"></a>6. 三方库 ReLinker 和 Soloder</h3><p>ReLinker 和 Soloder 都是用于解决一些 so 文件加载失败的场景，比如：</p>
<ul>
<li>嵌套的 so 文件加载异常，如程序引用了三方库，三方库又引用了三方库，各自库中又都存在 so 文件加载，有时候可能会导致 so 文件加载失败。</li>
<li>so 文件缺失导致加载异常，如程序的 so 文件在设备的 so 目录中不见了之类的异常。</li>
<li>等等</li>
</ul>
<p>它们的 Github 地址：</p>
<p><a href="https://github.com/facebook/SoLoader" target="_blank" rel="noopener">SoLoader:https://github.com/facebook/SoLoader</a></p>
<p><a href="https://github.com/KeepSafe/ReLinker" target="_blank" rel="noopener">ReLinker:https://github.com/KeepSafe/ReLinker</a></p>
<p>ReLinker 的原理我有去源码梳理了一遍，大体上是这样：</p>
<ol>
<li>先调用系统 <code>System.loadlibrary()</code> 加载 so 文件，如果成功，结束；</li>
<li>如果失败，则重新解压 apk 文件，解析其中的 lib 目录，遍历 so 文件，找到所需的 so 文件时，将其缓存一份至 data/data/{包名}/app-lib 目录下，调用 <code>System.load()</code> 加载这份 so 文件；</li>
<li>之后每次应用重启，仍旧先调用系统的 <code>System.loadlibrary()</code> 去尝试加载 so 文件，失败，如果 app-lib 下有缓存，且可用，则加载这个缓存的 so 文件，否则重新解压 apk，继续 2 步骤。</li>
</ol>
<ul>
<li>当然，解压 apk 遍历 so 文件时，如果需要的 so 文件存在于不同的 CPU 架构目录中，并不加以区分，直接拿第一个遍历到的 so 文件。</li>
</ul>
<p>SoLoder 的原理我只是稍微过了下，并没有详细看，因为我最后选择的是 ReLinker 方案，但也可以大体上说一说：</p>
<ul>
<li>遍历设备所有存放 so 文件的目录，如 system/lib, vendor/lib，缓存其中所有的 so 文件名。</li>
<li>如果系统加载 so 文件失败时，则从缓存的所有 so 文件名列表中寻找是否有和当前要加载的 so 文件一致的，有则直接加载这个 so 文件。</li>
</ul>
<p>原理大体上应该是这样，感兴趣可以自行去看一下。</p>
<p>那么，这两个 so 文件加载的开源库有什么用呢？看你是否有遇到过 so 文件加载异常了，我的应用场景在埋坑一节里细说。</p>
<h1 id="埋坑"><a href="#埋坑" class="headerlink" title="埋坑"></a>埋坑</h1><p>好了，理论基础都已经有了，那么接下去就是来埋坑了。</p>
<p>针对开头所遇到的 bug，其实原因归根结底就是没有加载到正确的 so 文件，比如程序需要加载的是 system/lib64 下的 so 文件，但运维人员只集成到 system/lib 中；甚至说，运维人员连 so 文件都忘记集成到 system/lib 下了。</p>
<p>另外，运维人员希望，可以有一种统一的集成方法，他不需要去考虑是否还要根据其他条件来判断他是否要集成到  system/lib 还是 system/lib64 还是两者都要。</p>
<p>那么，解决方案其实有两种，一是给他一个新的无需考虑场景的集成方式；二是代码层面做适配，动态去加载所缺失的或不能用的 so 文件。</p>
<h3 id="方案一：系统应用集成方式"><a href="#方案一：系统应用集成方式" class="headerlink" title="方案一：系统应用集成方式"></a>方案一：系统应用集成方式</h3><p>假设需要集成的应用包名：com.dasu.shuai，apk 文件名：dasu.apk</p>
<ol>
<li>在 system/app 目录下新建子目录，命名能表示那个应用即可，如：dasu</li>
<li>将 dasu.apk push 到 system/app/dasu/ 目录下</li>
<li>在 system/app/dasu 目录下新建子目录：lib/arm，这个命名是固定的，这样系统才可以识别</li>
<li>apk 编译打包时，可以删掉其他 CPU 架构的 so 文件，只保留 armeabi-v7a 即可（根据你们应用的用户设备场景为主）</li>
<li>解压 apk 文件，取出里面的 lib/armeabi-v7a 下的 so 文件，push 到 system/lib 或 system/app/dasu/lib/arm 都可以</li>
<li>重启（如果应用首次集成需重启，否则 packages.xml 中无该应用的任何信息）</li>
</ol>
<p>以上方案是针对我们应用自己的用户群场景的集成方式，如果想要通用，最好注意一下步骤 3 和 4，上述的这两个步骤目的在于让系统将该应用的 primaryCpuAbi 属性识别成 armeabi-v7a，这样就无需编译多个不同架构的 so 文件，集成也只需集成到 system/lib 目录中即可。</p>
<p>系统在扫描到 lib/arm 有这个目录存在时，会将 app 的 primaryCpuAbi 设置成 armeabi-v7a，相对应的，如果是 lib/arm64，那么就设置成 arm64-v8a，这是在 api22 机子上测试的结果。</p>
<h3 id="方案二：代码适配"><a href="#方案二：代码适配" class="headerlink" title="方案二：代码适配"></a>方案二：代码适配</h3><p>清楚了 ReLinker 的原理后，其实只要修改其中一个小小的流程即可。当系统加载 so 文件异常，ReLinker 接手来继续寻找 so 文件时，进行到解压 apk 包遍历所有 so 文件时，如果有多个不同 CPU 架构的 so 文件，此时修改原本的以第一个遍历到的 so 文件的逻辑，将其修改成寻找与此时应用的 primaryCpuAbi 一致的架构目录下的 so 文件来使用。</p>
<p>我是两种方案都做了，如果运维能够按照正常步骤集成，那么 so 文件加载异常的概率应该就不会大，即使运维哪个步骤操作失误了，方案二也可以弥补。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本来以为这样子的解决方案足够解决这个问题了，也达到了运维人员的需求了。但没想到，事后居然又发现了新的问题：</p>
<p>由于我们是使用 fresco 图片库的，所以我们 app 的 so 文件其实都是来自 fresco 的，但没想到，合作的厂商它们自己的 app 也是使用的 fresco，然后他们也需要集成 so 文件。</p>
<p>但由于都是作为系统应用集成，so 文件都是统一集成在同一个目录中，如 system/lib，那么我们使用的 fresco 的 so 文件肯定就跟他们的 so 文件冲突了，因为文件名都一致，最后集成的时候就只使用他们的 so 文件。</p>
<p>然后，我们使用的 fresco 版本还跟他们不一样，结果就导致了，使用他们的 so 文件，我们的 app 运行时仍旧会报：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError: No implementation found for long com.facebook.imagepipeline.memory.NativeMemoryChunk.nativeAllocate(int) (tried Java_com_facebook_imagepipeline_memory_NativeMemoryChunk_nativeAllocate and Java_com_facebook_imagepipeline_memory_NativeMemoryChunk_nativeAllocate__I)</span><br></pre></td></tr></table></figure>

<p>那要确认不同版本的 fresco 的 so 文件究竟有哪些差异，也只能去期待 fresco 官网是否有给出相关的文章。一般来说，新版本应该能兼容旧版本才对，这也就意味着，我们使用的版本其实比合作方他们新，如果集成时，使用的是我们的 so 文件，双方应该就都没问题。但跟他们合作一起集成时，如何来判断谁使用的版本新，谁的旧？都不更新的吗？</p>
<p>毕竟人家是厂商，我们只是需求合作，我们弱势，那还是我们自己再来想解决方案吧。</p>
<p>原本的 ReLinker 方案只能解决 so 文件不存在，加载失败，或者 so 文件 abi 异常的问题，但解决不了，so 文件的版本更新问题。</p>
<p>如果真要从代码层面着手，也不是不行，每次加载 so 文件前，先手动去系统的 so 文件目录中，将即将要加载的 so 文件进行一次 md5 计算，程序中可以保存打包时使用的 so 文件的 md5 值，两者相互比较，来判断 so 文件对应的代码版本是否一致。但这样会导致正常的流程需要额外处理一些耗时工作，自行评估吧。</p>
<p>或者，让运维人员在集成时，干脆不要将 so 文件集成到 system/lib 目录中，直接集成到 system/app/{新建目录}/lib/arm/ 目录下，这样我们就只使用我们自己的 so 文件，不用去担心跟他们共用时，版本差异问题了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/bupt073114/article/details/42298337" target="_blank" rel="noopener">1.APK文件结构和安装过程</a></p>
<p><a href="https://blog.csdn.net/leif_/article/details/79494795" target="_blank" rel="noopener">2.Android程序包管理(2)–使用adb install执行安装过程</a></p>
<p><a href="https://www.jianshu.com/p/f243117766f1" target="_blank" rel="noopener">3.Android 的 so 文件加载机制</a>    </p>
]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>继续封装个 Volley 组件</title>
    <url>/2018/10/23/Android%E7%BB%84%E4%BB%B6/%E7%BB%A7%E7%BB%AD%E5%B0%81%E8%A3%85%E4%B8%AA-Volley-%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>前面已经封装了很多常用、基础的组件了：<a href="https://github.com/woshidasusu/base-module" target="_blank" rel="noopener">base-module</a>， 包括了：  </p>
<ul>
<li>crash 处理</li>
<li>常用工具类</li>
<li>apk 升级处理</li>
<li>log 组件</li>
<li>logcat 采集</li>
<li>ftp 文件上传</li>
<li>blur 高斯模糊</li>
<li>fresco 图片处理</li>
<li>等等</li>
</ul>
<p>那么，今天继续再来封装一个网络组件，基于 <a href="https://github.com/google/volley" target="_blank" rel="noopener">volley</a> 的二次封装，目的也是为了简化外部使用，以及新项目可快速接入使用。</p>
<p>这样一来，开发一个简单的 app 所需要的公共基础组件基本都已经封装好了，在这些组件基础上，应该可以快速完成第一版迭代，快速出包。</p>
<p>下一次的计划，也许是封装 OkHttp 的组件，也许是封装个播放器的组件，也可能是封装常用的自定义 View，视情况而定吧。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>封装了这么多组件，一步步走过来，我已经有了自己一定习惯下的封装思路了，可能代码写得并不是很好，设计得不是很合理，内部职责划分不是很明确。</p>
<p>但，我热衷的封装思想是：<strong>一条调用链使用</strong>。</p>
<p>我喜欢借助 AndroidStudio 的代码提示功能，结合调用链的使用方式，将组件的使用划分成多个步骤，控制每个步骤的 api，让其他人使用的时候，最好可以达到不看文档，不看源码，只需要了解入口，之后都可以通过 AndroidStudio 的代码提示来一步步引导使用的目的。</p>
<p>至于为什么需要二次封装 Volley，这篇就不扯了，反正每个组件的封装肯定是来源于有这方面的需求。</p>
<h1 id="二次封装"><a href="#二次封装" class="headerlink" title="二次封装"></a>二次封装</h1><p>同样，<a href="https://github.com/woshidasusu/base-module/tree/master/volley" target="_blank" rel="noopener">DVolley</a> 组件你需要了解的入口也就是：DVolley  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-037f8c0bbdced5d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DVolley.png">  </p>
<p>第一个步骤我开放了三个 api，其实也就是 DVolley 大概支持的功能：</p>
<ul>
<li><code>url()</code> </li>
</ul>
<p>用于访问服务端的接口</p>
<ul>
<li><code>enterGlobalConfig()</code></li>
</ul>
<p>用于配置一些公共的请求参数或请求头信息，比如 mac，t 这类通常都是公共的请求参数，不必每次都手动去设置。</p>
<ul>
<li><code>cancelRequests()</code>  </li>
</ul>
<p>内部支持一次性同时发起六条请求，网络问题等等总会导致某些请求在队列中等待，但如果这时页面退出了，那么这些请求应该就要取消掉，甚至已经发出的请求这时候才回来，那也应该不要通知上层 ui。所以，支持对每条请求设置 tag，然后根据 tag 来取消这些请求。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-2a7ecc88bb8a7a70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Volley_url.png">  </p>
<p>目前组件只支持三个功能：</p>
<ul>
<li><code>post()</code></li>
</ul>
<p>post 方式访问网络接口</p>
<ul>
<li><code>get()</code></li>
</ul>
<p>get 方式访问网络接口</p>
<ul>
<li><code>asImageFile()</code></li>
</ul>
<p>下载网络中的图片文件到本地指定目录，因为 volley 的设计并不能够很好的支持大文件的下载，所以就不提供这个了，刚好有下载图片文件的需求，所以就封装上了。</p>
<p>虽然 volley 也支持类似 fresco 这种框架对图片的缓存，加载处理，但这些工作一般项目里都选择 fresco 或 glide 来处理了，所以组件也就不提供 volley 的这些功能了。</p>
<p>下面看看下载图片文件的用法：</p>
<h3 id="下载图片文件示例"><a href="#下载图片文件示例" class="headerlink" title="下载图片文件示例"></a>下载图片文件示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DVolley.url(<span class="string">"https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png"</span>)</span><br><span class="line">	.asImageFile()</span><br><span class="line">	.downloadTo(<span class="keyword">new</span> File(<span class="string">"/mnt/sdcard/my.png"</span>), <span class="keyword">new</span> VolleyListener&lt;String&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//data 是图片文件保存的目录地址</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">int</span> code, String description)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         &#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>通常图片框架都默认处理图片下载后的缓存目录、保存格式、文件名等等。这就导致有时如果需要明确指定下载网络上某张图片到指定的本地目录中以指定的文件名存储，使用这些图片框架就有些麻烦了，所以就封装了这个功能。</p>
<p>继续回来看看正常的网络接口访问的使用：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-64497db49a04aead.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Volley_get.png">  </p>
<p>post 方法支持的 api 跟 get 一样，也就是设置下 tag（用于取消该请求），设置下请求参数，请求头，然后调用 <code>enqueue()</code>，内部会根据队列情况自动发起请求，可设置回调，回调接收一个泛型参数，内部会自动根据泛型解析 json 数据后在回调方法中返回实体类数据。</p>
<p>所以，其实，封装的组件做的事并不多，就是将 Volley 的使用流程控制起来，提供调用链的使用方式。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.dasu.net:volley:0.0.1&apos;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//get 方法获取 wanAndroid 网站的公众号列表，内部自动进行 json 解析</span><br><span class="line">DVolley.url(&quot;http://wanandroid.com/wxarticle/chapters/json&quot;)</span><br><span class="line">        .get()</span><br><span class="line">        .enqueue(new VolleyListener&lt;ArrayList&lt;WanAndroid&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSuccess(ArrayList&lt;WanAndroid&gt; data) &#123;</span><br><span class="line">                Log.w(&quot;!!!!!!!&quot;, &quot;wan: &quot; + data.size());</span><br><span class="line">                for (WanAndroid wan : data) &#123;</span><br><span class="line">                   Log.e(&quot;!!!!!!!!!!&quot;, wan.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(int code, String description) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;&#125;);</span><br><span class="line"></span><br><span class="line">//post 方法请求，设置参数，请求头，tag（用于取消请求使用）</span><br><span class="line">DVolley.url(&quot;https://easy-mock.com/mock/5b592c01e4e04f38c7a55958/ywb/is/version/checkVersion&quot;)</span><br><span class="line">         .post()</span><br><span class="line">         .tag(&quot;VolleyActivity&quot;)</span><br><span class="line">         .addParam(&quot;name&quot;, &quot;dasu&quot;)</span><br><span class="line">         .addHeader(&quot;weixin&quot;, &quot;dasuAndroidTv&quot;)</span><br><span class="line">         .enqueue(new VolleyListener&lt;EasyMockReturn&gt;() &#123;</span><br><span class="line">             @Override</span><br><span class="line">             public void onSuccess(EasyMockReturn data) &#123;</span><br><span class="line">                 Log.e(&quot;!!!!!&quot;, &quot;return: &quot; + data);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             @Override</span><br><span class="line">             public void onError(int code, String description) &#123;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">//取消tag为xxx的请求</span><br><span class="line">DVolley.cancelRequests(&quot;VolleyActivity&quot;);</span><br><span class="line"></span><br><span class="line">//下载图片文件到本地指定的目录</span><br><span class="line">DVolley.url(&quot;https://upload-images.jianshu.io/upload_images/3537898-445477c7ce870988.png&quot;)</span><br><span class="line">        .asImageFile()</span><br><span class="line">        .downloadTo(new File(&quot;/mnt/sdcard/abcd.png&quot;), new VolleyListener&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSuccess(String data) &#123;</span><br><span class="line">                Log.e(&quot;!!!!!&quot;, &quot;asImageFile: &quot; + data);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(int code, String description) &#123;</span><br><span class="line">                Log.e(&quot;!!!!!&quot;, &quot;asImageFile: &quot; + description);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">//设置通用的请求参数或请求头</span><br><span class="line">DVolley.enterGlobalConfig()</span><br><span class="line">         .globalParam(&quot;t&quot;, String.valueOf(System.currentTimeMillis()))</span><br><span class="line">         .globalHeader(&quot;os&quot;, &quot;android&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a><a href="https://github.com/woshidasusu/base-module/tree/master/volley" target="_blank" rel="noopener">Github地址</a></h1><p><a href="https://github.com/woshidasusu/base-module/tree/master/volley" target="_blank" rel="noopener">DVolley组件:https://github.com/woshidasusu/base-module/tree/master/volley</a>  </p>
<p>组件有如下两个依赖库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.android.volley:volley:1.1.1&apos;</span><br><span class="line">compile &apos;com.google.code.gson:gson:2.7&apos;</span><br></pre></td></tr></table></figure>

<p>支持以下功能：</p>
<ul>
<li>get  请求</li>
<li>post 请求</li>
<li>图片下载在本地指定目录</li>
<li>自动根据泛型解析 json</li>
<li>取消指定请求</li>
<li>设置通用请求参数或请求头  </li>
</ul>
]]></content>
      <categories>
        <category>Android组件</category>
      </categories>
  </entry>
  <entry>
    <title>借鉴Glide思想二次封装Fresco</title>
    <url>/2018/10/19/Android%E7%BB%84%E4%BB%B6/%E5%80%9F%E9%89%B4Glide%E6%80%9D%E6%83%B3%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85Fresco/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>最近封装了个 Fresco 的组件库：<a href="https://github.com/woshidasusu/base-module/tree/master/fresco" target="_blank" rel="noopener">DFresco</a>，就顺便来讲讲。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Fresco 图片库很强大，我们项目中就是使用的 Fresco，但有一点就是，不怎么好使用，略麻烦。不同项目中，多多少少都需要对 Fresco 进行一层封装才能在 ui 里快速使用。</p>
<p>这就导致了，不同项目都根据自己的业务需求场景来进行封装，每次有新项目，复制粘贴时又得解决好多业务耦合的错误，麻烦，是真的麻烦~</p>
<p>而且，首次接触 Fresco，接入上手的成本相比其他图片库，如 Glide，成本都要大很多。</p>
<p>举个例子，假如你有这么个需求：加载一张网络上的 gif 图片，为了防止内存占用过多，需要设置分辨率压缩，最后显示到圆形控件上，同时，需要设置占位图，错误图，拉伸方式等。</p>
<p>那么此时，你的代码可能就是这样的： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ImageDecodeOptions imageDecodeOptions = ImageDecodeOptions.newBuilder()</span><br><span class="line">    	.setDecodePreviewFrame(<span class="keyword">true</span>).build();</span><br><span class="line">ImageRequestBuilder builder = ImageRequestBuilder.newBuilderWithSource(mUri)</span><br><span class="line">   		.setProgressiveRenderingEnabled(<span class="keyword">true</span>)</span><br><span class="line">    	.setImageDecodeOptions(imageDecodeOptions);</span><br><span class="line"><span class="keyword">if</span> (mWidth &gt; <span class="number">0</span> &amp;&amp; mHeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    builder.setResizeOptions(<span class="keyword">new</span> ResizeOptions(mWidth, mHeight));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImageRequest request = builder.build();</span><br><span class="line">AbstractDraweeController controller = Fresco.newDraweeControllerBuilder()</span><br><span class="line">    		.setImageRequest(request)</span><br><span class="line">   		 	.setControllerListener(listener)</span><br><span class="line">    		.setOldController(draweeView.getController())</span><br><span class="line">    		.setAutoPlayAnimations(<span class="keyword">true</span>).build();</span><br><span class="line">draweeView.setController(controller);</span><br></pre></td></tr></table></figure>

<p>同时，你可能还需要在 xml 中对 SimpleDrawwView 控件进行占位图等等的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.facebook.drawee.view.SimpleDraweeView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/sdv_fresco"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"500dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"500dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:actualImageScaleType</span>=<span class="string">"centerCrop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:fadeDuration</span>=<span class="string">"3000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:failureImage</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:failureImageScaleType</span>=<span class="string">"centerCrop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:placeholderImage</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:placeholderImageScaleType</span>=<span class="string">"centerCrop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:progressBarAutoRotateInterval</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:progressBarImage</span>=<span class="string">"@drawable/ani_rotate"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:progressBarImageScaleType</span>=<span class="string">"centerCrop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:retryImage</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:retryImageScaleType</span>=<span class="string">"centerCrop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:backgroundImage</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:overlayImage</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:pressedStateOverlayImage</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:roundAsCircle</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:roundingBorderWidth</span>=<span class="string">"2dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fresco:roundingBorderColor</span>=<span class="string">"@color/colorPrimary"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果忘记了某个自定义属性名是什么的时候，还得到网上搜索下资料，是吧。</p>
<p>小结一下，使用 Fresco，你的接入学习成本至少需要知道 Fresco 的如下信息：</p>
<ul>
<li>SimpleDraweeView 的自定义属性</li>
<li>ImageRequestBuilder 用法及大概用途</li>
<li>AbstractDraweeController 用法及大概用途</li>
<li>GenericDraweeHierarchy 用法及大概用途</li>
</ul>
<p>如果涉及到一些网络下载监听，缓存之类的，那么你还要了解：</p>
<ul>
<li>Imagepipeline 用法及大概用途</li>
</ul>
<p>总之，Fresco 强大是强大，但使用起来不方便，不得不封装一层。</p>
<p>既然要封装，那么就直接借鉴 Glide 的使用思想来进行封装好了，如果有使用过 Glide 的应该很清楚，要实现以上功能，全程一个调用链即可。</p>
<h1 id="二次封装"><a href="#二次封装" class="headerlink" title="二次封装"></a>二次封装</h1><p>封装要达到的目的有两点：</p>
<ul>
<li>使用简洁、方便</li>
<li>其他人接入直接上手的成本尽可能少，最好不用去看文档，去看源码</li>
</ul>
<p>第一点可以参考 Glide 的使用方式来设计，那么第二点我的想法是借助 AndroidStudio 的代码提示功能来实现。</p>
<p>比如，你只需知道，组件的入口是 DFresco 即可，其他都通过 AndroidStudio 来给你提示，如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a5f473375cac6cf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dfresco入口.png">  </p>
<p>当你在 AndroidStudio 上输入 <code>DFresco.</code> 后，界面上会弹出你可用 api，这些就是我开放给你的入口，我将这个使用过程划分成几个步骤，每个步骤能做什么，该做什么，我都给你规定好了，你参照着提示，直接从方法命名上就能够知道该如何使用了，AndroidStudio 会一步步引导你。</p>
<p>这里就两个入口，一个是用来初始化 Fresco 的：</p>
<ul>
<li><code>init(Context)</code></li>
</ul>
<p>这个内部封装了一些默认的初始化配置，比如内存大小配置，内部日志配置等等。</p>
<ul>
<li><code>init(Context, ImagePipelineConfig)</code></li>
</ul>
<p>这个是开放给你的自定义配置，如果你不想使用默认的配置的话。</p>
<ul>
<li><code>source(String url)</code> ：加载网络上的图片</li>
<li><code>source(File localFile)</code> ：加载磁盘上的图片</li>
<li><code>source(Context context, int resId)</code> ：加载 res 内的 drawable 资源图片</li>
<li><code>source(Uri uri)</code> ：通用的加载方式</li>
</ul>
<p>我将常用的几种图片来源单独封装出来使用，方便。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a0cfd99084357ca6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DFresco第二步.png">  </p>
<p>当调用了 <code>source()</code> 后就进入了第二个步骤，这个步骤中，我将图片相关的配置设计到另外一个步骤中去，否则连同图片配置的 api 也都在这里的话，会搞得蛮乱的，可能让使用者到这里后不清楚该调用哪些接口了。</p>
<p>所以，我会把控每个步骤的 api，尽量让每个步骤的 api 做的事都比较相近，比如这里：</p>
<ul>
<li><code>intoTarget(SimpleDraweeView)</code> 加载图片显示到控件上</li>
<li><code>intoTarget(SimpleDraweeView，ControllerListener)</code> 加载图片显示到控件上，允许监听这个过程</li>
<li><code>intoTarget(BaseBitmapDataSubscriber)</code> 只加载图片到内存中，以 Bitmap 形式存在</li>
</ul>
<p>我的需求场景大概就是直接加载图片显示到控件上，或者有时候只是需要将图片加载到内存中，但不用显示到某个控件上，反而要取得图片的 Bitmap 对象，所以我将这些都封装起来了。</p>
<ul>
<li><code>resize(int width, int height)</code></li>
</ul>
<p>这个实际上就是对 Fresco 中的 ResizeOptions 的一层封装而已，简化使用，不至于像以前那么麻烦。</p>
<ul>
<li><code>enterImageConfig()</code></li>
</ul>
<p>如果你都使用默认配置的话，那么是不用再去调用那些各种配置的接口的，所以我才将图片配置封装到另外一个步骤中，这个步骤你可进，可不进，如果有需求，那么通过这个方法进入图片配置步骤：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-849966a1a62a8598.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ImageConfig.png">  </p>
<p>这里的配置项很多，也是因为这个原因，所以才不想让这些接口跟上一个步骤放一起，不然很容易让使用者懵掉。而进入了图片配置这个步骤后，这里提供的 api 其实就是对 GenericDraweeHierarchy 的用途进行了一层封装，或者说对 SimpleDraweeView 的自定义属性进行了一层封装。</p>
<p>如果你不熟悉，没关系，其实就是一些常用的功能，如设置控件为圆形、圆角、边框，设置占位图、失败图、进度图、图片拉伸方式、淡入淡出动画时长等等。</p>
<p>这样封装的目的在于，你可以通过一条调用链的形式就设置完所有的配置，就像 Glide 的使用一样，而不用再去 new 很多 Fresco 的类，再去拼接。</p>
<p>进入图片配置步骤只是一个可选的步骤，进来之后当然就要出去，所以当完成了你的配置后，需要调用：<code>finishImageConfig()</code>，如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-1a196e6efa920365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第三部.png">  </p>
<p>这样就完成了图片配置，将流程切回主线了，就可以继续根据你的需要设置图片显示的目标了。</p>
<p>当然，为了防止再次进入图片配置步骤这样造成之前的配置项失效的场景，我借鉴了 Fresco 的 <code>init</code> 处理方法，即，如果一次使用过程中，重复进入图片配置步骤，那么程序会抛异常来提醒你不能这么做。</p>
<p>以上，就是 DFresco 组件的封装思想，欢迎指点一下哈~</p>
<p>另外，参考了 Glide 的一些处理，当你的 intoTarget 是传入了 SimpleDraweeView 控件时，DFresco 内部会自动根据控件的大小对图片进行一次分辨率压缩，降低图片占用内存，当然，如果你有手动调用了 <code>resize()</code>，那么以你的为主。</p>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.dasu.image:fresco:0.0.1&apos;</span><br></pre></td></tr></table></figure>

<p>使用之前，需先初始化，建议在 Application 中进行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DFresco.init(this);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//加载 res 中的 drawable 图片到 SimpleDraweeView 控件上（默认支持 gif 图，并且会自动根据控件宽高进行分辨率压缩，降低内存占用</span><br><span class="line">DFresco.source(mContext, R.drawable.weixin).intoTarget(mSimpleDraweeView);</span><br><span class="line"></span><br><span class="line">//加载磁盘中的图片，手动设置分辨率的压缩，并获取 bitmap 对象，监听回调，手动显示到 ImageView 控件上</span><br><span class="line">DFresco.source(new File(&quot;/mnt/sdcard/weixin.jpg&quot;))</span><br><span class="line">        .resize(500, 500)</span><br><span class="line">        .intoTarget(new BaseBitmapDataSubscriber() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                protected void onNewResultImpl(Bitmap bitmap) &#123;</span><br><span class="line">                    Log.w(&quot;!!!!!!&quot;, &quot;bitmap：ByteCount = &quot; + bitmap.getByteCount() + &quot;:::bitmap：AllocationByteCount = &quot; + bitmap.getAllocationByteCount());</span><br><span class="line">                    Log.w(&quot;!!!!!!&quot;, &quot;width:&quot; + bitmap.getWidth() + &quot;:::height:&quot; + bitmap.getHeight());</span><br><span class="line">                    mImageView.setImageBitmap(bitmap);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                protected void onFailureImpl(DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; dataSource) &#123;</span><br><span class="line">                    Log.e(&quot;!!!!!!&quot;, &quot;onFailureImpl&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">//加载网络图片，进行各种配置，如缩放方式，占位图，圆形，圆角，动画时长等等，最后自动显示到 SimpleDraweeView 控件上</span><br><span class="line">DFresco.source(&quot;https://upload-images.jianshu.io/upload_images/1924341-9e528ee638e837a5.png&quot;)</span><br><span class="line">                    .enterImageConfig() //进入配置步骤</span><br><span class="line">                    .allFitXY()  //所有图片，包括占位图等等的拉伸方式</span><br><span class="line">                    .animFade(3000) //淡入淡出动画时长</span><br><span class="line">                    .placeholderScaleType(ScalingUtils.ScaleType.CENTER_INSIDE) //设置占位图的拉伸方式，后面设置的会覆盖前面的</span><br><span class="line">                    .actualScaleType(ScalingUtils.ScaleType.CENTER)</span><br><span class="line">//                    .asRound(50) //设置圆角，（圆角和圆形不能同时设置）</span><br><span class="line">                    .asCircle() //设置控件显示为圆形控件</span><br><span class="line">                    .roundBorderColor(Color.RED) //设置圆角或圆形的边框颜色</span><br><span class="line">                    .roundBorderWidth(20)  //设置圆角或圆形的边框宽度</span><br><span class="line">                    .failure(R.drawable.timg) //设置失败图</span><br><span class="line">                    .progressBar(R.drawable.aaaa) //设置加载进度图</span><br><span class="line">                    .retry(R.drawable.weixin) //设置重试时的图</span><br><span class="line">                    .placeholder(R.drawable.image) //设置占位图</span><br><span class="line">                    .finishImageConfig() //退出配置步骤</span><br><span class="line">                    .intoTarget(mSimpleDraweeView);</span><br></pre></td></tr></table></figure>

<h1 id="Github-地址"><a href="#Github-地址" class="headerlink" title="Github 地址"></a><a href="https://github.com/woshidasusu/base-module/tree/master/fresco" target="_blank" rel="noopener">Github 地址</a></h1><p><a href="https://github.com/woshidasusu/base-module/tree/master/fresco" target="_blank" rel="noopener">DFresco：https://github.com/woshidasusu/base-module/tree/master/fresco</a>  </p>
]]></content>
      <categories>
        <category>Android组件</category>
      </categories>
  </entry>
  <entry>
    <title>Android 的 so 文件加载机制</title>
    <url>/2018/10/18/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Android-%E7%9A%84-so-%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</strong>  </p>
</blockquote>
<p>最近碰到一些 so 文件问题，顺便将相关知识点梳理一下。</p>
<h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><p>本文的结论是跟着 <code>System.loadlibrary()</code> 一层层源码走进去，个人对其的理解所整理的，那么开始看源码之前，先来提几个问题：</p>
<p><strong>Q1：你知道 so 文件的加载流程吗？</strong></p>
<p><strong>Q2：设备存放 so 的路径有 system/lib，vendor/lib，system/lib64，vendor/lib64，知道在哪里规定了这些路径吗？清楚哪些场景下系统会去哪个目录下寻找 so 文件吗？还是说，所有的目录都会去寻找？</strong></p>
<p><strong>Q3：Zygote 进程是分 32 位和 64 位的，那么，系统是如何决定某个应用应该运行在 32 位上，还是 64 位上？</strong></p>
<p><strong>Q4：如果程序跑在 64 位的 Zygote 进程上时，可以使用 32 位的 so 文件么，即应用的 primaryCpuAbi 为 arm64-v8a，那么是否可使用 armeabi-v7a 的 so 文件，兼容的吗？</strong></p>
<p>Q2，Q3，Q4，这几个问题都是基于设备支持 64 位的前提下，在旧系统版本中，只支持 32 位，也就没这么多疑问需要处理了。</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>由于这次的源码会涉及很多 framework 层的代码，包括 java 和 c++，直接在 AndroidStudio 跟进 SDK 的源码已不足够查看到相关的代码了。所以，此次是借助 Source Insight 软件，而源码来源如下：</p>
<p><a href="https://android.googlesource.com/platform/" target="_blank" rel="noopener">https://android.googlesource.com/platform/</a>  </p>
<p>我并没有将所有目录下载下来，只下载了如下目录的源码：</p>
<ul>
<li><a href="https://android.googlesource.com/platform/system/core/+archive/android-5.1.1_r24.tar.gz" target="_blank" rel="noopener">system/core</a></li>
<li><a href="https://android.googlesource.com/platform/bionic/+archive/android-5.1.1_r24.tar.gz" target="_blank" rel="noopener">bionic</a></li>
<li><a href="https://android.googlesource.com/platform/libcore/+archive/android-5.1.1_r24.tar.gz" target="_blank" rel="noopener">libcore</a></li>
<li><a href="https://android.googlesource.com/platform/dalvik/+archive/android-5.1.1_r24.tar.gz" target="_blank" rel="noopener">dalvik</a></li>
<li><a href="https://android.googlesource.com/platform/frameworks/base/+archive/android-5.1.1_r24.tar.gz" target="_blank" rel="noopener">frameworks/base</a></li>
<li><a href="https://android.googlesource.com/platform/frameworks/native/+archive/android-5.1.1_r24.tar.gz" target="_blank" rel="noopener">frameworks/native</a></li>
</ul>
<p>我没有下载最新版本的代码，而是选择了 Tags 下的 More 按钮，然后选择 tag 为： <strong>android-5.1.1 r24</strong> 的代码下载。所以，此次分析的源码是基于这个版本，其余不同版本的代码可能会有所不一样，但大体流程应该都是一致的。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>源码分析的过程很长很长，不想看过程的话，你也可以直接跳到末尾看结论，但就会错失很多细节的分析了。</p>
<p>那么下面就开始来过下源码吧，分析的入口就是跟着 <code>System.loadlibrary()</code> 走 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//System#loadlibrary()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Runtime#loadLibrary()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libraryName, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 程序中通过 System.loadlibrary() 方式，这个 loader 就不会为空，流程走这边</span></span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//2. loader.findLibrary() 这是个重点，这个方法用于寻找 so 文件是否存在</span></span><br><span class="line">        String filename = loader.findLibrary(libraryName);</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> + System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 如果 so 文件找到，那么加载它</span></span><br><span class="line">        String error = doLoad(filename, loader);</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//4. 如果加载失败，那么抛异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//1.1 以下代码的运行场景我不清楚，但有几个方法可以蛮看一下</span></span><br><span class="line">    <span class="comment">//mapLibraryName 用于拼接 so 文件名的前缀:lib，和后缀.so</span></span><br><span class="line">    String filename = System.mapLibraryName(libraryName);</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    <span class="comment">//1.2 mLibPaths 存储着设备存放 so 文件的目录地址</span></span><br><span class="line">    <span class="keyword">for</span> (String directory: mLibPaths) &#123;</span><br><span class="line">        String candidate = directory + filename;</span><br><span class="line">        candidates.add(candidate);</span><br><span class="line">        <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) </span><br><span class="line">            <span class="comment">// 1.3 调用 native 层方法加载 so 库</span></span><br><span class="line">            String error = doLoad(candidate, loader);</span><br><span class="line">            <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// We successfully loaded the library. Job done.</span></span><br><span class="line">            &#125;</span><br><span class="line">            lastError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，其实 System 的 <code>loadlibrary()</code> 是调用的 Runtime 的 <code>loadLibrary()</code>，不同系统版本，这些代码是有些许差别的，但不管怎样，重点都还是 <code>loadLibrary()</code> 中调用的一些方法，这些方法基本没变，改变的只是其他代码的优化写法。</p>
<p>那么，要理清 so 文件的加载流程，或者说，要找出系统是去哪些地址加载 so 文件的，就需要梳理清这些方法：</p>
<ul>
<li><code>loader.findLibrary()</code> </li>
<li><code>doLoad()</code></li>
</ul>
<p>第一个方法用于寻找 so 文件，所涉及的整个流程应该都在这个方法里，如果可以找到，会返回 so 文件的绝对路径，然后交由 <code>doLoad()</code> 去加载。</p>
<h4 id="java-library-path"><a href="#java-library-path" class="headerlink" title="java.library.path"></a>java.library.path</h4><p>但在深入去探索之前，我想先探索另一条分支，loader 为空的场景。loader 什么时候为空，什么时候不为空，我并不清楚，只是看别人的文章分析时说，程序中通过 <code>System.loadlibrary()</code> 方式加载 so，那么 loader 就不会为空。那，我就信你了，不然我也不知道去哪分析为不为空的场景。</p>
<p>既然程序不会走另一个分支，为什么我还要先来探索它呢？因为，第一个分支太不好探索了，先从另一个分支摸索点经验，而且还发现了一些感觉可以拿来讲讲的方法：</p>
<ul>
<li><code>System.mapLibraryName()</code> </li>
</ul>
<p>用于拼接 so 文件名的前缀 <code>lib</code>，和后缀 <code>.so</code>。</p>
<ul>
<li><code>mLibPaths</code> </li>
</ul>
<p>在其他版本的源码中，可能就没有这个变量了，直接就是调用一个方法，但作用都一样，我们看看这个变量的赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Runtime.mLibPaths</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] mLibPaths = initLibPaths();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Runtime#initLibPaths()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] initLibPaths() &#123;</span><br><span class="line">    String javaLibraryPath = System.getProperty(<span class="string">"java.library.path"</span>);</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后都是通过调用 System 的 <code>getProperty()</code> 方法，读取 <code>java.library.path</code> 的属性值。</p>
<p>也就是说，通过读取 <code>java.library.path</code> 的系统属性值，是可以获取到设备存放 so 库的目录地址的，那么就来看看在哪里有设置这个属性值进去。</p>
<p>System 内部有一个类型为 Properties 的静态变量，不同版本，这个变量名可能不一样，但作用也都一样，用来存储这些系统属性值，这样程序需要的时候，调用 <code>getProperty()</code> 读取属性值时其实是来这个静态变量中读取。而变量的初始化地方在类中的 static 代码块中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//System</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    <span class="comment">//1.初始化一些不变的系统属性值</span></span><br><span class="line">    unchangeableSystemProperties = initUnchangeableSystemProperties();</span><br><span class="line">    <span class="comment">//2.将上述的属性值以及一些默认的系统属性值设置到静态变量中</span></span><br><span class="line">    systemProperties = createSystemProperties();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System#initUnchangeableSystemProperties()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Properties <span class="title">initUnchangeableSystemProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略一些属性值设置</span></span><br><span class="line">    p.put(<span class="string">"java.vm.vendor"</span>, projectName);</span><br><span class="line">    p.put(<span class="string">"java.vm.version"</span>, runtime.vmVersion());</span><br><span class="line">    p.put(<span class="string">"file.separator"</span>, <span class="string">"/"</span>);</span><br><span class="line">    p.put(<span class="string">"line.separator"</span>, <span class="string">"\n"</span>);</span><br><span class="line">    p.put(<span class="string">"path.separator"</span>, <span class="string">":"</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//1.这里是重点</span></span><br><span class="line">    parsePropertyAssignments(p, specialProperties());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System#createSystemProperties()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Properties <span class="title">createSystemProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.拷贝不可变的一些系统属性值</span></span><br><span class="line">    Properties p = <span class="keyword">new</span> PropertiesWithNonOverrideableDefaults(unchangeableSystemProperties);</span><br><span class="line">    <span class="comment">//2.设置一些默认的属性值</span></span><br><span class="line">    setDefaultChangeableProperties(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System#setDefaultChangeableProperties()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultChangeableProperties</span><span class="params">(Properties p)</span> </span>&#123;</span><br><span class="line">    p.put(<span class="string">"java.io.tmpdir"</span>, <span class="string">"/tmp"</span>);</span><br><span class="line">    p.put(<span class="string">"user.home"</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>static 静态代码块中的代码其实就是在初始化系统属性值，分两个步骤，一个是先设置一些不可变的属性值，二是设置一些默认的属性值，然后将这些存储在静态变量中。</p>
<p>但其实，不管在哪个方法中，都没找到有设置 <code>java.library.path</code> 属性值的代码，那这个属性值到底是在哪里设置的呢？</p>
<p>关键点在于设置不可变的属性时，有调用了一个 native 层的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//System</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns an array of "key=value" strings containing information not otherwise</span></span><br><span class="line"><span class="comment">* easily available, such as #defined library versions.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String[] specialProperties();</span><br></pre></td></tr></table></figure>

<p>这方法会返回 key=value 形式的字符串数组，然后 <code>parsePropertyAssignments()</code> 方法会去遍历这些数组，将这些属性值填充到存储系统属性值的静态变量中。</p>
<p>也就是说，在 native 层还会设置一些属性值，而 <code>java.library.path</code> 有可能就是在 native 中设置的，那么就跟下去看看吧。</p>
<p>System 连同包名的全名是：java.lang.System；那么，通常，所对应的 native 层的 cpp 文件名为：java_lang_System.cpp，到这里去看看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//platform/libcore/luni/src/main/native/java_lang_System.cpp#System_specialProperties()</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jobjectArray <span class="title">System_specialProperties</span><span class="params">(JNIEnv* env, jclass)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//1. 获取 LD_LIBRARY_PATH 环境变量值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* library_path = getenv(<span class="string">"LD_LIBRARY_PATH"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_ANDROID_OS)</span></span><br><span class="line">    <span class="keyword">if</span> (library_path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//2.如果 1 步骤没获取到路径，那么通过该方法获取 so 库的目录路径</span></span><br><span class="line">        android_get_LD_LIBRARY_PATH(path, <span class="keyword">sizeof</span>(path));</span><br><span class="line">        library_path = path;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (library_path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        library_path = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.设置 java.library.path 属性值</span></span><br><span class="line">    properties.push_back(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"java.library.path="</span>) + library_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> toStringArray(env, properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错吧，对应的 native 层的方法是上述这个，它干的事，其实也是设置一些属性值，我们想要的 <code>java.library.path</code> 就是在这里设置的。那么，这个属性值来源的逻辑是这样的：</p>
<ol>
<li>先读取 LD_LIBRARY_PATH 环境变量值，如果不为空，就以这个值为准。但我测试过，貌似，程序运行时读取的这个值一直是 null，在 Runtime 的 <code>doLoad()</code> 方法注释中，Google 有解释是说由于 Android 的进程都是通过 Zygote 进程 fork 过来，所以不能使用 LD_LIBRARY_PATH 。应该，大概，可能是这个意思吧，我英文不大好，你们可以自行去确认一下。</li>
<li>也就是说，第一步读取的 LD_LIBRARY_PATH  值是为空，所以会进入第二步，调用 android_get_LD_LIBRARY_PATH 方法来读取属性值。（进入这个步骤有个条件是定义了 HAVE_ANDROID_OS 宏变量，我就不去找到底哪里在什么场景下会定义了，看命名我直接猜测 Android 系统就都有定义的了）</li>
</ol>
<p>那么，继续看看 android_get_LD_LIBRARY_PATH  这个方法做了些什么：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//platform/libcore/luni/src/main/native/java_lang_System.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_ANDROID_OS)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">android_get_LD_LIBRARY_PATH</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>emmm，看不懂，头疼。那，直接全局搜索下这个方法名试试看吧，结果在另一个 cpp 中找到它的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//platform/bionic/linker/dlfcn.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">android_get_LD_LIBRARY_PATH</span><span class="params">(<span class="keyword">char</span>* buffer, <span class="keyword">size_t</span> buffer_size)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedPthreadMutexLocker <span class="title">locker</span><span class="params">(&amp;g_dl_mutex)</span></span>;</span><br><span class="line">  do_android_get_LD_LIBRARY_PATH(buffer, buffer_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一行估计是加锁之类的意思吧，不管，第二行是调用另一个方法，继续跟下去看看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//platform/bionic/linker/linker.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_android_get_LD_LIBRARY_PATH</span><span class="params">(<span class="keyword">char</span>* buffer, <span class="keyword">size_t</span> buffer_size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">char</span>* end = stpcpy(buffer, kDefaultLdPaths[<span class="number">0</span>]);</span><br><span class="line">  *end = <span class="string">':'</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(end + <span class="number">1</span>, kDefaultLdPaths[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kDefaultLdPaths[] = &#123;</span><br><span class="line">#<span class="keyword">if</span> defined(__LP64__)</span><br><span class="line">  <span class="string">"/vendor/lib64"</span>,</span><br><span class="line">  <span class="string">"/system/lib64"</span>,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  <span class="string">"/vendor/lib"</span>,</span><br><span class="line">  <span class="string">"/system/lib"</span>,</span><br><span class="line">#endif</span><br><span class="line">  <span class="literal">nullptr</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还好 Source Insight 点击方法时有时可以支持直接跳转过去，调用的这个方法又是在另一个 cpp 文件中了。开头省略了一些大小空间校验的代码，然后直接复制了静态常量的值，而这个静态常量在这份文件顶部定义。</p>
<p>终于跟到底了吧，也就是说，如果有定义了 <strong>__LP64__</strong> 这个宏变量，那么就将 <code>java.library.path</code> 属性值赋值为 “/vendor/lib64:/system/lib64”，否则，就赋值为 “/vendor/lib:/system/lib”。</p>
<p>也就是说，so 文件的目录地址其实是在 native 层通过硬编码方式写死的，网上那些理所当然的说 so 文件的存放目录也就是这四个，是这么来的。那么，说白了，系统默认存放 so 文件的目录就两个，只是有两种场景。</p>
<p>而至于到底什么场景下会有这个 __LP64__ 宏变量的定义，什么时候没有，我实在没能力继续跟踪下去了，网上搜索了一些资料后，仍旧不是很懂，如果有清楚的大佬，能够告知、指点下就最棒了。</p>
<p>我自己看了些资料，以及，自己也做个测试：同一个 app，修改它的 primaryCpuAbi 值，调用 System 的 <code>getProperty()</code> 来读取 <code>java.library.path</code>，它返回的值是会不同的。</p>
<p>所以，以我目前的能力以及所掌握的知识，我是这么猜测的，纯属个人猜测：</p>
<p>__LP64__ 这个宏变量并不是由安卓系统代码来定义的，而是 Linux 系统层面所定义的。在 Linux 系统中，可执行文件，也可以说所运行的程序，如果是 32 位的，那么是没有定义这个宏变量的，如果是 64 位的，那么是有定义这个宏变量的。</p>
<p>总之，通俗的联想解释，__LP64__ 这个宏变量表示着当前程序是 32 位还是 64 位的意思。（个人理解）</p>
<p>有时间再继续研究吧，反正这里清楚了，系统默认存放 so 文件的目录只有两个，但有两种场景。vendor 较少用，就不每次都打出来了。也就是说，如果应用在 system/lib 目录中没有找到 so 文件，那么它是不会再自动去 system/lib64 中寻找的，两者它只会选其一。至于选择哪个，因为 Zygote 是有分 32 位还是 64 位进程的，那么刚好可以根据这个为依据。</p>
<h4 id="findLibrary"><a href="#findLibrary" class="headerlink" title="findLibrary"></a>findLibrary</h4><p>该走回主线了，在支线中的探索已经摸索了些经验了。  </p>
<p>大伙应该还记得吧，System 调用了 <code>loadlibrary()</code> 之后，内部其实是调用了 Runtime 的 <code>loadLibrary()</code> 方法，这个方法内部会去调用 ClassLoader 的 <code>findLibrary()</code> 方法，主要是去寻找这个 so 文件是否存在，如果存在，会返回 so 文件的绝对路径，接着交由 Runtime 的 <code>doLoad()</code> 方法去加载 so 文件。</p>
<p>所以，我们想要梳理清楚 so 文件的加载流程，<code>findLibrary()</code> 是关键。那么，接下去，就来跟着 <code>findLibrary()</code> 走下去看看吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassLoader#findLibrary()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">findLibrary</span><span class="params">(String libName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClassLoader 只是一个基类，具体实现在其子类，那这里具体运行的是哪个子类呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//System#loadlibrary()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这里是调用了 VMStack 的一个方法来获取 ClassLoader 对象，那么继续跟进看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">native</span> <span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getCallingClassLoader</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>又是一个 native 的方法，我尝试过跟进去，没有看懂。那么，换个方向来找出这个基类的具体实现子类是哪个吧，很简单的一个方法，打 log 输出这个对象本身：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = getClassLoader();</span><br><span class="line">Log.v(TAG, <span class="string">"classLoader = "</span> + classLoader.toString());</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// classLoader = dalvik.system.PathClassLoader[dexPath=/data/app/com.qrcode.qrcode-1.apk,libraryPath=/data/app-lib/com.qrcode.qrcode-1]</span></span><br></pre></td></tr></table></figure>

<p>以上打 Log 代码是从 <a href="https://my.oschina.net/wolfcs/blog/129696" target="_blank" rel="noopener">Java中System.loadLibrary() 的执行过程</a> 这篇文章中截取出来的，使用这个方法的前提是你得清楚 VMStack 的 <code>getCallingClassLoader()</code> 含义其实是获取调用这个方法的类它的类加载器对象。</p>
<p>或者，你对 Android 的类加载机制有所了解，知道当启动某个 app 时，经过层层工作后，会接着让 LoadedApk 去加载这个 app 的 apk，然后通过 ApplicationLoader 来加载相关代码文件，而这个类内部是实例化了一个 PathClassLoader 对象去进行 dex 的加载。</p>
<p>不管哪种方式，总之清楚了这里实际上是调用了 PathClassLoader 的 <code>findLibrary()</code> 方法，但 PathClassLoader  内部并没有这个方法，它继承自 BaseDexClassLoader，所以实际上还是调用了父类的方法，跟进去看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//platform/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pathList.findLibrary(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br></pre></td></tr></table></figure>

<p>内部又调用了 DexPathList 的 <code>findLibrary()</code> 方法，继续跟进看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//platform/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 拼接前缀：lib，和后缀：.so</span></span><br><span class="line">    String fileName = System.mapLibraryName(libraryName);</span><br><span class="line">    <span class="comment">//2. 遍历所有存放 so 文件的目录，确认指定文件是否存在以及是只读文件</span></span><br><span class="line">    <span class="keyword">for</span> (File directory: nativeLibraryDirectories) &#123;</span><br><span class="line">        String path = <span class="keyword">new</span> File(directory, fileName).getPath();</span><br><span class="line">        <span class="keyword">if</span> (IoUtils.canOpenReadOnly(path)) &#123;</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** List of native library directories. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File[] nativeLibraryDirectories;</span><br></pre></td></tr></table></figure>

<p>到了这里，会先进行文件名补全操作，拼接上前缀：lib 和后缀：.so，然后遍历所有存放 so 文件的目录，当找到指定文件，且是只读属性，则返回该 so 文件的绝对路径。</p>
<p>所以，重点就是 nativeLibraryDirectories 这个变量了，这里存放着 so 文件存储的目录路径，那么得看看它在哪里被赋值了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//platform/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//1. 唯一赋值的地方，构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.nativeLibraryDirectories = splitLibraryPath(libraryPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File[] splitLibraryPath(String path) &#123;</span><br><span class="line">    <span class="comment">// Native libraries may exist in both the system and</span></span><br><span class="line">    <span class="comment">// application library paths, and we use this search order:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   1. this class loader's library path for application libraries</span></span><br><span class="line">    <span class="comment">//   2. the VM's library path from the system property for system libraries</span></span><br><span class="line">    <span class="comment">//   (翻译下，大体是说，so 文件的来源有两处：1是应用自身存放 so 文件的目录，2是系统指定的目录)</span></span><br><span class="line">    <span class="comment">// This order was reversed prior to Gingerbread; see http://b/2933456.</span></span><br><span class="line">    ArrayList &lt; File &gt; result = splitPaths(path, System.getProperty(<span class="string">"java.library.path"</span>), <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> File[result.size()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将传入的两个参数的目录地址解析完都存放到集合中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList &lt; File &gt; splitPaths(String path1, String path2, <span class="keyword">boolean</span> wantDirectories) &#123;</span><br><span class="line">    ArrayList &lt; File &gt; result = <span class="keyword">new</span> ArrayList &lt; File &gt; ();</span><br><span class="line">	</span><br><span class="line">    splitAndAdd(path1, wantDirectories, result);</span><br><span class="line">    splitAndAdd(path2, wantDirectories, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">splitAndAdd</span><span class="params">(String searchPath, <span class="keyword">boolean</span> directoriesOnly, ArrayList &lt; File &gt; resultList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (searchPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为获取系统的 java.library.path 属性值返回的路径是通过 : 拼接的，所以先拆分，然后判断这些目录是否可用 </span></span><br><span class="line">    <span class="keyword">for</span> (String path: searchPath.split(<span class="string">":"</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            StructStat sb = Libcore.os.stat(path);</span><br><span class="line">            <span class="keyword">if</span> (!directoriesOnly || S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">                resultList.add(<span class="keyword">new</span> File(path));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ErrnoException ignored) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，nativeLibraryDirectories 这个变量是在构造函数中被赋值。代码不多，总结一下，构造函数会传入一个 libraryPath 参数，表示应用自身存放 so 文件的路径，然后内部会再去调用 System 的 <code>getProperty(&quot;java.library.path&quot;)</code> 方法获取系统指定的 so 文件目录地址。最后，将这些路径都添加到集合中。</p>
<p>而且，看添加的顺序，是先添加应用自身的 so 文件目录，然后再添加系统指定的 so 文件目录，也就是说，当加载 so 文件时，是先去应用自身的 so 文件目录地址寻找，没有找到，才会去系统指定的目录。</p>
<p>而系统指定的目录地址在 native 层的 linker.cpp 文件定义，分两种场景，取决于应用当前的进程是 32 位还是 64 位，32 位的话，则按顺序分别去 vendor/lib 和 system/lib 目录中寻找，64 位则是相对应的 lib64 目录中。</p>
<p>虽然，so 文件加载流程大体清楚了，但还有两个疑问点：</p>
<ul>
<li>构造方法参数传入的表示应用自身存放 so 文件目录的 libraryPath 值是哪里来的；</li>
<li>应用什么时候运行在 32 位或 64 位的进程上；</li>
</ul>
<h4 id="nativeLibraryDir"><a href="#nativeLibraryDir" class="headerlink" title="nativeLibraryDir"></a>nativeLibraryDir</h4><p>先看第一个疑问点，应用自身存放 so 文件目录的这个值，要追究的话，这是一个很漫长的故事。</p>
<p>这个过程，我不打算全部都贴代码了，因为很多步骤，我自己也没有去看源码，也是看的别人的文章，我们以倒着追踪的方式来进行追溯吧。</p>
<p>首先，这个 libraryPath  值是通过 DexPathList 的构造方法传入的，而 BaseDexClassLoader 内部的 DexPathList 对象实例化的地方也是在它自己的构造方法中，同样，它也接收一个 libraryPath 参数值，所以 BaseDexClassLoader 只是做转发，来源并不在它这里。</p>
<p>那么，再往回走，就是 LoadedApk 实例化 PathClassLoader 对象的地方了，在它的 <code>getClassLoader()</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//platform/frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">final</span> ArrayList &lt; String &gt; libPaths = <span class="keyword">new</span> ArrayList &lt; &gt;();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        libPaths.add(mLibDir);</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">        <span class="keyword">final</span> String lib = TextUtils.join(File.pathSeparator, libPaths);</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">        mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib, mBaseClassLoader);</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoadedApk</span><span class="params">(ActivityThread activityThread, ApplicationInfo aInfo, CompatibilityInfo compatInfo, ClassLoader baseLoader, <span class="keyword">boolean</span> securityViolation, <span class="keyword">boolean</span> includeCode, <span class="keyword">boolean</span> registerPackage)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">    mLibDir = aInfo.nativeLibraryDir;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无关代码都省略掉了，也就是说，传给 DexPathList  的 libraryPath 值，其实是将要启动的这个 app 的 ApplicationInfo 中的 nativeLibraryDir 变量值。</p>
<p>可以看看 ApplicationInfo 中这个变量的注释： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ApplicationInfo </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Full path to the directory where native JNI libraries are stored.</span></span><br><span class="line"><span class="comment">* 存放 so 文件的绝对路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> String nativeLibraryDir;</span><br></pre></td></tr></table></figure>

<p>通俗点解释也就是，存放应用自身 so 文件的目录的绝对路径。那么问题又来了，传给 LoadedApk 的这个 ApplicationInfo 对象哪里来的呢？</p>
<p>这个就又涉及到应用的启动流程了，大概讲一下：</p>
<p>我们知道，当要启动其他应用时，其实是通过发送一个 Intent 去启动这个 app 的 LAUNCHER 标志的 Activity。而当这个 Intent 发送出去后，是通过 Binder 通信方式通知了 ActivityManagerServer 去启动这个 Activity。</p>
<p>AMS 在这个过程中会做很多事，但在所有事之前，它得先解析 Intent，知道要启动的是哪个 app 才能继续接下去的工作，这个工作在 ActivityStackSupervisor 的 <code>resolveActivity()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ActivityStackSupervisor.java</span></span><br><span class="line"><span class="function">ActivityInfo <span class="title">resolveActivity</span><span class="params">(Intent intent, String resolvedType, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Collect information about the target of the Intent.</span></span><br><span class="line">    ActivityInfo aInfo;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ResolveInfo rInfo = AppGlobals.getPackageManager().resolveIntent(intent, resolvedType, PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS, userId);</span><br><span class="line">        aInfo = rInfo != <span class="keyword">null</span> ? rInfo.activityInfo: <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(RemoteException e) &#123;</span><br><span class="line">        aInfo = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同版本，可能不是由这个类负责这个工作了，但可以跟着 ActivityManagerService 的 <code>startActivity()</code> 走下去看看，不用跟很深就能找到，因为这个工作是比较早进行的。</p>
<p>所以，解析 Intent 获取 app 的相关信息就又交给 PackageManagerService 的 <code>resolveIntent()</code> 进行了，PKMS 的工作不贴了，我直接说了吧：</p>
<p>PKMS 会根据 Intent 中目标组件的 packageName，通过一个只有包权限的类 Settings 来获取对应的 ApplicationInfo 信息，这个 Settings 类全名：com.android.server.pm.Settings，它的职责之一是存储所有 app 的基本信息，也就是在 data/system/packages.xml 中各 app 的信息都交由它维护缓存。</p>
<p>所以，一个 app 的 ApplicationInfo 信息，包括 nativeLibraryDir 我们都可以在 data/system/packages.xml 这份文件中查看到。这份文件的角色我把它理解成类似 PC 端上的注册表，所有 app 的信息都注册在这里。</p>
<p>那这份 packages.xml 文件的数据又是从哪里来的呢，这又得涉及到 apk 的安装机制过程了。</p>
<p>简单说一下，一个 app 的安装过程，在解析 apk 包过程中，还会结合各种设备因素等等来决定这个 app 的各种属性，比如说 nativeLibraryDir 这个属性值的确认，就需要考虑这个 app 是三方应用还是系统应用，这个应用的 primaryCpuAbi 属性值是什么，apk 文件的地址等等因素后，最后才确定了应用存放 so 文件的目录地址是哪里。</p>
<p>举个例子，对于系统应用来说，这个 nativeLibraryDir 值有可能最后是 /system/lib/xxx，也有可能是 system/app/xxx/lib 等等；而对于三方应用来说，这值有可能就是 data/app/xxx/lib；</p>
<p>也就是说，当 app 安装完成时，这些属性值也就都解析到了，就都会保存到 Settings 中，同时会将这些信息写入到 data/system/packages.xml 中。</p>
<p><strong>到这里，先来小结一下，梳理下前面的内容：</strong></p>
<p>当一个 app 安装的时候，系统会经过各种因素考量，最后确认 app 的一个 nativeLibraryDir 属性值，这个属性值代表应用自身的 so 文件存放地址，这个值也可以在 data/system/packages.xml 中查看。</p>
<p>当应用调用了 System 的 <code>loadlibrary()</code> 时，这个 so 文件的加载流程如下：</p>
<ol>
<li>先到 nativeLibraryDir 指向的目录地址中寻找这个 so 文件是否存在、可用；</li>
<li>如果没找到，那么根据应用进程是 32 位或者 64 位来决定下去应该去哪个目录寻找 so 文件；</li>
<li>如果是 32 位，则先去 vendor/lib 找，最后再去 system/lib 中寻找；</li>
<li>如果是 64 位，则先去 vendor/lib64 找，最后再去 system/lib64 中寻找；</li>
<li>系统默认的目录是在 native 层中的 linker.cpp 文件中指定，更严谨的说法，不是进程是不是 32 位或 64 位，而是是否有定义了 __LP64__ 这个宏变量。</li>
</ol>
<h4 id="primaryCpuAbi"><a href="#primaryCpuAbi" class="headerlink" title="primaryCpuAbi"></a>primaryCpuAbi</h4><p>我们已经清楚了，加载 so 文件的流程，其实就分两步，先去应用自身存放 so 文件的目录（nativeLibraryDir）寻找，找不到，再去系统指定的目录中寻找。</p>
<p>而系统指定是目录分两种场景，应用进程是 32 位或者 64 位，那么，怎么知道应用是运行在 32 位还是 64 位的呢？又或者说，以什么为依据来决定一个应用是应该跑在 32 位上还是跑在 64 位上？</p>
<p>这个就取决于一个重要的属性了 primaryCpuAbi，它代表着这个应用的 so 文件使用的是哪个 abi 架构。</p>
<p>abi 常见的如：arm64-v8a，armeabi-v7a，armeabi，mips，x86_64 等等。</p>
<p>我们在打包 apk 时，如果不指定，其实默认是会将所有 abi 对应的 so 文件都打包一份，而通常，为了减少 apk 包体积，我们在 build.gradle 脚本中会指定只打其中一两份。但不管 apk 包有多少种不同的 abi 的 so 文件，在 app 安装过程中，最终拷贝到 nativeLibraryDir 中的通常都只有一份，除非你手动指定了要多份。</p>
<p>那么，app 在安装过程中，怎么知道，应该拷贝 apk 中的 lib 下的哪一份 so 文件呢？这就是由应用的 primaryCpuAbi 属性决定。</p>
<p>而同样，这个属性一样是在 app 安装过程中确定的，这个过程更加复杂，末尾有给了篇链接，感兴趣可以去看看，大概来说，就是 apk 包中的 so 文件、系统应用、相同 UID 的应用、设备的 abilist 等都对这个属性值的确定过程有所影响。同样，这个属性值也可以在 data/system/packages.xml 中查看。</p>
<p>那么，这个 primaryCpuAbi 属性值是如何影响应用进程是 32 位还是 64 位的呢？</p>
<p>这就涉及到 Zygote 方面的知识了。</p>
<p>在系统启动之后，系统会根据设备的 ro.zygote 属性值决定启动哪个 Zygote，可以通过执行 <code>getprop | grep ro.zygote</code> 来查看这个属性值，属性值与对应的 Zygote 进程关系如下：</p>
<ul>
<li>zygote32：只启动一个 32 位的 Zygote 进程</li>
<li>zygote32_64：启动两个 Zygote 进程，分别为 32 位和 64 位，32 位的进程名为 zygote，表示以它为主，64 位进程名为  zygote_secondary ，表示它作为辅助</li>
<li>zygote64：只启动一个 64 位的 Zygote 进程</li>
<li>zygote64_32：启动两个 Zygote 进程，分别为 32 位和 64 位，64 位的进程名为 zygote，表示以它为主，32 位进程名为  zygote_secondary ，表示它作为辅助</li>
</ul>
<p>而 Zygote 进程启动之后，会打开一个 socket 端口，等待 AMS 发消息过来启动新的应用时 fork 当前 Zygote 进程，所以，如果 AMS 是发给 64 位的 Zygote，那么新的应用自然就是跑在 64 位的进程上；同理，如果发给了 32 位的 Zygote 进程，那么 fork 出来的进程自然也就是 32 位的。</p>
<p>那么，可以跟随着 AMS 的 <code>startProcessLocked()</code> 方法，去看看是以什么为依据选择 32 位或 64 位的 Zygote：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ActivityManagerService</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...省略</span></span><br><span class="line">    <span class="comment">//1. 获取要启动的 app 的 primaryCpuAbi 属性值，abiOverride 不知道是什么，可能是 Google 开发人员写测试用例用的吧，或者其他一些场景</span></span><br><span class="line">    String requiredAbi = (abiOverride != <span class="keyword">null</span>) ? abiOverride: app.info.primaryCpuAbi;</span><br><span class="line">    <span class="keyword">if</span> (requiredAbi == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//2. 如果为空，以设备支持的首个 abi 属性值，可执行 getprot ro.product.cpu.abilist 查看</span></span><br><span class="line">        requiredAbi = Build.SUPPORTED_ABIS[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//3. 调用Precess 的 start 方法，将 requiredAbi 传入</span></span><br><span class="line">    Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AMS 会先获取要启动的 app 的 primaryCpuAbi 属性值，至于这个 app 的相关信息怎么来的，跟上一小节一样，解析 Intent 时交由 PKMS 去它模块内部的 Settings 读取的。</p>
<p>如果 primaryCpuAbi 为空，则以设备支持的首个 abi 属性值为主，设备支持的 abi 列表可以通过执行 <code>getprot ro.product.cpu.abilist</code> 查看，最后调用 Precess 的 <code>start()</code> 方法，将读取的 abi 值传入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Process</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass, <span class="keyword">final</span> String niceName, <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal, <span class="keyword">int</span> targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass, <span class="keyword">final</span> String niceName, <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid, <span class="keyword">final</span> <span class="keyword">int</span>[] gids, <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal, <span class="keyword">int</span> targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="comment">//所以 abi 最终是调用 openZygoteSocketIfNeeded() 方法，传入给它使用</span></span><br><span class="line">    <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>abi 值又是一层传一层，最终交到了 Process 的 <code>openZygoteSocketIfNeeded()</code> 方法中使用，跟进看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Process</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//ZYGOTE_SOCKET值为 zygote,</span></span><br><span class="line">            <span class="comment">//通过 ZygoteState 的 connect 方法，连接进程名为 zygote 的 Zygote 进程</span></span><br><span class="line">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to primary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//在进程名为 zygote 的 Zygote 进程支持的 abi 列表中，查看是否支持要启动的 app 的需要的 abi</span></span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The primary zygote didn't match. Try the secondary.</span></span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState == <span class="keyword">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//SECONDARY_ZYGOTE_SOCKET 的值为 zygote_secondary,</span></span><br><span class="line">            <span class="comment">//通过 ZygoteState 的 connect 方法，连接进程名为 zygote_secondary 的 Zygote 进程</span></span><br><span class="line">            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to secondary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//在进程名为 zygote_secondary 的 Zygote 进程支持的 abi 列表中，查看是否支持要启动的 app 的需要的 abi</span></span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        <span class="keyword">return</span> secondaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Unsupported zygote ABI: "</span> + abi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ZygoteState primaryZygoteState;</span><br><span class="line"><span class="keyword">static</span> ZygoteState secondaryZygoteState;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZYGOTE_SOCKET = <span class="string">"zygote"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECONDARY_ZYGOTE_SOCKET = <span class="string">"zygote_secondary"</span>;</span><br></pre></td></tr></table></figure>

<p>到了这里，是先获取进程名 zygote 的 Zygote 进程，查看它支持的 abi 列表中是否满足要启动的 app 所需的 abi，如果满足，则使用这个 Zygote 来 fork 新进程，否则，获取另一个进程名为 zygote_secondary 的 Zygote 进程，同样查看它支持的 abi 列表中是否满足 app 所需的 abi，如果都不满足，抛异常。</p>
<p>那么，名为 zygote 和 zygote_secondary 分别对应的是哪个 Zygote 进程呢？哪个对应 32 位，哪个对应 64 位？</p>
<p>还记得上述说过的，系统启动后，会去根据设备的 ro.zygote 属性决定启动哪个 Zygote 进程吗？对应关系就是这个属性值决定的，举个例子，可以看看 zygote64_32 对应的 Zygote 启动配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//platform/system/core/rootdir/init.zygote64_32.rc</span><br><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line"></span><br><span class="line">service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary</span><br><span class="line">    class main</span><br><span class="line">    socket zygote_secondary stream 660 root system</span><br><span class="line">    onrestart restart zygote</span><br></pre></td></tr></table></figure>

<p>这份代码前半段的意思就表示，让 Linux 启动一个 service，进程名为 zygote，可执行文件位于 /system/bin/app_process64，后面是参数以及其他命令。</p>
<p>所以，名为 zygote 和 zygote_secondary 分别对应的是哪个 Zygote 进程，就取决于设备的 ro.zygote 属性。</p>
<p>而，获取 Zygote 支持的 abi 列表是通过 ZygoteState 的 <code>connect()</code> 方法，我们继续跟进看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Process$ZygoteState</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZygoteState <span class="title">connect</span><span class="params">(String socketAddress)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    String abiListString = getAbiList(zygoteWriter, zygoteInputStream);</span><br><span class="line">    Log.i(<span class="string">"Zygote"</span>, <span class="string">"Process: zygote socket opened, supported ABIS: "</span> + abiListString);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZygoteState(zygoteSocket, zygoteInputStream, zygoteWriter, Arrays.asList(abiListString.split(<span class="string">","</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现没有，源码内部将 Zygote 支持的 abi 列表输出日志了，你们可以自己尝试下，过滤下 TAG 为 Zygote，然后重启下设备，因为如果本来就连着 Zygote，那么是不会走到这里的了，最后看一下相关日志，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01-01 08:00:13.509 2818-2818/? D/AndroidRuntime: &gt;&gt;&gt;&gt;&gt;&gt; START com.android.internal.os.ZygoteInit uid 0 &lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">01-01 08:00:15.068 2818-2818/? D/Zygote: begin preload</span><br><span class="line">01-01 08:00:15.081 2818-3096/? I/Zygote: Preloading classes...</span><br><span class="line">01-01 08:00:15.409 2818-3097/? I/Zygote: Preloading resources...</span><br><span class="line">01-01 08:00:16.637 2818-3097/? I/Zygote: ...preloaded 343 resources in 1228ms.</span><br><span class="line">01-01 08:00:16.669 2818-3097/? I/Zygote: ...preloaded 41 resources in 33ms.</span><br><span class="line">01-01 08:00:17.242 2818-3096/? I/Zygote: ...preloaded 3005 classes in 2161ms.</span><br><span class="line">01-01 08:00:17.373 2818-2818/? I/Zygote: Preloading shared libraries...</span><br><span class="line">01-01 08:00:17.389 2818-2818/? D/Zygote: end preload</span><br><span class="line">01-01 08:00:17.492 2818-2818/? I/Zygote: System server process 3102 has been created</span><br><span class="line">01-01 08:00:17.495 2818-2818/? I/Zygote: Accepting command socket connections</span><br><span class="line">01-01 08:00:32.789 3102-3121/? I/Zygote: Process: zygote socket opened, supported ABIS: armeabi-v7a,armeabi</span><br></pre></td></tr></table></figure>

<p>系统启动后，Zygote 工作的相关内容基本都打日志出来了。</p>
<p>最后，再来稍微理一理：</p>
<p>app 安装过程，会确定 app 的一个属性值：primaryCpuAbi，它代表着这个应用的 so 文件使用的是哪个 abi 架构，而且它的确定过程很复杂，apk 包中的 so 文件、系统应用、相同 UID 的应用、设备的 abilist 等都对这个属性值的确定过程有所影响。安装成功后，可以在 data/system/packages.xml 中查看这个属性值。</p>
<p>每启动一个新的应用，都是运行在新的进程中，而新的进程是从 Zygote 进程 fork 过来的，系统在启动时，会根据设备的 ro.zygote 属性值决定启动哪几个 Zygote 进程，然后打开 socket，等待 AMS 发送消息来 fork 新进程。</p>
<p>当系统要启动一个新的应用时，AMS 在负责这个工作进行到 Process 类的工作时，会先尝试在进程名为 zygote 的 Zygote 进程中，查看它所支持的 abi 列表中是否满足要启动的 app 所需的 abi，如果满足，则以这个 Zygote 为主，fork 新进程，运行在 32 位还是 64 位就跟这个 Zygote 进程一致，而 Zygote 运行在几位上取决于 ro.zygote 对应的文件，如值为 zygote64_32 时，对应着 init.zygote64_32.rc 这份文件，那么此时名为 zygote 的 Zygote 就是运行在 64 位上的。</p>
<p>而当上述所找的 Zygote 支持的 abi 列表不满足 app 所需的 abi 时，那么再去名为 zygote_secondary 的 Zygote 进程中看看，它所支持的 abi 列表是否满足。</p>
<p>另外，Zygote 的相关工作流程，包括支持的 abi 列表，系统都有打印相关日志，可过滤 Zygote 查看，如没发现，可重启设备查看。</p>
<h4 id="abi-兼容"><a href="#abi-兼容" class="headerlink" title="abi 兼容"></a>abi 兼容</h4><p>so 文件加载的流程，及应用运行在 32 位或 64 位的依据我们都梳理完了，以上内容足够掌握什么场景下，该去哪些目录下加载 so 文件的判断能力了。</p>
<p>那么，还有个问题，如果应用运行在 64 位上，那么此时，它是否能够使用 armeabi-v7a 的 so 文件？</p>
<p>首先，先来罗列一下常见的 abi ：</p>
<ul>
<li>arm64-v8a，armeabi-v7a，armeabi，mips，mips64，x86，x86_64</li>
</ul>
<p>其中，运行在 64 位的 Zygote 进程上的是：</p>
<ul>
<li>arm64-v8a，mips64，x86_64</li>
</ul>
<p>同样，运行在 32 位的 Zygote 进程上的是：</p>
<ul>
<li>armeabi-v7a，armeabi，mips，x86</li>
</ul>
<p>你们如果去网上搜索如下关键字：so 文件，abi 兼容等，你们会发现，蛮多文章里都会说：arm64-v8a 的设备能够向下兼容，支持运行 32 位的 so 文件，如 armeabi-v7a。</p>
<p>这句话没错，64 位的设备能够兼容运行 32 位的 so 文件，但别只看到这句话啊，良心一些的文章里还有另一句话：<strong>不同 cpu 架构的 so 文件不能够混合使用</strong>，例如，程序运行期间，要么全部使用 arm64-v8a 的 so 文件，要么全部使用 armeabi-v7a 的 so 文件，你不能跑在 64 位进程上，却使用着 32 位的 so 文件。</p>
<p>我所理解的兼容，并不是说，64 位的设备，支持你运行在 64 位的 Zygote 进程上时仍旧可以使用 32 位的 so 文件。有些文章里也说了，如果在 64 位的设备上，你选择使用 32 位的 so 文件，那么此时，你就丢失了专门为 64 位优化过的性能（ART，webview，media等等 ）。这个意思就是说，程序启动时是从 32 位的 Zygote 进程 fork 过来的，等于你在 64 位的设备上，但却只运行在 32 位的进程上。</p>
<p>至于程序如何决定运行在 32 位还是 64 位，上面的章节中也分析过了，以 app 的 primaryCpuAbi 属性值为主，而这个属性值的确定因素之一就是含有的 so 文件所属的 abi。</p>
<p>如果，你还想自己验证，那么可以跟着 Runtime 的 <code>doLoad()</code> 方法跟到 native 层去看看，由于我下载的源码版本可能有些问题，我没找到 Runtime 对应的 cpp 文件，但我找到这么段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//platform/bionic/linker/linker_phdr.cpp</span></span><br><span class="line"><span class="keyword">bool</span> ElfReader::VerifyElfHeader() &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//1.读取 elf 文件的 header 的 class 信息</span></span><br><span class="line">  <span class="keyword">int</span> elf_class = header_.e_ident[EI_CLASS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="comment">//2. 如果当前进程是64位的，而 elf 文件属于 32 位的，则报错</span></span><br><span class="line">  <span class="keyword">if</span> (elf_class != ELFCLASS64) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elf_class == ELFCLASS32) &#123;</span><br><span class="line">      DL_ERR(<span class="string">"\"%s\" is 32-bit instead of 64-bit"</span>, name_);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      DL_ERR(<span class="string">"\"%s\" has unknown ELF class: %d"</span>, name_, elf_class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">//3. 如果当前进程是32位的，而 elf 文件属于 64 位的，则报错</span></span><br><span class="line">  <span class="keyword">if</span> (elf_class != ELFCLASS32) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elf_class == ELFCLASS64) &#123;</span><br><span class="line">      DL_ERR(<span class="string">"\"%s\" is 64-bit instead of 32-bit"</span>, name_);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      DL_ERR(<span class="string">"\"%s\" has unknown ELF class: %d"</span>, name_, elf_class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>加载 so 文件，最终还是交由 native 层去加载，在 Linux 中，so 文件其实就是一个 elf 文件，elf 文件有个 header 头部信息，里面记录着这份文件的一些信息，如所属的是 32 位还是 64 位，abi 的信息等等。</p>
<p>而 native 层在加载 so 文件之前，会去解析这个 header 信息，当发现，如果当前进程运行在 64 位时，但要加载的 so 文件却是 32 位的，就会报 <code>xxx is 32-bit instead of 64-bit</code> 异常，同样，如果当前进程是运行在 32 位的，但 so 文件却是 64 位的，此时报 <code>xxx is 64-bit instead of 32-bit</code> 异常。</p>
<p>这个异常应该也有碰见过吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError: dlopen failed: &quot;libimagepipeline.so&quot; is 32-bit instead of 64-bit</span><br></pre></td></tr></table></figure>

<p>所以说，64 位设备的兼容，并不是说，允许你运行在 64 位的进程上时，仍旧可以使用 32 位的 so 文件。它的兼容是说，允许你在 64 位的设备上运行 32 位的进程。</p>
<p>其实，想想也能明白，这就是为什么三方应用安装的时候，并不会将 apk 包中所有 abi 目录下的 so 文件都解压出来，只会解压一种，因为应用在安装过程中，系统已经确定你这个应用是应该运行在 64 位还是 32 位的进程上了，并将这个结果保存在 app 的 primaryCpuAbi 属性值中。</p>
<p>既然系统已经明确你的应用所运行的进程是 32 位还是 64 位，那么只需拷贝对应的一份 so 文件即可，毕竟 64 位的 so 文件和 32 位的又不能混合使用。</p>
<p>以上，是我的理解，如果有误，欢迎指点下。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整篇梳理下来，虽然梳理 so 的加载流程不难，但要掌握知其所以然的程度，就需要多花费一点心思了。</p>
<p>毕竟都涉及到应用的安装机制，应用启动流程，系统启动机制，Zygote 相关的知识点了。如果你是开发系统应用的，建议还是花时间整篇看一下，毕竟系统应用的集成不像三方应用那样在 apk 安装期间自动将相关 so 文件解压到 nativeLibraryDirectories 路径下了。三方应用很少需要了解 so 的加载流程，但开发系统应用还是清楚点比较好。</p>
<p>不管怎么说，有时间，可以稍微跟着过一下整篇，相信多少是会有些收获的，如果发现哪里有误，也欢迎指点。没时间的话，那就看看总结吧。</p>
<ul>
<li>一个应用在安装过程中，系统会经过一系列复杂的逻辑确定两个跟 so 文件加载相关的 app 属性值：nativeLibraryDirectories ，primaryCpuAbi ；</li>
<li>nativeLibraryDirectories 表示应用自身存放 so 文件的目录地址，影响着 so 文件的加载流程；</li>
<li>primaryCpuAbi 表示应用应该运行在哪种 abi 上，如（armeabi-v7a），它影响着应用是运行在 32 位还是 64 位的进程上，进而影响到寻找系统指定的 so 文件目录的流程；</li>
<li>以上两个属性，在应用安装结束后，可在 data/system/packages.xml 中查看；</li>
<li>当调用 System 的 <code>loadLibrary()</code> 加载 so 文件时，流程如下：</li>
<li>先到 nativeLibraryDirectories 指向的目录中寻找，是否存在且可用的 so 文件，有则直接加载这里的 so 文件；</li>
<li>上一步没找到的话，则根据当前进程如果是 32 位的，那么依次去 vendor/lib 和 system/lib 目录中寻找；</li>
<li>同样，如果当前进程是 64 位的，那么依次去 vendor/lib64 和 system/lib64 目录中寻找；</li>
<li>当前应用是运行在 32 位还是 64 位的进程上，取决于系统的 ro.zygote 属性和应用的 primaryCpuAbi 属性值，系统的 ro.zygote 可通过执行 getprop 命令查看；</li>
<li>如果 ro.zygote 属性为 zygote64_32，那么应用启动时，会先在 ro.product.cpu.abilist64 列表中寻找是否支持 primaryCpuAbi 属性，有，则该应用运行在 64 位的进程上；</li>
<li>如果上一步不支持，那么会在 ro.product.cpu.abilist32 列表中寻找是否支持 primaryCpuAbi 属性，有，则该应用运行在 32 位的进程上；</li>
<li>如果 ro.zygote 属性为 zygote32_64，则上述两个步骤互换；</li>
<li>如果应用的 primaryCpuAbi 属性为空，那么以 ro.product.cpu.abilist 列表中第一个 abi 值作为应用的 primaryCpuAbi；</li>
<li>运行在 64 位的 abi 有：arm64-v8a，mips64，x86_64</li>
<li>运行在 32 位的 abi 有：armeabi-v7a，armeabi，mips，x86</li>
<li>通常支持 arm64-v8a 的 64 位设备，都会向下兼容支持 32 位的 abi 运行；</li>
<li>但应用运行期间，不能混合着使用不同 abi 的 so 文件；</li>
<li>比如，当应用运行在 64 位进程中时，无法使用 32 位 abi 的 so 文件，同样，应用运行在 32 位进程中时，也无法使用 64 位 abi 的 so 文件；</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/csdn_of_coder/article/details/52892266" target="_blank" rel="noopener">1.Android – 系统进程Zygote的启动分析</a> </p>
<p><a href="https://blog.csdn.net/itachi85/article/details/64123035" target="_blank" rel="noopener">2.Android应用程序进程启动过程（前篇）</a></p>
<p><a href="https://blog.csdn.net/hp910315/article/details/51733410" target="_blank" rel="noopener">3.如何查找native方法</a></p>
<p><a href="https://blog.csdn.net/weixin_40107510/article/details/78138874" target="_blank" rel="noopener">4.Android中app进程ABI确定过程</a>  </p>
<p><a href="https://blog.csdn.net/canney_chen/article/details/50633982" target="_blank" rel="noopener">5.Android 64 bit SO加载机制</a>  </p>
]]></content>
      <categories>
        <category>Android源码解析</category>
      </categories>
  </entry>
  <entry>
    <title>Android中一张图片占据的内存大小是如何计算</title>
    <url>/2018/10/14/Android%E7%9F%A5%E8%AF%86/Android%E4%B8%AD%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%E5%8D%A0%E6%8D%AE%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 hongyangAndroid （鸿洋）独家发布</strong>  </p>
</blockquote>
<p>最近封装了个<a href="https://www.jianshu.com/p/6064a14d86a3" target="_blank" rel="noopener">高斯模糊组件</a>，正好将图片相关的理论基础也梳理了下，所以，这次就来讲讲，在 Android 中，怎么计算一张图片在内存中占据的大小，如果要优化，可以从哪些方向着手。</p>
<h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><p>阅读本篇之前，先来想一些问题：</p>
<p><strong>Q1：一张 png 格式的图片，图片文件大小为 55.8KB，那么它加载进内存时所占的大小是多少？</strong>  </p>
<p><strong>Q2：为什么有时候，同一个 app，app 内的同个界面，界面上同张图片，但在不同设备上所耗内存却不一样？</strong>  </p>
<p><strong>Q3：同一张图片，在界面上显示的控件大小不同时，它的内存大小也会跟随着改变吗？</strong>  </p>
<p><strong>Q4：图片占用的内存大小公式：图片分辨率 * 每个像素点大小，这种说法正确吗，或者严谨吗？</strong></p>
<p><strong>Q5：优化图片的内存大小有哪些方向可以着手？</strong>  </p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>在 Android 开发中，经常需要对图片进行优化，因为图片很容易耗尽内存。那么，就需要知道，一张图片的大小是如何计算的，当加载进内存中时，占用的空间又是多少？</p>
<p>先来看张图片：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f82e8067f24fcb33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="png.png">  </p>
<p>这是一张普通的 png 图片，来看看它的具体信息：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-597927253298a6c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="png信息.png">  </p>
<p>图片的分辨率是 1080*452，而我们在电脑上看到的这张 png 图片大小仅有 55.8KB，那么问题来了：</p>
<p><strong>我们看到的一张大小为 55.8KB 的 png 图片，它在内存中占有的大小也是 55.8KB 吗？</strong>  </p>
<p>理清这点蛮重要的，因为碰到过有人说，我一张图片就几 KB，虽然界面上显示了上百张，但为什么内存占用却这么高？</p>
<p>所以，我们需要搞清楚一个概念：我们在电脑上看到的 png 格式或者 jpg 格式的图片，png(jpg) 只是这张图片的容器，它们是经过相对应的压缩算法将原图每个像素点信息转换用另一种数据格式表示，以此达到压缩目的，减少图片文件大小。</p>
<p>而当我们通过代码，将这张图片加载进内存时，会先解析图片文件本身的数据格式，然后还原为位图，也就是 Bitmap 对象，Bitmap 的大小取决于像素点的数据格式以及分辨率两者了。</p>
<p>所以，<strong>一张 png 或者 jpg 格式的图片大小，跟这张图片加载进内存所占用的大小完全是两回事。</strong>你不能说，我 jpg 图片也就 10KB，那它就只占用 10KB 的内存空间，这是不对的。  </p>
<p> <strong>那么，一张图片占用的内存空间大小究竟该如何计算？</strong>  </p>
<p>末尾附上的一篇大神文章里讲得特别详细，感兴趣可以看一看。这里不打算讲这么专业，还是按照我粗坯的理解来给大伙讲讲。</p>
<h3 id="图片内存大小"><a href="#图片内存大小" class="headerlink" title="图片内存大小"></a>图片内存大小</h3><p>网上很多文章都会介绍说，计算一张图片占用的内存大小公式：<strong>分辨率 * 每个像素点的大小</strong>。  </p>
<p>这句话，说对也对，说不对也不对，我只是觉得，不结合场景来说的话，直接就这样表达有点不严谨。</p>
<p>在 Android 原生的 Bitmap 操作中，某些场景下，图片被加载进内存时的分辨率会经过一层转换，所以，虽然最终图片大小的计算公式仍旧是分辨率*像素点大小，但此时的分辨率已不是图片本身的分辨率了。</p>
<p>我们来做个实验，分别从如下的几种考虑点相互组合的场景中，加载同一张图片，看一下占用的内存空间大小分别是多少：</p>
<ul>
<li>图片的不同来源：磁盘、res 资源文件</li>
<li>图片文件的不同格式：png、jpg</li>
<li>图片显示的不同大小的控件</li>
<li>不同的 Android 系统设备</li>
</ul>
<p>测试代码模板如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadResImage</span><span class="params">(ImageView imageView)</span> </span>&#123;</span><br><span class="line">	BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">	Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.weixin, options);</span><br><span class="line">    <span class="comment">//Bitmap bitmap = BitmapFactory.decodeFile("mnt/sdcard/weixin.png", options);</span></span><br><span class="line">	imageView.setImageBitmap(bitmap);</span><br><span class="line">	Log.i(<span class="string">"!!!!!!"</span>, <span class="string">"bitmap：ByteCount = "</span> + bitmap.getByteCount() + <span class="string">":::bitmap：AllocationByteCount = "</span> + bitmap.getAllocationByteCount());</span><br><span class="line">	Log.i(<span class="string">"!!!!!!"</span>, <span class="string">"width:"</span> + bitmap.getWidth() + <span class="string">":::height:"</span> + bitmap.getHeight());</span><br><span class="line">	Log.i(<span class="string">"!!!!!!"</span>, <span class="string">"inDensity:"</span> + options.inDensity + <span class="string">":::inTargetDensity:"</span> + options.inTargetDensity);</span><br><span class="line">	Log.i(<span class="string">"!!!!!!"</span>, <span class="string">"imageview.width:"</span> + imageView.getWidth() + <span class="string">":::imageview.height:"</span> + 	imageView.getHeight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps:这里提一下，使用 Bitmap 的 <code>getByteCount()</code> 方法可以获取当前图片占用的内存大小，当然在 api 19 之后有另外一个方法，而且当 bitmap 是复用时获取的大小含义也有些变化，这些特殊场景就不细说，感兴趣自行查阅。反正这里知道，大部分场景可以通过 <code>getByteCount()</code> 打印图片占用的内存大小来验证我们的实验即可。</p>
<p><strong><a href="https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png" target="_blank" rel="noopener">图片就是上图那张</a>：分辨率为 1080*452 的 png 格式的图片，图片文件本身大小 56KB</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th align="left">前提</th>
<th align="center">Bitmap内存大小</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="left">图片位于res/drawable，设备dpi=240，设备1dp=1.5px，<strong>控件宽高=50dp</strong></td>
<td align="center">4393440B（4.19MB）</td>
</tr>
<tr>
<td>2</td>
<td align="left">图片位于res/drawable，设备dpi=240，设备1dp=1.5px，<strong>控件宽高=500dp</strong></td>
<td align="center">4393440B（4.19MB）</td>
</tr>
<tr>
<td>3</td>
<td align="left"><strong>图片位于res/drawable-hdpi</strong>，设备dpi=240，设备1dp=1.5px</td>
<td align="center">1952640B（1.86MB）</td>
</tr>
<tr>
<td>4</td>
<td align="left"><strong>图片位于res/drawable-xhdpi</strong>，设备dpi=240，设备1dp=1.5px</td>
<td align="center">1098360B（1.05MB）</td>
</tr>
<tr>
<td>5</td>
<td align="left">图片位于res/drawable-xhdpi，<strong>设备dpi=160，</strong>设备1dp=1px</td>
<td align="center">488160B（476.7KB）</td>
</tr>
<tr>
<td>6</td>
<td align="left"><strong>图片位于res/drawable-hdpi</strong>，设备dpi=160，设备1dp=1px</td>
<td align="center">866880（846.5KB）</td>
</tr>
<tr>
<td>7</td>
<td align="left"><strong>图片位于res/drawable</strong>，设备dpi=160，设备1dp=1px</td>
<td align="center">1952640B（1.86MB）</td>
</tr>
<tr>
<td>8</td>
<td align="left"><strong>图片位于磁盘中</strong>，设备dpi=160，设备1dp=1px</td>
<td align="center">1952640B（1.86MB）</td>
</tr>
<tr>
<td>9</td>
<td align="left">图片位于磁盘中，<strong>设备dpi=240</strong>，设备1dp=1.5px</td>
<td align="center">1952640B（1.86MB）</td>
</tr>
</tbody></table>
<p>看见没有，明明都是同一张图片，但在不同场景下，所占用的内存大小却是有可能不一样的，具体稍后分析。以上场景中列出了图片的不同来源，不同 Android 设备，显示控件的不同大小这几种考虑点下的场景。我们继续来看一种场景：同一张图片，保存成不同格式的文件（不是重命名，可借助ps）；</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1924341-f4f0bc17fe695a80.jpg" target="_blank" rel="noopener">图片：</a><strong>分辨率 1080*452 的 jpg 格式的图片，图片文件本身大小 85.2KB</strong></p>
<p>ps:还是同样上面那张图片，只是通过 PhotoShop 存储为 jpg 格式</p>
<table>
<thead>
<tr>
<th>序号</th>
<th align="left">前提</th>
<th align="center">Bitmap内存大小</th>
<th>比较对象</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td align="left">图片位于res/drawable，设备dpi=240，设备1dp=1.5px</td>
<td align="center">4393440B（4.19MB）</td>
<td>序号1</td>
</tr>
<tr>
<td>11</td>
<td align="left"><strong>图片位于res/drawable-hdpi</strong>，设备dpi=240，设备1dp=1.5px</td>
<td align="center">1952640B（1.86MB）</td>
<td>序号3</td>
</tr>
<tr>
<td>12</td>
<td align="left"><strong>图片位于res/drawable-xhdpi</strong>，设备dpi=240，设备1dp=1.5px</td>
<td align="center">1098360B（1.05MB）</td>
<td>序号4</td>
</tr>
<tr>
<td>13</td>
<td align="left"><strong>图片位于磁盘中</strong>，设备dpi=240，设备1dp=1.5px</td>
<td align="center">1952640B（1.86MB）</td>
<td>序号9</td>
</tr>
</tbody></table>
<p>这里列出的几种场景，每个场景比较的实验对象序号也写在每行最后了，大伙可以自己比对确认一下，是不是发现，数据都是一样的，所以这里可以先得到一点结论：</p>
<p><strong>图片的不同格式：png 或者 jpg 对于图片所占用的内存大小其实并没有影响</strong></p>
<p>好了，我们开始来分析这些实验数据：</p>
<p>首先，如果按照图片大小的计算公式：分辨率 * 像素点大小</p>
<p>那么，这张图片的大小按照这个公式应该是：1080 * 452 * 4B = 1952640B ≈ 1.86MB</p>
<p>ps: 这里像素点大小以 4B 来计算是因为，当没有特别指定时，系统默认为 ARGB_8888 作为像素点的数据格式，其他的格式如下：</p>
<ul>
<li>ALPHA_8 – (1B)</li>
<li>RGB_565 – (2B)</li>
<li>ARGB_4444 – (2B)</li>
<li>ARGB_8888 – (4B)</li>
<li>RGBA_F16 – (8B)</li>
</ul>
<p>上述实验中，按理就应该都是这个大小，那，为什么还会出现一些其他大小的数据呢？所以，具体我们就一条条来分析下：</p>
<h4 id="分析点1"><a href="#分析点1" class="headerlink" title="分析点1"></a>分析点1</h4><p>先看序号 1，2 的实验，这两者的区别仅在于图片显示的控件的大小上面。做这个测试是因为，有些人会认为，图片占据内存空间大小与图片在界面上显示的大小会有关系，显示控件越大占用内存越多。显然，这种理解是错误的。</p>
<p>想想，图片肯定是先加载进内存后，才绘制到控件上，那么当图片要申请内存空间时，它此时还不知道要显示的控件大小的，怎么可能控件的大小会影响到图片占用的内存空间呢，除非提前告知，手动参与图片加载过程。</p>
<h4 id="分析点2"><a href="#分析点2" class="headerlink" title="分析点2"></a>分析点2</h4><p>再来看看序号 2，3，4 的实验，这三个的区别，仅仅在于图片在 res 内的不同资源目录中。当图片放在 res 内的不同目录中时，为什么最终图片加载进内存所占据的大小会不一样呢？</p>
<p>如果你们去看下 <code>Bitmap.decodeResource()</code>  源码，你们会发现，系统在加载 res 目录下的资源图片时，会根据图片存放的不同目录做一次分辨率的转换，而转换的规则是：</p>
<p>新图的高度 = 原图高度 * (设备的 dpi / 目录对应的 dpi )</p>
<p>新图的宽度 = 原图宽度 * (设备的 dpi / 目录对应的 dpi )</p>
<p>目录名称与 dpi 的对应关系如下，drawable 没带后缀对应 160 dpi：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-8b93a626fc35a76d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dpi关系.png">  </p>
<p>所以，我们来看下序号 2 的实验，按照上述理论的话，我们来计算看看这张图片的内存大小：</p>
<p>转换后的分辨率：1080 * （240/160） * 452 * （240/160） = 1620 * 678</p>
<p>显然，此时的分辨率已不是原图的分辨率了，经过一层转换，最后计算图片大小：</p>
<p>1620 * 678 * 4B = 4393440B ≈ 4.19MB</p>
<p>这下知道序号 2 的实验结果怎么来的了吧，同样的道理，序号 3 资源目录是 hdpi 对应的是 240，而设备的 dpi 刚好也是 240，所以转换后的分辨率还是原图本身，结果也才会是 1.86MB。</p>
<p>小结一下：</p>
<p><strong>位于 res 内的不同资源目录中的图片，当加载进内存时，会先经过一次分辨率的转换，然后再计算大小，转换的影响因素是设备的 dpi 和不同的资源目录。</strong></p>
<h4 id="分析点3"><a href="#分析点3" class="headerlink" title="分析点3"></a>分析点3</h4><p>基于分析点 2 的理论，看下序号 5，6，7 的实验，这三个实验其实是用于跟序号  2，3，4 的实验进行对比的，也就是这 6 个实验我们可以得出的结论是：</p>
<ul>
<li>同一图片，在同一台设备中，如果图片放在 res 内的不同资源目录下，那么图片占用的内存空间是会不一样的</li>
<li>同一图片，放在 res 内相同的资源目录下，但在不同 dpi 的设备中，图片占用的内存空间也是会不一样的</li>
</ul>
<p>所以，有可能出现这种情况，同一个 app，但跑在不同 dpi 设备上，同样的界面，但所耗的内存有可能是不一样的。</p>
<p>为什么这里还要说是有可能不一样呢？按照上面的理论，同图片，同目录，但不同 dpi 设备，那显然分辨率转换就不一样，所耗内存应该是肯定不一样的啊，为什么还要用有可能这种说辞？</p>
<p>emmm，继续看下面的分析点吧。</p>
<h4 id="分析点4"><a href="#分析点4" class="headerlink" title="分析点4"></a>分析点4</h4><p>序号 8，9 的实验，其实是想验证是不是只有当图片的来源是 res 内才会存在分辨率的转换，结果也确实证明了，当图片在磁盘中，SD 卡也好，assert 目录也好，网络也好（网络上的图片其实最终也是下载到磁盘），只要不是在 res 目录内，那么图片占据内存大小的计算公式，就是按原图的分辨率 * 像素点大小来。</p>
<p>其实，有空去看看 BitmapFactory 的源码，确实也只有 <code>decodeResource()</code> 方法内部会根据 dpi 进行分辨率的转换，其他 <code>decodeXXX()</code> 就没有了。</p>
<p>那么，为什么在上个小节中，要特别说明，即使同一个 app，但跑在不同 dpi 设备上，同样的界面，但所耗的内存有可能是不一样的。这里为什么要特别用<strong>有可能</strong>这个词呢？</p>
<p>是吧，大伙想想。明明按照我们梳理后的理论，图片的内存大小计算公式是：分辨率*像素点大小，然后如果图片的来源是在 res 的话，就需要注意，图片是放于哪个资源目录下的，以及设备本身的 dpi 值，因为系统取 res 内的资源图片会根据这两点做一次分辨率转换，这样的话，图片的内存大小不是肯定就不一样了吗？</p>
<p>emmm，这就取决于你本人的因素了，如果你开发的 app，图片的相关操作都是通过 BitmapFactory 来操作，那么上述问题就可以换成肯定的表述。但现在，哪还有人自己写原生，Github 上那么多强大的图片开源库，而不同的图片开源库，内部对于图片的加载处理，缓存策略，复用策略都是不一样的。</p>
<p>所以，如果使用了某个图片开源库，那么对于加载一张图片到内存中占据了多大的空间，就需要你深入这个图片开源库中去分析它的处理了。</p>
<p>因为基本所有的图片开源库，都会对图片操作进行优化，那么下面就继续来讲讲图片的优化处理吧。</p>
<h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><p>有了上述的理论基础，现在再来想想如果图片占用内存空间太多，要进行优化，可以着手的一些方向，也比较有眉目了吧。</p>
<p>图片占据内存大小的公式也就是：分辨率*像素点大小，只是在某些场景下，比如图片的来源是 res 的话，可能最终图片的分辨率并不是原图的分辨率而已，但归根结底，对于计算机来说，确实是按照这个公式计算。</p>
<p>所以，如果单从图片本身考虑优化的话，也就只有两个方向：</p>
<ul>
<li>降低分辨率</li>
<li>减少每个像素点大小</li>
</ul>
<p>除了从图片本身考虑外，其他方面可以像内存预警时，手动清理，图片弱引用等等之类的操作。</p>
<h4 id="减少像素点大小"><a href="#减少像素点大小" class="headerlink" title="减少像素点大小"></a>减少像素点大小</h4><p>第二个方向很好操作，毕竟系统默认是以 ARGB_8888 格式进行处理，那么每个像素点就要占据 4B 的大小，改变这个格式自然就能降低图片占据内存的大小。</p>
<p>常见的是，将 ARGB_8888 换成 RGB_565 格式，但后者不支持透明度，所以此方案并不通用，取决于你 app 中图片的透明度需求，当然也可以换成 ARGB_4444，但会大大降低图片质量，Google 官方并不推荐。</p>
<p>由于基本是使用图片开源库了，以下列举一些图片开源库修改像素点格式的处理：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fresco，默认使用ARGB_8888</span></span><br><span class="line">Fresco.initialize(context, ImagePipelineConfig.newBuilder(context).setBitmapsConfig(Bitmap.Config.RGB_565).build());</span><br><span class="line"></span><br><span class="line"><span class="comment">//Glide，不同版本，像素点格式不一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlideConfiguration</span> <span class="keyword">implements</span> <span class="title">GlideModule</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyOptions</span><span class="params">(Context context, GlideBuilder builder)</span> </span>&#123;  </span><br><span class="line">        builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(Context context, Glide glide)</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//在AndroidManifest.xml中将GlideModule定义为meta-data</span></span><br><span class="line">&lt;meta-data android:name=<span class="string">"com.inthecheesefactory.lab.glidepicasso.GlideConfiguration"</span> android:value=<span class="string">"GlideModule"</span>/&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Picasso，默认 ARGB_8888</span></span><br><span class="line">Picasso.with(imageView.getContext()).load(url).config(Bitmap.Config.RGB_565).into(imageView);</span><br></pre></td></tr></table></figure>

<p>以上代码摘抄自网络，正确性应该可信，没验证过，感兴趣自行去相关源码确认一下。</p>
<h4 id="降低分辨率"><a href="#降低分辨率" class="headerlink" title="降低分辨率"></a>降低分辨率</h4><p>如果能够让系统在加载图片时，不以原图分辨率为准，而是降低一定的比例，那么，自然也就能够达到减少图片内存的效果。</p>
<p>同样的，系统提供了相关的 API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BitmapFactory.Options.inSampleSize</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>设置 inSampleSize 之后，Bitmap 的宽、高都会缩小 inSampleSize 倍。例如：一张宽高为 2048x1536 的图片，设置 inSampleSize 为 4 之后，实际加载到内存中的图片宽高是 512x384。占有的内存就是 0.75M而不是 12M，足足节省了 15 倍</strong>  </p>
</blockquote>
<p>上面这段话摘抄自末尾给的链接那篇文章中，网上也有很多关于如何操作的讲解文章，这里就不细说了。我还没去看那些开源图片库的内部处理，但我猜想，它们对于图片的优化处理，应该也都是通过这个 API 来操作。</p>
<p>其实，不管哪个图片开源库，在加载图片时，内部肯定就有对图片进行了优化处理，即使我们没手动说明要进行图片压缩处理。这也就是我在上面讲的，为什么当你使用了开源图片库后，就不能再按照图片内存大小一节中所讲的理论来计算图片占据内存大小的原因。</p>
<p>我们可以来做个实验，先看下 fresco 的实验：</p>
<table>
<thead>
<tr>
<th>开源库</th>
<th align="left">前提</th>
<th align="center">Bitmap内存大小</th>
</tr>
</thead>
<tbody><tr>
<td>fresco</td>
<td align="left">图片位于res/drawable，设备dpi=240，设备1dp=1.5px</td>
<td align="center">1952640B（1.86MB）</td>
</tr>
<tr>
<td>fresco</td>
<td align="left"><strong>图片位于res/drawable-hdpi</strong>，设备dpi=240，设备1dp=1.5px</td>
<td align="center">1952640B（1.86MB）</td>
</tr>
<tr>
<td>fresco</td>
<td align="left"><strong>图片位于res/drawable-xhdpi</strong>，设备dpi=240，设备1dp=1.5px</td>
<td align="center">1952640B（1.86MB）</td>
</tr>
<tr>
<td>fresco</td>
<td align="left"><strong>图片位于磁盘中</strong>，设备dpi=240，设备1dp=1.5px</td>
<td align="center">1952640B（1.86MB）</td>
</tr>
</tbody></table>
<p>如果使用 fresco，那么不管图片来源是哪里，分辨率都是以原图的分辨率进行计算的了，从得到的数据也能够证实，fresco 对于像素点的大小默认以 ARGB_8888 格式处理。</p>
<p>我猜想，fresco 内部对于加载 res 的图片时，应该先以它自己的方式获取图片文件对象，最后有可能是通过 BitmapFactory 的 <code>decodeFile()</code> 或者 <code>decodeByteArray()</code> 等等之类的方式加载图片，反正就是不通过 <code>decodeResource()</code> 来加载图片，这样才能说明，为什么不管放于哪个 res 目录内，图片的大小都是以原图分辨率来进行计算。有时间可以去看看源码验证一下。</p>
<p>再来看看 Glide 的实验：</p>
<table>
<thead>
<tr>
<th>开源库</th>
<th align="left">前提</th>
<th align="center">Bitmap内存大小</th>
</tr>
</thead>
<tbody><tr>
<td>Glide</td>
<td align="left">图片位于res/drawable，设备dpi=240，设备1dp=1.5px，显示到宽高500dp的控件</td>
<td align="center">94200B（91.99KB）</td>
</tr>
<tr>
<td>Glide</td>
<td align="left"><strong>图片位于res/drawable-hdpi</strong>，设备dpi=240，设备1dp=1.5px，显示到宽高500dp的控件</td>
<td align="center">94200B（91.99KB）</td>
</tr>
<tr>
<td>Glide</td>
<td align="left">图片位于res/drawable-hdpi，设备dpi=240，设备1dp=1.5px，<strong>不显示到控件，只获取 Bitmap 对象</strong></td>
<td align="center">1952640B（1.86MB）</td>
</tr>
<tr>
<td>Glide</td>
<td align="left"><strong>图片位于磁盘中</strong>，设备dpi=240，设备1dp=1.5px，不显示到控件，只获取 Bitmap 对象</td>
<td align="center">1952640B（1.86MB）</td>
</tr>
<tr>
<td>Glide</td>
<td align="left">图片位于磁盘中，设备dpi=240，设备1dp=1.5px，显示到全屏控件（1920*984）</td>
<td align="center">7557120B（7.21MB）</td>
</tr>
</tbody></table>
<p>可以看到，Glide 的处理与 fresco 又有很大的不同：</p>
<p>如果只获取 bitmap 对象，那么图片占据的内存大小就是按原图的分辨率进行计算。但如果有通过 <code>into(imageView)</code> 将图片加载到某个控件上，那么分辨率会按照控件的大小进行压缩。</p>
<p>比如第一个，显示的控件宽高均为 500dp = 750px，而原图分辨率 1080<em>452，最后转换后的分辨率为：750 * 314，所以图片内存大小：750 \</em> 314 * 4B = 94200B；</p>
<p>比如最后一个，显示的控件宽高为 1920<em>984，原图分辨率转换后为：1920 * 984，所以图片内存大小：1920 \</em> 984 * 4B = 7557120B；</p>
<p>至于这个转换的规则是什么，我不清楚，有时间可以去源码看一下，但就是说，Glide 会自动根据显示的控件的大小来先进行分辨率的转换，然后才加载进内存。</p>
<p>但不管是 Glide，fresco，都不管图片的来源是否在 res 内，也不管设备的 dpi 是多少，是否需要和来源的 res 目录进行一次分辨率转换。</p>
<p>所以，我在图片内存大小这一章节中，才会说到，如果你使用了某个开源库图片，那么，那些理论就不适用了，因为系统开放了 <strong>inSampleSize</strong> 接口设置，允许我们对需要加载进内存的图片先进行一定比例的压缩，以减少内存占用。</p>
<p>而这些图片开源库，内部自然会利用系统的这些支持，做一些内存优化，可能还涉及其他图片裁剪等等之类的优化处理，但不管怎么说，此时，系统原生的计算图片内存大小的理论基础自然就不适用了。</p>
<p>降低分辨率这点，除了图片开源库内部默认的优化处理外，它们自然也会提供相关的接口来给我们使用，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fresco</span></span><br><span class="line">ImageRequestBuilder.newBuilderWithSource(uri)</span><br><span class="line">    .setResizeOptions(<span class="keyword">new</span> ResizeOptions(<span class="number">500</span>, <span class="number">500</span>)).build()</span><br></pre></td></tr></table></figure>

<p>对于 fresco 来说，可以通过这种方式，手动降低分辨率，这样图片占用的内存大小也会跟着减少，但具体这个接口内部对于传入的 (500, 500) 是如何处理，我也还不清楚，因为我们知道，系统开放的 API 只支持分辨率按一定比例压缩，那么 fresco 内部肯定会进行一层的处理转换了。</p>
<p>需要注意一点，我使用的 fresco 是 0.14.1 版本，高版本我不清楚，此版本的 <code>setResizeOptions()</code> 接口只支持对 jpg 格式的图片有效，如果需要对 png 图片的处理，网上很多，自行查阅。</p>
<p>Glide 的话，本身就已经根据控件大小做了一次处理，如果还要手动处理，可以使用它的 <code>override()</code> 方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，来稍微总结一下：</p>
<ul>
<li>一张图片占用的内存大小的计算公式：分辨率 * 像素点大小；但分辨率不一定是原图的分辨率，需要结合一些场景来讨论，像素点大小就几种情况：ARGB_8888(4B)、RGB_565(2B) 等等。</li>
<li>如果不对图片进行优化处理，如压缩、裁剪之类的操作，那么 Android 系统会根据图片的不同来源决定是否需要对原图的分辨率进行转换后再加载进内存。</li>
<li>图片来源是 res 内的不同资源目录时，系统会根据设备当前的 dpi 值以及资源目录所对应的 dpi 值，做一次分辨率转换，规则如下：新分辨率 = 原图横向分辨率 * (设备的 dpi / 目录对应的 dpi ) * 原图纵向分辨率 * (设备的 dpi / 目录对应的 dpi )。</li>
<li>其他图片的来源，如磁盘，文件，流等，均按照原图的分辨率来进行计算图片的内存大小。</li>
<li>jpg、png 只是图片的容器，图片文件本身的大小与它所占用的内存大小没有什么关系，当然它们的压缩算法并不一样，在解码时所耗的内存与效率此时就会有些区别。</li>
<li>基于以上理论，以下场景的出现是合理的：</li>
<li>同个 app，在不同 dpi 设备中，同个界面的相同图片所占的内存大小有可能不一样。</li>
<li>同个 app，同一张图片，但图片放于不同的 res 内的资源目录里时，所占的内存大小有可能不一样。</li>
<li>以上场景之所说有可能，是因为，一旦使用某个热门的图片开源库，那么，以上理论基本就不适用了。</li>
<li>因为系统支持对图片进行优化处理，允许先将图片压缩，降低分辨率后再加载进内存，以达到降低占用内存大小的目的</li>
<li>而热门的开源图片库，内部基本都会有一些图片的优化处理操作：</li>
<li>当使用 fresco 时，不管图片来源是哪里，即使是 res，图片占用的内存大小仍旧以原图的分辨率计算。</li>
<li>当使用 Glide 时，如果有设置图片显示的控件，那么会自动按照控件的大小，降低图片的分辨率加载。图片来源是 res 的分辨率转换规则对它也无效。</li>
</ul>
<p>本篇所梳理出的理论、基本都是通过总结别人的博客内容，以及自己做相关实验验证后，得出来的结论，正确性相比阅读源码本身梳理结论自然要弱一些，所以，如果有错误的地方，欢迎指点一下。有时间，也可以去看看相关源码，来确认一下看看。</p>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="https://www.jianshu.com/p/e49ec7d053b3" target="_blank" rel="noopener">1. Android性能优化（五）之细说Bitmap</a>   </p>
]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>封装个-Android-的高斯模糊组件</title>
    <url>/2018/10/14/Android%E7%BB%84%E4%BB%B6/%E5%B0%81%E8%A3%85%E4%B8%AA-Android-%E7%9A%84%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 hongyangAndroid （鸿洋）独家发布</strong>  </p>
</blockquote>
<p>最近基于 <a href="https://github.com/kikoso/android-stackblur" target="_blank" rel="noopener">Android StackBlur</a> 开源库，根据自己碰到的需求场景，封装了个高斯模糊组件，顺便记录一下。  </p>
<p><strong>为什么要自己重复造轮子？</strong>  </p>
<p>其实也谈不上重头自己造轮子，毕竟是基于大神的开源库，做了二次封装。封装的目的在于，方便外部使用。毕竟有着自己的编程习惯，大神的开源库也只是提供了基础的功能，现实编程中，产品的需求是各种各样的。</p>
<p>导致每次使用时，都蛮麻烦的，需要额外自己处理蛮多东西。而一旦新的项目又需要接入高斯模糊了，又得重新写一些代码，复制粘贴也麻烦，经常由于各种业务耦合报错。</p>
<p>既然如此，干脆花时间抽个基础、公用的高斯模糊组件，需要时直接依赖即可。</p>
<h1 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h1><h3 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h3><p>高斯模糊的原理和算法就不介绍了，我也不懂，没深入，这里就大概讲讲我的粗坯理解：</p>
<p>我们知道，一张图片，本质上其实是一个个像素点构成的，虽然经过计算机处理后，呈现在我们眼前的是具体的图像。但在计算机中，其实就是一堆数组数据。</p>
<p>数组中每个单位就是一个个像素点，那么每个像素点是存储什么内容呢，其实也就是 RGB 或者 ARGB 之类格式的数据。</p>
<p>高斯模糊，大体上就是对这张图片中的每个像素点都重新进行计算，每个像素点的新值等于以它为中心，半径为 r 的周围区域内所有像素点各自按照不同权重相加之和的平均值。</p>
<p>可以粗坯的理解为，<strong>本来这个像素点是要呈现它自己本身的内容，但经过高斯模糊计算后，掺杂进它周围区域像素点的内容了。就像加水稀释类似的道理，既然都掺杂进周围的内容了，那么它呈现的内容相比最初，肯定就不那么清晰了</strong>。</p>
<p>而如果掺杂的半径越大，混合进的内容也就越多，那么它本身的内容就越淡了，是不是这个理。所以，这就是为什么每个开源的高斯模糊组件库，使用时基本都需要我们传入一个 radius 半径的参数。而且，半径越大，越模糊。</p>
<p>这么一粗坯的解释，就理解多了，是吧。</p>
<p>为什么需要大概掌握这个理论基础呢？</p>
<p>想想，高斯模糊是遍历所有像素点，对每个像素点都重新计算。那么，这自然是一个耗时的工作，掌握了理论基础，我们要优化时也才有方向去优化。</p>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>大神的开源库中提供了三种高斯模糊方式，而我在 <a href="https://github.com/Blankj/AndroidUtilCode" target="_blank" rel="noopener">Blankj 的 AndroidUtilCode</a> 开源库中发现了另外一种，所以我将他们都整合起来，一共有四种：</p>
<ul>
<li>Google 官方提供的 RenderScript 方式 （RSBlur）</li>
<li>C 编写的高斯算法 blur.c 方式 （NativeBlur）</li>
<li>Java 编写的高斯算法方式1（JavaBlur）</li>
<li>Java 编写的高斯算法方式2（StackBlur）</li>
</ul>
<p>其实，大体上就三种：Google 官方提供的，大神用 C 写的高斯模糊算法，大神用 Java 写的高斯模糊算法。至于后面两种，看了下，算法的代码不一样，我就把它们当做是两种不同的算法实现了。也许是一样，但我没深入去看，反正代码不一样，我就这么认为了。</p>
<p>下面我们来做个实验，在如下相同条件下，不同高斯模糊方案的耗时比较：</p>
<ul>
<li>radius=10, scale=1, bitmap=200*200(11.69KB)</li>
</ul>
<p>ps: radius 表示高斯算法计算过程中的半径取值，scale=1表示对 bitmap 原图进行高斯模糊。这些前提条件需要了解一下，不然你在看网上其他类似性能比对的文章时，发现它们动不动就优化到几 ms 级别的，然而你自己尝试却始终达不到。这是因为也许所使用的这些前提都不一致，不一致的前提下，耗时根本无从比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testBlur</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">long</span> time = SystemClock.uptimeMillis();</span><br><span class="line">		DBlur.source(<span class="keyword">this</span>, R.drawable.image).modeRs().radius(<span class="number">10</span>).sampling(<span class="number">1</span>).build().doBlurSync();</span><br><span class="line">		<span class="keyword">long</span> end = SystemClock.uptimeMillis();</span><br><span class="line">		sum += (end - time);</span><br><span class="line">	&#125;</span><br><span class="line">    Log.e(<span class="string">"DBlur"</span>, <span class="string">"RSBlur cast "</span> + (sum/<span class="number">100</span>) + <span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码模板如上，分别运行 100 次后取平均值，四种不同方式的耗时如下表：</p>
<table>
<thead>
<tr>
<th align="center">前提条件</th>
<th align="center">RSBlur</th>
<th align="center">NativeBlur</th>
<th align="center">JavaBlur</th>
<th align="center">StackBlur</th>
</tr>
</thead>
<tbody><tr>
<td align="center">radius=<strong>10</strong>, scale=1, bitmap=200*200</td>
<td align="center">51ms</td>
<td align="center">13ms</td>
<td align="center">162ms</td>
<td align="center">384ms</td>
</tr>
<tr>
<td align="center">radius=<strong>20</strong>, scale=1, bitmap=200*200</td>
<td align="center">56ms</td>
<td align="center">12ms</td>
<td align="center">164ms</td>
<td align="center">435ms</td>
</tr>
<tr>
<td align="center">radius=10, scale=<strong>2</strong>, bitmap=200*200</td>
<td align="center">48ms</td>
<td align="center">11ms</td>
<td align="center">75ms</td>
<td align="center">110ms</td>
</tr>
<tr>
<td align="center">radius=10, scale=<strong>8</strong>, bitmap=200*200</td>
<td align="center">45ms</td>
<td align="center">7ms</td>
<td align="center">14ms</td>
<td align="center">19ms</td>
</tr>
<tr>
<td align="center">radius=10, scale=8, bitmap=<strong>1920*1180</strong></td>
<td align="center">183ms</td>
<td align="center">143ms</td>
<td align="center">346ms</td>
<td align="center">460ms</td>
</tr>
<tr>
<td align="center">radius=<strong>20</strong>, scale=8, bitmap=1920*1180</td>
<td align="center">204ms</td>
<td align="center">145ms</td>
<td align="center">353ms</td>
<td align="center">510ms</td>
</tr>
<tr>
<td align="center">radius=20, scale=<strong>1</strong>, bitmap=1920*1180</td>
<td align="center">474ms</td>
<td align="center">444ms</td>
<td align="center">8663ms</td>
<td align="center">内存溢出</td>
</tr>
</tbody></table>
<p>100 次样本可能不多，但大体上我们也能比较出不同类型的高斯模糊之前的区别，及其适用场景：</p>
<ul>
<li>总体上，NativeBlur 和 RSBlur 的耗时会少于 JavaBlur 和 StackBlur</li>
<li>JavaBlur 和 StackBlur 方式，如果先对 Bitmap 进行缩小，再高斯模糊，最后再放大，耗时会大大缩短</li>
<li>radius 增大会增加耗时，但影响不大，但视图呈现效果会越模糊</li>
<li>scale 对原图缩小倍数越多，耗时越短，但视图呈现效果同样会越模糊</li>
<li>分辨率越高的图片，高斯模糊的就越耗时</li>
<li>对于大图而言，如果要使用 JavaBlur 或 StackBlur，最好设置 scale 先缩小再模糊，否则将非常耗时且容易内存溢出</li>
<li>如果已经通过 scale 方式进行优化，那么最好 radius 值可以相对小一点，否则两者的值都大会对图片的模糊效果特别强烈，也许会过了头</li>
</ul>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>高斯模糊的优化考虑点，其实就三个：</p>
<ul>
<li>选择不同的高斯模糊方式</li>
<li>通过 scale 对原图先缩小，再模糊，最后再放大方式</li>
<li>优化高斯模糊算法</li>
</ul>
<p>最后一点就不考虑了，毕竟难度太大。那么，其实就剩下两种，要么是从高斯模糊的方案上选择，要么从待模糊的图片上做手脚。</p>
<p>虽然有四种高斯模糊方案，但每种都有各自优缺点：</p>
<ul>
<li>RSBlur 在低端机上可能无法兼容</li>
<li>NativeBlur 需要生成对应 CPU 架构的 so 文件支持</li>
<li>JavaBlur 和 StackBlur 耗时会较长</li>
</ul>
<p>优化的考虑点大体上这几种：</p>
<ul>
<li>大体上，使用 NativeBlur 或者 RSBlur 即可，如果出现一些问题，那么此时可考虑切到 JavaBlur 或 StackBlur 方案，但记得结合 scale 方式优化处理。</li>
<li>如果高斯模糊的图片有实时性要求，要求模糊得同步进行处理，主线程后续的工作需要等待高斯模糊后才能够处理的话，那么尽量选择 scale 方式进行优化，减少耗时。</li>
<li>如果对实时性没要求，但对图片模糊程度有要求，那其实，只要后台异步去进行高斯模糊即可，此时 scale 可不用缩小太多，而利用 radius 来控制模糊效果，以达到理想的要求。</li>
<li>如果两者都有要求，那就自行尝试寻找折中点吧。</li>
</ul>
<p>最后说一点，因为已经封装成组件库了，RSBlur 也是引入的 support 包，so 文件也打包好了，那么使用这两种方案足够满足绝大部分场景了，所以，没有特意指定，组件默认的方案为 RSBlur。</p>
<h1 id="二次封装"><a href="#二次封装" class="headerlink" title="二次封装"></a>二次封装</h1><h3 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h3><p>为什么要二次封装？那肯定是因为有自己的各种需求场景的，我的需求如下：</p>
<ul>
<li>要能够对当前页面（Activity）截图后，进行模糊</li>
<li>要能够对 drawable 资源图片进行模糊、或者对指定 View 的视图进行模糊</li>
<li>模糊完成后，要能够自动以淡入的动画方式显示在指定的控件上</li>
<li>存在这种需求场景：对当前界面截图、并且模糊，模糊后的图片展示的时机可能在其他界面，因此需要支持缓存功能，可以根据指定 cacheKey 值获取缓存</li>
<li>当然，可以根据各种配置使用高斯模糊，当不指定配置时，有默认配置</li>
</ul>
<p>总结一下，其实封装要做的事也就是要实现：</p>
<ul>
<li>截图、缓存、淡入动画、默认配置</li>
<li>可以的话，组件最好可以达到，其他人在不看文档，不看源码前提下，以最少的成本接入直接上手使用</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>截图、缓存、动画这些都属于纯功能代码的封装了，具体就不说了。</p>
<p>这里想来讲讲，如何设计，可以让其他人以最少的成本接入直接上手使用。</p>
<p>我的想法是，利用 AndroidStudio 的代码提示功能，具体的说就是，你只需要了解组件的入口是 DBlur 即可，至于后续怎么使用，全靠 AndroidStudio 来提示，跟着 AndroidStudio 走就行。</p>
<p>例如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-7eb4707f967a5577.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DBlur入口.png">  </p>
<p>当敲完 DBlur. 时，会弹出代码提示框，入口很少，是吧，就两个，看命名也能猜到作用：<code>getCacheBitmap()</code> 明显是用来取缓存的，那么要高斯模糊自然是另外一个入口 <code>source()</code>，这个方法有多个重载函数，看参数，其实也能知道，这就对应着要模糊的图片的不同来源类型，如：</p>
<ul>
<li>直接传入 Bitmap 对其进行模糊</li>
<li>传入 Activity/View，内部会对这个界面/控件进行截图后再模糊</li>
<li>传入 resId，对 drawable 资源图片进行模糊</li>
</ul>
<p>那么，可能想问了，哪里进行高斯模糊配置，哪里设置同步或异步，哪里注册回调等等。别急，既然只给你开了一个入口，那么就跟着入口走下去，自然会一步步引导你走到最后。如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-9efa2fb81a12cd2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BlurConfigBuilder入口.png">  </p>
<p>第一步、第二步该做什么，我都给你规定好了，你也只能按照步骤一步步来。想要设置高斯模糊配置，你得先指定图片来源，才能进入第二步，在这里，可以进行的配置也都给你列出来了，想要哪个，直接设置即可。如：</p>
<ul>
<li><code>mode()</code>，<code>modeRs()</code>，<code>modeNative()</code> 等等类似 mode 开头的方法，用于指定要使用哪种高斯模糊方案，一共四种，每种内部都有提供对应的常量标志，但如果你不知道哪里找，那么直接调用 modeXXX 方法即可。</li>
<li><code>radius()</code> 用于设置高斯模糊计算的半径，内部默认为 4。</li>
<li><code>sampling()</code> 用于设置对原图的缩小比例，内部默认为 8，即默认先缩小 8 倍，再模糊，最后再放大。</li>
<li><code>cache()</code> 用于设置缓存此次模糊后的图片，没有调用默认不缓存。</li>
<li><code>animAlpha()</code> 用于设置使用淡入动画，需要结合 <code>intoTarget()</code> 使用，否则不生效。</li>
<li><code>intoTarget()</code> 用于设置模糊完成后，自动显示到指定控件上。</li>
</ul>
<p>另外，看每个方法返回的类名，其实这个过程都是在设置配置项，如果有对 Builder 模式了解的话，应该清楚，这个大多用来解决构造函数参数过多的场景，最后一般都会有一个 <code>build()</code> 或者 <code>create()</code> 类型的方法。参考的是 Android 源码中 AlertDialog。</p>
<p>也就是说，要进入下一个步骤，需要调用 <code>build()</code> 方法，如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-96ce20f8a2154350.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="doblur.png">  </p>
<p>显然，已经到最后一个步骤了，这里就是发起高斯模糊工作的地方了。</p>
<ul>
<li><code>doBlur()</code> 会指定此次高斯模糊工作异步进行，所以需要注册回调的在这里传入。</li>
<li><code>doBlurSync()</code> 指定高斯模糊同步进行，模糊后的 Bitmap 直接返回。</li>
</ul>
<p>至此，接入结束。</p>
<p>使用这个高斯模糊的组件，只需要知道 DBlur 入口，其他都跟随着 AndroidStudio 代码提示一步步往下走即可，当然你也可以直接看源码，注释里也写得蛮清楚的了。</p>
<p>这个就是我的想法，能力不足，只能想出这种方案，如果有哪里需要改进，哪里不合理，或者有其他思路，欢迎指点一下。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">compile <span class="string">'com.dasu.image:blur:0.0.4'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用默认配置，最短调用链</span></span><br><span class="line">Bitmap bitmap = DBlur.source(MainActivity.<span class="keyword">this</span>).build().doBlurSync();</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步模糊，将imageView控制的视图进行模糊，完成后自动显示到 imageView1 控件上，以淡入动画方式</span></span><br><span class="line">DBlur.source(imageView).intoTarget(imageView1).animAlpha().build().doBlurSync();</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步模糊，将drawable资源文件中的图片以 NATIVE 方式进行模糊，注册回调，完成时手动显示到 imageView1 控件上</span></span><br><span class="line">DBlur.source(<span class="keyword">this</span>, R.drawable.background).mode(BlurConfig.MODE_NATIVE).build()</span><br><span class="line">      .doBlur(<span class="keyword">new</span> OnBlurListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBlurSuccess</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">                imageView1.setImageBitmap(bitmap);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBlurFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">            &#125;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a><a href="https://github.com/woshidasusu/base-module/tree/master/blur" target="_blank" rel="noopener">Github</a></h3><p><a href="https://github.com/woshidasusu/base-module/tree/master/blur" target="_blank" rel="noopener">DBlur 的 Github 链接：https://github.com/woshidasusu/base-module/tree/master/blur</a>  </p>
]]></content>
      <categories>
        <category>Android组件</category>
      </categories>
  </entry>
  <entry>
    <title>讲讲断点续传那点儿事</title>
    <url>/2018/08/12/Android%E7%9F%A5%E8%AF%86/%E8%AE%B2%E8%AE%B2%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E9%82%A3%E7%82%B9%E5%84%BF%E4%BA%8B/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>这次想来讲讲断点续传，以前没相关需求，所以一直没去接触，近阶段了解了之后，其实并不复杂，那么也便来写一篇记录一下，分享给大伙，也方便自己后续查阅。</p>
<h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><p><strong>Q1：如果你的 app 需要下载大文件，那么是否有方法可以缩短下载耗时？</strong>  </p>
<p><strong>Q2：如果你的 app 在下载大文件时，程序因各种原因被迫中断了，那么下次再重启时，文件是否还需要重头开始下载？</strong>  </p>
<p><strong>Q3：你的 app 下载大文件时，支持暂停并恢复下载么？即使这两个操作分布在程序进程被杀前后。</strong></p>
<h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><p>讲之前，先来通俗的解释下什么是<strong>断点续传</strong>：</p>
<p>说得白一点，其实也就是下载文件时，不必重头开始下载，而是从指定的位置继续下载，这样的功能就叫做断点续传。</p>
<p>既然如此，那么要实现断点续传的关键点其实也就是两点：</p>
<ul>
<li><strong>如何告知服务端，从指定的位置下载</strong></li>
<li><strong>如何知道客户端想要的指定位置是多少</strong></li>
</ul>
<p>是吧，理论上来讲，当这两点都可以做到的时候，自然就可以实现断点续传了。那么，要如何做到呢？</p>
<p>其实，也很简单，并不需要我们自己去写一些什么，HTTP 协议本身就支持断点续传了，所以借助它就可以实现告知服务端，从指定位置下载的功能了。</p>
<p>而另一点，就更简单了，文件是下载到客户端设备上的，那么只要获取到这份下载到一半的文件，看一下它目前的大小，也就知道需要让服务端从哪开始继续下载了。</p>
<p>那么，下面就介绍一下涉及到的相关理论：</p>
<p><strong>Range  &amp; Content-Length &amp; Content-Range &amp; If-Range</strong> </p>
<p>这些都是 HTTP 包中 Header 头部的一些字段信息，其中 Range 和 If-Range 是请求头中的字段，Content-Length 和 Content-Range 是响应头中的字段。</p>
<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>当请求头中出现 Range 字段时，表示告知服务端，客户端下载该文件想要从指定的位置开始下载，至于 Range 字段属性值的格式有以下几种：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Range:bytes=0-500</td>
<td>表示下载从0到500字节的文件，即头500个字节</td>
</tr>
<tr>
<td>Range:bytes=501-1000</td>
<td>表示下载从500到1000这部分的文件，单位字节</td>
</tr>
<tr>
<td>Range:bytes=-500</td>
<td>表示下载最后的500个字节</td>
</tr>
<tr>
<td>Range:bytes=500-</td>
<td>表示下载从500开始到文件结束这部分的内容</td>
</tr>
</tbody></table>
<p>当 app 想实现缩短大文件的下载耗时，可以开启多个下载线程，每个线程只负责文件的一部分下载，当所有线程下载结束后，将每个线程下载的文件按顺序拼接成一个完整的文件，这样就可以达到缩短下载大文件的耗时目的了。</p>
<p>那么，此时，就可以使用 <code>Range:bytes=501-1000</code> 这种格式了，每个线程在各自的请求头字段中，以这种格式加入相对应的信息即可达到目的了。</p>
<p>如果 app 想实现断点续传，文件下载到一半被迫中断，下次启动还可以继续接着上次进度下载时，那么此时可以使用 <code>Range:bytes=500-</code> 这种格式了，只要先获取本地那份文件目前的大小，通过在请求头中加入 Range 字段信息即可。</p>
<h3 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h3><p>Content-Length 字段出现在响应头中，用于告知客户端此次下载的文件大小。</p>
<p>一般，如果客户端需要实现下载进度实时更新时，就需要知道文件的总大小和目前下载的大小，后者可以通过对本地文件的操作得知，前者一般就是通过响应头中的 Content-Length 字段得知。</p>
<p>另外，如果想要实现多线程同时分段下载大文件功能时，显然在下载前，客户端需要先知道文件总大小，才可以做到动态进行分段，因此一般在下载前都会先发送一个不需要携带 body 信息请求，用于先获取响应头中的 Content-Length 字段来得知文件总大小。</p>
<p><strong>但有一点需要注意：Content-Length 只表示此链接中下载的文件大小</strong>  </p>
<p>什么意思，也就是说，如果这条链接是一次性将整个文件下载下来的，那么 Content-Length 就表示这个文件的总大小。</p>
<p>但，如果这条链接指定了 Range，表明了只是下载文件的指定部分的内容，那么此时 Content-Length 表示的就只是这一部分的大小。</p>
<p>所以，如果客户端实现了下载进度实时更新功能时，需要注意一下。因为如果文件是断点续传的，那么进度条的分母就不能用每次 HTTP 链接中的 Content-Length。要么下载前先发一条获取用于文件总大小的请求，然后一直维护着这个数据，要么就使用 Content-Range 字段。</p>
<h3 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h3><p>Content-Range 字段也是出现在响应头中，用于告知客户端此链接下载的文件是哪个部分的，以及文件的总大小。</p>
<p>比如，当客户端在请求头中指定了 <code>Range:bayes=501-1000</code> 来下载一个总大小为 2000 字节文件的中间一部分内容时，此时，响应头中的 Content-Range 字段信息如下：</p>
<p><code>Content-Range:bytes 501-1000/2000</code></p>
<p>斜杠前表示此链接下载的文件是哪一部分，斜杠后表示文件的总大小。</p>
<h3 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h3><p>断点续传，说白点也就是分多次下载，既然不是一次性下载，那么就无法保证多次下载的间隔。</p>
<p>也就是说，有可能出现这种场景，这次由于某些原因只下载的一部分，而下次重启继续下载，但可能等到过了很多天后才重启去继续下载，如果在这期间，服务端的这份文件更新了怎么办？</p>
<p>只要不是一次性下载的，那么就有可能会出现这种场景，显然，这时候，就不希望断点续传了，而是要让客户端直接重头开始下载，毕竟文件都已经发生更新了，不是同一份了，再继续恢复下载也没有什么意义。</p>
<p>那么，客户端要如何知道服务端的文件是否发生变化，要重头下载呢？</p>
<p>这时就可以结合 If-Range 字段来实现了，这个也是在请求头中的字段，跟 Range 字段一起使用，它的作用是给 Range 字段生效设置了一些条件，只有满足这些条件，Range 才能生效。</p>
<p>也就是说，只有先满足 If-Range，那么才能通过 Range 来实现断点续传。</p>
<p>那它的条件值可以设置为哪些呢？有两种，Last-Modified 或者 ETag，这两个也都是响应头中的字段。  </p>
<p>具体可以参考这篇文章：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Range" target="_blank" rel="noopener">MDN If-Range</a>  </p>
<h3 id="抓包示例"><a href="#抓包示例" class="headerlink" title="抓包示例"></a>抓包示例</h3><p>以上就是断点续传相关的理论基础，下面抓个包，看看请求头和响应头中的信息，来总结一下理论基础。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-e01bee6c8b81e0e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="断点续传.png">  </p>
<p>首先先发起一个请求，设置了不携带 BODY 信息，这样就可以在下载前先获取到文件的总大小。至于怎么设置不携带 BODY 信息，不同的网络框架不同，具体下节代码示例中说明。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-91495ddefb8b2eb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="断点续传2.png">  </p>
<p>这是下载中断后，重启想要继续下载时发起的请求信息，请求头中指定了 <code>Range:bytes=12341380-</code> 表示本地已经下载了这么多，需要从这里开始继续往下下载。</p>
<p>响应头中返回了这部分的内容，并在 Content-Length 和 Content-Range 字段中给出了相关信息。  </p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>理论基础掌握了，那么下面就是来看看代码怎么实现。不管用什么语言，使用了什么网络框架，要写的代码都有两个部分：</p>
<ul>
<li><strong>文件处理操作</strong></li>
<li><strong>添加请求头信息操作</strong>  </li>
</ul>
<p>文件处理操作有两个关键点，一是获取文件大小，二是以追加的方式写文件。添加请求头的操作则是参考各自网络框架的指示即可。</p>
<p>下面介绍了三种示例，分别是 C++&amp;libcurl，Android&amp;HttpURLConnection，Android&amp;OkHttp。&amp;前面是语言，后面是所使用的网络框架。</p>
<h3 id="C-amp-libcurl"><a href="#C-amp-libcurl" class="headerlink" title="C++&amp;libcurl"></a>C++&amp;libcurl</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入libcurl库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl\curl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"libcurl.lib"</span>) </span></span><br><span class="line"><span class="comment">//文件操作库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* mLocalFilePath;<span class="comment">//下载到本地的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取已下载部分的大小，如果没有则返回0</span></span><br><span class="line"><span class="keyword">curl_off_t</span> getLocalFileLength()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">curl_off_t</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileStat</span>;</span></span><br><span class="line">	ret = stat(mLocalFilePath, &amp;fileStat);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> fileStat.st_size;<span class="comment">//返回本地文件已下载的大小</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载前先发送一次请求，获取文件的总大小</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDownloadFileLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> rel = <span class="number">0</span>, downloadFileLenth = <span class="number">0</span>;</span><br><span class="line">	CURL *handle = curl_easy_init();</span><br><span class="line">	curl_easy_setopt(handle, CURLOPT_URL, mDownloadFileUrl);</span><br><span class="line">	curl_easy_setopt(handle, CURLOPT_HEADER, <span class="number">1</span>);    <span class="comment">//只需要header头</span></span><br><span class="line">	curl_easy_setopt(handle, CURLOPT_NOBODY, <span class="number">1</span>);    <span class="comment">//不需要body</span></span><br><span class="line">	<span class="keyword">if</span> (curl_easy_perform(handle) == CURLE_OK) &#123;</span><br><span class="line">		curl_easy_getinfo(handle, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &amp;downloadFileLenth);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		downloadFileLenth = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rel = downloadFileLenth;</span><br><span class="line">	curl_easy_cleanup(handle);</span><br><span class="line">	<span class="keyword">return</span> rel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件下载</span></span><br><span class="line"><span class="function">CURLcode <span class="title">downloadInternal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取本地已下载的大小，有则断点续传</span></span><br><span class="line">	<span class="keyword">curl_off_t</span> localFileLenth = getLocalFileLength();</span><br><span class="line">    <span class="comment">//2. 以追加的方式写入文件</span></span><br><span class="line">	FILE *file = fopen(mLocalFilePath, <span class="string">"ab+"</span>);</span><br><span class="line">	CURL* mHandler = curl_easy_init();</span><br><span class="line">	<span class="keyword">if</span> (mHandler &amp;&amp; file)</span><br><span class="line">	&#123;</span><br><span class="line">         <span class="comment">//3. 设置url</span></span><br><span class="line">		curl_easy_setopt(mHandler, CURLOPT_URL, mDownloadFileUrl);</span><br><span class="line">		<span class="comment">//4. 设置请求头 Range 字段信息，localFileLength 不等于0时，值大小就表示从哪开始下载 </span></span><br><span class="line">		curl_easy_setopt(mHandler, CURLOPT_RESUME_FROM_LARGE, localFileLenth);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5. 设置接收数据的处理函数和存放变量</span></span><br><span class="line">		curl_easy_setopt(mHandler, CURLOPT_WRITEFUNCTION, writeFile);</span><br><span class="line">		curl_easy_setopt(mHandler, CURLOPT_WRITEDATA, file);</span><br><span class="line">		<span class="comment">// 6. 发起请求</span></span><br><span class="line">		CURLcode rel = curl_easy_perform(mHandler);</span><br><span class="line">		fclose(file);</span><br><span class="line">		<span class="keyword">return</span> rel;</span><br><span class="line">	&#125;</span><br><span class="line">	curl_easy_cleanup(mHandler);</span><br><span class="line">	<span class="keyword">return</span> CURLE_FAILED_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>writeFile 函数和下载进度通知的函数我都没贴，用过 libcurl 的应该都知道怎么写，或者网上搜一下，资料很多。上面就是将断点续传的几个关键函数贴出来，理清楚了即可。</p>
<h3 id="Android-amp-HttpURLConnection"><a href="#Android-amp-HttpURLConnection" class="headerlink" title="Android&amp;HttpURLConnection"></a>Android&amp;HttpURLConnection</h3><h3 id="Android-amp-OkHttp"><a href="#Android-amp-OkHttp" class="headerlink" title="Android&amp;OkHttp"></a>Android&amp;OkHttp</h3><p>由于最近都在忙 C++ 的项目了，Android 暂时还没时间自己写个 demo 测试一下，所以先给几篇网上找的链接占个坑，后续抽个时间自己再来写个 demo。</p>
<p>之所以列了这两点，是因为感觉目前 Android 中网络框架大多都是用的 OkHttp 了，而下载文件还有很多都是用的 HttpURLConnection，所以这两个都想研究一下，怎么写断点续传。</p>
<p><a href="https://www.jianshu.com/p/2b82db0a5181" target="_blank" rel="noopener">Android多线程断点续传下载</a>  </p>
<p><a href="https://blog.csdn.net/cfy137000/article/details/54838608" target="_blank" rel="noopener">Android使用OKHttp3实现下载(断点续传、显示进度)</a>  </p>
<p>两篇我都有大概过了下，其实断点续传原理不难，真的蛮简单的，所以实现上基本也大同小异，就是不同的网络框架的 api 用法不同而已。以及，如何维护本地已下载文件的大小的思路，有的是直接去获取文件对象查看，有的则是手动自己建个数据库维护。</p>
]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>讲讲网络模块中加解密那点儿事--AES+BASE64</title>
    <url>/2018/08/04/Android%E7%9F%A5%E8%AF%86/%E8%AE%B2%E8%AE%B2%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%8A%A0%E8%A7%A3%E5%AF%86%E9%82%A3%E7%82%B9%E5%84%BF%E4%BA%8B--AES+BASE64/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>这次想来讲讲网络安全通信这一块，也就是网络层封装的那一套加密、解密，编码、解码的规则，不会很深入，但会大概将这一整块的讲一讲。</p>
<p>之所以想写这篇，是因为，最近被抽过去帮忙做一个 C++ 项目，在 Android 中，各种编解码、加解密算法官方都已经封装好了，我们要使用非常的方便，但在 C++ 项目中很多都要自己写。</p>
<p>然而，自己写是不可能的了，没这么牛逼也没这么多时间去研究这些算法，网上自然不缺少别人写好的现成算法。但不同项目应用场景自然不一样，一般来说，都需要对其进行修修改改才能拿到项目中来用。</p>
<p>踩的坑实在有点儿多，所以想写一篇来总结一下。好了，废话结束，开始正文。</p>
<h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><p><strong>Q1: 你的 app 与后台各接口通信时有做身份校验吗？</strong>  </p>
<p><strong>Q2: 你的 app 与后台各接口通信的数据有涉及敏感数据吗？你是如何处理的？</strong>  </p>
<p><strong>Q3: MD5 了解过吗？</strong>  </p>
<p><strong>Q4: AES(16位密钥 + CBC + PKCS5Padding) 呢？</strong></p>
<p><strong>Q5: BASE64 呢？或者 UTF-8?</strong></p>
<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h3 id="身份校验-–-MD5-算法"><a href="#身份校验-–-MD5-算法" class="headerlink" title="身份校验 – MD5 算法"></a>身份校验 – MD5 算法</h3><p>第一点：<strong>为什么需要身份校验？</strong>  </p>
<p>身份校验是做什么，其实也就是校验访问接口的用户合法性。说得白一点，也就是要过滤掉那些通过脚本或其他非正常  app 发起的访问请求。</p>
<p>试想一下，如果有人破解了服务端某个接口，然后写个脚本，模拟接口所需的各种参数，这样它就可以伪装成正常用户从这个接口拿到他想要的数据了。</p>
<p>更严重点的是，如果他想图摸不轨，向服务端发送了一堆伪造的数据，如果这些数据会对服务端造成损失怎么办。</p>
<p>所以，基本上服务端的接口都会有身份校验机制，来检测访问的对象是否合法。</p>
<p>第二点：<strong>MD5 算法是什么？</strong>  </p>
<p>通俗的讲，MD5 算法能对一串输入生成一串唯一的不可逆的 128 bit 的 0 和 1 的二进制串信息。</p>
<p>通常 app 都会在发起请求前根据自己公司所定义的规则做一次 MD5 计算，作为 token 发送给服务端进行校验。</p>
<p>MD5 有两个特性：唯一性和不可逆性。</p>
<p>唯一性可以达到防止输入被篡改的目的，因为一旦第三方攻击者劫持了这个请求，篡改了携带的参数，那么服务端只要再次对这些输入做一次 MD5 运算，比较计算的结果与 app 上传的 token 即可检测出输入是否有被修改。</p>
<p>不可逆的特点，则是就算第三方攻击者劫持了这次请求，看到了携带的参数，以及 MD5 计算后的 token，那么他也无法从这串 token 反推出我们计算 MD5 的规则，自然也就无法伪造新的 token，那么也就无法通过服务端的校验了。</p>
<p>第三点：<strong>理解 16 位和 32 位 MD5 值的区别</strong></p>
<p>网上有很多在线进行 MD5 计算的工具，如 <a href="http://www.cmd5.com/" target="_blank" rel="noopener">http://www.cmd5.com/</a>，这里演示一下，尝试一下分别输入：</p>
<p><code>I am dasu</code> 和 <code>I&#39;m dasu</code> 看一下经过 MD5 运算后的结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-66628f61bc02489e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MD5.png">  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-03059a86616e8391.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MD5_.png">  </p>
<p>首先确认一点，不同的输入，输出就会不一样，即使只做了细微修改，两者输出仍旧毫无规律而言。</p>
<p>另外，因为经过 MD5 计算后输出是 128 bit 的 0 和 1 二进制串，但通常都是用十六进制来表示比较友好，1个十六进制是 4 个 bit，128 / 4 = 32，所以常说的 32 位的 MD5 指的是用十六进制来表示的输出串。</p>
<p>那么，为什么还会有 16 位的 MD5 值？其实也就是嫌 32 位的数据太长了，所以去掉开头 8 位，末尾 8 位，截取中间的 16 位来作为 MD5 的输出值。</p>
<p>所以，MD5 算法的输出只有一种：128 bit 的二进制串，而通常结果都用十六进制表示而已，32 位与 16 位的只是精度的区别而已。</p>
<p>第四点：<strong>MD5 的应用</strong>  </p>
<p>应用场景很多：数字签名、身份校验、完整性（一致性）校验等等。</p>
<p>这里来讲讲 app 和服务端接口访问通过 MD5 来达到身份校验的场景。</p>
<p>app 持有一串密钥，这串密钥服务端也持有，除此外别人都不知道，因此 app 就可以跟服务端协商，两边统一下交互的时候都有哪些数据是需要加入 MD5 计算的，以怎样的规则拼接进行 MD5 运算的，这样一旦这些数据被三方攻击者篡改了，也能检查出来。</p>
<p>也就是说，密钥和拼接规则都是关键点，不可以泄漏出去。</p>
<h3 id="敏感数据加密-–-AES-BASE64"><a href="#敏感数据加密-–-AES-BASE64" class="headerlink" title="敏感数据加密 – AES + BASE64"></a>敏感数据加密 – AES + BASE64</h3><p>MD5 只能达到校验的目的，而 app 与服务端交互时，数据都是在网络中传输的，这些请求如果被三方劫持了，那么如果交互的数据里有一些敏感信息，就会遭到泄漏，存在安全问题。</p>
<p>当然，如果你的 app 与服务端的交互都是 HTTPS 协议了的话，那么自然就是安全的，别人抓不到包，也看不到信息。</p>
<p>如果还是基于 HTTP 协议的话，那么有很多工具都可以劫持到这个 HTTP 包，app 与服务端交互的信息就这样赤裸裸的展示在别人面前。</p>
<p>所以，通常一些敏感信息都会经过加密后再发送，接收方拿到数据后再进行解密即可。</p>
<p>而加解密的世界很复杂，对称加密、非对称加密，每一种类型的加解密算法又有很多种，不展开了，因为实在展开不了，我门槛都没踏进去，实在没去深入学习过，目前只大概知道个流程原理，会用的程度。</p>
<p>那么，本篇就介绍一种网上很常见的一整套加解密、编解码流程：</p>
<h4 id="UTF-8-AES-BASE64"><a href="#UTF-8-AES-BASE64" class="headerlink" title="UTF-8 + AES + BASE64"></a>UTF-8 + AES + BASE64</h4><p>UTF-8 和 BASE64 都属于编解码，AES 属于对称加密算法。</p>
<p>信息其实本质上是由二进制串组成，通过各种不同的编码格式，来将这段二进制串信息解析成具体的数据。比如 ASCII 编码定义了一套标准的英文、常见符号、数字的编码；UTF-8 则是支持中文的编码。目前大部分的 app 所使用的数据都是基于 UTF-8 格式的编码的吧。</p>
<p>AES 属于对称加密算法，对称的意思是说，加密方和解密方用的是同一串密钥。信息经过加密后会变成一串毫无规律的二进制串，此时再选择一种编码方式来展示，通常是 BASE64 格式的编码。</p>
<p>BASE64 编码是将所有信息都编码成只用大小写字母、0-9数字以及 + 和 / 64个字符表示，所有称作 BASE64。</p>
<p>不同的编码所应用的场景不同，比如 UTF-8 倾向于在终端上呈现各种复杂字符包括简体、繁体中文、日文、韩文等等数据时所使用的一种编码格式。而 BASE64 编码通常用于在网络中传输较长的信息时所使用的一种编码格式。</p>
<p>基于以上种种，目前较为常见的 app 与服务端交互的一套加解密、编解码流程就是：UTF-8 + AES + BASE64</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-e12adc004153766d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加解密流程.png">  </p>
<p>上图就是从 app 端发数据给服务端的一个加解密、编解码过程。</p>
<p>需要注意的是，因为 AES 加解密时输入和输出都是二进制串的信息，因此，在发送时需先将明文通过 UTF-8 解码成二进制串，然后进行加密，再对这串二进制密文通过 BASE64 编码成密文串发送给接收方。</p>
<p>接收方的流程就是反着来一遍就对了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>理论上基本清楚了，那么接下去就是代码实现了，Android 项目中要实现很简单，因为 JDK 和 SDK 中都已经将这些算法封装好了，直接调用 api 接口就可以了。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptDecryptUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENCODE = <span class="string">"UTF-8"</span>;</span><br><span class="line">    <span class="comment">//AES算法加解密模式有多种，这里选择 CBC + PKCS5Padding 模式，CBC 需要一个AES_IV偏移量参数，而AES_KEY 是密钥。当然，这里都是随便写的，这些信息很关键，不宜泄露</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AES = <span class="string">"AES"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AES_IV = <span class="string">"aaaaaaaaaaaaaaaa"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AES_KEY = <span class="string">"1111111111111111"</span>;<span class="comment">//16字节，128bit，三种密钥长度中的一种</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CIPHER_ALGORITHM = <span class="string">"AES/CBC/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * AES加密后再Base64编码，输出密文。注意AES加密的输入是二进制串，所以需要先将UTF-8明文转成二进制串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doEncryptEncode</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(AES_KEY.getBytes(ENCODE), AES);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, <span class="keyword">new</span> IvParameterSpec(AES_IV.getBytes(ENCODE)));</span><br><span class="line">        <span class="comment">//1. 先获取二进制串，再进行AES（CBC+PKCS5Padding)模式加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] result = cipher.doFinal(content.getBytes(ENCODE));</span><br><span class="line">        <span class="comment">//2. 将二进制串编码成BASE64串</span></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeToString(result, Base64.NO_WRAP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Base64解码后再进行AES解密，最后对二进制明文串进行UTF-8编码输出明文串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doDecodeDecrypt</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(AES_KEY.getBytes(ENCODE), AES);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, <span class="keyword">new</span> IvParameterSpec(AES_IV.getBytes(ENCODE)));</span><br><span class="line">        <span class="comment">//1. 先将BASE64密文串解码成二进制串</span></span><br><span class="line">        <span class="keyword">byte</span>[] base64 = Base64.decode(content, Base64.NO_WRAP);</span><br><span class="line">        <span class="comment">//2. 再将二进制密文串进行AES(CBC+PKCS5Padding)模式解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] result = cipher.doFinal(base64);</span><br><span class="line">        <span class="comment">//3. 最后将二进制的明文串以UTF-8格式编码成字符串后输出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result, Charset.forName(ENCODE)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 的实现代码是不是很简单，具体算法的实现都已经封装好了，就是调一调 api 的事。</p>
<p>这里需要稍微知道下，AES 加解密模式分很多种，首先，它有三种密钥形式，分别是 128 bit，192 bit，256 bit，注意是 bit，Java 中的字符串每一位是 1B = 8 bit，所以上面例子中密钥长度是 16 位的字符串。</p>
<p>除了密钥外，AES 还分四种模式的加解密算法：ECB，CBC，CFB，OFB，这涉及到具体算法，我也不懂，就不介绍了，清楚上面是使用了 CBC 模式就可以了。</p>
<p>最后一点，使用 CBC 模式进行加密时，是对明文串进行分组加密的，每组的大小都一样，因此在分组时就有可能会存在最后一组的数量不够的情况，那么这时就需要进行填充，而这个填充的概念就是 PKCS5Padding 和 PKCS7Padding 两种。</p>
<p>这两种的填充规则都一样，具体可看其他的文章，区别只在于分组时规定的每组的大小。在PKCS5Padding中，明确定义 Block 的大小是 8 位，而在 PKCS7Padding 定义中，对于块的大小是不确定的，可以在 1-255 之间。</p>
<p>稍微了解下这些就够了，如果你不继续往下研究 C++ 的写法，这些不了解也没事，会用就行。</p>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>c++ 坑爹的地方就在于，这整个流程，包括 UTF-8 编解码、AES 加解密、BASE64 编解码都得自己写。</p>
<p>当然，不可能自己写了，网上轮子那么多了，但问题就在于，因为 AES 加解密模式太多了，网上的资料大部分都只是针对其中一种进行介绍，因此，如果不稍微了解一下相关原理的话，就无从下手进行修改了。</p>
<p>我这篇，自然也只是介绍我所使用的模式，如果你刚好跟我一样，那也许可以帮到你，如果跟你不一样，至少我列出了资料的来源，整篇下来也稍微讲了一些基础性的原理，掌握这些，做点儿修修补补应该是可以的。</p>
<p>贴代码前，先将我所使用的模式列出来：</p>
<p><strong>UTF-8 + AES(16位密钥 + CBC + PKCS5Padding) + BASE64</strong>  </p>
<p>其实这些都类似于工具类，官方库没提供，那网上找个轮子就好了，都是一个 h 和 cpp 文件而已，复制粘贴下就可以了。重点在于准备好了这些工具类后，怎么用，怎么稍微修改。</p>
<p>如果你不想自己网上找，那下面我已经将相关链接都贴出来了，去复制粘贴下就可以了。</p>
<p><a href="https://blog.csdn.net/yinshi_blog/article/details/6731809" target="_blank" rel="noopener">c++ string、UTF8相互转换方法</a>  </p>
<p><a href="https://blog.csdn.net/csdn49532/article/details/50686222" target="_blank" rel="noopener">C++使用AES+Base64算法对文本进行加密</a>  </p>
<p>我最开始就是拿的第二篇来用的，然后才发现他所采用的模式是：AES(16位密钥 + CBC + PKCS7Padding) + BASE64</p>
<p>也就是说，他的例子中不支持中文的加解密，而且填充模式采用的是 PKCS7Padding，跟我的不一致。一开始我也不了解相关原理基础，怎么调都调不出结果，无奈只能先去学习下原理基础。</p>
<p>还好后面慢慢的理解了，也懂得该改哪些地方，也增加了 UTF-8 编解码的处理。下面贴的代码中注释会写得很清楚，整篇看下来，我相信，就算你模式跟我的也不一样，你的密钥是24位的、32位的，没关系，稍微改一改就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EncryptDecryptUtils.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> AES_INFO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AES_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AES_KEY <span class="meta-string">"1111111111111111"</span>  <span class="comment">//AES 16B的密钥</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AES_IV <span class="meta-string">"aaaaaaaaaaaaaaaa"</span> <span class="comment">//AES CBC加解密模式所需的偏移量</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncryptDecryptUtils</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//解码解密</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">doDecodeDecrypt</span><span class="params">(<span class="built_in">string</span> content)</span></span>;</span><br><span class="line">	<span class="comment">//加密编码</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">doEncryptEncode</span><span class="params">(<span class="built_in">string</span> content)</span></span>;</span><br><span class="line">	EncryptDecryptUtils();</span><br><span class="line">    ~EncryptDecryptUtils();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//去除字符串中的空格、换行符</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">removeSpace</span><span class="params">(<span class="built_in">string</span> content)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下才是具体实现，其中在头部 include 的 AES.h，Base64.h，UTF8.h 需要先从上面给的博客链接中将相关代码复制粘贴过来。这些文件基本都是作为工具类使用，不需要进行改动。可能需要稍微改一改的就只是 AES.h 文件，因为不同的填充模式需要改一个常量值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EncryptDecryptUtils.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EncryptDecryptUtils.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"AES.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Base64.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"UTF8.h"</span></span></span><br><span class="line"></span><br><span class="line">EncryptDecryptUtils::EncryptDecryptUtils()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">~EncryptDecryptUtils::EncryptDecryptUtils()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 流程：服务端下发的BASE64编码的密文字符串 -&gt; 去除字符串中的换行符 -&gt; BASE64解码 -&gt; AES::CBC模式解密 -&gt; 去掉AES::PKCS5Padding 填充 -&gt; UTF-8编码 -&gt; 明文字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">string</span> EncryptDecryptUtils::doDecodeDecrypt(<span class="built_in">string</span> content)</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment">//1.去掉字符串中的\r\n换行符</span></span><br><span class="line"> 	<span class="built_in">string</span> noWrapContent = removeSpace(<span class="built_in">string</span>);</span><br><span class="line">	<span class="comment">//2. Base64解码</span></span><br><span class="line">	<span class="built_in">string</span> strData = base64_decode(noWrapContent);</span><br><span class="line">	<span class="keyword">size_t</span> length = strData.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. new些数组，给解密用</span></span><br><span class="line">	<span class="keyword">char</span> *szDataIn = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memcpy</span>(szDataIn, strData.c_str(), length + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">char</span> *szDataOut = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memcpy</span>(szDataOut, strData.c_str(), length + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4. 进行AES的CBC模式解密</span></span><br><span class="line">	AES aes;</span><br><span class="line">    <span class="comment">//在这里传入密钥，和偏移量，以及指定密钥长度和iv长度，如果你的密钥长度不是16字节128bit，那么需要在这里传入相对应的参数。</span></span><br><span class="line">	aes.MakeKey(<span class="built_in">string</span>(AES_KEY).c_str(), <span class="built_in">string</span>(AES_IV).c_str(), <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">//这里参数有传入指定加解密的模式，AES::CBC，如果你不是这个模式，需要传入相对应的模式，源码中都有注释说明</span></span><br><span class="line">	aes.Decrypt(szDataIn, szDataOut, length, AES::CBC);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.去PKCS5Padding填充:解密后需要将字符串中填充的去掉，根据填充规则进行去除，感兴趣可去搜索相关的填充规则</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0x00</span> &lt; szDataOut[length - <span class="number">1</span>] &lt;= <span class="number">0x16</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = szDataOut[length - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= length - tmp; i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (szDataOut[i] != tmp)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">memset</span>(szDataOut, <span class="number">0</span>, length);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				szDataOut[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//6. 将二进制的明文串转成UTF-8格式的编码方式，输出</span></span><br><span class="line">	<span class="built_in">string</span> srcDest = UTF8_To_string(szDataOut);</span><br><span class="line">	<span class="keyword">delete</span>[] szDataIn;</span><br><span class="line">	<span class="keyword">delete</span>[] szDataOut;</span><br><span class="line">	<span class="keyword">return</span> srcDest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 流程：UTF-8格式的明文字符串 -&gt; UTF-8解码成二进制串 -&gt; AES::PKCS5Padding 填充 -&gt; AES::CBC模式加密 -&gt; BASE64编码 -&gt; 密文字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">string</span> EncryptDecryptUtils::doEncryptEncode(<span class="built_in">string</span> content)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1. 先获取UTF-8解码后的二进制串</span></span><br><span class="line">	<span class="built_in">string</span> utf8Content = string_To_UTF8(content);</span><br><span class="line">	<span class="keyword">size_t</span> length = utf8Content.length();</span><br><span class="line">	<span class="keyword">int</span> block_num = length / BLOCK_SIZE + <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2. new 些数组供加解密使用</span></span><br><span class="line">	<span class="keyword">char</span>* szDataIn = <span class="keyword">new</span> <span class="keyword">char</span>[block_num * BLOCK_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memset</span>(szDataIn, <span class="number">0x00</span>, block_num * BLOCK_SIZE + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(szDataIn, utf8Content.c_str());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 进行PKCS5Padding填充：进行CBC模式加密前，需要填充明文串，确保可以分组后各组都有相同的大小。</span></span><br><span class="line">	<span class="comment">// BLOCK_SIZE是在AES.h中定义的常量，PKCS5Padding 和 PKCS7Padding 的区别就是这个 BLOCK_SIZE 的大小，我用的PKCS5Padding，所以定义成 8。如果你是使用 PKCS7Padding，那么就根据你服务端具体大小是在 1-255中的哪个值修改即可。</span></span><br><span class="line">    <span class="keyword">int</span> k = length % BLOCK_SIZE;</span><br><span class="line">	<span class="keyword">int</span> j = length / BLOCK_SIZE;</span><br><span class="line">	<span class="keyword">int</span> padding = BLOCK_SIZE - k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; padding; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		szDataIn[j * BLOCK_SIZE + k + i] = padding;</span><br><span class="line">	&#125;</span><br><span class="line">	szDataIn[block_num * BLOCK_SIZE] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *szDataOut = <span class="keyword">new</span> <span class="keyword">char</span>[block_num * BLOCK_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memset</span>(szDataOut, <span class="number">0</span>, block_num * BLOCK_SIZE + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4. 进行AES的CBC模式加密</span></span><br><span class="line">	AES aes;</span><br><span class="line">     <span class="comment">//在这里传入密钥，和偏移量，以及指定密钥长度和iv长度，如果你的密钥长度不是16字节128bit，那么需要在这里传入相对应的参数。</span></span><br><span class="line">	aes.MakeKey(<span class="built_in">string</span>(AES_KEY).c_str(), <span class="built_in">string</span>(AES_IV).c_str(), <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">//这里参数有传入指定加解密的模式，AES::CBC，如果你不是这个模式，需要传入相对应的模式，源码中都有注释说明</span></span><br><span class="line">	aes.Encrypt(szDataIn, szDataOut, block_num * BLOCK_SIZE, AES::CBC);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//5. Base64编码</span></span><br><span class="line">	<span class="built_in">string</span> str = base64_encode((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)szDataOut, block_num * BLOCK_SIZE);</span><br><span class="line">	<span class="keyword">delete</span>[] szDataIn;</span><br><span class="line">	<span class="keyword">delete</span>[] szDataOut;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去除字符串中的空格、换行符</span></span><br><span class="line"><span class="built_in">string</span> EncryptDecryptUtils::formatText(<span class="built_in">string</span> src)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> len = src.length();</span><br><span class="line">	<span class="keyword">char</span> *dst = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (src[++i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span> (src[i])</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dst[j++] = src[i];</span><br><span class="line">	&#125;</span><br><span class="line">	dst[j] = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="built_in">string</span> rel = <span class="built_in">string</span>(dst);</span><br><span class="line">	<span class="keyword">delete</span> dst;</span><br><span class="line">	<span class="keyword">return</span> rel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再列个在线验证 AES 加解密结果的网站，方便调试：</p>
<p><a href="http://www.seacha.com/tools/aes.html" target="_blank" rel="noopener">http://www.seacha.com/tools/aes.html</a></p>
<p><strong>Java 实现那么方便，为什么还需要用 C++ 的呢？</strong>  </p>
<p>想一想，密钥信息那么重要，你要放在哪？像我例子那样直接写在代码中？那只是个例子，别忘了，app 混淆的时候，字符串都是不会参与混淆的，随便反编译下你的 app，密钥就暴露给别人了。</p>
<p>那么，有其他比较好的方式吗？我只能想到，AES 加解密相关的用 C++ 来写，生成个 so 库，提供个 jni 接口给 app 层调用，这样密钥信息就可以保存在 C++ 中了。</p>
<p>也许你会觉得，哪有人那么闲去反编译 app，而且正在写的 app 又没有什么价值让别人反编译。</p>
<p>emmm，说是这么说，但安全意识还是要有的，至少也要先知道有这么个防护的方法，以及该怎么做，万一哪天你写的 app 就火了呢？</p>
]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>带你了解源码中的 ThreadLocal</title>
    <url>/2018/07/20/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84-ThreadLocal/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</strong>  </p>
</blockquote>
<p>这次想来讲讲 <strong>ThreadLocal</strong> 这个很神奇的东西，最开始接触到这个是看了主席的《开发艺术探索》，后来是在研究 ViewRootImpl 中又碰到一次，而且还发现 Android 中一个小彩蛋，就越发觉得这个东西很有趣，那么便借助主席的这次作业来好好梳理下吧。  </p>
<h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><p>开始看源码前，还是照例来思考一些问题，带着疑问过源码比较有条理，效率比较高一点。</p>
<p>大伙都清楚，Android 其实是基于消息驱动机制运行的，主线程有个消息队列，通过主线程对应的 Looper 一直在对这个消息队列进行轮询操作。</p>
<p>但其实，每个线程都可以有自己的消息队列，都可以有自己的 Looper 来轮询队列，不清楚大伙有接触过 HandlerThread 这东西么，之前看过一篇文章，通过 HandlerThread 这种单线程消息机制来替代线程同步操作的场景，这种思路很让人眼前一亮。</p>
<p>而 Looper 有一个静态方法：<code>Looper.myLooper()</code>  </p>
<p>通过这个方法可以获取到当前线程的 Looper 对象，那么问题来了：  </p>
<p><strong>Q1：在不同线程中调用 <code>Looper.myLooper()</code> 为什么可以返回各自线程的 Looper 对象呢？明明我们没有传入任何线程信息，内部是如何找到当前线程对应的 Looper 对象呢？</strong>  </p>
<p>我们再来看一段《开发艺术探索》书中的描述：  </p>
<blockquote>
<p>ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<p>虽然在不同线程中访问的是同一个 ThreadLocal 对象，但是它们通过 ThreadLocal 获取到的值却是不一样的。</p>
<p>一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal。</p>
</blockquote>
<p>好，问题来了：  </p>
<p><strong>Q2：ThreadLocal 是如何做到同一个对象，却维护着不同线程的数据副本呢？</strong></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><strong>ps：ThreadLocal 内部实现在源码版本 android-24 做了改动，《开发艺术探索》书中分析的源码是 android-24 版本之前的实现原理，本篇分析的源码版本基于 android-25，感兴趣的可以阅读完本篇再去看看《开发艺术探索》，比较一下改动前后的实现原理是否有何不同。</strong>  </p>
<p>因为是从 Q1 深入才接触到 ThreadLocal 的，那么这次源码阅读的入口很简单，也就是 <code>Looper.myLopper()</code>：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Looper#myLooper()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>

<p>所以，<code>Looper.myLooper()</code> 实际上是调用的 ThreadLocal 的 <code>get()</code> 方法，也就是说，<code>Looper.myLooper()</code> 能实现即使不传入线程信息也能获取到各自线程的 Looper 是通过 ThreadLocal 实现的。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>那么，下面就继续跟着走下去吧：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal#get()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取当前的线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//2. 以当前线程为参数，获取一个 ThreadLocalMap 对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//3. map 不为空，则以当前 ThreadLocal 对象实例作为key值，去map中取值，有找到直接返回</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. map 为空或者在map中取不到值，那么走这里，返回默认初始值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的关键点就是从这里开始看了，到底 ThreadLocal 是如何实现即使调用同一个对象同一个方法，却能自动根据当前线程返回不同的数据，一步步来看。</p>
<p>首先，获取当前线程对象。</p>
<p>接着，调用了 <code>getMap()</code> 方法，并传入了当前线程，看看这个 <code>getMap()</code> 方法：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal#getMap()</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来直接返回线程的 threadLocals 成员变量，由于 ThreadLocal 与 Thread 位于同一个包中，所以可以直接访问包权限的成员变量。我们接着看看 Thread 中的这个成员变量 threadLocals :  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Thread.threadLocal</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadLocal#createMap()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread 中的 threadLocal 成员变量初始值为 null，并且在 Thread 类中没有任何赋值的地方，只有在 ThreadLocal 中的 <code>createMap()</code> 方法中对其赋值，而调用 <code>createMap()</code> 的地方就两个：<code>set()</code> 和 <code>setInitialValue()</code>，而调用 <code>setInitialValue()</code> 方法的地方只有 <code>get()</code>。</p>
<p>也就是说，ThreadLocal 的核心其实也就是在 <code>get()</code> 和 <code>set()</code>，搞懂这两个方法的流程原理，那么也就基本理解 ThreadLocal 这个东西的原理了。  </p>
<p>到这里，先暂时停一停，<strong>我们先来梳理一下目前的信息，因为到这里为止应该对 ThreadLocal 原理有点儿眉目了</strong>：  </p>
<p>不同线程调用相同的 <code>Looper.myLooper()</code>，其实内部是调用了 ThreadLocal 的 <code>get()</code> 方法，而 <code>get()</code> 方法则在一开始就先获取当前线程的对象，然后直接通过包权限获取当前线程的 threadLocals 成员变量，该变量是一个 ThreadLocal 的内部类 ThreadLocalMap 对象，初始值为 null。</p>
<p>以上，是我们到目前所梳理的信息，虽然我们还不知道 ThreadLocalMap 作用是什么，但不妨碍我们对其进行猜测啊。如果这个类是用于存储数据的，那么一切是不是就可以说通了！</p>
<p><strong>为什么不同线程中明明调用了同一对象的同一方法，却可以返回各自线程对应的数据呢？原来，这些数据本来就是存储在各自线程中了，ThreadLocal 的 <code>get()</code> 方法内部其实会先去获取当前的线程对象，然后直接将线程存储的容器取出来。</strong>  </p>
<p>所以，我们来验证一下，ThreadLocalMap 是不是一个用于存储数据的容器类：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal$ThreadLocalMap</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">        Object value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal key, Object value)</span> </span>&#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal key)</span> </span>&#123;</span><br><span class="line">     	...   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>猜对了，很明显，ThreadLocalMap 就是一个用于存储数据的容器类，set 操作，get 操作，连同容器数组都有了，这样一个类不是用于存储数据的容器类还是什么。至于它内部的各种扩容算法，hash 算法，我们就不管了，不深入下去了，知道这个类是干嘛用的就够了。当然，感兴趣你可以自行深入研究。  </p>
<p>那么，好，我们回到最初的 ThreadLocal 的 <code>get()</code> 方法中继续分析：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal#get()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取当前的线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//2. 以当前线程为参数，获取一个 ThreadLocalMap 对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//3. map 不为空，则以当前 ThreadLocal 对象实例作为key值，去map中取值，有找到直接返回</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. map 为空或者在map中取不到值，那么走这里，返回默认初始值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 1 步，第 2 步我们已经梳理清楚了，就是去获取当前线程的数据存储容器，也就是 map。拿到容器之后，其实也就分了两条分支走，一是容器不为 null，一是容器为 null 的场景。我们先来看看容器为 null 场景的处理：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal#setInitialValue()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取初始值，默认返回Null，允许重写</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//2. 创建线程t的数据存储容器：threadLocals</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">//3. 返回初始值</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会通过 <code>initialValue()</code> 去获取初始值，默认实现是返回 null，但该方法允许重写。然后同样去获取当前线程的数据存储容器 map，为null，所以这里会走 <code>createMap()</code>，而 <code>createMap()</code> 我们之前分析过了，就是去创建参数传进去的线程自己的数据存储容器 threadLocals，并将初始值保存在容器中，最后返回这个初始值。</p>
<p>那么，这条分支到这里就算结束了，我们回过头继续看另一条分支，都跟完了再来小结：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal#get()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取当前的线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//2. 以当前线程为参数，获取一个 ThreadLocalMap 对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//3. map 不为空，则以当前 ThreadLocal 对象实例作为key值，去map中取值，有找到直接返回</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. map 为空或者在map中取不到值，那么走这里，返回默认初始值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一条分支很简单，也就是如果线程的数据存储容器不为空，那么就以当前 ThreadLocal 对象实例作为 key 值，去这个容器中寻找对应的数据，如果有找到直接返回，没找到，那么就走 <code>setInitialValue()</code>，该方法内部会去取默认的初始值，然后以当前 ThreadLocal 对象实例作为 key 值存入到当前线程的数据存储容器中，并返回初始值。</p>
<p><strong>到这里，<code>get()</code> 的流程已经梳理完毕了，那就先来小结一下：</strong>  </p>
<p>当不同的线程调用同一个 ThreadLocal 对象的 <code>get()</code> 方法时，内部其实是会先获取当前线程的对象，然后通过包权限直接获取对象的数据存储容器 ThreadLocalMap 对象，如果容器为空，那么会新建个容器，并将初始值和当前 ThreadLocal 对象绑定存储进去，同时返回初始值；如果容器不为空，那么会以当前 ThreadLocal 对象作为 key 值去容器中寻找，有找到直接返回，没找到，那么以同样的操作先存入容器再返回初始值。</p>
<p>这种设计思想很巧妙，首先，容器是各自线程对象的成员变量，也就是数据其实就是交由各自线程维护，那么不同线程即使调用了同一 ThreadLocal 对象的同一方法，取的数据也是各自线程的数据副本，这样自然就可以达到维护不同线程各自相互独立的数据副本，且以线程为作用域的效果了。</p>
<p>同时，在将数据存储到各自容器中是以当前 ThreadLocal 对象实例为 key 存储，这样，即使在同一线程中调用了不同的 ThreadLocal 对象的 <code>get()</code> 方法，所获取到的数据也是不同的，达到同一线程中不同 ThreadLocal 虽然共用一个容器，但却可以相互独立运作的效果。</p>
<p>（特别佩服 Google 工程师！）</p>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>get()</code> 方法我们已经梳理完了，其实到这里，ThreadLocal 的原理基本上算是理清了，而且有一点，梳理到现在，其实 ThreadLocal 该如何使用我们也可以猜测出来了。</p>
<p>你问我为什么可以猜测出来了？</p>
<p>忘了我们上面梳理的 <code>get()</code> 方法了么，内部会一直先去取线程的容器，然后再从容器中取最后的值，取不到就会一直返回初始值，会有哪种应用场景是需要一直返回初始值的么？肯定没有，既然如此，就要保证在容器中可以取到值，那么，自然就是要先 <code>set()</code> 将数据存到容器中，<code>get()</code> 的时候才会有值啊。</p>
<p>所以，用法很简单，实例化 ThreadLocal 对象后，直接调用 <code>set()</code> 存值，调用 <code>get()</code> 取值，两个方法内部会自动根据当前线程选择相对应的容器存取。</p>
<p>我们来看看 <code>set()</code> 是不是这样：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal#set()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 取当前线程对象</span></span><br><span class="line">	Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//2. 取当前线程的数据存储容器</span></span><br><span class="line">	ThreadLocalMap map = getMap(t);</span><br><span class="line">	<span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//3. 以当前ThreadLocal实例对象为key，存值</span></span><br><span class="line">		map.set(<span class="keyword">this</span>, value);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="comment">//4. 新建个当前线程的数据存储容器，并以当前ThreadLocal实例对象为key，存值</span></span><br><span class="line">		createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是吧，<code>set()</code> 方法里都是调用已经分析过的方法了，那么就不继续分析了，注释里也写得很详细了。</p>
<p>那么，最后来回答下开头的两个问题：  </p>
<p><strong>Q1：在不同线程中调用 <code>Looper.myLooper()</code> 为什么可以返回各自线程的 Looper 对象呢？明明我们没有传入任何线程信息，内部是如何找到当前线程对应的 Looper 对象呢？</strong> </p>
<p><strong>A：</strong>因为 <code>Looper.myLooper()</code> 内部其实是调用了 ThreadLocal 的 <code>get()</code> 方法，ThreadLocal 内部会自己去获取当前线程的成员变量 threadLocals，该变量作用是线程自己的数据存储容器，作用域自然也就仅限线程而已，以此来实现可以自动根据不同线程返回各自线程的 Looper 对象。</p>
<p>毕竟，数据本来就只是存在各自线程中，自然互不影响，ThreadLocal 只是内部自动先去获取当前线程对象，再去取对象的数据存储容器，最后取值返回而已。</p>
<p>但取值之前要先存值，而在 Looper 类中，对 ThreadLocal 的 <code>set()</code> 方法调用只有一个地方： <code>prepare()</code>，该方法只有主线程系统已经帮忙调用了。这其实也就是说，主线程的 Looper 消息循环机制是默认开启的，其他线程默认关闭，如果想要使用，则需要自己手动调用，不调用的话，线程的 Looper 对象一直为空。</p>
<p><strong>Q2：ThreadLocal 是如何做到同一个对象，却维护着不同线程的数据副本呢？</strong></p>
<p><strong>A：</strong>梳理清楚，其实好像也不是很难，是吧。无外乎就是将数据保存在各自的线程中，这样不同线程的数据自然相互不影响。然后存值时再以当前 ThreadLocal 实例对象为 key，这样即使同一线程中，不同 ThreadLocal 虽然使用同一个容器，但 key 不一样，取值时也就不会相互影响。</p>
<h1 id="小彩蛋"><a href="#小彩蛋" class="headerlink" title="小彩蛋"></a>小彩蛋</h1><p>说是小彩蛋，其实是 Android 的一个小 bug，尽管这个 bug 并不会有任何影响，但发现了 Google 工程师居然也写了 bug，就异常的兴奋有没有。</p>
<p>另外，先说明下，该 bug 并不是我发现的，我以前在写一篇博客分析 <a href="https://www.jianshu.com/p/85fc4decc947" target="_blank" rel="noopener">View.post 源码</a>时，期间有个问题卡住，然后阅读其他大神的文章时发现他提了这点，bug 是他发现并不是由我发现，只是刚好，我看的源码版本比他的新，然后发现在我看的源码版本上，这个 bug 居然被修复了，那么也就是说， Google 的这一点行为也就表示这确实是一个 bug，所以异常兴奋，特别佩服那个大神。</p>
<p>是这样的，不清楚 <code>View.post()</code> 流程原理的可以先去我那篇博客过过，不过也么事，我简单来说下：</p>
<p>通过 <code>View.post(Runnable action)</code> 传进来的 Runnable，如果此时 View 还没 attachToWindow，那么这个 Runnable 是会先被缓存起来，直到 View 被 attachToWindow 时才取出来执行。</p>
<p>而在<strong>版本 android-24</strong> 之前，缓存是交由 ViewRootImpl 来做的，如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//View#post()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. mAttachInfo 是当 View 被 attachToWindow 时才会被赋值</span></span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 所以，如果 View 还没被 attachToWindow 时，这些 Runnable 会先被缓存起来</span></span><br><span class="line">    ViewRootImpl.getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mAttachInfo 是当 View 被 attachToWindow 时才会被赋值，所以，如果 View 还没被 attachToWindow 时，这些 Runnable 会先被缓存起来，版本 android-24 之前的实现是交由 ViewRootImpl 实现，如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl#getRunQueue()</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RunQueue <span class="title">getRunQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RunQueue rq = sRunQueues.get();</span><br><span class="line">    <span class="keyword">if</span> (rq != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rq;</span><br><span class="line">    &#125;</span><br><span class="line">    rq = <span class="keyword">new</span> RunQueue();</span><br><span class="line">    sRunQueues.set(rq);</span><br><span class="line">    <span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewRootImpl.sRunQueues</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RunQueue&gt; sRunQueues = <span class="keyword">new</span> ThreadLocal&lt;RunQueue&gt;();</span><br></pre></td></tr></table></figure>

<p>这点关键点是，sRunQueues 是一个 ThreadLocal 对象，而且我们使用 <code>View.post()</code> 是经常有可能在各种子线程中的，为的就是利用这个方法方便的将 Runnable 切到主线程中执行，但这样的话，其实如果在 View 还没被 attachToWindow 时，这些 Runnable 就是被缓存到各自线程中了，因为使用的是 ThreadLocal。</p>
<p>而这些被缓存起来的 Runnable 被取出来执行的地方是在 ViewRootImpl 的 <code>performTraversals()</code>，这方法是控制 View 树三大流程：测量、布局、绘制的发起者，而且可以肯定的是，这方法肯定是运行在主线程中的。</p>
<p>那么，根据我们分析的 ThreadLocal 原理，不同线程调用 <code>get()</code> 方法时数据是相互独立的，存值的时候有可能是在各种线程中，所以 Runnable 被缓存到各自的线程中去，但取值执行时却只在主线程中取，这样一来，就会造成很多缓存在其他子线程中的 Runnable 就被丢失掉了，因为取不到，自然就执行不了了。</p>
<p>验证方式也很简单，切到 android-24 之前的版本，然后随便在 Activity 的 <code>onCreate()</code> 里写段在子线程中调用 <code>View.post(Runnable)</code>，看看这个 Runnable 会不会被执行就清楚了。</p>
<p>更具体的分析看那个大神的博客：<a href="https://blog.csdn.net/scnuxisan225/article/details/49815269" target="_blank" rel="noopener">通过View.post()获取View的宽高引发的两个问题</a></p>
<p>而在 android-24 版本之后，源码将这个实现改掉了，不用 ThreadLocal 来做缓存了，而是直接让各自的 View 内部去维护了，具体不展开了，感兴趣可以去看看我那篇博客和那个大神的博客。</p>
<p>PS：另外，不知道大伙注意到了没有，<strong>android-24</strong> 版本的源码是不是发生了什么大事，在这个版本好像改动了很多原本内部的实现，比如一开头分析的 ThreadLocal 内部实现在这个版本也改动了，上面看的 <code>View.post()</code> 在这个版本也改动了。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h3 id="源码中的应用场景"><a href="#源码中的应用场景" class="headerlink" title="源码中的应用场景"></a>源码中的应用场景</h3><p>源码内部很多地方都有 ThreadLocal 的身影，其实这也说明了在一些场景下，使用 ThreadLocal 是可以非常方便的帮忙解决一些问题，但如果使用不当的话，可能会造成一些问题，就像上面说过的在 android-24 版本之前 <code>View.post()</code> 内部采用 ThreadLocal 来做缓存，如果考虑不当，可能会造成丢失一些缓存的问题。</p>
<ul>
<li>场景1：<code>Looper.myLooper()</code></li>
</ul>
<p>用于不用线程获取各自的 Looper 的需求，具体见上文。</p>
<ul>
<li>场景2：<code>View.post()</code></li>
</ul>
<p>android-24 版本之前用于缓存 Runnable，具体见上文。</p>
<ul>
<li>场景3：<strong>AnimationHandler</strong></li>
</ul>
<p>大伙不清楚对这个熟悉不，我之前写过一篇分析 <a href="https://www.jianshu.com/p/46f48f1b98a9" target="_blank" rel="noopener">ValueAnimator 运行原理</a>，所以有接触到这个。先看一下，它内部是如何使用 ThreadLocal 的：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AnimationHandler.sAnimatorHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;AnimationHandler&gt; sAnimatorHandler = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//AnimationHandler#getInstance()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AnimationHandler <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sAnimatorHandler.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sAnimatorHandler.set(<span class="keyword">new</span> AnimationHandler());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sAnimatorHandler.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例 + ThreadLocal？ 是不是突然又感觉眼前一亮，居然可以这么用！</p>
<p>那么这种应用场景是什么呢，首先，单例，那么就说明只存在一个实例，希望外部只使用这么一个实例对象。然后，单例又结合了 ThreadLocal，也就是说，希望在同一个线程中实例对象只有一个，但允许不同线程有各自的单例实例对象。</p>
<p>而源码这里为什么需要这么使用呢，我想了下，觉得应该是这样的，个人观点，还没理清楚，不保证完全正确，仅供参考：</p>
<p>动画的实现肯定是需要监听 Choreographer 的每一帧 vsync 信息事件的，那么在哪里发起监听，在哪里接收回调，属性动画就则是通过一个单例类 AnimationHandler 来实现。也就是，程序中，所有的属性动画共用一个 AnimationHandler 单例来监听 Choreographer 的每一帧 vsync 信号事件。</p>
<p>那么 AnimationHandler 何时决定不监听了呢？不是某个动画执行结束就取消监听，而是所有的动画都执行完毕，才不会再发起监听，那么，它内部其实就维护着所有正在运行中的动画信息。所以，在一个线程中它必须也只能是单例模式。</p>
<p>但是，ValueAnimator 其实不仅仅可以用来实现动画，也可以用来实现一些跟帧率相关的业务场景，也就是说，如果不涉及 ui 的话，也是允许在其他子线程中使用 ValueAnimator 的，那么此时，这些工作就不应该影响到主线程的动画，那么它是需要单独另外一份 AnimationHandler 单例对象来管理了。</p>
<p>两者结合下，当有在线程内需要单例模式，而又允许不同线程相互独立运作的场景时，也可以使用 ThreadLocal。</p>
<ul>
<li>场景4：<strong>Choreographer</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Choreographer.sThreadInstance</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance = <span class="keyword">new</span> ThreadLocal&lt;Choreographer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Choreographer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   	 	Looper looper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The current thread must have a looper!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Choreographer(looper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Choreographer#getInstance()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Choreographer <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadInstance.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Choreographer 在 Android 的屏幕刷新机制中扮演着非常重要的角色，想了解的可以看看我之前写的一篇文章：<a href="https://www.jianshu.com/p/0d00cb85fdf3" target="_blank" rel="noopener">Android 屏幕刷新机制</a>  </p>
<p>具体也就不分析了，在这里也列出这个，只是想告诉大伙，在源码中，单例 + ThreadLocal 这种模式蛮常见的，我们有要求线程安全的单例模式，相对应的自然也会有线程内的单例模式，要求不同线程可以互不影响、独立运作的单例场景，如果大伙以后有遇到，不妨尝试就用 ThreadLocal 来实现看看。</p>
<ul>
<li>其他</li>
</ul>
<p>源码中，还有很多地方也有用到，View 中也有，ActivityThread 也有，ActivityManagerService 也有，很多很多，但很多地方的应用场景我也还搞不懂，所以也就不列举了。总之，就像主席在《开发艺术探索》中所说的：</p>
<blockquote>
<p>一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal</p>
</blockquote>
<p>精辟，上述源码中不管是用于缓存功能，还是要求线程独立，还是单例 + ThreadLocal 模式，其实本质上都是上面那句话：某些数据如果是以线程为作用域并且不同线程可以互不影响、独立运作的时候，那么就可以采用 ThreadLocal 了。</p>
<h3 id="《开发艺术探索》中描述的应用场景"><a href="#《开发艺术探索》中描述的应用场景" class="headerlink" title="《开发艺术探索》中描述的应用场景"></a>《开发艺术探索》中描述的应用场景</h3><ul>
<li>场景1</li>
</ul>
<blockquote>
<p>一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal。</p>
<p>比如对应 Handler 来说，它需要获取当前线程的 Looper，很显然 Looper 的作用域就是线程并且不同线程具有不同的 Looper，这个时候通过 ThreadLocal 就可以轻松实现 Looper 在线程中的存取。如果不采用 ThreadLocal，那么系统就必须提供一个全局的哈希表供 Handler 查找指定线程的 Looper，这样一来就必须提供一个类似于 LooperManager 的类了，但是系统并没有这么做而是选择了 ThreadLocal，这就是 ThreadLocal 的好处</p>
</blockquote>
<ul>
<li>场景2</li>
</ul>
<blockquote>
<p>ThreadLocal 另一个使用场景是复杂逻辑下的对象传递，比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢？</p>
<p>其实这时就可以采用 ThreadLocal，采用 ThreadLocal 可以让监听器作为线程内的全局对象而存在，在线程内部只要通过 get 方法就可以获取到监听器。如果不采用 ThreadLocal，那么我们能想到的可能是如下两种方法：第一种方法是将监听器通过参数的形式在函数调用栈中进行传递，第二种方法就是将监听器作为静态变量供线程访问。上述这两种方法都是有局限性的。第一种方法的问题是当函数调用栈很深的时候，通过函数参数来传递监听器对象这几乎是不可接受的，这会让程序的设计看起来糟糕。第二种方法是可以接受的，但是这种状态是不具有可扩充性的，比如同时有两个线程在执行，那么就需要提供两个静态的监听器对象，如果有 10 个线程在并发执行呢？提供 10 个静态的监听器对象？这显然是不可思议的，而采用 ThreadLocal，每个监听器对象都在自己的线程内部存储，根本就不会有方法 2 的这种问题。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android源码解析</category>
      </categories>
  </entry>
  <entry>
    <title>谈谈 final finally finalize 区别</title>
    <url>/2018/07/09/Java/%E8%B0%88%E8%B0%88-final-finally-finalize-%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本篇所涉及的提问，正文的知识点，全都来自于<strong>杨晓峰的《Java核心技术36讲》</strong>，当然，我并不会全文照搬过来，毕竟这是付费的课程，应该会涉及到侵权之类的问题。</p>
<p>所以，本篇正文中的知识点，是我从课程中将知识点消耗后，用个人的理解、观念所表达出来的文字，参考了原文，但由于是个人理解，因此不保证观点完全正确，也不代表错误的观点是课程所表达的。如果这样仍旧还是侵权了，请告知，会将发表的文章删掉。</p>
<p>当然，如果你对此课程有兴趣，建议你自己也购买一下，新用户立减 30，微信扫码订阅时还可以返现 6 元，相当于 32 元购买 36 讲的文章，每篇文章还不到 1 元，蛮划算的了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6ca755c2bd0a6122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ图片20180703142535.png">  </p>
<h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><ul>
<li>谈谈 final、finally、finalize 有什么不同？</li>
<li>为什么局部内部类和匿名内部类只能访问局部final变量？ </li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>emmm，说实话，感觉这一讲好像没什么实质性内容。而且，就像评论区里有人提到的，搞不懂为啥总有人喜欢拿这三者来比较，它们有个毛的关系？仅仅就是因为单词相近就拿来比较？</p>
<p>但课程小结还是要做下，梳理梳理下相关面试知识点也好，那也不说废话了，结合原文和评论区，以及一些扩展，尽量多总结一些知识点吧。</p>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final 是 java 中的关键字，可用于修饰类，方法，变量。</p>
<p>当修饰类时，表明这个类不可被继承。Java 中有一些核心类都被 final 修饰了，比如 String，System。当考虑到安全性原因时，可以将该类设计成 final。</p>
<p>当修饰方法时，表明该方法不可被重写。一般是某些流程控制不希望被修改掉时，可以将这些方法声明成 final，比如 View 中的 <code>measure()</code>，<code>requestFocus()</code>，<code>findViewById()</code>。</p>
<p>当修饰变量时，表明该变量为常量，不允许被重新赋值，因此声明成 final 的变量都需要显示的进行赋值，否则编译会报错。 </p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>finally 是确保 try-catch 方式最后执行的一种机制，通常的用法都是在 finally 里进行一些资源的关闭，回收。比如 IO 流的关闭等等。</p>
<p>建议最好不要利用 finally 来控制流程，也不要在 finally 中有返回值，否则很容易影响正常流程，导致流程结构特别杂乱。</p>
<p>另外，有些特殊情况下，finally 中的代码并不会被执行到，比如：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.try-catch异常退出</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.exit(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">//不会执行到这里</span></span><br><span class="line">    Log.d(<span class="string">"finally"</span>, <span class="string">"finally"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.无限循环</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//不会执行到这里</span></span><br><span class="line">    Log.d(<span class="string">"finally"</span>, <span class="string">"finally"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 线程被杀死</span></span><br><span class="line"><span class="comment">//当执行 try-catch 时，线程被杀死了，那么 finally 里的代码也无法被执行到</span></span><br></pre></td></tr></table></figure>

<p>总之，finally 通常情况下都会最后被执行到，所以最好不要在这里有 return 之类的语句来影响正常流程。但在某些特殊的场景下，finally 并不会被执行到，了解一下即可。</p>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><p>这个是 Object 中的一个方法，方法注释说了很多，大概就是讲这个方法是由垃圾收集器即将要回收该对象时会调用该方法，用户可在这里做一些最后的资源释放工作。</p>
<p>以上是概念定义，但说实话，没用过该方法，而且作者也说了，不推荐使用 finalize 机制来做资源回收，并且在 JDK 9，这个方法已经被标志为 deprecated 废弃的方法了。</p>
<p>作者有提到说，因为我们无法保证 finalize 什么时候执行，执行是否符合预期，使用不当还会影响性能，导致程序死锁、挂起等问题。</p>
<p>那么，有其他方案来替代 finalize 处理回收资源的工作么？有，Cleaner 机制，这个我没接触过，作者提了这个替代方案。另外，作者也说了，回收资源最好就是资源用完后就随手清除，或者结合 try-catch-finally 机制回收。不管是 finalize 或者 Cleaner 机制，最好都只将它看成是最后一道防线，一旦将主要的回收工作依赖于这两个机制的话，很容易出现各种问题。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><strong>为什么局部内部类和匿名内部类只能访问局部final变量？</strong>  </p>
<p>先来看这么段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数 msg 必须声明为 final 类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyChange</span><span class="params">(<span class="keyword">final</span> String msg)</span> </span>&#123;</span><br><span class="line">    mTextView.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mTextView.setText(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>post()</code> 方法的参数是一个匿名内部类，在内部类中如果要使用外部 <code>notifyChange()</code> 方法的参数 msg，那么必须将 msg 类型声明成 final，否则编译器会保错。</p>
<p>这种场景非常常见的吧，不管是类似上述的 Ui 场景，还有网络访问时也经常需要通过回调通知上层，此时也就经常出现这种场景了。</p>
<p>那么，<strong>有考虑过，为什么内部类只能访问局部 final 变量么？</strong>  </p>
<p>如果懂得反编译 class 文件的，那么应该就很清楚了。我也不懂，理解这点是通过阅读其他大神分析的文章，以下是我的理解：</p>
<p>首先，变量都是有生命周期的，成员变量的生命周期就跟随着对象的整个生命周期，而局部变量的生命周期则是非常有限。</p>
<p>比如方法内部的局部变量，它的生命周期就是在这个方法执行结束就终止。同样，方法的参数也是局部变量，它是生命周期也同样是到该方法执行结束。</p>
<p>另外，内部类的执行时机有时是会在外部方法执行结束之后。就拿上述例子来说，<code>post()</code> 中 Runnable 的执行时机，肯定是在外部 <code>notifyChange()</code> 方法执行完之后的。</p>
<p>那么，问题来了。内部类 Runnable 的执行需要使用到外部方法 <code>notifyChange()</code> 的参数，但当它执行的时候，这个参数的生命周期早已结束，已经被回收掉了。既然已经被回收了，内部类又是怎么使用外部的这个局部变量呢？</p>
<p>有大神反编译了 class 文件后，给出了结论，<strong>原来内部类使用外部的局部变量时，是通过 copy 一份过来</strong>。也就是说，其实内部类此时使用的是自己内部定义的局部变量了，只是这个变量的值是复制外部那个局部变量的而已。</p>
<p>这也就解释了，为什么外部的局部变量明明已经被回收了，内部类仍旧可以使用，因为内部类此时使用的并不是外部类的局部变量引用了。</p>
<p>但到这里，<strong>新的问题就来了</strong>：既然内部类使用的局部变量本质上跟外部的局部变量是相互独立的两个变量，那如果在内部类中修改了这个局部变量的值会出现什么情况？是吧，数据的不一致性。</p>
<p>基于此，java 编译器就直接限定死，内部类使用外部的局部变量时，必须将其限制为 final 类型，确保该变量不允许进行更改。</p>
<p>这样一来，其实也就顺便理解了，为什么成员变量可以直接在内部类中使用，因为成员变量的声明周期很长，不存在局部变量的问题。</p>
<p>以上内容，是在大神的文章里被醍醐灌顶了，感谢大神，原文链接放出来：  </p>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">Java内部类详解</a></p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>毕业一年啦</title>
    <url>/2018/07/09/%E7%9E%8E%E6%89%AF%E6%89%AF/%E6%AF%95%E4%B8%9A%E4%B8%80%E5%B9%B4%E5%95%A6/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<blockquote>
<p>本篇作者是我的舍友，文章中第一人称我也就是我舍友了，那么文章里的舍友也就包含一个我了，写得蛮文艺的，转载发表一下。另，以下是原文链接：<br><a href="https://www.cnblogs.com/schaepher/p/9311152.html" target="_blank" rel="noopener">https://www.cnblogs.com/schaepher/p/9311152.html</a>  </p>
</blockquote>
<hr>
<h1 id="毕业一年啦"><a href="#毕业一年啦" class="headerlink" title="毕业一年啦"></a><a href="https://www.cnblogs.com/schaepher/p/9311152.html" target="_blank" rel="noopener">毕业一年啦</a></h1><p>从毕业到现在，一年过去了。趁着刚写完《入职一年啦》，也来回顾回顾这一年的生活吧。</p>
<p>现在跟同事谈起的时候，他们还会感到羡慕。因为无论是刚毕业还是后来换地方，我们几个同学都住在一起。</p>
<p>我们部门里就有四个新人是同一个学院的，其中三个是同班同学，我就是其中一个。</p>
<h2 id="住"><a href="#住" class="headerlink" title="住"></a>住</h2><p>在我们入职前就说再过不久公司就要搬到其他地方。嗯，到现在还没开始。</p>
<p>我还记得我们几个同学一起去找房子，找了一天没什么进展。我还记得那天下午我爸妈要去找我外婆玩，他们来接我一起去。后来他们继续找，在泊寓订了下来。我和其中两个同学住三房一厅的套房，剩下三个人各自租单间，其中有一个租了 1700 的单间（算上水电费）。</p>
<p>套房感觉挺好的，我们是第一批住户，一切都很新。有个厨房可以让我们学做饭。在这年代，做饭这种基础技能还是要有的。我们自己买了个冰箱，可以放菜或者其他需要保鲜的东西。</p>
<p>平时我们会在客厅里聊天、玩游戏、看电视。一般晚上会在这吃完饭，有时候会一起吃火锅。</p>
<p>上周因为一年的合同到期了，我们搬到离公司更近的民房。两人住一间，每人 400，对比一下上面的 1700 看看？相当于我那同学一个月省了 1300 左右啊！暂时先这样住着，可能会等公司搬了我们再一起搬过去。</p>
<h2 id="食"><a href="#食" class="headerlink" title="食"></a>食</h2><p>刚入职那会儿，没有多少事情做，没有加班。每天下班就买点菜回到宿舍做晚饭。</p>
<p>最开始只有一个会炒菜，有厨师证！不过倒没从他那学到什么就对了，因为没做过什么高大上的菜。后来我们几个都会做一些家常菜。</p>
<p>比如几乎天天吃的炒包菜。这个真是会让人吃出阴影……几乎每餐都有。每个人炒出来的都有自己的特色。他们都不喜欢加味精，导致有时候盐加多了很难吃。这时得安利个： <a href="https://www.zhihu.com/question/28066901/answer/152551386" target="_blank" rel="noopener">味精对人体健康有危害吗？ - 知乎</a> 。</p>
<p>除了包菜，我偶尔会炒个西蓝花，做道韭黄炒蛋、番茄炒蛋、茄子等等。很家常对吧！</p>
<p>除了这种特别家常的，还是要学点有特色的菜。比如我有一道非常喜欢吃的菜，那是我妈炒的鸡腿肉。有一次回家就去跟她学，后来这道菜成为了我们宿舍的特色菜。因为同公司也有一个新入职的同事住在我们楼下，有时会邀请她过来吃饭，我们也去过她们那（也是三房一厅）吃饭。两边手艺比起来，自然是我们这边 low 了很多，只能靠我的炒鸡腿肉撑撑场面。吃过都说好（噗）。哈哈哈。</p>
<p>后来有了高压锅，也会经常买五花肉回来做。</p>
<p>我偶尔会买龙骨来煲汤，算是加餐。他们都不喜欢喝汤，夏天的时候总是买饮料来喝。我倒是会比较经常煮点什么，有时候是紫菜蛋汤，有时候是云吞，有时候连汤圆都煮！</p>
<p>我个人蛮喜欢吃咖喱饭，大概每周会做一次。以前以为咖喱很难做，其实买盒咖喱块，再买点鸡胸肉、萝卜、土豆就可以开始做。真是简单便宜又好吃！</p>
<p>早餐也还算丰盛。一开始是煮粥，自配的八宝粥。有几次出现某些配料没熟，根本没法吃。后来干脆就不加那种配料了，哈哈。中间有段时间是买包子来蒸，通常我们会买三种口味的包子，奶黄包是必备的（吃到怕为止），其他两种会换：豆沙包、紫薯包、肉包、小馒头、杂粮馒头、云吞……后来博饼博到豆浆机，每天早上又能加杯豆浆，美滋滋。过一段时间又换回粥，配上榨菜或者腌萝卜。吃了一段时间又换回包子。哈哈。</p>
<p>除了正餐，还会做点其他的。比如自从博饼拿到了个烤箱，我们就开始做蛋糕吃。不过做了几次就没做了，一是经常加班，二是懒（这个才是最主要的！）。还有，因为有冰箱，我买过冰淇淋粉来做冰淇淋。</p>
<h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2><p>公司有上班班车，我们那是首站。不过从住的地方到站点，快一点的话要走十分钟。班车八点半出发，有时候起晚了（经常），得跑着过去赶班车。我们美其名曰：晨跑。</p>
<p>有时候赶上了，心里美滋滋；有时候，班车在人行道那头，我们在这头，眼睁睁地看班车开走；更绝望的是，绿灯了，我们到了那头，车走了。</p>
<p>从我们那到公司坐班车要半个小时，早上比较堵。有时候加班比较晚，打的回去只要十几分钟。上周搬到公司附近，走路慢点也只要大概二十分钟。</p>
<p>中间有段时间是自己开车上班的哈哈。大概 2017 年九月底报考了驾校，十一月初考科一，2018 年一月初终于预约上科二，中旬考完科二，月底考科三，二月初考科四。终于赶在过年前拿到驾照~</p>
<p>练科二的那段时间，每天六点多起来做早饭，吃完去坐半小时公交到练车点。从快八点开始练到九点，然后走路到公司。当时就因为练车点离公司近才选了它。教练也挺不错的。</p>
<p>回家之后就开始直接开了，第一次是和爸妈一起去外婆那。夜晚加上山路，挺稳。就是我爸坐在副驾驶座一路上怕怕的（他怕），抓着手刹没放松过。那一次右边留空比较大。后来我专门找时间到人少的地方练练距离感，感觉一下右车轮的距离。</p>
<p>很快春节结束，我直接开两个多小时的车到工作的地方。这个时候开得还是特别小心谨慎的那种，毕竟还不太稳。当我两个月后开车回家，就快了很多。</p>
<p>两个月间，每次上班都开车。再也不用晨跑了。但是比较不好的是下班的时候，快累死了还得开车！而我的伙伴们坐在后面休息。o(╥﹏╥)o</p>
<p>中间有一次和公司其他人一起开车去赏樱花，好几辆车一起过去。但没有同时到，也没一起回来，哈哈。来回路上七八个小时，赏花只赏了半个小时。挺累的。</p>
<p>后来开回家就没有再开过来了。感觉还是不如坐班车上班和公交车回去爽。而且停车费惊人：小区一个月 300，公司这边一个月 260。对刚出来工作的萌新来说，还是蛮贵的！</p>
<h2 id="娱"><a href="#娱" class="headerlink" title="娱"></a>娱</h2><p>大部分娱乐挺单调的，就是几个人坐在客厅开黑，有时候不开黑就自己在房间里看动漫。</p>
<p>此外，有上面提到的赏樱花。还有一起去游戏室体验 VR 游戏，Xbox，还有打桌球。我们楼下也有桌球，有一阵子比较经常去，后来就没去过了。</p>
<p>有一次突然想去外面走走，就骑着小黄车到处逛。后来遇到大雨，就赶紧回去了。</p>
<p>周末会约在同城的老同学出去吃饭，或者看电影什么的。</p>
<p>有一次和舍友坐动车回学校，去见了栋哥，还有老同学。栋哥还是挺忙的，不过还是抽出一些时间出来跟我们聊。下次还要找个时间去找他。</p>
<p>龙眼成熟那时候，还去同事家摘，摘了好几袋。带了一袋子回宿舍和舍友一起吃。</p>
<p>部门有一次组织去打沙滩排球。我的排球技术还是不错的。想当初高中时候，在实践中锻炼的技术可以打得过不少人。可惜那时候只有女子排球赛，我们只能当陪练。那时候一个对她们六个完全没问题，哈哈。</p>
<p>还有其他的一些活动。这么算起来，娱乐活动也还算蛮丰富。</p>
<h2 id="健"><a href="#健" class="headerlink" title="健"></a>健</h2><p>从 18 年春节后，我就开始锻炼身体了，下载了个 keep 跟着做。两天锻炼一次，都是在客厅里面做。到了夏天，每次锻炼都会出一身汗。直到现在还保持着。不过这一两周少锻炼了两次，要警惕，不能把这习惯断掉。</p>
<p>锻炼身体开始前去体检了一次，大部分都正常。就血脂和尿酸偏离正常值，但都是轻微。最近公司的体检已经开始了，我打算再过一两个月去体检。有锻炼身体以及比较注意饮食，应该会好很多！</p>
<h2 id="书"><a href="#书" class="headerlink" title="书"></a>书</h2><p>心痛！心痛啊！知道看书很重要的我，还是没有怎么去看书。重视程度不够高。</p>
<p>这一年间，我把《红顶商人胡雪岩》听完了。嗯，是听。大学的时候下载了喜马拉雅，那时候就开始断断续续地听这个。基本上是走在路上的时候听。出来工作后，我在路上也会听。有时候回家要两三个小时，可以听好几集。王刚讲的是真的好！通过声音能够把每个人物的性格表现出来。然而听完没有写什么听后感，这是不足的地方。</p>
<p>后来在喜马拉雅上买了吴军老师的《文明之光》音频版，也听完了。补了一波历史。貌似温吞的声音好听！很适合这种类型的内容。还是没写听后感。</p>
<p>打开多看阅读，发现除了大四看完的《异类》和《褚时健传》。其他的诸如《美国种族简史》和《人类群星闪耀时》都只看了一小部分。Kindle 上的《What if?》也只看了 6%。</p>
<p>技术类的书籍也没怎么看。大部分阅读都是在看各种英文技术文档吧。</p>
<p>前一段时间学了点日语，后来停了一段时间，最近又恢复了。打算国庆去一趟日本。</p>
<p>得想办法把读书的习惯培养起来。还有多写点东西。</p>
<p>春节那会儿，还跟周老师和邹老师说要多写博客。几个月过去了，都没什么动作……</p>
<h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>就先这样。今天两篇博客先写上，以后争取多发写博文。以前总觉得有些东西太过于简单，发出来岂不是贻笑大方？现在觉得虽然不是什么高级的东西，但聊胜于无。</p>
<hr>
]]></content>
      <categories>
        <category>谈人生</category>
      </categories>
  </entry>
  <entry>
    <title>Exception 和 Error 有什么区别么</title>
    <url>/2018/07/04/Java/Exception-%E5%92%8C-Error-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E4%B9%88/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本篇所涉及的提问，正文的知识点，全都来自于<strong>杨晓峰的《Java核心技术36讲》</strong>，当然，我并不会全文照搬过来，毕竟这是付费的课程，应该会涉及到侵权之类的问题。</p>
<p>所以，本篇正文中的知识点，是我从课程中将知识点消耗后，用个人的理解、观念所表达出来的文字，参考了原文，但由于是个人理解，因此不保证观点完全正确，也不代表错误的观点是课程所表达的。如果这样仍旧还是侵权了，请告知，会将发表的文章删掉。</p>
<p>当然，如果你对此课程有兴趣，建议你自己也购买一下，新用户立减 30，微信扫码订阅时还可以返现 6 元，相当于 32 元购买 36 讲的文章，每篇文章还不到 1 元，蛮划算的了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6ca755c2bd0a6122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ图片20180703142535.png">  </p>
<h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><ul>
<li>Exception 和 Error 有什么区别？</li>
<li>运行时异常和一般异常有什么区别？</li>
<li>你了解哪些常见的 Error，Exception，RuntimeException？</li>
<li>NoClassDefFoundError 和 ClassNotFoundException 有什么区别？</li>
<li>异常处理的代码有哪些比较良好的规范？</li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>对于这个问题，感觉我讲不了很多，顶多都是一些概念性回答而已。</p>
<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><p>Exception 是程序正常运行时，可以预料到的意外情况，可以被捕获，也应该进行相应异常处理。</p>
<p>Exception 继承自 Throwable，具体又可划分为 RuntimeException 运行时异常和一般异常。两者的区别在于运行时异常在编译阶段可以不用进行捕获，这类异常通常都是在 Lint 检查过程中，或者程序运行期间才暴露出来的异常，因此也可以被归类为非检查型异常。  </p>
<p>一般异常则是在编译期间就必须进行异常捕获，因此也被归类为检查型异常。</p>
<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><p>Error 也是继承自 Throwable，同样会造成程序崩溃退出，但跟异常不大一样的是，这类错误问题，通常是由于 JVM 运行状态出了问题导致，我们不应捕获处理。要做的，应该是分析该错误出现的原因，尽量避免这类问题的出现。</p>
<p>关于 Exception 和 Error 的区别，可以简单这么理解，我们可以从异常中恢复程序但却不应该尝试从错误中恢复程序。</p>
<p>以上，基本就是我对于该讲问题所能想到的最大限度的点了。看了该讲作者所扩展的点，以及评论区里大神的回复，其实还可以从常见的一些异常，即原因和处理方式扩展；也可以从异常处理代码的规范角度出发扩展讲一讲，我都统一将这些扩展都在开头的提问中列出来了。</p>
<h4 id="常见的-Exception-或-Error"><a href="#常见的-Exception-或-Error" class="headerlink" title="常见的 Exception 或 Error"></a>常见的 Exception 或 Error</h4><p>想查阅相关的 Exception 或 Error，如果你记得该异常的名称，那可以直接通过 Android Stduio 查阅相关源码即可。</p>
<p>如果想翻看所有的类别，那么也可通过 AS 的 <strong>Hierarchy</strong>  功能查阅，快捷键 <code>Ctrl + H</code>，如下：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f41de8ab6f297084.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="asHierarchy.png">  </p>
<p>在这里翻看、过滤你熟悉的，或者想找的异常或错误，点进去查看相关源码说明即可。</p>
<p>至于常见的 Exception，RuntiomeException，Error，我针对个人在项目中较常遇见，目前印象较深的画了张类图：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f6dd9d24b4016056.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常见异常和错误.png">    </p>
<ul>
<li>ActivityNotFoundException</li>
</ul>
<p>源码注释里说了，该异常是当调用了 <code>startActivity()</code> 之后，找不到匹配的 Activity 时抛出该异常。也就是说，通常通过隐式 Intent 打开 Activity，或者通过广播，URI 等方式，不注意一点的话，可能会出现该异常。</p>
<p>如果有使用到这些场景，可以考虑是否增加异常捕获，防止使用不当造成异常。</p>
<ul>
<li>BadTokenException</li>
</ul>
<p>这里的异常指的是 WindowManager 内部类 BadTokenException，显然，当添加一个新的 window 时，如果 LayoutParams 不合法，就会抛出该异常。</p>
<p>添加 window 的场景，除了手动通过 WindowManager 的 <code>addView()</code> 的场景外，其实打开一个新的 Activity，新的 Dialog，内部也是通过 WindowManager 来 <code>addView()</code> 的，因此，这些场景下都是有可能发生该异常的。</p>
<p>不过，这个异常的日志会比较详细，因为在 ViewRootImpl 的 <code>setView()</code> 中，会去细分参数不合法的类别，附上部分源码：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//ViewRootImpl#setView()</span><br><span class="line"> </span><br><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">	switch (res) &#123;</span><br><span class="line">            case WindowManagerGlobal.ADD_BAD_APP_TOKEN:</span><br><span class="line">            case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:</span><br><span class="line">                throw new WindowManager.BadTokenException(</span><br><span class="line">                        &quot;Unable to add window -- token &quot; + attrs.token</span><br><span class="line">                                + &quot; is not valid; is your activity running?&quot;);</span><br><span class="line">            case WindowManagerGlobal.ADD_NOT_APP_TOKEN:</span><br><span class="line">                throw new WindowManager.BadTokenException(</span><br><span class="line">                        &quot;Unable to add window -- token &quot; + attrs.token</span><br><span class="line">                                + &quot; is not for an application&quot;);</span><br><span class="line">            case WindowManagerGlobal.ADD_APP_EXITING:</span><br><span class="line">                throw new WindowManager.BadTokenException(</span><br><span class="line">                        &quot;Unable to add window -- app for token &quot; + attrs.token</span><br><span class="line">                                + &quot; is exiting&quot;);</span><br><span class="line">            case WindowManagerGlobal.ADD_DUPLICATE_ADD:</span><br><span class="line">                throw new WindowManager.BadTokenException(</span><br><span class="line">                        &quot;Unable to add window -- window &quot; + mWindow</span><br><span class="line">                                + &quot; has already been added&quot;);</span><br><span class="line">            case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:</span><br><span class="line">                // Silently ignore -- we would have just removed it</span><br><span class="line">                // right away, anyway.</span><br><span class="line">                return;</span><br><span class="line">            case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:</span><br><span class="line">                throw new WindowManager.BadTokenException(&quot;Unable to add window &quot;</span><br><span class="line">                        + mWindow + &quot; -- another window of type &quot;</span><br><span class="line">                        + mWindowAttributes.type + &quot; already exists&quot;);</span><br><span class="line">            case WindowManagerGlobal.ADD_PERMISSION_DENIED:</span><br><span class="line">                throw new WindowManager.BadTokenException(&quot;Unable to add window &quot;</span><br><span class="line">                        + mWindow + &quot; -- permission denied for window type &quot;</span><br><span class="line">                        + mWindowAttributes.type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ClassCastException</li>
</ul>
<p>父类可以通过强制类型转换成具体某个子类，但如果强转的两个类之间不存在继承关系，那么就会抛出该异常。</p>
<p>如果不确定需要强转的两个类的关系，可以先通过关键字 instanceof 进行判断。</p>
<ul>
<li>ConcurrentModificationException</li>
</ul>
<p>这异常则是由于一些不恰当的集合操作导致，比如遍历集合的过程中，进行了不恰当的删除操作；或者有某个线程正在遍历集合，另外一个线程则对该集合进行的修改操作；</p>
<p>相对应的避免方法网上也很多，比如遍历集合删除的操作通过迭代器来实现等等。</p>
<ul>
<li>IndexOutOfBoundsException</li>
</ul>
<p>数组越界异常，这类异常还蛮经常出现的，避免方式就只能是尽量书写规范的代码，注意一些，或者多让程序跑跑 Lint 检查。</p>
<ul>
<li>NullPointerException</li>
</ul>
<p>空指针异常，这异常算是最令人头疼的异常了，在线上异常的比例中，肯定不少。</p>
<p>而且出现情况有时还很难分析，代码流程上查看，明明不会出现空指针场景，但现实就是有用户的的确确出现了。</p>
<p>解决时，如果可以，尽量不要简单的加个非空判断，在程序中各个地方加非空判断，其实是种特别不优雅的行为。如果能明确为什么会出现为空的场景，如何解决，这是最好的，而不是每次都简单的加个非空判断。</p>
<p>场景很多很多，之前也有写过一篇专门处理实体类的空判断文章，感兴趣的可以看看：  </p>
<p><a href="https://www.jianshu.com/p/68fd5373effc" target="_blank" rel="noopener">分享两个提高效率的AndroidStudio小技巧</a></p>
<ul>
<li>IOException</li>
</ul>
<p>IO 异常，属于检查型异常，必须通过 try catch 代码块捕获才能通过编译阶段，这也就没什么好介绍的了。</p>
<ul>
<li>OutOfMemoryError</li>
</ul>
<p>内存溢出错误，这类问题属于 Error，不属于 Exception，所以不要期待解决这类问题仅仅通过捕获就可以处理。</p>
<p>针对 Error 这类问题，我们没法捕获处理，只能是从避免的角度出发，分析出现的原因，尽量不用出现这类问题。</p>
<p>造成内存溢出的问题，有多种，大概就是图片问题、内存泄漏问题。</p>
<p>针对图片使用的优化处理，网上很多，各种压缩、降分辨率等等方式。</p>
<p>针对内存泄漏，一是开发期间遵守规范的代码行为，尽量避免写出有内存泄漏的隐患；二是发生内存泄漏后，借助相应工具进行定位分析。</p>
<ul>
<li>StackOverflowError</li>
</ul>
<p>这类错误很严重，表示程序陷入了死循环当中，原因也就是你写了有问题的代码。</p>
<p>因此，当出现这类问题，最好尽快定位处理。</p>
<ul>
<li>NoClassDefFoundError</li>
</ul>
<p>这类问题，通常出现的场景是：编译阶段没问题，但程序运行期间却出现该问题。</p>
<p>原因一般是由于打包时，jar 出现问题，部分类没有打包进去，导致的问题。</p>
<ul>
<li>ClassNotFoundException</li>
</ul>
<p>这个异常，同样属于相关类找不到的问题，但出现的场景通常是由于程序中使用了反射，或者动态加载之类的方式，使用了错误的类名，导致的问题。</p>
<p>还有可能是由于混淆导致。</p>
<h4 id="异常处理良好规范"><a href="#异常处理良好规范" class="headerlink" title="异常处理良好规范"></a>异常处理良好规范</h4><ul>
<li>尽量不要捕获类似 Exception 这样通用的异常，而是应该捕获特定异常</li>
</ul>
<blockquote>
<p>这是因为在日常的开发和合作中，我们读代码的机会往往超过写代码，软件工程是门协作艺术，所以我们有义务让自己的代码能够直观的体现出尽量多的信息，而泛泛的 Exception 之类，恰恰隐藏了我们的目的。另外，我们也要保证程序不会捕获到我们不希望捕获的异常。比如，你可能更希望 RuntimeException 被扩散出来，而不是被捕获。</p>
<p>进一步讲，除非深思熟虑了，否则不要捕获 Throwable 或者 Error，这样很难保证我们能够正确处理异常。</p>
</blockquote>
<ul>
<li>不要生吞异常</li>
</ul>
<blockquote>
<p>如果我们不把异常抛出来，或者也没有输出到日志之类，程序可能在后续代码以不可控的方式结束。没人能够轻易判断究竟是哪里抛出了异常，以及是什么原因产生了异常。</p>
</blockquote>
<ul>
<li>try-catch 代码段会产生额外的性能开销</li>
</ul>
<blockquote>
<p>try-catch 代码段往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句 （if / else, switch）要低效</p>
<p>Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作，如果发生的非常频繁，这个开销可就不能被忽略了。</p>
</blockquote>
<ul>
<li>不要在 finally 代码块中处理返回值</li>
</ul>
<blockquote>
<p>按照我们程序员的惯性认知：当遇到 return 语句的时候，执行函数会立刻返回。但是，在 Java 语言中，如果存在 finally 就会有例外。除了 return 语句， try 代码块中的 break 或 continue 语句也可能使控制权进入 finally 代码块。</p>
<p>请勿在 try 代码块中调用 return, break, continue 语句。万一无法避免，一定要确保 finally 的存在不会改变函数的返回值。</p>
<p>函数的返回值有两种类型：值类型和对象引用，对于对象引用，要特别小心，如果在 finally 代码块中对函数返回的对象成员属性进行了修改，即使不在 finally 块中显示调用 return 语句，这个修改也会作用于返回值上。</p>
</blockquote>
<ul>
<li>当一个 try 后跟了很多个 catch 时，必须先捕获小的异常再捕获大的异常。  </li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>谈谈你对 Java 平台的理解</title>
    <url>/2018/07/03/Java/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-Java-%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本篇所涉及的提问，正文的知识点，全都来自于<strong>杨晓峰的《Java核心技术36讲》</strong>，当然，我并不会全文照搬过来，毕竟这是付费的课程，应该会涉及到侵权之类的问题。</p>
<p>所以，本篇正文中的知识点，是我从课程中将知识点消耗后，用个人的理解、观念所表达出来的文字，参考了原文，但由于是个人理解，因此不保证观点完全正确，也不代表错误的观点是课程所表达的。如果这样仍旧还是侵权了，请告知，会将发表的文章删掉。</p>
<p>当然，如果你对此课程有兴趣，建议你自己也购买一下，新用户立减 30，微信扫码订阅时还可以返现 6 元，相当于 32 元购买 36 讲的文章，每篇文章还不到 1 元，蛮划算的了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6ca755c2bd0a6122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ图片20180703142535.png">  </p>
<h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><ul>
<li>谈谈你对 Java 最直观的印象是什么？是它宣传的 “Write once, run anywhere”？</li>
<li>谈谈你对 Java 平台的理解？ </li>
<li>Java 是解释执行，这句话正确吗？</li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>谈谈你对 Java 平台的理解？</p>
<p>一看到这个问题时很懵，对 Java 平台的理解？这是啥问题，面这么广，该说些啥。</p>
<p>一瞬间闪过脑袋的，无外乎：面向对象的高级编程语言？跨平台？三大特性？然后就没了~</p>
<p>然后看了本讲的内容，浏览了评论区各大神的回答，才发现，自己的基础确实很薄弱。这个问题并没有固定的答案，但关键在于考核你对 Java 掌握的系统性？你自己有没有生成关于 Java 知识的大体框架？你是否对每个知识点有深入的了解过？</p>
<p>结合课程的内容和评论区大神的回复，我梳理出了大伙对于这个问题回答后的脑图，也算是在这门课程之后，我所学到的以及生成的对于 Java 知识点的一个大体的认识框架吧。  </p>
<p>当然，这张系统性的知识框架肯定不全，在后续课程的学习中，我会渐渐来完善自己的这张知识框架体系。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-30ac1e463a057717.png" alt="Java平台的认识.png">    </p>
<h3 id="1-三大特性"><a href="#1-三大特性" class="headerlink" title="1. 三大特性"></a>1. 三大特性</h3><p>Java 语言有三大特性：继承、封装、多态</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>子类继承父类非私有的成员变量和成员方法。</p>
<p>final 声明的类不允许继承。</p>
<p>子类可通过 super 调用父类的有权限的方法。</p>
<p>父类有显示声明构造函数时，子类的构造函数中必须直接或间接的调用 super，另构造函数中使用 super 和 this 关键字必须在首行。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>这个特性更倾向于编程思想，将一些细节实现对外隐藏，通过权限控制，让外部仅需要与公开的接口打交道即可。</p>
<p>Java 有四种权限：包权限、私有权限、保护权限、公开权限</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-3b199c0481004968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java四大权限.png">  </p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态：对象的多种形态</p>
<p>引用多态：父类对象可指向具体子类</p>
<p>方法多态：重写 &amp; 重载</p>
<h3 id="2-语言特性"><a href="#2-语言特性" class="headerlink" title="2. 语言特性"></a>2. 语言特性</h3><p>Java 语言有很多很多特性：泛型、反射、代理、并发、等等，每个特性我并不是很了解，所以只将目前自己较为熟悉的特性记录下来，其他特性留待后续慢慢完善。</p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><ul>
<li>类</li>
</ul>
<p>泛型的使用： public class BaseView<t>{}</t></p>
<p>定义时类型限定：  public class BaseView<t extend object>{}</t></p>
<p>使用时类型限定：  private void test(BaseView&lt;? extend Object&gt; o){}</p>
<ul>
<li>方法参数</li>
</ul>
<p>泛型的使用：public <t> void test(T t){}</t></p>
<p>类型限定：  public <t extend object>  void test(T t){}</t></p>
<p>返回值泛型限定： public <t> T test(){}</t></p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ul>
<li>创建构造函数私有化的类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取类的无参构造函数</span></span><br><span class="line"><span class="comment">//2. 设置访问权限</span></span><br><span class="line"><span class="comment">//3. 调用 newInstance，创建对象</span></span><br><span class="line">Constructor&lt;Test&gt; constructor = Test.class.getDeclaredConstructor();</span><br><span class="line">construcotr.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Test test = constructor.newInstance();</span><br></pre></td></tr></table></figure>

<ul>
<li>调用私有方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 先获取类对象</span></span><br><span class="line"><span class="comment">//2. 根据方法名和方法参数获取方法对象</span></span><br><span class="line"><span class="comment">//3. 设置访问权限</span></span><br><span class="line"><span class="comment">//4. 调用 invoke，传入类对象，调用私有方法</span></span><br><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line">Method method = Test.class.getDeclaredMethod(<span class="string">"test"</span>);</span><br><span class="line">method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method.invoke(t);</span><br></pre></td></tr></table></figure>

<ul>
<li>改变私有属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 先获取类对象</span></span><br><span class="line"><span class="comment">//2. 根据变量名获取 Field 对象</span></span><br><span class="line"><span class="comment">//3. 设置访问权限</span></span><br><span class="line"><span class="comment">//4. 调用 Field 的 setXXX 方法，传入类对象，修改私有方法</span></span><br><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line">Field field = Test.class.getDeclaredField(<span class="string">"m"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.setInt(t, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-JDK-amp-JRE"><a href="#3-JDK-amp-JRE" class="headerlink" title="3. JDK&amp;JRE"></a>3. JDK&amp;JRE</h3><p>最开始我只知道，JDK 是 Java 开发者开发所需要的工具，JRE 则是 Java 程序运行所需的运行环境。仅仅只知道这么多了，至于有哪些工具，运行环境又是些什么则不大清楚。</p>
<p>课程里则提到了对于这些最好也要能够深入了解，比如清楚 JDK 中的编译器：javac、sjavac，诊断工具：jmap、jstack、jconsole、jhsdb、jcmd，辅助工具：jlink、jar、jdeps 等等。</p>
<p>对于 JRE 需要清楚 JVM 虚拟机，虚拟机的一些特性：垃圾收集器、运行时、动态编译等等，运行环境的一些基本类库：集合、并发、网络、安全、线程、IO、NIO 等等，对于每个类库都要有所了解。</p>
<p>突然发现，一个简单的知识点，一旦深入的话，是可以挖掘出一大堆知识点的。</p>
<p>目前对于这块，我基本算是没接触，后续慢慢来完善这块的知识点，让自己构建一个系统化、体系化、牢固的知识框架。</p>
<h3 id="4-JVM"><a href="#4-JVM" class="headerlink" title="4. JVM"></a>4. JVM</h3><p>Java 跨平台特性的基础其实是依赖于 JVM 虚拟机的，Java 语言本身并没有跨平台的特性，而是借助了 JVM 虚拟机。它就类似于一个中间件，将各个系统平台之间的差异隐藏掉，接收字节码。所以，只要将 Java 源程序编译成字节码，JVM 内部就会对字节码转换成各系统平台的可执行的机器码，做到”编译一次，到处运行”的特性。  </p>
<p>而从 JVM 虚拟机这一点出发，可以挖掘出一系列的知识点：</p>
<ul>
<li>内存管理，包括内存模型、常见的 GC、回收算法、内存泄漏、内存优化等等</li>
<li>类加载机制，包括双亲委派等等</li>
<li>解释执行与编译执行机制，包括 JIT、AOT 等等</li>
</ul>
<p>每个点都可以单独开好几篇章来讲，现在也没有系统的掌握，对每个点都是零零散散的印象理解，同样也留待后续慢慢完善。  </p>
<p>最后，针对开头的问题引用原文回答一下：</p>
<blockquote>
<p>对于“Java是解释执行”这句话，这个说法不太准确。我们开发的 Java的源代码，首先通过 Javac编译成为字节码（bytecode），然后，在运行时，通过 Java虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的 JVM，比如我们大多数情况使用的 Oracle JDK提供的 Hospot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。   </p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>关于RecyclerView你知道的不知道的都在这了（下）</title>
    <url>/2018/07/02/Android%E7%9F%A5%E8%AF%86/%E5%85%B3%E4%BA%8ERecyclerView%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E4%BA%86%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>由于本篇篇幅特长，特意做了个目录，让大伙对本篇内容先有个大概的了解。</p>
<p>另外，由于有些平台可能不支持 <code>[TOC]</code> 解析，所以建议大伙可借助本篇目录，或平台的目录索引进行快速查阅。  </p>
<blockquote>
<ol>
<li><p><strong>LayoutManager</strong></p>
<p>1.1 <strong>LinearLayoutManager</strong></p>
<pre><code>- 基本效果介绍
- findFirstCompletelyVisibleItemPosition()
- findFirstVisibleItemPosition()
- findLastCompletelyVisibleItemPosition()
- findLastVisibleItemPosition()
- setRecycleChildrenOnDetach()</code></pre><p>1.2 <strong>GridLayoutManager</strong></p>
<ul>
<li>基本效果介绍</li>
<li>setSpanSizeLookUp()</li>
</ul>
<p>1.3 <strong>StaggeredGridLayoutManager</strong></p>
<ul>
<li>基本效果介绍</li>
<li>setFullSpan()</li>
<li>findXXX() 系列方法介绍</li>
</ul>
</li>
<li><p><strong>ViewHolder</strong></p>
<ul>
<li>getAdapterPosition()</li>
<li>getLayoutPosition()</li>
<li>setIsRecyclable()</li>
</ul>
</li>
<li><p><strong>LayoutParams</strong></p>
</li>
<li><p><strong>Adapter</strong></p>
<ul>
<li>基本用法介绍</li>
<li>onViewRecycled()</li>
<li>onViewAttachedFromWindow()</li>
<li>onViewDetachedFromWindow()</li>
<li>onAttachedToRecyclerView()</li>
<li>onDetachedFromRecyclerView()</li>
<li>registerAdapterDataObserver()</li>
<li>unregisterAdapterDataObserver()</li>
</ul>
</li>
<li><p><strong>RecyclerView</strong></p>
<ul>
<li>addOnItemTouchListener()</li>
<li>addOnScrollListener()</li>
<li>setHasFixedSize()</li>
<li>setLayoutFrozen()</li>
<li>setPreserveFocusAfterLayout()</li>
<li>findChildViewUnder()</li>
<li>findContainingItemView()</li>
<li>findContainingViewHolder()</li>
<li>findViewHolderXXX()</li>
</ul>
</li>
<li><p><strong>Recycler</strong></p>
<ul>
<li>setItemViewCacheSize()</li>
<li>setViewCacheExtension()</li>
<li>setRecycledViewPool()</li>
<li>setRecyclerListener()</li>
</ul>
</li>
<li><p><strong>ItemAnimator</strong></p>
<p>7.1 <strong>SimpleItemAnimator</strong></p>
<p>7.2 <strong>DefaultItemAnimator</strong></p>
</li>
<li><p><strong>ItemDecoration</strong></p>
<p>8.1 <strong>DividerItemDecoration</strong></p>
<p>8.2 <strong>ItemTouchHelper</strong></p>
<p>8.3 <strong>FastScroller</strong></p>
</li>
<li><p><strong>OnFlingListener</strong></p>
<p>9.1 <strong>SnapHelper</strong></p>
<p>9.2 <strong>LinearSnapHelper</strong></p>
<p>9.3 <strong>PagerSnapHelper</strong></p>
</li>
</ol>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>阅读须知：</strong></p>
<ul>
<li>本篇力求列举 RecyclerView 所有功能的使用示例，由于篇幅原因，并不会将实现代码全部贴出，只贴出关键部分的代码。</li>
<li>本篇所使用的 RecyclerView 的版本是 26.0.0。</li>
<li>下列标题中，但凡是斜体字，表示该知识点目前暂时没理清楚，留待后续继续补充。</li>
<li>第 1 章至第 5 章节内容在上一篇中：<a href="https://www.jianshu.com/p/aff499a5953c" target="_blank" rel="noopener">关于RecyclerView你知道的不知道的都在这了（上）</a></li>
</ul>
<h3 id="6-Recycler"><a href="#6-Recycler" class="headerlink" title="6. Recycler"></a>6. Recycler</h3><p>Recycler 是 RecyclerView 的一个内部类，主要职责就是处理回收复用相关工作的。</p>
<p>回收复用的单位是 ViewHolder，至于 Item 移出屏幕是怎样回收，回收到哪里，Item 移进屏幕时是怎样复用，整个流程是先复用再回收，还是先回收再复用，还是两边同时进行等等一系列的工作都是交由 Recycler 来处理。</p>
<p>关于回收复用机制的部分原理，之前已经梳理过一篇文章了：<a href="https://www.jianshu.com/p/9306b365da57" target="_blank" rel="noopener">基于滑动场景解析RecyclerView的回收复用机制原理</a>，感兴趣的可以先去看看。</p>
<p>本篇侧重点是介绍各个接口的含义和使用场景，至于回收复用机制，后续肯定还会继续深入去分析，敬请期待。</p>
<h4 id="6-1-setItemViewCacheSize"><a href="#6-1-setItemViewCacheSize" class="headerlink" title="6.1 setItemViewCacheSize()"></a>6.1 setItemViewCacheSize()</h4><p>有看到上面链接那篇文章的应该就清楚，当 item 被移出屏幕外时，其实这个 item 的 ViewHolder 会被回收掉，而 Recycler 里有一种分级缓存的概念。</p>
<p>分级缓存，说得白点，就是不同的容器，容器之间有优先级，回收时先将 ViewHolder 缓存到高优先级的容器中，容器满了的话，那就将容器腾出个位置来，被腾出来的 ViewHolder 这时就可以放到优先级较低的容器中。分级缓存的概念就是这样。</p>
<p>移出屏幕的 ViewHolder 会被缓存到两个容器中，按优先级高到低分别是：<strong>mCachedViews</strong>  和 <strong>mRecyclerPool</strong> </p>
<p>该方法就是用于设置 <strong>mCachedViews</strong> 容器的大小，默认值为 2，可通过该方法随时改变缓存容器的大小。</p>
<p><strong>应用场景</strong>：</p>
<p>要搞清楚应用场景，那得先明白 <strong>mCachedViews</strong> 这一级的缓存有什么作用，建议还是到上面给出的链接的那篇文章看一看，就明白了。</p>
<p>这里大概说一下，个人对于 <strong>mCachedViews</strong> 这一级缓存的理解：这一级的缓存仅仅就只是用来缓存而已，里面存储的 ViewHolder 并没有通用的能力。换句话说也就是，只有原来位置的 Item 可复用这级容器里的 ViewHolder，其他位置的 Item 没办法使用。效果就好像是 ViewPager 之类的缓存一样，所以我才说它仅仅只有缓存的功能。</p>
<p>这样能达到的效果就是：当某个 Item 刚被移出屏幕外，下一步又立马移进屏幕时，此时并不会去触发到 Adapter 的 onBindXXX 的调用，也就是说，这一级缓存里的 ViewHolder 可直接 addView 到 RecyclerView 上面，不需要重新去设置数据，因为它原本携带的数据都还处于正常状态，并没有被重置掉。 </p>
<h4 id="6-2-setViewCacheExtension"><a href="#6-2-setViewCacheExtension" class="headerlink" title="6.2 setViewCacheExtension()"></a>6.2 setViewCacheExtension()</h4><p>当 Item 要被移进屏幕时，Recycler 会先去那些不需要重新调用 onBindViewHolder() 的缓存容器中寻找是否有可直接复用的 Item，如果没找到，那么会接着调用开发者自定义扩展的复用工作，如果在这里也没找到，那么才会去 RecyclerViewPool 中根据 type 来寻找可复用的，再没找到最后就直接调用 onCreateViewHolder() 新建一个来使用。</p>
<p>先来看看开发者要怎么自定义扩展：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我删了一些注释，留下一些困惑的点</span></span><br><span class="line"><span class="comment"> * 1. Note that, Recycler never sends Views to this method to be cached. It is developers</span></span><br><span class="line"><span class="comment"> * responsibility to decide whether they want to keep their Views in this custom cache</span></span><br><span class="line"><span class="comment"> * or let the default recycling policy handle it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewCacheExtension</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 2.This method should not create a new View. Instead, it is expected to return</span></span><br><span class="line"><span class="comment">	 * an already created View that can be re-used for the given type and position.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> View <span class="title">getViewForPositionAndType</span><span class="params">(Recycler recycler, <span class="keyword">int</span> position, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看着好像很简单是吧，就只需要实现一个方法，返回指定 position 和 type 下的 Item 的 View 即可，网上所有分析到回收复用机制时也全部都是这么一笔带过。</p>
<p><strong>但实际上，存在很多困惑点，这个到底该怎么用？</strong>  </p>
<p>注释 1 里说了，Recycler 永远也不会将 ItemView 发送到这个类里来缓存，然后还说由开发者自行决定是要自己维护这些缓存还说交由 Recycler 来处理。</p>
<p><strong>困惑1：</strong>交由 Recycler 来处理我能理解，毕竟 Recycler 只在复用的过程中开了个接口给开发者扩展使用，但回收的过程并没有开任何接口给开发者扩展。也正是基于这点，我就不理解官方说的让开发者自行维护，怎么维护？</p>
<p>注释 2 中，官方告诉我们在这个方法中，不要去新建一个新的 ItemView，而是直接从旧的里面拿一个复用。</p>
<p><strong>困惑2：</strong>我又不知道怎么自己去维护 ViewHolder，那不新建一个 ItemView 又该如何使用，直接借助 Recycler？但 Recycler 不是只开放了 getViewForPosition()？本来内部在复用时就是自己调了这个方法，我们在这个方法内部走到开发者扩展自定义扩展的流程时再重新调一下？那不是就陷入嵌套循环里了？有什么意义或者应用场景么？</p>
<p>最最困惑的一点，国内居然找不到任何一篇讲解如何使用这个自定义缓存的相关文章！？</p>
<p>不清楚是由于他们文章的标题太过抽象没加入我的关键词过滤中，还是我关键词提取太烂，总之就是找不到任何一篇相关文章。所以，这小节先埋个坑，我打算后续抽时间自己来研究一下，到底应该如何使用自定义 RecyclerView 的缓存策略，到底都有哪些应用场景。</p>
<h4 id="6-3-setRecycledViewPool"><a href="#6-3-setRecycledViewPool" class="headerlink" title="6.3 setRecycledViewPool()"></a>6.3 setRecycledViewPool()</h4><p>最后一级缓存就是 RecyclerViewPool，这个容器有三个特性：</p>
<ul>
<li>缓存到 RecyclerViewPool 中的 ViewHolder，携带的信息都会被重置，因此从这个容器中取 ViewHolder 去复用时，都会触发 <code>onBindViewHolder()</code> 重新绑定数据。</li>
<li>多个 RecyclerView 可共用同一个 RecyclerViewPool 容器。</li>
<li>该容器以 Item 的 type 区分缓存，每种 type 的默认存储容量为 5。</li>
</ul>
<p>一般当我们需要修改这个缓存容器的大小，或者需要设置多个 RecyclerView 共用一个 RecyclerViewPool 时才需要调用到该方法。并且，官方在注释中也给出一种应用场景：使用 ViewPager 时各页面中的 RecyclerView 有相同的 Item 布局结构。</p>
<p><strong>应用场景：</strong></p>
<p>我们来举个例子，就不用官方给的例子了，我额外补充一种场景：界面上存在多行可分别左右滑动的列表控件，即每行是一个 RecyclerView，每行里的 Item 布局样式一致，这时候就可以让每一行的 RecyclerView 共用一个 RecyclerViewPool 缓存池了，如下：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-9e528ee638e837a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多行可局部滑动.png">  </p>
<p>以上布局的实现是外层一个竖直方向的 RecyclerView，它的每一个 Item 都是占据一行的水平方向的 RecyclerView，也就是嵌套 RecyclerView 的方式，实现可上下滑动且每一行均可左右滑动的效果。</p>
<p>这里的每一行的 RecyclerView 里的每个 Item 项的样式均一致，那么这种场景下，可以让每一行的 RecyclerView 都共用同一个 RecyclerViewPool 缓存池。这样的好处是，当某一行被移出屏幕时，可以将这一行的每个卡位都回收起来，供其他行使用，而不至于每一行每次都是重新创建。</p>
<p>但有些<strong>注意事项</strong>：</p>
<ul>
<li>外层 RecyclerView 缓存复用的应该仅仅是每一行的 RecyclerView 控件而已，不应该包括每一行 RecyclerView 内部的卡位控件，因为各行卡位的个数并不一定相同。</li>
<li>对于外层 RecyclerView 来说，它的 Item 是每一行的 RecyclerView 控件，所以当某一行被移出屏幕时，它仅仅是将这一行的 RecyclerView 控件从它本身 remove 掉，并回收起来。因此，此时这一行的 RecyclerView 还是携带着它的卡位子 View 的，所以需要我们手动去将这些卡位回收、并从父控件上 remove 掉。</li>
<li>这个操作可以在外层 RecyclerView 的 adapter 的 <code>onViewRecycled()</code> 回调中进行，也可以在内层每个 RecyclerView 的 adapter 的 <code>onViewDetachedFromWindow()</code> 回调中进行。</li>
<li>移除并回收卡位可通过 <code>setAdapter(null)</code> 配合 RecyclerView 本身的 <code>removeAllView()</code> 或者 LayoutManager 的 <code>removeAllView()</code> 实现 。或者直接使用 LinearLayoutManager 的 <code>setRecycleChildrenOnDetach()</code> 功能。</li>
</ul>
<h4 id="6-4-setRecyclerListener"><a href="#6-4-setRecyclerListener" class="headerlink" title="6.4 setRecyclerListener()"></a>6.4 setRecyclerListener()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RecyclerView$Recycler#</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchViewRecycled</span><span class="params">(ViewHolder holder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mRecyclerListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mRecyclerListener.onViewRecycled(holder);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mAdapter.onViewRecycled(holder);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，这个方法设置的监听 Item 的回收，回调的时机跟 adapter 的 onViewRecycled() 一模一样，都是在 mCachedViews 容器满了之后，放入 RecyclerViewPool 之前被回调。</p>
<h3 id="7-ItemAnimator"><a href="#7-ItemAnimator" class="headerlink" title="7. ItemAnimator"></a>7. ItemAnimator</h3><p>RecyclerView 是支持对每个 item 做各种各样动画的，那么什么时候才该去执行这些 item 动画呢？说白了，也就是 adapter 数据源发生变化的时候，那么变化的方式无外乎就是四种：add, remove, change, move。相对应的，也就是这些状态时的 item 动画。</p>
<p>所以当要自定义实现 ItemAnimator 时，需要实现的方法如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animateAppearance</span><span class="params">(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animateDisappearance</span><span class="params">(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animatePersistence</span><span class="params">(@NonNull ViewHolder viewHolder, @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animateChange</span><span class="params">(@NonNull ViewHolder oldHolder, @NonNull ViewHolder newHolder, @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">runPendingAnimations</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endAnimation</span><span class="params">(ViewHolder item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endAnimations</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>看起来，要实现一个自定义的 Item 好像很复杂，要实现这么多方法。网上这方面的文章已经非常多了，也都跟你说清了每个方法的含义是什么，在这里写些什么，甚至流程都帮你列出来了。</p>
<p>但大伙会不会好奇，这帮牛人是咋这么清楚的呢？</p>
<p>其实，Google 内部已经封装好了一个默认动画的实现，有时间大伙可以自己过一下源码，看看默认动画是怎么做的，理解清楚了后，举一反三下，其实也就懂了。</p>
<p>我目前也不懂，但我就是带着这么一种想法，也是打算这么去做的。虽然跟着大神的文章，最后确实能实现想要的效果，但其实掌握并不是很牢，并不大清楚为什么需要这么写，只是因为大神说这里这么写，然后就这么写了。</p>
<p>所以，有时间有精力，还是建议深入源码中去学习，自己梳理出来的知识终归是自己的。</p>
<h4 id="7-1-SimpleItemAnimator"><a href="#7-1-SimpleItemAnimator" class="headerlink" title="7.1 SimpleItemAnimator"></a>7.1 SimpleItemAnimator</h4><p>当 adapter 数据源发生变化，通知了 RecyclerView 去刷新界面时，RecyclerView 会去通知 ItemAnimaotr 此时相应的动画行为。</p>
<p>比如 add 了一个 Item，那么就会去触发 ItemAnimator 的 <code>animateAppearance()</code> 方法，并将这个 ItemView 在刷新前后不同的信息，如默认携带的信息是 RecyclerView 内部类 ItemHolderInfo，这个类里有关于这个 Item 的坐标信息。</p>
<p>那么，开发者就可以在这些回调方法里自行判断刷新前后的 Item 的不同信息来决定是否需要进行相对应的动画。</p>
<p><strong>而 SimpleItemAnimator 其实就是帮忙处理这件事，也就是说，它在四个回调中，如 <code>animateAppearance()</code> 中，根据 Item 前后的坐标信息来判断该 Item 需要进行的动画类型</strong>。</p>
<p>比如 <code>animateAppearance()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">animateAppearance</span><span class="params">(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (preLayoutInfo != <span class="keyword">null</span> &amp;&amp; (preLayoutInfo.left != postLayoutInfo.left</span><br><span class="line">		|| preLayoutInfo.top != postLayoutInfo.top)) &#123;</span><br><span class="line">         <span class="comment">// slide items in if before/after locations differ</span></span><br><span class="line">         <span class="keyword">return</span> animateMove(viewHolder, preLayoutInfo.left, preLayoutInfo.top,</span><br><span class="line">                postLayoutInfo.left, postLayoutInfo.top);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		 <span class="keyword">return</span> animateAdd(viewHolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 RecyclerView 回调了 <code>animateAppearance()</code> 方法后，SimpleItemAnimator 内部对其进行的分类，根据参数判断，最终是要执行 <code>animateMove()</code> 类型的动画，还是执行 <code>animateAdd()</code> 类型的动画。</p>
<p>同理，对于另外三个回调方法，SimpleItemAnimator 内部同样对其进行了封装处理，简单的通过刷新前后 Item 的坐标信息来进行动画类型的区分。</p>
<p>所以，这个类并没有实现任何动画的逻辑，它只是将动画的准备工作做好，简化开发者开发。所以，如果想要自定义 ItemAnimator，其实没必要从零开始继承自 ItemAnimator 自己写，是可以借助 SimpleItemAnimator 这个类的。</p>
<h4 id="7-2-DefaultItemAnimator"><a href="#7-2-DefaultItemAnimator" class="headerlink" title="7.2 DefaultItemAnimator"></a>7.2 DefaultItemAnimator</h4><p>RecyclerView 默认有提供 Item 的动画，而 SimpleItemAnimator 只是处理跟动画无关的准备工作，那么具体的默认动画的实现就是在 DefaultItemAnimator 这个类中实现的了。</p>
<p>先看一下这个类的结构：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-06de56724562ea79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DefaultItemAnimagtor结构.png">  </p>
<p>它是继承自 SimpleItemAnimator 的，我们如果想要自定义实现一些 Item 动画，需要写的东西，大概就跟上图类似。</p>
<p>想要自定义 Item 动画，真的可以来参考、借鉴这个类的实现，能学到的东西很多。</p>
<p>我也还没深入去仔细学习，大概过了一眼，这里就大概说下：</p>
<p>这个类用了很多集合来维护各种不同类型的动画，在四个 <code>animateXXX()</code> 方法中通过集合记录相对应类型的动画和做了动画的初始化工作。</p>
<p>然后在 <code>runPendingAnimations()</code> 方法中，依次遍历这些集合，将记录的动画取出来执行，动画的实现方式是通过 <code>View.animate()</code> 方式实现，这种方式的动画本质上是借助了 ValueAnimator 机制，在每帧的回调过程中手动调用 <code>setXXX()</code> 来实现的动画效果。具体分析可参考我之前写的一篇文章：<a href="https://www.jianshu.com/p/b43cf452afc1" target="_blank" rel="noopener">View.animate()动画ViewPropertyAnimator原理解析</a>。  </p>
<p>大体上的流程原理就是这样，当然，这个类做的事肯定不止这些，还包括了集合的清理维护工作，动画的维护等等，所以很值得去借鉴学习一番。但这里就只给出大概的流程，本篇重点不在这里。</p>
<p>下面就来列举下，默认实现的各类型的动画分别是什么：  </p>
<p><strong>animateAdd</strong> -&gt; 透明度 0 ~ 1 的动画，默认动画时长 120 ms</p>
<p><strong>animateChange</strong> -&gt; 涉及两个 ItemView，旧的跟新的，默认动画时长 250ms</p>
<p>旧 ItemView：透明度从原有值 ~ 0，位置从原坐标移动到新 ItemView 坐标的动画组合</p>
<p>新 ItemView：透明度从 0 ~ 1，位置从旧 ItemView 坐标移动到新坐标的动画组合</p>
<p><strong>animateMove</strong> -&gt; 从原坐标位置移动到新坐标位置的移动动画，默认动画时长 250 ms</p>
<p><strong>animateRemove</strong> -&gt; 从原有透明度 ~ 0 的动画，默认动画时长 120 ms</p>
<p>所以，RecyclerView 默认的 Item 动画其实也就透明度和移动动画两种，而且大多数情况下都只是单一的动画，只有 change 类型时才会是组合动画。</p>
<p><strong>效果展示：</strong></p>
<p>首先，可通过下列方式修改动画时长，这里将动画时长延长，方便查看效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mRecyclerView.getItemAnimator().setAddDuration(1000);</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-baf6b6217218ae9f.gif?imageMogr2/auto-orient/strip" alt="20180702_162126.gif">  </p>
<p>可以看到，动画基本就只有透明度动画跟移动动画两种。</p>
<p>另外，只有通过 <code>notifyItemXXX()</code> 方式更新数据源时才会触发动画行为，如果是通过 <code>notifyDataSetChange()</code> 方式，则不会触发动画。</p>
<h3 id="8-ItemDecoration"><a href="#8-ItemDecoration" class="headerlink" title="8. ItemDecoration"></a>8. ItemDecoration</h3><p>RecyclerView 支持为每个 Item 之间自定义间隔样式，是要空段距离，还是要以分割线隔开，还是要唯美唯幻的边框，想长啥样都行，自己写得出来就可以了，它给我们提供了这个接口。</p>
<p>本节就先介绍下系统内置的几种样式，内置里一共有三个类继承该类，分别是 DividerItemDecoration，ItemTouchHelper，FastScroller。前两个都是 public 权限，最后一个包权限，下面分别看看它们都有哪些效果，最后再来看看如何自定义。</p>
<h4 id="8-1-DividerItemDecoration"><a href="#8-1-DividerItemDecoration" class="headerlink" title="8.1 DividerItemDecoration"></a>8.1 DividerItemDecoration</h4><p>看一下这个类的注释：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DividerItemDecoration is a &#123;<span class="doctag">@link</span> RecyclerView.ItemDecoration&#125; that can be used as a divider</span></span><br><span class="line"><span class="comment"> * between items of a &#123;<span class="doctag">@link</span> LinearLayoutManager&#125;. It supports both &#123;<span class="doctag">@link</span> #HORIZONTAL&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #VERTICAL&#125; orientations.</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     mDividerItemDecoration = new DividerItemDecoration(recyclerView.getContext(),</span></span><br><span class="line"><span class="comment"> *             mLayoutManager.getOrientation());</span></span><br><span class="line"><span class="comment"> *     recyclerView.addItemDecoration(mDividerItemDecoration);</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DividerItemDecoration</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ItemDecoration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the &#123;<span class="doctag">@link</span> Drawable&#125; for this divider.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> drawable Drawable that should be used as a divider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawable</span><span class="params">(@NonNull Drawable drawable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (drawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Drawable cannot be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mDivider = drawable;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么用，类注释也给我们示例了，有点可惜的是，它只能用于 LinearLayoutManager 这种布局，而 GridLayoutManager 继承自 LinearLayoutManager，所以它也可以用，但需要注意的是，它只有一个方向会生效。来看看如何使用和效果：  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">DividerItemDecoration itemDecoration = <span class="keyword">new</span> DividerItemDecoration(mContext, LinearLayoutManager.HORIZONTAL);</span><br><span class="line">itemDecoration.setDrawable(getResources().getDrawable(R.drawable.divider_space));</span><br><span class="line">mRecyclerView.addItemDecoration(itemDecoration);</span><br><span class="line"></span><br><span class="line"><span class="comment">//R.drawable.divider_space</span></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;shape xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">    &lt;size android:width=<span class="string">"20dp"</span> android:height=<span class="string">"20dp"</span>/&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>

<p>我们在 xml 中写宽度为 20dp 的空隙，然后调用 <code>setDrawable()</code> 应用，看看效果：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-02ae65a7f2cce81d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="空隙示例.png">  </p>
<p>这样就可以达到将 item 隔离开的效果了，中间这个空隙的样式你可以自己通过 xml 写，也可以直接使用图片，都可以，只要是 Drawable 类型的即可。</p>
<p>虽然说，RecyclerView 不像 ListView 只要设置个属性就可以达到设置 Item 之间空隙的样式，但它也内置了基本的实现，其实也已经方便了我们的使用。</p>
<h4 id="8-2-ItemTouchHelper"><a href="#8-2-ItemTouchHelper" class="headerlink" title="8.2 ItemTouchHelper"></a>8.2 <em>ItemTouchHelper</em></h4><p>这是一个工具类，也是 Google 为了方便开发人员实现 item 的拖拽和移动等等效果所提供的一个辅助工具类。借助这个类可以很容易实现 item 的侧滑删除、长按拖拽等功能。</p>
<p>由于这部分我没有研究过，日常也较少接触，所以暂时先从网上搜索一篇文章，以下的效果图来自大神的博客，会给出链接，侵权删。后续有接触相关需求时再自行来研究一番。  </p>
<p><a href="https://blog.csdn.net/wuyuxing24/article/details/78985026" target="_blank" rel="noopener">推荐博客： ItemTouchHelper源码分析 </a>  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-470540d87bab3787.gif?imageMogr2/auto-orient/strip" alt="20180105202851329.gif">  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-36ecbcb6385c86cc.gif?imageMogr2/auto-orient/strip" alt="20180105202823469.gif">  </p>
<h4 id="8-3-FastScroller"><a href="#8-3-FastScroller" class="headerlink" title="8.3 FastScroller"></a>8.3 <em>FastScroller</em></h4><p>这个类也是继承自 ItemDecoration，但它的类权限只是包权限，不开放给外部使用，稍微看了下注释，说是用来处理动画以及快速滑动相关的支持，具体原理是什么，如何生效，留待后续深入研究时再来分析。</p>
<h4 id="8-4-自定义ItemDecoration"><a href="#8-4-自定义ItemDecoration" class="headerlink" title="8.4 自定义ItemDecoration"></a>8.4 自定义ItemDecoration</h4><p>上面说过系统默认提供的 DividerItemDecoration 只支持用于 LinearLayoutManager，而如果用于 GridLayoutManager 时，只有一个方向会生效，那么下面我们就以 GridLayoutManager 为例，来看看，如何自定义写 ItemDecoration。</p>
<p>用 GridLayoutManager 实现一个四列的布局，然后让除了四个边的 Item 外，内部的每个 Item 之间相互间隔 20 dp 的空隙。为了能更明显看出，将 20dp 的空隙用红色绘制出来。</p>
<p>先来看下效果：</p>
<ul>
<li>4 列布局 &amp; 2 行布局</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-4c6b0f5f95f53602.gif?imageMogr2/auto-orient/strip" alt="20180619_200035.gif">    </p>
<p>代码：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyItemDecoration</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ItemDecoration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> spanCount;<span class="comment">//几行或几列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> orientation;<span class="comment">//方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> itemSpace;<span class="comment">//空隙大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Rect mBounds = <span class="keyword">new</span> Rect();</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;<span class="comment">//用来将空隙绘制成红色的画笔</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyItemDecoration</span><span class="params">(GridLayoutManager gridLayoutManager)</span> </span>&#123;</span><br><span class="line">        spanCount = gridLayoutManager.getSpanCount();</span><br><span class="line">        orientation = gridLayoutManager.getOrientation();</span><br><span class="line">        initPaint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        mPaint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">        mPaint.setColor(Color.RED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItemSpace</span><span class="params">(<span class="keyword">int</span> space)</span> </span>&#123;</span><br><span class="line">        itemSpace = space;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        c.save();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = parent.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = parent.getChildAt(i);</span><br><span class="line">            parent.getLayoutManager().getDecoratedBoundsWithMargins(child, mBounds);</span><br><span class="line">            c.drawRect(mBounds, mPaint);</span><br><span class="line">        &#125;</span><br><span class="line">        c.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getItemOffsets</span><span class="params">(Rect outRect, View view, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前view的layoutPosition</span></span><br><span class="line">        <span class="keyword">int</span> itemPosition = parent.getChildLayoutPosition(view);</span><br><span class="line">        <span class="comment">//计算该View位于哪一行哪一列</span></span><br><span class="line">        <span class="keyword">int</span> positionOfGroup = itemPosition % spanCount;</span><br><span class="line">        <span class="keyword">int</span> itemGroup = itemPosition / spanCount;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//根据不同方向进行不同处理，最终效果都要实现除四周的View 外，内部的View之间横竖都以相同空隙间隔开</span></span><br><span class="line">        <span class="comment">//实现方式，以水平方向为例：</span></span><br><span class="line">        <span class="comment">//每个view的left和bottom都设置相同间隙</span></span><br><span class="line">        <span class="comment">//去掉第1列的left，和最后一行的bottom，也就实现了除四周外内部view都以相同间隙空隔开</span></span><br><span class="line">        <span class="keyword">if</span> (orientation == LinearLayoutManager.HORIZONTAL) &#123;</span><br><span class="line">            outRect.set(itemSpace, <span class="number">0</span>, <span class="number">0</span>, itemSpace);</span><br><span class="line">            <span class="keyword">if</span> (itemGroup == <span class="number">0</span>) &#123;</span><br><span class="line">                outRect.left = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (positionOfGroup == (spanCount - <span class="number">1</span>)) &#123;</span><br><span class="line">                outRect.bottom = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orientation == LinearLayoutManager.VERTICAL) &#123;</span><br><span class="line">            outRect.set(<span class="number">0</span>, itemSpace, itemSpace, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (itemGroup == <span class="number">0</span>) &#123;</span><br><span class="line">                outRect.top = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (positionOfGroup == (spanCount - <span class="number">1</span>)) &#123;</span><br><span class="line">                outRect.right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：由于 GridLayoutManager 会根据设置的 Orientation 方向，默认为 VERTICAL 数值方向，以及 RecyclerView 的宽高模式来决定是否自动将某一方向的空隙平均分配给各 Item，这点需要注意一下。</p>
<p>以上的例子想说明，如果要自定义写 Iiem 间的空隙，那么关键点在于重写两个方法：  </p>
<ul>
<li><code>getItemOffsets()</code> </li>
<li><code>onDraw()</code></li>
</ul>
<p>第 1 个方法会携带很多参数，最重要的是 outRect 这个参数，它是一个 Rect 类型的对象，重写这个方法并设置了这个 outRect 的 left, top, right, bottom，就相当于设置了对应这个 view 的四周分别有多大的空隙。</p>
<p>其他的参数是用来给我们辅助使用，如果不需要区分对待，每个 item 的四周都是同样的间隔空隙，那直接设置 outRect 即可。</p>
<p>如果需要像上述例子那样，要求四周的 Item 的间隙要区别于内部 item 的间隙，那么就需要判断出这个 View 的位置，因此可以通过其他参数辅助配合实现。</p>
<p><code>onDraw()</code> 这个方法就是用于绘制，注意这个方法参数只给了 RecyclerView，而绘制 item 的 Decoration 是针对于每个 item 而言的，所以内部需要通过遍历子 View 来对每个 item 进行绘制操作。</p>
<p>当然，我这里写得很粗糙，考虑到性能优化方面，绘制过度方面等等因素，通常是需要使用到 canvas.clipRect()。这部分代码建议可以参考 DividerItemDecoration 内部的实现。</p>
<h3 id="9-OnFlingListener"><a href="#9-OnFlingListener" class="headerlink" title="9. OnFlingListener"></a>9. <em>OnFlingListener</em></h3><p>RecyclerView 是可滑动控件，在平常使用过程中，我们可能就是上滑，下滑，左边滑滑，右边滑滑，能够刷新更多列表即可，通常都没太过去注意到滑动的细节。</p>
<p>但其实，滑动策略也是支持多样化的。</p>
<p>比如，如果想要实现不管以多大的加速度滑动，滑多长距离，最终停下来时都系统有个 ItemView 是居中显示的效果。</p>
<p>再比如，只希望翻页滑动，当手指滑动距离小于翻页时，自动滑回原位进行翻页等等。</p>
<p>这些滑动策略其实就可以直接借助内置的两个类来实现：LinearSnapHelper 和 PagerSnapHelper</p>
<p><strong>ps：本来以为这种滑动策略也是支持由焦点触发的滑动行为的，最后测试时才发现，原来只支持手指触摸式的滑动行为。由于我是搞 Tv 应用开发的，Tv 应用没有触摸事件，只有遥控器事件，滑动是由于焦点的变化触发的滑动行为。而在 Tv 上，Item 居中的需求也非常常见，但利用这个是无法实现的。所以，我就先不打算深入了解这块了，后续有时间再来慢慢研究。附上鸿神公众号中的一篇文章，大伙看这篇就行了。</strong>  </p>
<p><a href="https://www.jianshu.com/p/ef3a3b8d0a77" target="_blank" rel="noopener">Android中使用RecyclerView + SnapHelper实现类似ViewPager效果</a>  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/3513995-aafe6c4113148c23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt>  </p>
<h4 id="9-1-SnapHelper"><a href="#9-1-SnapHelper" class="headerlink" title="9.1 SnapHelper"></a>9.1 <em>SnapHelper</em></h4><h4 id="9-2-LinearSnapHelper"><a href="#9-2-LinearSnapHelper" class="headerlink" title="9.2 LinearSnapHelper"></a>9.2 <em>LinearSnapHelper</em></h4><h4 id="9-3-PagerSnapHelper"><a href="#9-3-PagerSnapHelper" class="headerlink" title="9.3 PagerSnapHelper"></a>9.3 <em>PagerSnapHelper</em></h4>]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>关于RecyclerView你知道的不知道的都在这了（上）</title>
    <url>/2018/06/09/Android%E7%9F%A5%E8%AF%86/%E5%85%B3%E4%BA%8ERecyclerView%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E4%BA%86%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>最近打算花点精力来研究 RecyclerView 这个控件架构和原理，对我来说，难度很大，我不清楚最后能不能彻底搞清楚，这个系列的博客会不会被太监，但我会尽我最大努力，并将这整个过程分享出来。</p>
<p>第一篇打算从使用方面入手，力求将 RecyclerView 开放给开发人员的所有接口都体验一番。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然在日常开发中，大伙或多或少都会接触到 RecyclerView，但通常，也就是写写 adapter，用个系统提供的 LayoutManager，写写点击事件，处理处理复杂的 item 布局。</p>
<p>也就是说，大部分场景下，我们其实并不会去接触到 RecyclerView 的大部分其他功能，比如自定义 LayoutManager ，自定义 Item 动画，自定义边界样式，自定义滑动效果，自定义回收策略等等之类的功能。</p>
<p>那么，本篇就专门来试用下这些功能，力求将 RecyclerView 支持的所有功能都试一遍，只有清楚了这个控件都支持哪些功能效果，那么分析起它的架构、原理才会有一个比较清晰的脉络。  </p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>由于本篇篇幅特长，特意做了个目录，让大伙对本篇内容先有个大概的了解。</p>
<p>另外，由于有些平台可能不支持 <code>[TOC]</code> 解析，所以建议大伙可借助本篇目录，或平台的目录索引进行快速查阅。  </p>
<blockquote>
<ol>
<li><p><strong>LayoutManager</strong></p>
<p>1.1 <strong>LinearLayoutManager</strong></p>
<pre><code>- 基本效果介绍
- findFirstCompletelyVisibleItemPosition()
- findFirstVisibleItemPosition()
- findLastCompletelyVisibleItemPosition()
- findLastVisibleItemPosition()
- setRecycleChildrenOnDetach()</code></pre><p>1.2 <strong>GridLayoutManager</strong></p>
<ul>
<li>基本效果介绍</li>
<li>setSpanSizeLookUp()</li>
</ul>
<p>1.3 <strong>StaggeredGridLayoutManager</strong></p>
<ul>
<li>基本效果介绍</li>
<li>setFullSpan()</li>
<li>findXXX() 系列方法介绍</li>
</ul>
</li>
<li><p><strong>ViewHolder</strong></p>
<ul>
<li>getAdapterPosition()</li>
<li>getLayoutPosition()</li>
<li>setIsRecyclable()</li>
</ul>
</li>
<li><p><strong>LayoutParams</strong></p>
</li>
<li><p><strong>Adapter</strong></p>
<ul>
<li>基本用法介绍</li>
<li>onViewRecycled()</li>
<li>onViewAttachedFromWindow()</li>
<li>onViewDetachedFromWindow()</li>
<li>onAttachedToRecyclerView()</li>
<li>onDetachedFromRecyclerView()</li>
<li>registerAdapterDataObserver()</li>
<li>unregisterAdapterDataObserver()</li>
</ul>
</li>
<li><p><strong>RecyclerView</strong></p>
<ul>
<li>addOnItemTouchListener()</li>
<li>addOnScrollListener()</li>
<li>setHasFixedSize()</li>
<li>setLayoutFrozen()</li>
<li>setPreserveFocusAfterLayout()</li>
<li>findChildViewUnder()</li>
<li>findContainingItemView()</li>
<li>findContainingViewHolder()</li>
<li>findViewHolderXXX()</li>
</ul>
</li>
<li><p><strong>Recycler</strong></p>
<ul>
<li>setItemViewCacheSize()</li>
<li>setViewCacheExtension()</li>
<li>setRecycledViewPool()</li>
<li>setRecyclerListener()</li>
</ul>
</li>
<li><p><strong>ItemAnimator</strong></p>
<p>7.1 <strong>SimpleItemAnimator</strong></p>
<p>7.2 <strong>DefaultItemAnimator</strong></p>
</li>
<li><p><strong>ItemDecoration</strong></p>
<p>8.1 <strong>DividerItemDecoration</strong></p>
<p>8.2 <strong>ItemTouchHelper</strong></p>
<p>8.3 <strong>FastScroller</strong></p>
</li>
<li><p><strong>OnFlingListener</strong></p>
<p>9.1 <strong>SnapHelper</strong></p>
<p>9.2 <strong>LinearSnapHelper</strong></p>
<p>9.3 <strong>PagerSnapHelper</strong></p>
</li>
</ol>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>阅读须知：</p>
<ul>
<li>本篇力求列举 RecyclerView 所有功能的使用示例，由于篇幅原因，并不会将实现代码全部贴出，只贴出关键部分的代码。</li>
<li>本篇所使用的 RecyclerView 的版本是 26.0.0。</li>
<li>下列标题中，但凡是斜体字，表示该知识点目前暂时没理清楚，留待后续继续补充。  </li>
<li>第 6 章至第 9 章内容在下篇：<a href="https://www.jianshu.com/p/311df8be8633" target="_blank" rel="noopener">关于RecyclerView你知道的不知道的都在这了（下）</a></li>
</ul>
<h3 id="1-LayoutManager"><a href="#1-LayoutManager" class="headerlink" title="1. LayoutManager"></a>1. LayoutManager</h3><p>RecyclerView 的 support 包里默认提供了三个 LayoutManager，分别是下列三个，可用于实现大部分场景的布局需求：线性布局、网格布局、瀑布流布局等等。</p>
<h4 id="1-1-LinearLayoutManager"><a href="#1-1-LinearLayoutManager" class="headerlink" title="1.1 LinearLayoutManager"></a>1.1 LinearLayoutManager</h4><p>线性布局，用它可以来实现横竖自由切换的线性布局，先来看看它的构造函数：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">LayoutManager</span> <span class="keyword">implements</span> <span class="title">ItemTouchHelper</span>.<span class="title">ViewDropHandler</span>, <span class="title">RecyclerView</span>.<span class="title">SmoothScroller</span>.<span class="title">ScrollVectorProvider</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearLayoutManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, VERTICAL, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearLayoutManager</span><span class="params">(Context context, <span class="keyword">int</span> orientation, <span class="keyword">boolean</span> reverseLayout)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearLayoutManager</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总共三个，我们分别来看看它们各自的使用场景：</p>
<ul>
<li><strong>第一个构造函数</strong>  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用法(在Activity里初始化控件后)：</span></span><br><span class="line">LinearLayoutManager layoutManager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(layoutManager);</span><br></pre></td></tr></table></figure>

<p>很简单，这种时候默认就是竖直方向的线性布局，效果图：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-8ad93d1d803f9c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="竖直LinearLayoutManager示例.png">  </p>
<p>在 Tv 应用中，这种竖直方向的 LinearLayoutManager 使用场景大多都是用于显示菜单项，使用频率并不是特别高，但在手机应用中，这种的使用频率算是特别高的了，几乎每个 app 都会有竖直方向的滑动列表控件。  </p>
<ul>
<li><strong>第二个构造函数</strong>  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用法(在Activity里初始化控件后)：</span></span><br><span class="line"><span class="comment">//第二个参数就是用于指定方向是竖直还是水平，第三个参数用于指定是否从右到左布局，基本都是false，我们的习惯都是左到右的排列方式</span></span><br><span class="line">LinearLayoutManager layoutManager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>, LinearLayoutManager.HORIZONTAL, <span class="keyword">false</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(layoutManager);</span><br></pre></td></tr></table></figure>

<p>第二个参数就是用于指定方向是竖直还是水平，第三个参数用于指定是否从右到左布局，基本都是false，我们的习惯都是左到右的排列方式，来看看效果：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-3076dcee4df3758e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="水平LinearLayoutManager.png">  </p>
<p>在 Tv 应用中，这种布局就比较常见了，常见的还有网格布局，多行布局等等；而在手机应用中，水平滑动的列表控件也还是有，但会比竖直的少见一些。</p>
<ul>
<li><strong>第三个构造函数</strong>  </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//xml文件：</span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/recycler_main"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layoutManager</span>=<span class="string">"LinearLayoutManager"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种方式基本没见过吧，我也是看了 LinearLayoutManager 源码的构造函数，才发现，原来还有这种方式，可以直接在 xml 布局文件中指定 RecyclerView 的 LayoutManager，这时候，android:orientation 就是用来指定 LinearLayoutManager 的布局方向了。</p>
<p>那么使用这种 xml 方式时，还有哪些属性可以配置呢？直接去看对应的 LayoutManager 的源码就清楚了，比如：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinearLayoutManager.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructor used when layout manager is set in XML by RecyclerView attribute</span></span><br><span class="line"><span class="comment">    * "layoutManager". Defaults to vertical orientation.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@attr</span> ref android.support.v7.recyclerview.R.styleable#RecyclerView_android_orientation</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@attr</span> ref android.support.v7.recyclerview.R.styleable#RecyclerView_reverseLayout</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@attr</span> ref android.support.v7.recyclerview.R.styleable#RecyclerView_stackFromEnd</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//上面是源码的注释，当在 xml 中通过 app:layoutManager="LinearLayoutManager" 之后，那么此时就还可以再使用三个属性来配置 LinearLayoutManager,如下：</span></span><br><span class="line"><span class="comment">//android:orientation="horizontal"</span></span><br><span class="line"><span class="comment">//app:reverseLayout="false"</span></span><br><span class="line"><span class="comment">//app:stackFromEnd="false"</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LinearLayoutManager</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">       Properties properties = getProperties(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">       setOrientation(properties.orientation);</span><br><span class="line">       setReverseLayout(properties.reverseLayout);</span><br><span class="line">       setStackFromEnd(properties.stackFromEnd);</span><br><span class="line">       setAutoMeasureEnabled(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>另外两个 LayoutManager 同理。</p>
<p>以上，仅仅就是 LinearLayoutManager 支持的布局样式，我们只需要设置布局方向后，其他都不用管了。那么，LinearLayoutManager 是否还有提供其他一些可选功能来让我们使用呢？接下去就一起再看看：  </p>
<ul>
<li><strong>setOrientation()</strong></li>
</ul>
<p>用于设置布局方向，如果不通过构造函数来指定，也可以通过该方法指定，就两个值：<br>LinearLayoutManager.HORIZONTAL<br>LinearLayoutManager.VERTICAL</p>
<ul>
<li><strong>findFirstCompletelyVisibleItemPosition()</strong></li>
<li><strong>findFirstVisibleItemPosition()</strong></li>
<li><strong>findLastCompletelyVisibleItemPosition()</strong></li>
<li><strong>findLastVisibleItemPosition()</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-0d420ec9bbfc29c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="findItem示例.png">  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-09a7678bb91a7d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="findItem日志.png">  </p>
<p>上述四个方法作用从方法命名就可以很直观的理解了，但有些<strong>细节需要注意</strong>一下：</p>
<p>两个查找全部可见的 item 方法并不是我们正常意义上的全部可见，而是指在布局方向上是否已全部可见。说得白点，如果是 HORIZONTAL 水平样式，如上图，那么它只会去计算左右方向上是否全部可见来判定，比如我们特意在代码中通过 layout_marginTop=”-100dp” 来将控件移出屏幕一部分，如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-7fa0f3a1efeb3c96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="部分可见.png">  </p>
<p>此时，按照我们正常意义上来理解是没有一个 item 处于全部可见的，因为每个 item 的上半部分都被移出屏幕了。但是调用那两个查找全部可见的 item 方法，仍然会返回 0 和 4，因为它只去判断水平方向是否全部可见。</p>
<p>findFirst 就是判断左边第一个 item 的左边界是否可见，findLast 就是判断右边最后一个 item 的右边界是否可见。如果布局方向是竖直的，那么同样的道理。这点细节需要注意一下。</p>
<p>还有另外两个查找第一个或最后一个可见的 item 方法也有个细节需要注意一下，如果这个 item 是有设置了 ItemDecoration，那么如果 ItemDecoration 这部分区域是可见的，也会判定该 item 是可见的。</p>
<ul>
<li><strong>setRecycleChildrenOnDetach()</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set whether LayoutManager will recycle its children when it is detached from</span></span><br><span class="line"><span class="comment">    * RecyclerView.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * If you are using a &#123;<span class="doctag">@link</span> RecyclerView.RecycledViewPool&#125;, it might be a good idea to set</span></span><br><span class="line"><span class="comment">    * this flag to &lt;code&gt;true&lt;/code&gt; so that views will be available to other RecyclerViews</span></span><br><span class="line"><span class="comment">    * immediately.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Note that, setting this flag will result in a performance drop if RecyclerView</span></span><br><span class="line"><span class="comment">    * is restored.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> recycleChildrenOnDetach Whether children should be recycled in detach or not.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRecycleChildrenOnDetach</span><span class="params">(<span class="keyword">boolean</span> recycleChildrenOnDetach)</span> </span>&#123;</span><br><span class="line">       mRecycleChildrenOnDetach = recycleChildrenOnDetach;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>先来看看源码注释，注释里说了，这个方法是用来设置，当它（LinearLayoutManager）从 RecyclerView 上面 detached 时是否要回收所有的 item。而且，它还建议我们，如果我们项目里有复用 RecyclerViewPool 的话，那么开启这个功能会是一个很好的辅助，它可以将这些 item 回收起来给其他 RecyclerView 用。最后，还指明了一点，开启这个功能的话，当 RecyclerView 恢复时，也就是从 detached 又变回 attached，那么会消耗一定的性能来绘制。</p>
<p>有<strong>两种场景</strong>会导致 LinearLayoutManager 从 RecyclerView 上被 detached，一种是：<code>setLayoutManager()</code>，而另外一种是：RecyclerView 从视图树上被 remove 掉。</p>
<p>但经过测试（你也可以去看源码），<code>setLayoutManager()</code> 时，如果之前有设置过 LayoutManger，那么内部会自动先去将之前 LayoutManager 的所有 item 回收，然后再给新的 LayoutManager 复用。此时，这个方法并没有什么卵用。</p>
<p>也就是说，上面说了有两种场景会触发到该方法开启的回收工作，但实际上，第一种场景内部默认的工作中就包含了回收工作，那么有没有通过这个方法来开启并没有任何影响。只有第二种场景下，要不要去处理回收工作才是由该方法来控制。</p>
<p>所以我怀疑是不是 Google 工程师太懒了，没有同步更新这个方法的注释。注释的第一句 when 后面应该改成：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set whether LayoutManager will recycle its children when RecyclerView is detached from Window.</span><br></pre></td></tr></table></figure>

<p>我觉得这样才比较合理一点，但纯属个人观点哈，也许是我某个地方理解错了。</p>
<p><strong>那么这个方法开启的回收工作到底有什么使用场景呢？</strong>  </p>
<p>这类场景还是有的，我举个例子，比如当前页面是通过 ViewPager + Fragment 来实现的，每个 Fragment 里又有 RecyclerView 控件，那么如果当页面布局信息需要更新时，有时候是直接暴力的通过 ViewPager 的 <code>setAdapter()</code> 来刷新，那么此时，旧的 fragment 其实就全被移除掉了，然后 new 了新的 fragment 绘制新的布局信息。</p>
<p>这样，新的 fragment 里新的 RecyclerView 的 item 就又需要全部重新创建了，如果用这个方法开启了回收工作，那么当旧的 fragment 被移除时会触发到 RecyclerView 的 detachedFromWindow 的回调，那么此时这个回收工作就会去将 item 回收到 RecyclerViewPool 中，如果新的 fragment 里的 RecyclerView 复用了这个 RecyclerViewPool，就可以省掉重新创建 item 的消耗，达到直接复用 item 的效果。</p>
<p>小结一下，其实也就是 RecyclerView 有更换新的实例对象时，这个方法开启的回收工作是有一定的好处的。但如果同一个 RecyclerView 实例对象存在从 attached 到 detached 又到 attached 的场景，默认没有开启回收工作时，由于 item 一直都附着在 RecyclerView 上，所以当重新 attached 时就可以直接显示出来了。但如果用该方法开启了回收工作，等于是要重新在 onBind 一次了，这点也是在注释中有提到的。</p>
<p>所以，这是一把双刃剑，有好有坏，有符合的场景下再去开启使用吧。</p>
<ul>
<li><strong><em>RecyclerView 内嵌 RecyclerView</em></strong> </li>
</ul>
<p>另外，LayoutManager 里还有许多 public 的接口，这些方法涉及的方面是 RecyclerView 内嵌 RecyclerView 的场景，比如：<br><code>collectInitialPrefetchPositions()</code><br><code>setInitialPrefetchItemCount()</code><br>等等，但目前还没搞懂这些相关方法的用法及效果，等待后续补充。  </p>
<h4 id="1-2-GridLayoutManager"><a href="#1-2-GridLayoutManager" class="headerlink" title="1.2 GridLayoutManager"></a>1.2 GridLayoutManager</h4><p>网格样式的布局管理器，同样，先来看看它的构造函数：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意看，GridLayoutManager 是继承的 LinearLayoutManger 的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GridLayoutManager</span> <span class="keyword">extends</span> <span class="title">LinearLayoutManager</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GridLayoutManager</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GridLayoutManager</span><span class="params">(Context context, <span class="keyword">int</span> spanCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        setSpanCount(spanCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GridLayoutManager</span><span class="params">(Context context, <span class="keyword">int</span> spanCount, <span class="keyword">int</span> orientation, <span class="keyword">boolean</span> reverseLayout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, orientation, reverseLayout);</span><br><span class="line">        setSpanCount(spanCount);</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GridLayoutManager 继承自 LinearLayoutManager， 并在它的继承上补充了 spanCount 的概念，也就是说 LinearLayoutManager 是只支持线性布局，要么一行，要么一列。而 GridLayoutManager 补充了 spanCount 概念后，支持多行或者多列，这就是网格布局了。  </p>
<p>使用方面跟 LinearLayoutManager 基本一样，只是在构造函数内需要多传一个 spanCount 参数，来指定多少行或多少列，来看看效果图：  </p>
<ul>
<li>2 行  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GridLayoutManager gridLayoutManager = <span class="keyword">new</span> GridLayoutManager(<span class="keyword">this</span>, <span class="number">2</span>, LinearLayoutManager.HORIZONTAL, <span class="keyword">false</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(gridLayoutManager);</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5df7cee852f08ce6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两行.png">  </p>
<ul>
<li>4 列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GridLayoutManager gridLayoutManager = new GridLayoutManager(this, 4);</span><br><span class="line">mRecyclerView.setLayoutManager(gridLayoutManager);</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f4decf7689865af3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四列.png">  </p>
<p>这种网格布局不管是 Tv 应用还是手机应用都挺常见的，Tv 上经常需要有多行或多列的形式来展示各个卡位信息，而手机上一些类似于九宫格之类的布局也可以用这个实现。</p>
<p>但有一些<strong>细节同样需要注意</strong>一下：</p>
<p>如果指定 HORIZONTAL 样式，即以多行形式进行布局，那么 item 布局的顺序则是以竖直方向来进行，如上图中标注的 item 序号，并且，此时的 RecyclerView 只支持水平方向的滑动，不支持竖直方向。如果指定 VERTICAL 样式，则相反。</p>
<p>其实想想也很容易理解，GridLayoutManager 是继承自 LinearLayoutManager，只是在它基础上补充了 spanCount 概念，滑动的实现还是延用 LinearLayoutManager 的逻辑，那么如果指定水平样式，自然就只有水平方向可滑动。</p>
<p>当设置成水平样式，水平方向可滑动的话，那么水平方向的长度自然就是可根据 item 数量动态增加的，此时自然要按照竖直方向来进行 item 布局，否则还以行为优先的话，哪里知道尽头是哪里，什么时候该换行布局了。</p>
<p>还有一点细节需要注意，当使用 GridLayoutManager 时，RecyclerView 的宽高在 match_parent 和 wrap_content 两种情况下的表现完全不一样，具体表现怎样，有兴趣的可以去试一下，这里就简单举个例子给大伙有个直观印象：  </p>
<ul>
<li>4 列，RecycerView 宽高为 wrap_content 模式，item 设置具体宽高数值</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f4decf7689865af3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四列.png">  </p>
<ul>
<li>4 列，RecyclerView 宽高为 match_parent 模式，item 设置具体宽高数值</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-afe2db4b56586054.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四列2.png">  </p>
<p>简单点说，就是在 match_parent 模式下，如果指定了水平样式，那么在竖直方向上，GridLayoutManager 会保证让所有行都显示出来，如果 item 指定了具体宽高，全部显示出来还不足以铺满 RecyclerView，那么会自动将剩余空间平均分配到每个 item 之间的间隙。</p>
<p>如果 RecyclerView 高度不足以让所有行都显示出来，那么就会出现 item 重叠现象。这就是在 match_parent 下的表现，至于 wrap_content 则完全根据 item 设定的宽高来考虑了，不会再有自动分配剩余空间或者 Item 重叠之类的工作了。 </p>
<p>所以，使用 GridLayoutManager 时，RecyclerView 的宽高模式需要注意一下。</p>
<ul>
<li><strong>setSpanCount()</strong></li>
</ul>
<p>通过构造函数指定了 spanCount 后也还可以继续通过该方法进行修改</p>
<ul>
<li><strong>LinearLayoutManager 的方法</strong></li>
</ul>
<p>由于是继承关系，所有 LinearLayoutManager 中的四个  <strong><code>findFirstCompletelyVisibleItemPosition()</code></strong> 方法一样可以使用，但在 LinearLayoutManager 一节中对这四个方法所讲的注意事项在这里就更加明显了，使用时需要注意一下。</p>
<ul>
<li><strong>setSpanSizeLookup()</strong>  </li>
</ul>
<p>通常情况下，网格布局样式下，每个小格的大小基本都是一样的，但如果我们想实现如下的效果呢：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-cbb3595bd767d01a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网格示例.png">    </p>
<p>区别于常见的网格布局，这里有的小格就占据了多个网格，这种效果就可以通过该方法来实现了。</p>
<p>上述布局是设定了 HORIZONTAL 水平方向的 GridLayoutManager，并且设定为 3 行，默认情况下每个 item 占据一个小格，按照竖直方向依次布局。</p>
<p>通过 <code>setSpanSizeLookup()</code> 方法就可以自定义为每个 item 指定它在竖直方向要占据多少个小格，最多不超过设定的行数，上述例子中每个 item 最多就只能占据 3 行的高度。如果在该列的剩余空间不足 item 设定占据的行数，那么会将该列剩余的空间空闲出来，将该 item 移到下列进行布局。</p>
<p>同样的道理，当设定为 VERTICAL 竖直方向的样式时，那么可以自定义为每个 item 设定要占据的列数，最多不超过指定的列数。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GridLayoutManager gridLayoutManager = <span class="keyword">new</span> GridLayoutManager(<span class="keyword">this</span>, <span class="number">3</span>, LinearLayoutManager.HORIZONTAL, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//自定义item占据的小格大小时需要重写 getSpanSize()，返回值就是占据的小格数量</span></span><br><span class="line">gridLayoutManager.setSpanSizeLookup(<span class="keyword">new</span> GridLayoutManager.SpanSizeLookup() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpanSize</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;    </span><br><span class="line">		<span class="comment">//以下代码仅为上图示例为写，具体场景中应该根据需求具体编写</span></span><br><span class="line">        <span class="keyword">if</span> (position == <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (position == <span class="number">7</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这个方法也很重要，但我还没搞清楚它的具体效果，从注释上来看，该方法是用于指定 item 在该行或该列上具体哪个位置，比如将GridLayoutManager设置为3行水平样式，那么第1个卡位就是在第一列的 0 位置，第2个卡位 1，一次类推。但该方法具体被调用的场景还没理清</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpanIndex</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span> spanCount)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">super</span>.getSpanIndex(position, spanCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//官方建议说，如果延用默认的 getSpanIndxe() 的实现逻辑的话，那么建议调用下述方法来进行优化，否则每次布局计算时会很耗性能。 </span></span><br><span class="line">gridLayoutManager.getSpanSizeLookup().setSpanIndexCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(gridLayoutManager);</span><br></pre></td></tr></table></figure>

<p>虽然提供了该方法让网格布局可以更加多样化布局，但仍然<strong>无法满足一些场景</strong>，比如当设定为多行的样式时，此时就只支持自定义每个 item 占据的行数，只有行数！也就是说，所有的卡位顶多只会在高度方面不一样，同一列的卡位的宽度都是一样的。那么，如果需求是五花八门的网格布局，每个卡位都有可能占据多行的情况下又占据多列，用这个就没法实现了。</p>
<h4 id="1-3-StaggeredGridLayoutManager"><a href="#1-3-StaggeredGridLayoutManager" class="headerlink" title="1.3 StaggeredGridLayoutManager"></a>1.3 StaggeredGridLayoutManager</h4><p>英文直译过来是：交错式的网格布局管理者，不过我还是喜欢网上大伙的说法：瀑布流。</p>
<p>首先，也还是来看看它的构造方法：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaggeredGridLayoutManager</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">LayoutManager</span> <span class="keyword">implements</span> <span class="title">RecyclerView</span>.<span class="title">SmoothScroller</span>.<span class="title">ScrollVectorProvider</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaggeredGridLayoutManager</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaggeredGridLayoutManager</span><span class="params">(<span class="keyword">int</span> spanCount, <span class="keyword">int</span> orientation)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有两个构造方法，第一个跟 LinearLayoutManager 一样，用于在 xml 布局文件中直接指定 LayoutManager 时用的。</p>
<p>第二个构造方法才是我们经常使用它的入口，两个参数，说白点就是用来设置成多行的瀑布流或者多列的瀑布流样式。</p>
<p>这里顺便提一点不怎么重要的，注意到没有，这里的构造方法是不需要 Context，那么为啥另外两个 LayoutManager 却需要呢？它们之间有什么不同么？</p>
<p>哈哈哈，答案是没啥不同，LinearLayoutManager 实际上也是不需要 Context 的，看看它的源码就会发现它根本没使用这个参数，可能是早期版本有需要用到，然后新版不需要了，为了让开发者兼容旧代码，就一直留着的吧。</p>
<ul>
<li><strong>竖直方向瀑布流</strong>  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StaggeredGridLayoutManager staggeredGridLayoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);</span><br><span class="line">mRecyclerView.setLayoutManager(staggeredGridLayoutManager);</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-c73aef159fb6e264.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="瀑布流.png">  </p>
<p>瀑布流的样式在手机应用上比较常见，尤其图片查看相关的应用，在 Tv 应用上这种瀑布流布局就比较少见了。</p>
<p>瀑布流的方向可以选择水平或者竖直，两者只是方向上的区别而已，水平方向的效果图就不贴了。</p>
<p>有点<strong>细节需要注意</strong>一下，瀑布流样式在布局 item 时，并不是说一定按照某个方向某个顺序来布局。当设定为竖直方向时，以水平方向为顺序，寻找水平方向上最靠近顶端的位置来布局 item，所以并不是说一定按照第 1 列、第 2 列、第 3 列这种顺序来布局。</p>
<ul>
<li><strong>瀑布流样式和网格样式的区别</strong>  </li>
</ul>
<p>也许有人会疑惑，瀑布流就是设置下几行或者几列，然后设定下方向而已。网格样式时不也一样是设置下几行或几列，也一样是要再设置个方向。那么为什么瀑布流不可以直接用网格样式来实现呢？它们两者有什么区别么？</p>
<p>有去尝试过的就清楚了，这是两种完全不一样的布局样式。下面以两者都设置为竖直方向多列的样式来区分：</p>
<ol>
<li>网格样式每一行中的所有 item 高度是一致的，不同行可以不一样，但同行的都是一样的，因此它就实现不了瀑布流的样式了；瀑布流所有的 item 高度都允许不一样，所有能实现瀑布流样式。</li>
<li>网格样式支持 item 占据多列的宽度；瀑布流支持 item 占据总列数的宽度，不支持只占据其中几列。</li>
<li>当设置为水平方向样式时，以上结论中行列对调，宽度高度对调。</li>
</ol>
<ul>
<li><strong>setFullSpan()</strong></li>
</ul>
<p>该方法是 StaggeredGridLayoutManager 内部类 LayoutParams 的方法，用这个方法可以设置 item 是否要占据总宽度或总高度，当瀑布流中有某个 item 需要横穿的场景时，可以使用这个方法，效果如下：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-453cb36deed55957.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="瀑布流示例.png">  </p>
<ul>
<li><strong>setOrientation()</strong></li>
<li><strong>setSpanCount()</strong></li>
</ul>
<p>不解释，上面两个 LayoutManager 中介绍过了。</p>
<ul>
<li><strong>findFirstCompletelyVisibleItemPositions()</strong></li>
<li><strong>findFirstVisibleItemPositions()</strong></li>
<li><strong>findLastCompletelyVisibleItemPositions()</strong></li>
<li><strong>findLastVisibleItemPositions()</strong></li>
</ul>
<p>作用跟 LinearLayoutManager 的一样，但有些许区别，因为这里需要传入 int[] 类型的参数，返回的结果也是 int[] 类型的。</p>
<p>就以上上图的布局为例，来看下打出来的日志：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-d1df0bab15cb2e0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志.png">  </p>
<p>得到的结果是个数组，数组的大小就是构造方法中传入的 spanCount。</p>
<p>简单点说，上面四个方法的作用，是以每行或每列为单位来寻找相对应的首个（末个）可见或完全可见的 item。</p>
<p><strong>为什么要这么做呢？</strong></p>
<p>我想了想，还是想不出比较合理的解释，大概硬套了下，感觉也许是因为瀑布流的布局下是没办法确定 item 的大小的，如果还像 LinearLayoutManager 只寻找首个或末个完全可见的 item 时，也许它并不是处于当前屏的最顶部或最底部，就像上图日志中的 position=7 的 item，它虽然是最后完全可见的 item，但并不是位于最底部，最底部是 6 的 item。</p>
<p>在这种场景下，如果我们的需求是要找到处于最底部的 item 时，如果还只是像 LinearLayoutManager 只寻找最后完全可见的 item 时，就没办法做到了。那么，如果你想说，那干脆将寻找最后一个完全可见 item 改成寻找位于最底部的完全可见的 item，不就好了。那如果这时我的需求是要寻找最后一个 item 而不是最底部的呢？</p>
<p>所以，瀑布流它直接以每行或每列为单位，将该行/列的首（末）个可见或完全可见的 item 信息都全部给我们，我们需要哪些数据，是最后一个，还是最底部一个，就自行去处理这些信息好了。</p>
<p>以上，纯属个人观点。</p>
<ul>
<li><strong><em>setGapStrategy()</em></strong></li>
<li><strong><em>invalidateSpanAssignments()</em></strong></li>
</ul>
<p>这两个方法还没理清它们是干嘛用的，网上有资料说是用于解决滑动时 item 自动变换位置以及顶部留白问题，但我不是很清楚，后续有时间再继续查证。</p>
<h3 id="2-ViewHolder"><a href="#2-ViewHolder" class="headerlink" title="2. ViewHolder"></a>2. ViewHolder</h3><p>ViewHolder 大伙也不陌生了，但没想到我会单独开个小节来讲吧，也是，平时使用时顶多就是继承它，然后重写一下构造方法而已，但其实，它本身携带着很多信息，利用得当的话，可以方便我们处理很多事情。</p>
<ul>
<li><strong>getAdapterPosition()</strong></li>
<li><strong>getLayoutPosition()</strong></li>
</ul>
<p>将这两个放在一起讲，因为这两个很类似，不理清它们之间的区别的话，很容易搞乱，源码中的注释其实已经说得很清楚了。</p>
<p>在大部分场景下，这两个的值都是一样的，但在涉及到刷新时，由于 Android 是每隔 16.6 ms 刷新一次屏幕，如果在某一帧开始时，adapter 关联的数据源发生的变化，item 被移除或者新增了，我们一般都会调用 <code>notifyDataSetChanged()</code> 或者 <code>notifyItem系列()</code> 方法来刷新，但 RecyclerView 会直到下个帧来的时候才会去刷新界面。</p>
<p>那么，从调用了 <code>notifyDataSetChanged()</code> 到界面刷新这之间就会存在一定的时间差，在这段时间内，数据源与界面呈现的 Item 就不是一致性的了，如果这时候有需要区分实际数据源的 Item 和界面呈现 Item 的需求，那么这两个方法就派上用场了。</p>
<p><code>getLayoutPosition()</code>：返回的一直是界面上呈现的 Item 的位置信息，即使某个 Item 已经从数据源中被移除。</p>
<p><code>getAdapterPosition()</code>：当数据源发生变化，且界面已经刷新过后即 <code>onBindViewHolder()</code> 已经被调用了后，返回的值跟 <code>getLayoutPosition()</code> 一致；但当数据源发生变化，且在 <code>onBindViewHolder()</code> 被调用之前，如果调用了 <code>notifyDataSetChanged()</code>, 那么将返回无效的位置标志 -1；如果调用了 <code>notifyItem系列()</code>，那么将返回 Item 在数据源中的位置信息。</p>
<p><strong>示例场景：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mDataList.remove(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//1. 场景1</span></span><br><span class="line">mAdapter.notifyDataSetChanged();</span><br><span class="line">logPosition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 场景2</span></span><br><span class="line">mAdapter.notifyItemRemove(<span class="number">0</span>);</span><br><span class="line">logPosition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 场景3</span></span><br><span class="line">mAdapter.notifyItemRemove(<span class="number">0</span>);</span><br><span class="line">mRecyclerView.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		logPosition();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mRecyclerView.getChildCount(); i++) &#123;</span><br><span class="line">        View view = mRecyclerView.getChildAt(i);</span><br><span class="line">        <span class="keyword">int</span> layPosi = mRecyclerView.findContainingViewHolder(view).getLayoutPosition();</span><br><span class="line">        <span class="keyword">int</span> adapterPosi = mRecyclerView.findContainingViewHolder(view).getAdapterPosition();</span><br><span class="line">        <span class="keyword">int</span> oldPosi = mRecyclerView.findContainingViewHolder(view).getOldPosition();</span><br><span class="line">        LogUtils.d(TAG, <span class="string">"getLayoutPosition = "</span> + layPosi);</span><br><span class="line">        LogUtils.d(TAG, <span class="string">"getAdapterPosition = "</span> + adapterPosi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景1：</strong>由于数据源发生变化后，调用了 <code>notifyDataSetChanged()</code>，在这之后马上去遍历界面上的 Item 元素，分别输出 ViewHolder 的几个方法，那么打日志的时间点肯定是在界面刷新之前，所以可以看到这些方法的区别：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-e61bb62656167372.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景1日志.png">  </p>
<p>0 position 的 Item 明明已经从数据源中被移除掉了，但由于日志打印的时机是在界面刷新之前，因此可以看到通过 <code>getLayoutPosition()</code> 获取到的是界面上还未刷新之前的 Item 的信息，而由于是调用了 <code>notifyDataSetChanged()</code> 去通知，因此 <code>getAdapterPosition()</code> 对于所有 Item 都返回无效的位置标志 -1。</p>
<p><strong>场景2：</strong>同理，这次也是在数据源发生变化，界面刷新之前就去打印日志了，但是是通过 <code>notifyItemRemove()</code> 通知，这个时候 <code>getAdapterPosition()</code> 方法返回的值跟上面就有所差别了：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-9ffe280f22db0d2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景2日志.png">  </p>
<p>由于这次是通过 <code>notifyItemRemove()</code> 方法来通知的，因此，此时可以通过 <code>getAdapterPositon()</code> 来获取到界面还未刷新之前的 Item 的实际在数据源中的 position 信息。position = 0 的 Item 由于已经从数据源中移除，因此返回 -1，之后的所有 Item 位置自动向前移 1 位。</p>
<p><strong>场景3：</strong>上面讲解时一直强调说，只有在数据源发生变化且界面刷新之前，这两个方法才会有所区别，所以场景 3 就来模拟一下，通过 <code>mRecyclerView.post()</code> 的工作由于消息队列的同步屏障机制会被延迟到下一帧的屏幕刷新之后才执行（详情翻看我的历史博客），所以可以来比较下两次日志的区别，你就清楚了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-0733bf5c3aa038d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景3日志.png">  </p>
<p>左边的日志是场景 2 所打的日志，右边的日志是场景 3 下的日志。由于场景 3 将日志的执行时机延迟到下一帧的界面刷新之后，所有，可以看到，界面刷新之后，原本的第一个 Item 就被移除掉了。既然界面已经刷新了，那么数据源和界面的呈现其实就是一致的了，所以 <code>getLayoutPosition()</code> 返回的值就跟 <code>getAdapterPosition()</code> 是一致的了。</p>
<p><strong>小结：</strong>说得白点，<code>getLayoutPosition()</code> 会返回 Item 在界面上呈现的位置信息，不管数据源有没有发生变化，界面是否已刷新，总之你在界面上看到的 Item 在哪个位置，这个方法就会返回那个位置信息，注释里也说了，我们大部分场景下，使用这个方法即可。</p>
<p><code>getAdapterPosition()</code> 的使用场景是，当数据源发生变化，且界面刷新之前，你又需要获取 Item 在数据源中的实际位置时才需要考虑使用该方法。另外，使用该方法时，还要注意你是用哪种 notifyXXX 来通知刷新。这个方法的实际应用场景我还没遇到过，后续有用到再继续补充。</p>
<ul>
<li><strong><em>getOldPosition()</em></strong></li>
</ul>
<p>这个看注释说是用于处理动画时用的，但还没找到相关的场景，也没理解具体有啥样，后续再继续研究。</p>
<ul>
<li><strong>getItemId()</strong></li>
</ul>
<p>返回在 adapter 中通过 <code>getItemId(int position)</code> 为该 item 生成的 id，没有在 adapter 重写那个方法的话，就返回 RecyclerView.NO_ID。</p>
<p>用途在 adapter 一节讲解。</p>
<ul>
<li><strong>getItemViewType()</strong></li>
</ul>
<p>返回在 adapter 中通过  <code>getItemViewType()</code> 为该 item 设定的 type，没有在 adapter 重写那个方法的话，默认就是单一类型的 item type。</p>
<p>item type 是用于实现不同 item 样式。</p>
<ul>
<li><strong>setIsRecyclable()</strong></li>
</ul>
<p>RecyclerView 最大的特性就是它内部实现了一套高效的回收复用机制，而回收复用是以 ViewHolder 为单位进行管理的，每个 item 都会对应一个 ViewHolder，默认都是会参与进回收复用机制中。</p>
<p>但可以通过该方法来标志该 ViewHolder 不会被回收</p>
<h3 id="3-LayoutParams"><a href="#3-LayoutParams" class="headerlink" title="3. LayoutParams"></a>3. LayoutParams</h3><p>RecyclerView 自定义了 LayoutParams 内部类，在每个 Item 的 LayoutParams 携带了一些额外的信息，需要的话，我们也可以通过这里来获取这些信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">ViewGroup</span>.<span class="title">MarginLayoutParams</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">viewNeedsUpdate</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isViewInvalid</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isItemRemoved</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isItemChanged</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewLayoutPosition</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewAdapterPosition</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公开的接口有以上几个，也就是说，我们可以通过 LayoutParams 获取到 item 的 position 信息、状态信息，是否需要刷新，是否被移除等等。</p>
<p>更多的应用场景留待后续补充。</p>
<h3 id="4-Adapter"><a href="#4-Adapter" class="headerlink" title="4. Adapter"></a>4. Adapter</h3><p>adapter 大伙肯定是最熟悉的了，写 RecyclerView 打交道最多的也就是 adapter 了，所以一些基本知识我就一笔带过了，本节着重介绍各种可选功能。</p>
<ul>
<li><strong>onCreateViewHolder()</strong></li>
<li><strong>onBindViewHolder()</strong></li>
<li><strong>getItemCount()</strong></li>
<li><strong>RecyclerView.ViewHolder</strong></li>
</ul>
<p>以上是写一个 adapter 时必须实现的四点，它们决定了 item 长啥样，填充啥数据，以及有多少个 item，有了这些信息，一个 RecyclerView 列表也就出来了。</p>
<ul>
<li><strong>notifyDataSetChanged()</strong></li>
<li><strong>notifyItemChanged()</strong></li>
<li><strong>notifyItemXXX() 系列</strong></li>
</ul>
<p>以上是用于刷新 item，当数据源发生变化时，我们手动去刷新 item。官方说了， item 的更新分两种，一种是数据需要更新，这类刷新不涉及到 item 的位置变化；而另一种属于结构刷新，就是涉及到 item 的位置变化。</p>
<p>使用 <strong><code>notifyDataSetChanged()</code></strong> 时，它不管你分哪种形式的刷新，强制所有 item 重新绑定数据，重新布局操作。</p>
<p>以上都属于常用的基本功能，一句话带过，下面介绍一些可选功能：</p>
<ul>
<li><strong>onViewRecycled()</strong></li>
<li><strong>onViewAttachedFromWindow()</strong></li>
<li><strong>onViewDetachedFromWindow()</strong></li>
<li><strong>onAttachedToRecyclerView()</strong></li>
<li><strong>onDetachedFromRecyclerView()</strong></li>
</ul>
<p>这些方法基本都是 item 或 adapter 的一些生命周期的回调，所以分别来看看每个方法都是什么时候会被回调的，可以用来处理什么场景，做些啥工作：  </p>
<p><strong><code>onViewRecycled()</code></strong>：当 ViewHolder 已经确认被回收，且要放进 RecyclerViewPool 中前，该方法会被回调。</p>
<p>首先需要明确，RecyclerView 的回收机制在工作时，会先将移出屏幕的 ViewHolder 放进一级缓存中，当一级缓存空间已满时，才会考虑将一级缓存中已有的 ViewHolder 移到 RecyclerViewPool 中去。所以，并不是所有刚被移出屏幕的 ViewHoder 都会回调该方法。</p>
<p>另外，注释中也说了，该方法的回调是在 ViewHolder 放进 RecyclerViewPool 中前，而 ViewHolder 在放进 Pool 中时会被 reset，因为上一节中也说过，其实 ViewHolder 本身携带着很多信息。那么，在该方法回调时，这些信息还没被重置掉，官方建议我们可以在这里释放一些耗内存资源的工作，如 bitmap 的释放。</p>
<p><strong>onViewAttachedFromWindow()</strong><br> <strong>onViewDetachedFromWindow()</strong>：</p>
<p>RecyclerView 本质上也是一个 ViewGroup，那么它的 Item 要显示出来，自然要 <code>addView()</code> 进来，移出屏幕时，自然要 <code>removeView()</code> 出去，对应的就是这两个方法的回调。</p>
<p>所以，当 Item 移出屏幕时，<code>onViewRecycled()</code> 不一定会回调，但 <code>onViewDetachedFromWindow()</code> 肯定会回调。相反，当 Item 移进屏幕内时，另一个方法则会回调。</p>
<p>那么，其实，在一定场景下，可以通过这两个回调来处理一些 Item 移出屏幕，移进屏幕所需要的工作。为什么说一定场景下呢，因为如果调用了 <code>notifyDataSetChanged()</code> 的话，会触发所有 Item 的 detached 回调先触发再触发 onAttached 回调。</p>
<p><strong>onAttachedToRecyclerView()</strong><br> <strong>onDetachedFromRecyclerView()</strong>：</p>
<p>这两个回调则是当 RecyclerView 调用了 <code>setAdapter()</code> 时会触发，旧的 adapter 回调 onDetached，新的 adapter 回调 onAttached。</p>
<p>我们同样可以在这里来做一些资源回收工作，更多其他应用场景留待后续补充。</p>
<ul>
<li><strong>registerAdapterDataObserver()</strong></li>
<li><strong>unregisterAdapterDataObserver()</strong></li>
</ul>
<p>用于注册监听 <code>notifyXXX()</code> 系列方法的事件，当调用了 <code>notifyXXX()</code> 系列的方法时，注册监听后就可以接收到回调。</p>
<ul>
<li><strong><em>setHasStableIds()</em></strong></li>
<li><strong><em>getItemId()</em></strong></li>
</ul>
<p>这两方法看注释是说用于回收复用机制中，给 ViewHoler 设置一个唯一的标识符，但具体的使用场景还不清楚，后续有用到，再补充。</p>
<p>另，<code>setHasStableIds()</code> 必须在 <code>setAdapter()</code> 方法之前调用，否则会抛异常。</p>
<h3 id="5-RecyclerView"><a href="#5-RecyclerView" class="headerlink" title="5. RecyclerView"></a>5. RecyclerView</h3><h4 id="5-1-addOnItemTouchListener"><a href="#5-1-addOnItemTouchListener" class="headerlink" title="5.1 addOnItemTouchListener()"></a>5.1 addOnItemTouchListener()</h4><p>咋一看到这个方法，我还以为 RecyclerView 也把 item 的点击事件封装好了，终于不用我们自己去写了呢。看了下源码注释才发现，这个方法的作用是用于根据情况是否拦截触屏事件的分发。先看一下它的参数类型：OnItemTouchListener  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnItemTouchListener</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(RecyclerView rv, MotionEvent e)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onTouchEvent</span><span class="params">(RecyclerView rv, MotionEvent e)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onRequestDisallowInterceptTouchEvent</span><span class="params">(<span class="keyword">boolean</span> disallowIntercept)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉接口里的方法很熟悉，没错，就是触屏事件分发流程中的拦截和处理的两个方法。</p>
<p>通常我们都说在自定义 View 中重写这几个方法来将触屏事件拦截，交由自己处理。RecyclerView 也是一个 View，如果你有 RecyclerView 需要拦截触屏事件自己处理的需求，那么你可以选择继承 RecyclerView，也可以选择调用这个方法。</p>
<h4 id="5-2-addOnScrollListener"><a href="#5-2-addOnScrollListener" class="headerlink" title="5.2 addOnScrollListener()"></a>5.2 addOnScrollListener()</h4><p>RecyclerView 是一个列表控件，自然会涉及到滑动，所以它提供了滑动状态的监听接口，当我们需要在滑动状态变化时相对应的工作时，可以调用该方法注册滑动监听。来看看它的参数：OnScrollListener  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnScrollListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* Callback method to be invoked when RecyclerView's scroll state changes.</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@param</span> recyclerView The RecyclerView whose scroll state has changed.</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@param</span> newState     The updated scroll state. One of &#123;<span class="doctag">@link</span> #SCROLL_STATE_IDLE&#125;,</span></span><br><span class="line"><span class="comment">	*                     &#123;<span class="doctag">@link</span> #SCROLL_STATE_DRAGGING&#125; or &#123;<span class="doctag">@link</span> #SCROLL_STATE_SETTLING&#125;.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> newState)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrolled</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onScrolled()</code>：滑动的实现本质上就是每一帧时要么通过动画，要么通过修改属性，一帧帧内处理一小段滑动，整个过程连起来就是一个流畅的滑动效果。这个方法就是每帧内处理的滑动距离，理想状态下，每帧都会回调一次，直到滑动结束。</p>
<p>如果想得到滑动的距离，方向的话，可以在这个方法里做。</p>
<p><code>onScrollStateChanged()</code>：该方法则是滑动状态变化时的回调，一共设置了三种状态：</p>
<ul>
<li>SCROLL_STATE_IDLE：停止滑动时的状态</li>
<li>SCROLL_STATE_DRAGGING：手指拖动时的状态</li>
<li>SCROLL_STATE_SETTLING：惯性滑动时的状态（这是我的理解）</li>
</ul>
<p>在手机应用上和 Tv 应用上，这些状态的回调还是有所区别的，所以分开来说一下：</p>
<ul>
<li>手机应用：</li>
</ul>
<p>手机上的 RecyclerView 列表控件，通常都是通常手指拖动来触发滑动的，因此在手指触摸并拖动的那个时刻，这个方法会被回调，参数传入 SCROLL_STATE_DRAGGING 表示进入拖动状态。</p>
<p>当手指放开的时候，分两种情况，一是手指放开后 RecyclerView 又根据惯性滑动了一段距离，只要有稍微滑动就算，那么这个时候进入惯性滑动时该方法会被回调，参数传入 SCROLL_STATE_SETTLING 表示进入了惯性滑动状态。当最终停止滑动后，该方法还会被回调，参数传入 SCROLL_STATE_IDLE。</p>
<p>另外一种情况是，手指放开后，RecyclerView 并没有任何滑动了，通常是手指很慢的拖动情况下放开，这时候该方法就会只回调一次，参数传入 SCROLL_STATE_IDLE，因为在手指还没放开前就已经停止滑动了，放开后更不会滑动，所以直接进入停止滑动状态。</p>
<p>所以，在手机应用上，ReyclerView 的滑动状态变化有两种，一是从 SCROLL_STATE_DRAGGING 到 SCROLL_STATE_SETTLING 再到 SCROLL_STATE_IDLE；另外一种是直接从 SCROLL_STATE_DRAGGING 到 SCROLL_STATE_IDLE。</p>
<ul>
<li>Tv 应用：</li>
</ul>
<p>由于 Tv 应用没有触摸事件，只有遥控器事件，因此 RecyclerView 滑动的触发都是由遥控器方向键操作后由于焦点的变化来触发的，所以在 Tv 应用上不会有 SCROLL_STATE_DRAGGING 这个状态。</p>
<p>每次滑动都是从 SCROLL_STATE_SETTLING 到 SCROLL_STATE_IDLE。</p>
<p>两者有所区别，需要注意一下，如果从事 Tv 应用开发的话。</p>
<h4 id="5-3-setHasFixedSize"><a href="#5-3-setHasFixedSize" class="headerlink" title="5.3 setHasFixedSize()"></a>5.3 setHasFixedSize()</h4><p>看方法注释，它是说，当你能够确定后续通过 <code>notifyItemXXX()</code> 系列方法来刷新界面时，RecyclerView 控件的宽高不会因为 item 而发生变化，那么这时候可以通过该方法来让 ReyclerView 每次刷新界面时不用去重新计算它本身的宽高。</p>
<p>从代码层面上来看，也就是说，当调用该方法设置了后，之后通过 <code>notifyItemXXX()</code> 系列方法刷新界面时，RecyclerView 的 <code>onMeasure()</code>, <code>onLayout()</code> 就不会被调用了，而是直接调用 LayoutManager 的 <code>onMeasure()</code>。</p>
<p>但这样做具体有什么好处，提高性能一点，但其他的就不清楚了。想了想，当 ReyclerView 控件的宽高模式是 match_parent 时，其实这个方法可以使用，因为此时它的宽高就不会受到 item 的因素影响了。如果模式为 wrap_content，那这个方法就不要用了。</p>
<h4 id="5-4-setLayoutFrozen"><a href="#5-4-setLayoutFrozen" class="headerlink" title="5.4 setLayoutFrozen()"></a>5.4 setLayoutFrozen()</h4><p>这方法可以禁掉 RecyclerView 的布局请求操作，而 RecyclerView 的滑动，item 的添加或移除本质上都会触发 RecyclerView 的重新测量、布局操作。</p>
<p>所以，调用该方法，其实等效于关闭了 ReyclerView 的刷新，不管数据源发生了何种变化，不管用户滑动了多长距离，都不会去刷新界面，看起来就像是不响应一样，但等到再次调用该方法参数传入 false 后，就会立马去根据变化后的数据源来刷新界面了。</p>
<p>使用场景还是有的，假如有些场景暂时不想让 RecyclerView 去刷新，比如此时有其他动画效果正在执行中，RecyclerView 刷新多少会有些耗时，万一导致了当前动画的卡顿，那么体验就不好了。所以，这个时候可以暂时将 ReyclerView 的刷新关闭掉，但后面记得要重新开启。</p>
<h4 id="5-5-setPreserveFocusAfterLayout"><a href="#5-5-setPreserveFocusAfterLayout" class="headerlink" title="5.5 setPreserveFocusAfterLayout()"></a>5.5 <em>setPreserveFocusAfterLayout()</em></h4><p>这个还没搞清它的应用场景是什么，注释是说，当在进行布局工作时，有些时候，会由于 item 的状态发生改变，或者由于动画等原因，导致焦点丢失。通过该方法可以再这些工作之后，再继续保持之前 item 的焦点状态。这个方法默认就是开启的。</p>
<p>但我测试了下，不管有没有开启这个方法，<code>notifyDataSetChanged()</code> 时，焦点仍然会乱飘，后续再继续查证。</p>
<h4 id="5-6-findChildViewUnder"><a href="#5-6-findChildViewUnder" class="headerlink" title="5.6 findChildViewUnder()"></a>5.6 findChildViewUnder()</h4><p>方法参数是 (float x, float y)，作用是查找指定坐标点 (x, y) 落于 RecyclerView 的哪个子 View 上面，这里的坐标点是以 RecyclerView 控件作为坐标轴，并不是以屏幕左上角作为坐标原点。</p>
<p>具体应用场景，目前还没遇到过，后续补充。</p>
<h4 id="5-7-findContainingItemView"><a href="#5-7-findContainingItemView" class="headerlink" title="5.7 findContainingItemView()"></a>5.7 findContainingItemView()</h4><p>该方法参数是 （View view），作用正如命名上的理解，查找含有指定 View 的 ItemView，而 ItemView 是指 RecyclerView 的直接子 View。</p>
<p>通常，RecyclerView 的 Item 布局都不会简单到直接就是一个具体的 TextView，往往都挺复杂的，比如：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-45b91396cbc6db60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Item布局.png">  </p>
<p>Item 布局的结构至少如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;RelativeLayout&gt;</span><br><span class="line">	&lt;ImageView/&gt;</span><br><span class="line">	&lt;TextView/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>

<p>这种 item 已经算是很简单的了，那么如果我们当前拿到的是 TextView 对象，通过该方法就可以找到这个 TextView 的根布局，即 RecyclerView 的直接子 View，这里是 RelativeLayout 对象。</p>
<p><strong>应用场景：</strong></p>
<p>我想到一种应用场景，通常我们点击事件都是作用于具体的某个 View，比如上面的 TextView，那我们在点击事件的回调中就只能拿到 TextView 对象而已。而通过这个方法，我们可以拿到这个 TextView 所属的 ItemView。拿到 ItemView 之后可以做些什么呢？</p>
<p>看需求场景，反正总有些场景是需要用到根布局的。还有一点就是，RecyclerView 内部其实自定义了一个 LayoutParams，作用于它的直接子 View。所以只要我们可以拿到 RecyclerView 的直接子 View，就可以拿到它对应的 LayoutParams，那么就可以通过 LayoutParams 拿到一些这个 item 的信息，比如 position 等等。</p>
<h4 id="5-8-findContainingViewHolder"><a href="#5-8-findContainingViewHolder" class="headerlink" title="5.8 findContainingViewHolder()"></a>5.8 findContainingViewHolder()</h4><p>该方法参数是 （View view），作用跟上述方法类似，用于查找含有指定 View 的 ItemView 所对应的 ViewHolder。</p>
<p>这里就不展开介绍了，该方法跟上述的方法基本一模一样，区别就仅仅是一个用于查找 ItemView，一个用于查找 ItemView 对应的 ViewHoler。</p>
<p>至于应用场景，拿到 ViewHolder 能做的事就更多了，而是 LayoutParams 提供的信息其实内部也是去 ViewHolder 中拿的，所以实际上 Item 携带的各种信息基本都在 ViewHolder 上面了。</p>
<h4 id="5-9-findViewHolderXXX"><a href="#5-9-findViewHolderXXX" class="headerlink" title="5.9 findViewHolderXXX()"></a>5.9 findViewHolderXXX()</h4><p>既然 ViewHolder 携带着大量 Item 的相关信息，RecyclerView 自然也就提供了各种方式来获取 ViewHolder，这个系列的方法如下：  </p>
<ul>
<li><strong>findViewHolderForAdapterPosition()</strong></li>
<li><strong>findViewHolderForLayoutPosition()</strong></li>
<li><strong>findViewHolderForItemId()</strong></li>
<li><strong>findContainingViewHolder()</strong></li>
</ul>
<p>通过 position, id, view 都可以获取到对应的 ViewHolder 对象。</p>
<hr>
<p>ps:以下内容留待下篇介绍~  </p>
<p><a href="https://www.jianshu.com/p/311df8be8633" target="_blank" rel="noopener">链接：关于RecyclerView你知道的不知道的都在这了（下）</a></p>
<h3 id="6-Recycler"><a href="#6-Recycler" class="headerlink" title="6. Recycler"></a>6. Recycler</h3><h4 id="6-1-setItemViewCacheSize"><a href="#6-1-setItemViewCacheSize" class="headerlink" title="6.1 setItemViewCacheSize()"></a>6.1 setItemViewCacheSize()</h4><h4 id="6-2-setViewCacheExtension"><a href="#6-2-setViewCacheExtension" class="headerlink" title="6.2 setViewCacheExtension()"></a>6.2 setViewCacheExtension()</h4><h4 id="6-3-setRecycledViewPool"><a href="#6-3-setRecycledViewPool" class="headerlink" title="6.3 setRecycledViewPool()"></a>6.3 setRecycledViewPool()</h4><h4 id="6-4-setRecyclerListener"><a href="#6-4-setRecyclerListener" class="headerlink" title="6.4 setRecyclerListener()"></a>6.4 setRecyclerListener()</h4><h3 id="7-ItemAnimator"><a href="#7-ItemAnimator" class="headerlink" title="7. ItemAnimator"></a>7. ItemAnimator</h3><h4 id="7-1-SimpleItemAnimator"><a href="#7-1-SimpleItemAnimator" class="headerlink" title="7.1 SimpleItemAnimator"></a>7.1 SimpleItemAnimator</h4><h4 id="7-2-DefaultItemAnimator"><a href="#7-2-DefaultItemAnimator" class="headerlink" title="7.2 DefaultItemAnimator"></a>7.2 DefaultItemAnimator</h4><h3 id="8-ItemDecoration"><a href="#8-ItemDecoration" class="headerlink" title="8. ItemDecoration"></a>8. ItemDecoration</h3><h4 id="8-1-DividerItemDecoration"><a href="#8-1-DividerItemDecoration" class="headerlink" title="8.1 DividerItemDecoration"></a>8.1 DividerItemDecoration</h4><h4 id="8-2-ItemTouchHelper"><a href="#8-2-ItemTouchHelper" class="headerlink" title="8.2 ItemTouchHelper"></a>8.2 ItemTouchHelper</h4><h4 id="8-3-FastScroller"><a href="#8-3-FastScroller" class="headerlink" title="8.3 FastScroller"></a>8.3 FastScroller</h4><h3 id="9-OnFlingListener"><a href="#9-OnFlingListener" class="headerlink" title="9. OnFlingListener"></a>9. OnFlingListener</h3><h4 id="9-1-SnapHelper"><a href="#9-1-SnapHelper" class="headerlink" title="9.1 SnapHelper"></a>9.1 SnapHelper</h4><h4 id="9-2-LinearSnapHelper"><a href="#9-2-LinearSnapHelper" class="headerlink" title="9.2 LinearSnapHelper"></a>9.2 LinearSnapHelper</h4><h4 id="9-3-PagerSnapHelper"><a href="#9-3-PagerSnapHelper" class="headerlink" title="9.3 PagerSnapHelper"></a>9.3 PagerSnapHelper</h4>]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>Android技能树</title>
    <url>/2018/05/27/%E6%8A%80%E8%83%BD%E6%A0%91/Android%E6%8A%80%E8%83%BD%E6%A0%91/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1924341-d23f4ef9f50304cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android技能树.png"></p>
]]></content>
      <categories>
        <category>技能树</category>
      </categories>
  </entry>
  <entry>
    <title>Gradle 系列博客梳理</title>
    <url>/2018/05/27/Gradle/Gradle-%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>这一年来陆陆续续写了 6 篇 Gradle 相关的博客，本篇便来做一下汇总梳理，方便查阅，也分享给大伙。</p>
<h1 id="系列博客"><a href="#系列博客" class="headerlink" title="系列博客"></a>系列博客</h1><ol>
<li><p><a href="https://www.jianshu.com/p/a3805905a5c7" target="_blank" rel="noopener">看不懂的 build.gradle 代码</a></p>
<p><a href="https://www.jianshu.com/p/a3805905a5c7" target="_blank" rel="noopener">https://www.jianshu.com/p/a3805905a5c7</a></p>
</li>
</ol>
<ol start="2">
<li><p><a href="https://www.jianshu.com/p/501726c979b1" target="_blank" rel="noopener">学点Groovy来理解build.gradle代码</a>  </p>
<p><a href="https://www.jianshu.com/p/501726c979b1" target="_blank" rel="noopener">https://www.jianshu.com/p/501726c979b1</a>  </p>
</li>
</ol>
<ol start="3">
<li><p><a href="https://www.jianshu.com/p/28bb90e565de" target="_blank" rel="noopener">如何用Android Studio查看build.gradle源码</a></p>
<p><a href="https://www.jianshu.com/p/28bb90e565de" target="_blank" rel="noopener">https://www.jianshu.com/p/28bb90e565de</a></p>
</li>
</ol>
<ol start="4">
<li><p><a href="https://www.jianshu.com/p/718b4927f425" target="_blank" rel="noopener">读书笔记–Android Gradle权威指南（上）</a></p>
<p><a href="https://www.jianshu.com/p/718b4927f425" target="_blank" rel="noopener">https://www.jianshu.com/p/718b4927f425</a></p>
</li>
</ol>
<ol start="5">
<li><p><a href="https://www.jianshu.com/p/238eecc9c08d" target="_blank" rel="noopener">读书笔记–Android Gradle权威指南（下）</a> </p>
<p><a href="https://www.jianshu.com/p/238eecc9c08d" target="_blank" rel="noopener">https://www.jianshu.com/p/238eecc9c08d</a></p>
</li>
</ol>
<ol start="6">
<li><p><a href="https://www.jianshu.com/p/36ecd23191d2" target="_blank" rel="noopener">再写个Gradle脚本干活去，解放双手</a></p>
<p><a href="https://www.jianshu.com/p/36ecd23191d2" target="_blank" rel="noopener">https://www.jianshu.com/p/36ecd23191d2</a></p>
</li>
</ol>
<h1 id="博客概要"><a href="#博客概要" class="headerlink" title="博客概要"></a>博客概要</h1><h3 id="1-看不懂的-build-gradle-代码"><a href="#1-看不懂的-build-gradle-代码" class="headerlink" title="1. 看不懂的 build.gradle 代码"></a>1. 看不懂的 build.gradle 代码</h3><p>本篇是以 drakeet 大神的 <a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fdrakeet%2FMeizhi" target="_blank" rel="noopener">Meizi</a> 项目里的 build.gradle 为例来初步接触 build.gradle，因为大神的 build.gradle 用到了挺多平常不常用到的特性，而且是很实用的功能。</p>
<p>以此为敲门砖来开始学习 Gradle 相关知识点。</p>
<h3 id="2-学点-Groovy-来理解-build-gradle-代码"><a href="#2-学点-Groovy-来理解-build-gradle-代码" class="headerlink" title="2. 学点 Groovy 来理解 build.gradle 代码"></a>2. 学点 Groovy 来理解 build.gradle 代码</h3><p>由于 Gradle 是基于 Groovy 语言的，了解一下 Groovy 语言的语法特性，对于理解 build.gradle 里的代码有一定的帮助，因此第二篇就是来介绍 Groovy 的相关特性。</p>
<p>但由于 Groovy 又是基于 Java，而且完美兼容 Java，所以本篇重点在于介绍 Groovy 与 Java 之间的不同点，学完本篇也就清楚为什么说 build.gradle 里一行行的代码大部分都是在调用对应的方法。</p>
<h3 id="3-如何用-Android-Studio-查看-build-gradle-源码"><a href="#3-如何用-Android-Studio-查看-build-gradle-源码" class="headerlink" title="3. 如何用 Android Studio 查看 build.gradle 源码"></a>3. 如何用 Android Studio 查看 build.gradle 源码</h3><p>学完第二篇，我们就清楚了原来 build.gradle 里一行行的配置项，其实都是在调用某个方法，那么如果可以直接看到对应源码的注释说明，对于一些没看过的配置项也可以直接去看注释来理解，或者通过源码来搜索是否还有其他可选配置项。</p>
<p>说了是源码，其实分两部分，一部分是 Android Gradle 插件的源码，但由于某些原因，可能 Android Studio 并没有将源码下载下来，那么就需要自己去下载了，所以本篇介绍的如何自行去下载 Android Gradle 插件的源码。</p>
<p>还有一部分是 Gradle 的源码，但这个通常都会下载成功，这个通常不用过多关注。</p>
<p>另外，本篇正文中介绍的下载方法，目前已经下载不到新版的 Android Gradle 插件的源码了，只能下载旧版本的源码，新版本的下载方法来评论区有人已经给出，在文章开头也有提到。</p>
<h3 id="4-读书笔记–Androoid-Gradle-权威指南（上）"><a href="#4-读书笔记–Androoid-Gradle-权威指南（上）" class="headerlink" title="4. 读书笔记–Androoid Gradle 权威指南（上）"></a>4. 读书笔记–Androoid Gradle 权威指南（上）</h3><p>前三篇都是基于 build.gradle 为入手点，来学习相关知识。第四篇开始，通过《Android Gradle 权威指南》一书来较为系统的学习相关知识点，所以第四篇和第五篇都是针对这本书所做的笔记内容，记录一些自己的理解和较为重要的点。</p>
<h3 id="5-读书笔记–Android-Gradle-权威指南（下）"><a href="#5-读书笔记–Android-Gradle-权威指南（下）" class="headerlink" title="5. 读书笔记–Android Gradle 权威指南（下）"></a>5. 读书笔记–Android Gradle 权威指南（下）</h3><p>本篇和上一篇的内容是前后衔接，分两篇对《Android Gradle》一书来做总结，总结的点如下：  </p>
<blockquote>
<ol>
<li><p>Groovy 基础</p>
</li>
<li><p>Android 项目中的 Gradle<br>2.1 gradle/wrapper 目录<br>2.2 gradlew.bat 文件<br>2.3 setting.gradle 文件<br>2.4 build.gradle 文</p>
</li>
<li><p>Gradle 基础<br>3.1 task 概念<br>3.2 gradle 插件概念</p>
</li>
<li><p>区分 Gradle 和 Android Gradle</p>
</li>
<li><p>build.gradle 代码<br>5.1 apply plugin: ‘com.android.application’<br>5.2 android {}<br>5.3 buildTypes {}<br>5.4 productFlavors {}<br>5.5 flavorDimensions<br>5.6 applicationVariants<br>5.7 buildToolsVersion<br>5.8 其他</p>
</li>
<li><p>Gradle 各种技巧<br>6.1 批量修改生成的 apk 文件名<br>6.2 System.getenv()<br>6.3 动态配置 AndroidManifest.xml 文件<br>6.4 美团黑科技多渠道打包<br>6.5 Gradle 性能检测<br>6.6 关闭指定 task</p>
</li>
<li><p>gradle 脚本</p>
</li>
</ol>
</blockquote>
<p>通过这两篇，应该要学习到 Gradle 和 Android Gradle 插件这两个概念，以及清楚为什么需要这些配置，以及搞懂为什么有时候打开一个 Github 上的新项目时会一直卡在构建中，以及掌握 build.gradle 中各种配置项的作用。</p>
<h3 id="6-再写个-Gradle-脚本干活去，解放双手"><a href="#6-再写个-Gradle-脚本干活去，解放双手" class="headerlink" title="6. 再写个 Gradle 脚本干活去，解放双手"></a>6. 再写个 Gradle 脚本干活去，解放双手</h3><p>基于前面所学到的 Gradle 的基础知识，本篇就可以来应用到一些具体场景中，比如通过写 Gradle 脚本来做一些重复性，手工性的工作。</p>
<p>那么脚本所涉及到的工作，大概就是文件的遍历工作，java 命令的执行，以及字符串的处理。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Gradle 系列的相关博客就暂时到此告一段落了，虽然仍然还有一部分知识没涉及到，比如如何自定义 Gradle 插件等等，由于没有相关方面的需求，等待后续有接触时再来继续补充。</p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记--Android Gradle权威指南（下）</title>
    <url>/2018/05/25/Gradle/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--Android-Gradle%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近看了一本书《Android Gradle 权威指南》，收获挺多，就想着来记录一些读书笔记，方便后续查阅。</p>
<p>本篇内容是基于上一篇：<a href="https://www.jianshu.com/p/718b4927f425" target="_blank" rel="noopener">读书笔记–Android Gradle权威指南（上）</a>  </p>
<p>上一篇中我们讲了：  </p>
<blockquote>
<ol>
<li><p>Groovy 基础</p>
</li>
<li><p>Android 项目中的 Gradle<br>2.1 gradle/wrapper 目录<br>2.2 gradlew.bat 文件<br>2.3 setting.gradle 文件<br>2.4 build.gradle 文</p>
</li>
<li><p>Gradle 基础<br>3.1 task 概念<br>3.2 gradle 插件概念</p>
</li>
<li><p>区分 Gradle 和 Android Gradle</p>
</li>
</ol>
</blockquote>
<p>在上一篇中，我们了解了 Android 项目中每个 gradle 文件的作用是什么，以及 Gradle 和 Android Gradle 插件的区别，也清楚了为什么有时候打开 Github 上的项目时会一直处于构建中，也知道了如何去解决。</p>
<p>那么，本篇，我们继续往下来学习，build.gradle 文件里各个配置项的作用，以及如何用 Gradle 来写脚本帮助我们做一些重复性的手工工作。</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h3 id="5-build-gradle-代码"><a href="#5-build-gradle-代码" class="headerlink" title="5.build.gradle 代码"></a>5.build.gradle 代码</h3><h4 id="5-1-apply-plugin-39-com-android-application-39"><a href="#5-1-apply-plugin-39-com-android-application-39" class="headerlink" title="5.1 apply plugin: &#39;com.android.application&#39;"></a>5.1 <code>apply plugin: &#39;com.android.application&#39;</code></h4><p>apply 是 Gradle 的一个方法，接收 map 类型的参数，map 的 key 值可以有三种：from, plugin, to</p>
<p><code>com.android.application</code> 是 Android Gradle 插件中提供的一个唯一指向某个 Plugin 的 id。在 2.3.3 版本的 Android Gradle 插件中，这个 id 指向的类为 AppPlugin</p>
<p><code>apply plugin</code> 意思是为当前项目的构建应用一个 Gradle 插件，至于应用哪个插件，可以通过指定一个唯一的 id 值即可，也可以直接指定插件类的类名，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//apply plugin: &apos;com.android.application&apos;</span><br><span class="line">//等效于</span><br><span class="line">//apply plugin: com.android.build.gradle.AppPlugin  </span><br><span class="line"></span><br><span class="line">//同理</span><br><span class="line">//apply plugin: &apos;com.android.library&apos;</span><br><span class="line">//等效于</span><br><span class="line">//apply plugin: com.android.build.gradle.LibraryPlugin</span><br></pre></td></tr></table></figure>

<p>上述代码中两种方式是等效的，因为 Android Gradle 插件已经通过一份配置文件，将这两者绑定在一起，使用者不清楚具体要用哪个插件类的话，那么可以直接使用跟它对应的 id 值即可，而且通过 id 值的方式也会更方便。</p>
<p><strong>那么，为什么构建 Android 项目时都需要在 build.gradle 开头声明这么一句 <code>apply plugin</code> 应用某个插件呢？</strong>  </p>
<p>上一篇中已经提到过了，本篇继续提一下。这之前，需要区分 Gradle 跟 Android Gradle 是两种概念，两个东西。</p>
<p>Android Studio 是采用 Gradle 来构建项目，而 Gradle 并不是为了构建 Android 项目而设计的，它也可以构建 C++ 项目等等，因此，Gradle 它只提供了构建项目的一些基本工作，如配置依赖库等等。</p>
<p>但 Gradle 扩展性很好，它提供了插件的概念，可以根据需要自行去扩展一些构建工作。</p>
<p>因此，Google 基于 Gradle 提供的插件接口，开发了一套 Android Gradle 插件，就是专门用来构建 Android 项目。</p>
<p>build.gradle 文件里的 <code>android {}</code> 代码块配置，就是 Android Gradle 插件提供的，而 <code>dependencies {}</code> 代码块配置则是 Gradle 原生就提供的了。</p>
<p>所以，如果开头不通过 <code>apply plugin</code> 声明需要应用 Android Gradle 的插件，而 build.gradle 里又使用到了 Gradle 没有提供的 <code>android {}</code> 配置，当然就会出错了。</p>
<p>当然，不仅仅是这点，构建 Android 项目过程中的很多工作，都是 Gradle 原生没有提供，都需要借助 Google 开发的 Android Gradle 插件。</p>
<h4 id="5-2-android"><a href="#5-2-android" class="headerlink" title="5.2 android {}"></a>5.2 android {}</h4><p><strong>官方文档：</strong><a href="http://google.github.io/android-gradle-dsl/current/" target="_blank" rel="noopener">http://google.github.io/android-gradle-dsl/current/</a></p>
<p>不同的项目构建时，所需的配置可能不同，那么，设置这些配置项的入口就在 <code>android {}</code> 代码块中，一些必配项，在新建项目时，build.gradle 就已经自动生成了。当然，它还提供了很多可选的配置项，具体都有哪些，可以在官方文档中找，也可以直接看源码，还可以去网上搜索大神的博客。  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-fbde13f42d6e2b2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="官方文档.png">  </p>
<p>上图只截了一部分，官方文档肯定是最全的了，建议还是官方文档里查阅，至于源码方面，也许可以找到一些隐藏配置，也是一个好的选择，com.android.application 插件对应的 android {} 配置的源码是 AppExtension。</p>
<h4 id="5-3-buildTypes"><a href="#5-3-buildTypes" class="headerlink" title="5.3 buildTypes {}"></a>5.3 buildTypes {}</h4><p>这个是配置什么的呢，其实它最后的效果跟 productFlavors 很像，都是用于根据不同的配置需求，打不同的 apk 包。</p>
<p>但用官方文档里的话来说，这个是专门给<strong>开发人员用于在软件开发的整个周期内根据不同的阶段来配置不同属性，打相对应阶段的 apk 包的</strong>。</p>
<p>说得白点，一个产品从开发到上线过程中，最起码需要经过开发、测试、上线三个阶段。那么，在前两个阶段可以打一些 debug 包，这个 debug 包可以不用正式签名，可以携带一些调试日志，可以使用一些三方检测工具如内存泄漏等等。但等到要上线了，那么就应该打个 release 包，在 debug 包中的配置在这个阶段就可以都关掉了。</p>
<p>当然，在这里，除了配置我们很熟悉的 debug 和 release 两种，还可以根据需要配置类型像 prerelease 预发布等等类型。</p>
<h4 id="5-4-productFlavors"><a href="#5-4-productFlavors" class="headerlink" title="5.4 productFlavors {}"></a>5.4 productFlavors {}</h4><p>这个配置的作用跟 buildTypes 很类似，但它是从产品角度出发来设置不同的配置。</p>
<p><strong>不同的渠道可能需要不一样的 Logo，不一样的包名，不一样的资源文件，不一样的功能模块等等，那么就可以通过这里来配置</strong>。</p>
<p>之所以提了 buildTypes 和 productFlavors 这两个，是因为想来讲讲，最终打包的时候，总类型的包一共是：buildTypes * productFlavors </p>
<p>比如在 buildTypes 中定义了 debug 和 release 两种类型，在 productFlavors 中定义了 google，baidu 两种类型，那么打出来的包一共有：google_debug，google_release，baidu_debug，baidu_release，共四个类型的包。但这是通常情况下的配置，如果在 productFlavors 中使用了 dimension 的话，那又是另外一种方式了。</p>
<h4 id="5-5-flavorDimensions"><a href="#5-5-flavorDimensions" class="headerlink" title="5.5 flavorDimensions"></a>5.5 flavorDimensions</h4><p>这个是用于将 productFlavors 划分维度的，比如我们打包时不仅需要多个渠道，每个渠道还分收费版、免费版。那么此时，传统的方法就是在 productFlavors 里对每个渠道分别去配置，比如 :  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        googleFree &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        googleVip &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，这种有多维度需求时，如果还是用常规的方式，将会特别麻烦，这种场景下就可以使用 flavorDimensions 来实现了，这个需要跟 dimension 一起使用，如：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">	flavorDimensions &apos;channel&apos;, &apos;pay&apos;</span><br><span class="line">	productFlavors &#123;</span><br><span class="line">    	google &#123;</span><br><span class="line">            dimension &apos;channel&apos;</span><br><span class="line">    	&#125; </span><br><span class="line">		build &#123;</span><br><span class="line">            dimension &apos;channel&apos;</span><br><span class="line">		&#125;   </span><br><span class="line">		free &#123;</span><br><span class="line">            dimension &apos;pay&apos;</span><br><span class="line">		&#125;</span><br><span class="line">		vip &#123;</span><br><span class="line">            dimension &apos;pay&apos;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子中，划分了两个维度：渠道和收费模式，那么这时候打包的时候就是根据 channel + pay + buildTypes。</p>
<p>比如会有 google-free-debug，google-free-release，google-vip-debug，baidu-vip-release 等等。</p>
<p>如果还是用传统方式，那么在 productFlavors 就需要对每个渠道增加 free 和 vip 两种类型了，那么当渠道很多时就特别麻烦了。 </p>
<h4 id="5-6-applicationVariants"><a href="#5-6-applicationVariants" class="headerlink" title="5.6 applicationVariants"></a>5.6 applicationVariants</h4><p><img src="https://upload-images.jianshu.io/upload_images/1924341-36ab19575704812c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="applicationVariant.png">  </p>
<p>通过这个可以拿到最后要打包时的所有类型，然后可以获取到各种配置信息，或者修改各种配置信息。</p>
<p>比如说通过 buildTypes 和 productFlavors 一共配置了 4 种 apk 包类型，那么我们全都可以在这边拿到，要遍历它的话，需要使用 .all {} 方式，那么具体有哪些信息可以拿到呢，可以直接看源码，也可以借助 AS 左侧的 Structure 面板中查看：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a26d055eda038c73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="structure面板.png">  </p>
<p>比如可以拿到 applicationId 包名，拿到 buidlType 类型等等，我们经常会去修改 apk 生成时的命名规则，其实就是通过这个拿到它的 outputs 属性，它是个 List 列表，所以可以通过 .each {} 来遍历，达到自定义 apk 文件的命名格式。</p>
<p>再比如可以通过 mergedFlavor 来拿到 manifest 文件中的一些数据，向占位符输入数据啊等等。</p>
<h4 id="5-7-buildToolsVersion"><a href="#5-7-buildToolsVersion" class="headerlink" title="5.7 buildToolsVersion"></a>5.7 buildToolsVersion</h4><p>这个是用来配置要使用哪个版本的 Android 构建工具。</p>
<p>也许你会有这种疑问，前面都已经配置了 Gradle 的版本，还配置了 Android Gradle 插件的版本了，为什么还要配置一个 Android 构建工具的版本，这个工具又是个什么鬼，为什么需要配置这么多，一个 Gradle 不够么？  </p>
<p>Gradle 和 Android Gradle 插件的区别和概念前面已经反复提过了，而至于为什么要配置 buildToolsVersion？</p>
<p>理解这点，需要清楚一点，即使不使用 Gradle，也有其他办法来构建 Android 项目，像早期 Eclipse 使用 Ant 来构建一样。就算也不使用 Ant，也还是可以自己通过 Google 提供的工具来构建，只是这个过程特别繁琐，而构建一个 Android 项目所需的一些工具，Google 都提供在 SDK 中了。</p>
<p>那么，Android Gradle 插件其实本质上也就是通过使用 SDK 中的工具来构建项目，所以对这三者可以这么理解，<strong>Google 基于 Gradle 提供的插件接口自己开发了一套 Android Gradle 插件来扩展一些构建工作，而这些构建工作使用到了 SDK 中的构建工具</strong>，因此一个 AS 项目，才会需要你配置 Gradle 版本，Android Gradle 插件版本，以及 buildToolsVersion。</p>
<h4 id="5-8-其他"><a href="#5-8-其他" class="headerlink" title="5.8 其他"></a>5.8 其他</h4><ul>
<li><p><strong>adbExecutable</strong>：获取 adb.exe 路径，写脚本的时候可以用</p>
</li>
<li><p><strong>useLibrary</strong>：使用共享库，因为高版本的 Android 可能会移除一些库，比如 API 23 之后就将 HttpClient 库移除掉了，这些在高版本被移除掉的库，如果还想再使用，就可以使用 useLibrary 来配置。如：  </p>
<p><code>useLibrary &#39;org.apache.http.legacy&#39;</code>  </p>
<p>另外，官方建议说，即使在 build.gradle 配置了这个，最好也还是在 AndroidManifest.xml 中也配置一下，防止意外。</p>
</li>
<li><p><strong>applicationId</strong>：配置包名，没配置的话，默认使用 AndroidManifest.xml 文件中指定的包名。</p>
</li>
<li><p><strong>applicationIdSuffix</strong>：配置包名的后缀，使用场景通常是在 debug 中配置，这样 debug 包和 release 包都可以安装在同一台设备上。</p>
</li>
<li><p><strong>flavorDimensionList</strong>：获取通过 flavorDimensions 声明的多维度的 productFlavors 信息</p>
</li>
<li><p><strong>buildConfigField</strong>：动态配置 BuildConfig 类的常量，这个方法接收三个参数，全是 String 类型，各个参数含义为：type, key, value，示例：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildConfigField &apos;String&apos;, &apos;weixin&apos;, &apos;&quot;dasuAndroidTv&quot;&apos;</span><br><span class="line">buildConfigField &apos;boolean&apos;, &apos;enable&apos;, &apos;false&apos;</span><br></pre></td></tr></table></figure>

<p>注意，BuildConfig 里生成的常量的类型，变量名，以及属性值，三者全部是根据这三个参数来生成的，所以如果配置 String 类型时，需要特别注意第三个参数。</p>
</li>
<li><p><strong>resValue</strong>：这是 productFlavors 或 buildTypes 里的方法，用法跟 buildConfigField 一模一样，区别仅仅是 buildConfigField 是在 BuildConfig 中生成常量，而 resValue 是在 res/value.xml 中生成对应的字符串资源。</p>
<p>场景也很多，比如对于同一个控件，在不同渠道上要显示不同的文案，在代码里实现的话，就需要用很多判断逻辑，但如果是直接在 build.gradle 中通过 resValue 来配置的话，那么代码中就完全不用去管渠道问题，它只需要用即可，至于具体是什么文案，交由 resValue 来动态配置。</p>
</li>
</ul>
<h3 id="6-Gradle-各种技巧"><a href="#6-Gradle-各种技巧" class="headerlink" title="6. Gradle 各种技巧"></a>6. Gradle 各种技巧</h3><h4 id="6-1-批量修改生成的-apk-文件名"><a href="#6-1-批量修改生成的-apk-文件名" class="headerlink" title="6.1 批量修改生成的 apk 文件名"></a>6.1 批量修改生成的 apk 文件名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">	variant.outputs.each &#123; output -&gt;</span><br><span class="line">		def outputFile = output.outputFile</span><br><span class="line">		if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) &#123;</span><br><span class="line">			//def fileName = &quot;自定义命名规则&quot;</span><br><span class="line">			output.outputFile = new File(outputFile.parent, fileName)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-System-getenv"><a href="#6-2-System-getenv" class="headerlink" title="6.2 System.getenv()"></a>6.2 System.getenv()</h4><p>通过这个可以获取到系统的环境变量，所以可以结合这个来将一些工作放在特定服务器上做。</p>
<p>通常都会有一个专门用来自动化打包的服务器，那么我们可以将一些检查工作，如果 Lint 检查，单元测试等等之类的工作放于服务器上执行，因为这类工作通常比较耗时，而且我们本地开发时经常需要调试，打包，也没必要每次都去开启  Lint 检查。</p>
<p>那么在 build.gradle 中就可以结合这个方法，然后在服务器上配置一个特定的环境变量，当检查到当前打包环境在服务器上时，就可以去触发这些本地开发过程中较耗时的构建工作了，尤其打包服务器还可以将这些 Lint 检查，单元测试工作的结果通过邮件发送给开发人员。</p>
<h4 id="6-3-动态配置-AndroidManifest-xml-文件"><a href="#6-3-动态配置-AndroidManifest-xml-文件" class="headerlink" title="6.3 动态配置 AndroidManifest.xml 文件"></a>6.3 动态配置 AndroidManifest.xml 文件</h4><p>先在 AndroidManifext.xml 中设置占位符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta-data android:value=&quot;$&#123;CHANNEL&#125;&quot; android:name=&quot;CHANNEL&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>然后在 build.gradle 中的 productFlavors 中通过 manifestPlaceholders 来改变 manifest 里的占位符：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        google &#123;</span><br><span class="line">            mainfestPlaceholders.put(&quot;CHANNEL&quot;, &quot;google&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种使用场景还可以用于根据不同渠道动态控制不同的权限</p>
<h4 id="6-4-美团黑科技式多渠道打包"><a href="#6-4-美团黑科技式多渠道打包" class="headerlink" title="6.4 美团黑科技式多渠道打包"></a>6.4 美团黑科技式多渠道打包</h4><p><a href="https://github.com/GavinCT/AndroidMultiChannelBuildTool" target="_blank" rel="noopener">https://github.com/GavinCT/AndroidMultiChannelBuildTool</a>  </p>
<p><a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="noopener">http://tech.meituan.com/mt-apk-packaging.html</a></p>
<h4 id="6-5-Gradle-性能检测"><a href="#6-5-Gradle-性能检测" class="headerlink" title="6.5 Gradle 性能检测"></a>6.5 Gradle 性能检测</h4><p><strong>命令</strong>：<code>gradlew build -profile</code>  </p>
<p>在项目根目录下执行完该命令后，就可以在 build/report 下找到生成的报告文件：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-e72d98c0987cee73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="性能报告.png">  </p>
<p>在这份报告中，可以看到每个步骤，每个 task 的耗时，那么也就可以针对性的去优化这个构建过程，比如将一些没必要的 task 关闭掉，如 lint 检查，在 debug 过程中不断的打包、调试过程中也许没必要开启这个。</p>
<p>另外，所有的命令只要后面加上 <code>-profile</code> 即可生成报告文件，如 <code>gradlew assemble -profile</code>。</p>
<h4 id="6-6-关闭指定-task"><a href="#6-6-关闭指定-task" class="headerlink" title="6.6 关闭指定 task"></a>6.6 关闭指定 task</h4><p><strong>方式一</strong>：<code>gradlew build -x lint</code>，增加参数 -x，后面跟着要关闭的 task 即可。</p>
<p><strong>方式二</strong>： <code>project.gradle.startParameter.excludedTaskNames.add(&#39;lint&#39;)</code>，在 build.gradle 中增加这行代码</p>
<h3 id="7-gradle-脚本"><a href="#7-gradle-脚本" class="headerlink" title="7. gradle 脚本"></a>7. gradle 脚本</h3><p><strong>命令：</strong><code>apply from: &#39;xxx.gradle&#39;</code>  </p>
<p><strong>解释：</strong><code>apply from</code> 是应用脚本插件，该脚本可以是本地的脚本，也可以是网络上的脚本，本地脚本时，from 后面填写脚本的相对路径名称即可，如果脚本文件跟 build.gradle 在同一层级，直接写脚本文件名即可。</p>
<p>如果是使用网络上的脚本，那么 from 后面填写该网络脚本的 url 地址即可。</p>
<p><strong>执行：</strong>在项目里应用了一个脚本插件的时候，其实脚本里的代码就被运行了，而 Gradle 有一个 task 的概念，代码里是没办法直接触发某个 task 的执行的，但可以设置各个 task 之间的前后依赖关系。也就是说，脚本中 task 里 doLast{} 代码块里的工作需要外部去触发才会运行，那么这些工作该如何执行呢？两种方式：</p>
<ul>
<li>命令行方式执行：在根目录下，借助 gradlew.bat 文件，执行在终端执行 <code>gradlew task名</code> 即可。</li>
<li>Android Studio 图形界面操作方式：在 AS 右侧的 Gradle 面板里找到脚本中的 task，点击即可运行，这种方式最好给 task 设置 group 属性，这样可以非常方便寻找。</li>
</ul>
<p><strong>实例：</strong>可参考之前写的一篇博客：<a href="https://www.jianshu.com/p/36ecd23191d2" target="_blank" rel="noopener">再写个Gradle脚本干活去，解放双手</a>  </p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>整本书介绍的内容确实不错，即使写了两篇笔记，但记录的也仅仅是平常比较常接触的一些知识点，还有一部分内容并没有去深入，比如：  </p>
<ul>
<li>自定义 Gradle 插件</li>
<li>Lint 检查配置，单元测试配置</li>
<li>…  </li>
</ul>
<p>因为并没有这方面的需求，后续如果有再继续接触，再来慢慢补充。</p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记--Android Gradle权威指南（上）</title>
    <url>/2018/05/24/Gradle/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--Android-Gradle%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>最近看了一本书《Android Gradle 权威指南》，对于 Gradle 理解又更深了，但不想过段时间就又忘光了，所以打算写一篇读书笔记，将书中一些我个人觉得蛮有用的点记录、总结一下。  </p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先，先来过一下整书的目录章节，先大概清楚整本书都介绍了哪些知识点：  </p>
<blockquote>
<p>第 1 章    Gradle 入门</p>
<p>第 2 章    Groovy 基础</p>
<p>第 3 章    Gradle 构建脚本基础</p>
<p>第 4 章    Gradle 任务</p>
<p>第 5 章    Gradle 插件</p>
<p>第 6 章    Java Gradle 插件</p>
<p>第 7 章    Android Gradle 插件</p>
<p>第 8 章    自定义 Android Gradle 工程</p>
<p>第 9 章    Android Gradle 高级自定义</p>
<p>第 10 章  Android Gradle 多项目构建</p>
<p>第 11 章  Android Gradle 多渠道构建</p>
<p>第 12 章  Android Gradle 测试</p>
<p>第 13 章  Android Gradle NDK 支持</p>
<p>第 14 章  Android Gradle 持续集成  </p>
</blockquote>
<p>整本书介绍的内容很全，从 Gradle 的环境配置 –&gt; Groovy 介绍 –&gt; 讲解项目中常见 gradle 文件作用 （setting.gradle, build.gradle） –&gt; 详细讲解 build.gradle 文件内每行代码的含义 –&gt; 各种高级自定义使用。  </p>
<p>看完这本书，对于掌握项目中的 build.gradle 文件应该就不成问题了，虽然将整本书过了一遍，但其实我也只是着重挑了一些自己感兴趣的章节深入阅读，所以就来记录一下，方便后续查阅吧。  </p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h3 id="1-Groovy-基础"><a href="#1-Groovy-基础" class="headerlink" title="1. Groovy 基础"></a>1. Groovy 基础</h3><p>首先清楚一点，Gradle 是基于 Groovy 语言的，他们之间的关系就像《Android 群英传：神兵利器》中说的：  </p>
<blockquote>
<p>Groovy 对于 Gradle，就好比 Java 对于 Android</p>
</blockquote>
<p>所以，了解一些 Groovy，对于学习 Gradle 来说，肯定是有所帮助的。</p>
<p>关于这方面内容，我之前写过一篇博客：<a href="https://www.jianshu.com/p/501726c979b1" target="_blank" rel="noopener">学点Groovy来理解build.gradle代码</a>  </p>
<p>所以，这里不会再去介绍，但有几个点可以提一下，如果你都还不怎么熟悉，那么可以点开链接去看看：  </p>
<ul>
<li>Groovy 中支持用 <code>&#39;xxx&#39;</code>,<code>&quot;xxx&quot;</code>,<code>&#39;&#39;&#39;xxx&#39;&#39;&#39;</code>,<code>/xxx/</code> 等多种方式来定义字符串，所以如果在 build.gradle 里看到既有单引号又有双引号定义的字符串时，不用去疑惑他们到底是不是字符串。</li>
<li>Groovy 中的方法支持省略括号，也就是说，在 build.gradle 中一行行的代码，大部分都是在调用某个方法。</li>
<li>Groovy 中有一种特性叫闭包，说白点也就是代码块，支持作为方法参数，结合方法括号省略的特点，在 build.gradle 里 defauleConfig {} 代码块之类的其实也都是在调用一个个方法。</li>
</ul>
<h3 id="2-Android-项目中的-Gradle"><a href="#2-Android-项目中的-Gradle" class="headerlink" title="2. Android 项目中的 Gradle"></a>2. Android 项目中的 Gradle</h3><p><img src="https://upload-images.jianshu.io/upload_images/1924341-820acc755f44474b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构.png">  </p>
<p>新建一个项目时，Android Studio 会自动生成项目的初步结构，这通常会携带一些 gradle 相关的文件，这一节就来学学，各个 gradle 文件都有什么作用</p>
<h4 id="2-1-gradle-wrapper-目录"><a href="#2-1-gradle-wrapper-目录" class="headerlink" title="2.1 gradle/wrapper 目录"></a>2.1 gradle/wrapper 目录</h4><p>就像我们要开发 Java 程序，本地需要配置 JDK 环境，要开发 Android 程序，需要配置 SDK 一样，想要借助 Gradle 来构建项目，那么按理说本地也需要配置相关的 Gradle 环境才对。  </p>
<p>而我们之所以可以省掉这一步，就是 gradle/wrapper 这个目录下的文件的作用了，可以先看看 gradle-wrapper.properties 这个文件的内容：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">#Thu May 24 10:30:42 CST 2018</span><br><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br><span class="line">distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-3.3-all.zip</span></span><br></pre></td></tr></table></figure>

<p>内容无非就是一些配置项，而最重要的就是最后一句，指明了当前这个项目要使用哪个版本的 Gradle 来构建，我们在 Android Studio 的 File -&gt; Project Structure -&gt; Project 里配置的 Gradle Version，最终改变的其实就是上述文件里最后一行的 Gradle 版本属性值  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-ae9ad09aa95697e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AS的Gradle版本配置.png">  </p>
<p>官方说了，提供了 gradle/wrapper 这种方式，可以让你特别灵活的进行配置，想换个 Gradle 版本来构建项目，只需要修改这个配置文件的 Gradle 版本属性值即可，当然也可以直接通过 AS 提供的 UI 界面操作，结果都一样。</p>
<p>由于 Gradle 更新换代特别快，而且新的大版本经常都会提供很多新特性，这就导致了在 clone Github 上一些开源项目到本地构建时经常有报错的问题，本质原因就是因为它使用的 Gradle 版本跟你本地不一样，而由于有堵巨墙的原因，导致一直没法成功下载它配置的 Gradle 版本，进而就无法构建项目，而报错了。</p>
<p>网上说的一些解决方案是让你手动去修改 gradle-wrapper.properties 文件里的 Gradle 版本，改成你本地的版本，但我觉得这种方法不一定适用，这取决于那个项目中是否有用到一些新特性，以及你本地的 Gradle 版本是否兼容项目中用到的 Gradle 新特性。</p>
<p>通常来说，如果你本地的 Gradle 比克隆的项目的 Gradle 版本高的话，那么这种直接修改项目的 Gradle 版本方式应该是可行的，那么怎么知道你本地都有哪些 Gradle 版本呢：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-d59f514024c18aa2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地Gradle版本.png">  </p>
<p>默认在 C 盘， C:\Users\suxq\ .gradle 目录下有 Android Studio 自动帮你下载的 Gradle 的各个版本，只要你在 gradle-wrapper.properties 修改了 Gradle 的版本号，那么当你在构建项目时，就会先到你电脑的这个路径下查找相对应版本的 Gradle，如果可用，则直接进行构建项目任务，如果不存在，那么就会自动去下载对应版本的 Gradle。</p>
<p>最后，还有个问题，怎么确定都有哪些 Gradle 版本可用呢？如果想要自己去下载，不借助 Android Studio 可行么？  </p>
<p>当然可以，去官网找到对应版本点击下载即可：<a href="http://services.gradle.org/distributions/" target="_blank" rel="noopener">http://services.gradle.org/distributions/</a>  </p>
<p>下载完成之后，将文件放到上面介绍的 C 盘下的 .gradle 文件里相对应版本的目录下即可。</p>
<p>如果你有自己去尝试下载，你就会体验到，下载速度是有多么的龟速，90M 左右的文件硬是要下载个把小时。同样的道理，你自己下载这么慢，那通过 Android Studio 下载的速度也同样这么慢，两者唯一的区别就只是在于你自己下载时你可以看到速度和进度。</p>
<p>这样一来的话，<strong>明白为什么有时候打开新项目或者打开 Github 上的项目时，Android Studio 会一直卡在构建中的原因了吧？</strong>  </p>
<p>因为这个项目用到了你本地没有的 Gradle 版本，所以 Android Studio 自动去下载了，但由于都懂的原因，下载速度贼慢，因此网上才有一些博客教你说让你要去翻墙，明白为什么了吧。</p>
<p>另外，网上还有一些博客会让你不管它，让你等隔天再去打开这个项目，然后有时候你会发现，隔天打开竟然能正常构建项目了，莫名其妙的就好了，就不一直卡在构建中了。这是由于 Android Studio 会有一个后台构建的功能，也就是说它可以在背后默默的帮你自动去下载 Gradle，虽然速度贼慢，但总有下载完成的时候，当你隔天再去打开这个新项目时，如果已经下载好了，那自然就可以正常构建使用了。</p>
<h4 id="2-2-gradlew-bat-文件"><a href="#2-2-gradlew-bat-文件" class="headerlink" title="2.2 gradlew.bat 文件"></a>2.2 gradlew.bat 文件</h4><p>gradlew 文件和 gradlew.bat 文件，两份没有什么差别，它们都是脚本文件，区别只是一个是 shell 脚本，一个是批处理脚本，那么自然一个是用来在 Linux 上运行，一个在 Windows 上运行。</p>
<p>感兴趣的可以去看看这份脚本代码，其中比较关键的代码：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar</span><br><span class="line"></span><br><span class="line">@rem Execute Gradle</span><br><span class="line">"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%</span><br></pre></td></tr></table></figure>

<p>大概翻译一下，它借助了 gradle/wrapper 目录下的 gradle-wrapper.jar 文件，并借助了 java 命令，提供了可让我们直接以命令行形式运行一些相应的 gradle 指令，而这些指令在 gradle-wrapper.jar 文件中都提供了相应的实现。</p>
<p>比如：  <code>gradlew -version</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-fb005f14ea7ea957.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradlew命令示例2.png">  </p>
<p>直接在 Android Studio 的 Terminal 面板运行 <code>gradlew -version</code> 命令，或者在 Dos 窗口，进到项目的根目录下执行该命令，都可以，前者只是打开时就默认将项目根目录作为当前路径了。</p>
<p>这也是为什么一些资料说，如果没有配置 Gradle 环境，那么在每个项目根目录下也可以运行 gradle 命令的原因，因为每个项目都提供了 gradlew.bat 脚本以及 gradle/wrapper 目录下的 gradle-wrapper.jar 文件支持。你可以试一下，删掉两者中任意一个，就没法正常运行 gradle 命令了。  </p>
<p><strong>那么，提供了脚本文件来支持直接运行 gradle 命令有什么用呢？</strong>  </p>
<p>用处可多了，我们在构建项目时，基本都是直接借助 Android Studio 的图形界面来操作，点一点就可以了。但有时候，经常会遇见一些构建失败的情况，然后日志中经常会给我们这么一段提示：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-b28003535c5f8c9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle构建失败日志.png">  </p>
<p>如果想查看更多的日志信息，需要在执行命令的时候加上一些参数，而这种时候就需要通过命令行的形式来了，那么这时脚本文件也就派上用场了：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6ee813b372aff2bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle命令带参数示例.png">  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-1488e157b01b210c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle命令异常栈.png">   </p>
<p>这样一来就可以看到更多的日志信息了，当然我举的这个例子不好，因为可以直接看出问题出在哪了，不需要再去获取更多的辅助信息来定位了。</p>
<p>但有些时候，Gradle 构建时确实就是失败了，然后给的信息又少，让人莫名其妙，不知道为啥失败了，这种时候就可以借助命令行形式来执行这个 task，然后添加一些参数来获取更多的辅助日志。至于要添加哪些参数，执行什么命令，通常情况下，Gradle 构建失败时都会给出建议，跟着来就可以了。</p>
<h4 id="2-3-setting-gradle-文件"><a href="#2-3-setting-gradle-文件" class="headerlink" title="2.3 setting.gradle 文件"></a>2.3 setting.gradle 文件</h4><p>setting.gradle 文件通常是当项目涉及到多 Module 的场景。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-2225e33a5c04870c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setting示例.png">  </p>
<p>只有在 setting.gradle 中 include 的 Module，才会被加入构建中，也就是说，如果一个项目文件夹内，包含了很多子工程，但如果没在 setting.gradle 中将这些子工程 include 进来的话， 这些 Module 是不会参与进构建的。</p>
<p>另外，如果子工程的这些 Module 都直接放在了项目根目录中，那么 setting.gradle 中只需要写 include 就可以了，那如果这些子工程是放在别的地方，那么也可以通过修改 project().projectDir 来指定子工程的具体路径，也就是说，所有的 Module 并不一定需要全部集中放在同一个项目内。 </p>
<h4 id="2-4-build-gradle-文件"><a href="#2-4-build-gradle-文件" class="headerlink" title="2.4 build.gradle 文件"></a>2.4 build.gradle 文件</h4><p>一个项目中可能存在多个子工程，每个子工程构建都应该是相互独立的，也就是说，每个子工程都可以根据自己的需要，配置各种依赖，插件等。那么，Gradle 是如何分开来管理每个子工程的构建任务的呢？  </p>
<p>这就是 build.gradle 文件的作用了，所以你会发现，每个子工程，也就是每个 Module 都会有一个 build.gradle 文件，Gradle 就是以这个文件为根据来构建这个 Module。</p>
<p>那么，如果有些配置项，在所有的子工程中都是一致的话，如果在每个子工程里都去重复粘贴的话，当这个共同的配置项需要发生变化时，维护起来会非常麻烦，这也就是为什么根目录下面还会有一个 build.gradle 文件。</p>
<p>根目录下的这个 build.gradle 是统筹全局的，在这里，你可以配置一些所有工程共同的配置项，比如 Android Gradle 的版本，依赖库的仓库地址这些所有工程的共同配置项。</p>
<p>也就是说，其实将根目录下的 build.gradle 文件里的内容移到每一个工程下的 build.gradle 里，也是可行的。但没必要这样做，吃饱了撑着。</p>
<h3 id="3-Gradle-基础"><a href="#3-Gradle-基础" class="headerlink" title="3. Gradle 基础"></a>3. Gradle 基础</h3><h4 id="3-1-task-概念"><a href="#3-1-task-概念" class="headerlink" title="3.1 task 概念"></a>3.1 task 概念</h4><p>task 是 Gradle 中的一种概念，引用书中的解释：  </p>
<blockquote>
<p> 一个 task 其实就是一个操作，一个原子性的操作，比如打个 jar 包，复制一份文件，编译一次 Java 代码，上传一个 jar 到 Maven 中心库等，这就是一个 Task，和 Ant 里的 Target， Maven 中的 goal 是一样的。  </p>
</blockquote>
<p>有点类似于 Java 里面的类，但又有很多不同之处。我们要通过 Java 命令来执行某个 java 文件，那么至少需要一个类，类里面需要有 main 方法，这个 java 文件才能运行起来。</p>
<p>同样，要通过 gradle 命令来执行某个构建任务，那么至少需要一个 task，这个构建任务才能跑起来。</p>
<p>但更多的是不同的概念，多个类之间可以有相互依赖的关系，类中持有另一个类的引用等等。</p>
<p>但在 task 方面，多个 task 之间只能有前后依赖关系，即某个 task 的运行是否需要哪个 task 先运行的基础上才允许，也就是说，在 Gradle 的构建工作过程中，多个 task 是构成一条直线的，一个个 task 按顺序的去工作，而不存在某个 task 工作到一半时去调用另一个 task。  </p>
<p>不过，通常情况下，我们并不需要去接触到 task 层面，build.gradle 文件里的代码大多都只是在调用各种方法进行各种配置，而最后，会根据这份文件生成很多 task，比如：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-abac23c1724b329e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Gradle面板.png">  </p>
<p>在 Android Studio 右侧的 Gradle 的面板这边，就是一个个的 task，assemble 是一个 task，build 也是一个 task，很多 task 是 Gradle 已经提供的，而有些 task 则是根据 build.gradle 里面的配置项自动生成的，比如 assembleDebug 这一类。</p>
<p>要执行 task 的方式，可以通过 AS 的图形界面点一点即可，也可以通过命令行方式，由于根目录提供了 gradlew 脚本文件，因此可以在根目录下执行 <code>gradlew task名</code> 即可。</p>
<h4 id="3-2-gradle-插件概念"><a href="#3-2-gradle-插件概念" class="headerlink" title="3.2 gradle 插件概念"></a>3.2 gradle 插件概念</h4><p>Gradle 是用来构建项目的，但并不是说只能用于构建 Android 的项目，Java 的也行，C++ 的也行，很多很多。</p>
<p>那如果我只是做 Android 开发，我也就只需要 Gradle 构建 Android 项目的功能即可，其他的又不需要，鉴于此，Gradle 封装好了基本的构建工作，然后提供了插件的接口，支持根据各自需要去扩展相应的构建任务。</p>
<p>以上就是我对于 Gradle 插件概念的理解，我认为它是用于给大伙可以根据需要自行去扩展。</p>
<p>就拿 Android 项目来说，来看一份 build.gradle 文件结构：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有点击方法进去看过源码的话，你会发现：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-0c5957cb23efc34c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dependencies.png">  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6ab837803546b7d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="androidGradle.png">  </p>
<p>发现没有，dependencies 是 Gradle 提供的方法，但 android，defaultConfig 却都是 Android Gradle 插件提供的方法了。</p>
<p>也就是说，其实 Gradle 只提供了构建项目的一些基本功能，如配置依赖库，不管什么项目都需要。但像 android {} 代码块里的配置项，很明显，就只有 Android 项目才需要用到了，所以这些配置并不是由 Gradle 来提供的，而是由 Android Gradle 插件提供的，这也就是为什么在根目录的 build.gradle 文件里会有这么一行代码：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.3.3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>com.android.tools.build:gradle:2.3.3</code> 这行代码其实就是声明了我们的项目还需要使用 Android Gradle 插件，版本号为 2.3.3，而插件的下载地址在 jecnter() 仓库。 </p>
<p>所以，得搞清楚，Gradle 和 Android Gradle 是两种概念，也是两个不同的东西，如果有人问说你项目构建的 Gradle 的版本是多少，得搞清楚，他想问的是 Gradle，还是 Android Gradle 插件。</p>
<p>但是我们在根目录的 build.gradle 里是可以配置多个插件的，比如如果有使用 GreenDao，或者使用了 Jcenter 的上传功能：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">    	//Google提供的构建Android项目的插件</span><br><span class="line">    	classpath &apos;com.android.tools.build:gradle:2.3.3&apos;</span><br><span class="line">    	//GreenDao 提供的插件</span><br><span class="line">        classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos;</span><br><span class="line">        //Jcenter提供的插件</span><br><span class="line">        classpath &apos;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.4&apos;</span><br><span class="line">        //Maven提供的插件</span><br><span class="line">    	classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，Gradle 在根据 build.gradle 构建 Module 时，怎么知道要使用哪个插件呢，声明了这么多。</p>
<p>这就是为什么在每个 Module 的 build.gradle 文件的开头有行 <code>apply plugin</code> 的代码了。</p>
<p>apply 是 Gradle 的方法，它可以接收一个 map 类型的参数，而在 Groovy 中，map 的定义可以直接 <code>&#39;key&#39;: value</code>，也就是说：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span>  </span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="comment">// def map = ['plugin':'com.android.application']</span></span><br><span class="line"><span class="comment">// apply(map)</span></span><br></pre></td></tr></table></figure>

<p>每个 build.gradle 开头这行代码，其实是调用了 Gradle 的 apply() 方法，然后传入了一个 map 值，key 为 plugin， value 为 ‘com.android.application’，那么 Gradle 就知道了你这个项目需要使用到一个 id 为 ‘com.android.application’ 的插件来辅助构建了，那么它就会去你在根目录下配置的插件列表里寻找。</p>
<p>也就是说，apply plugin 是 Gradle 规定并提供的，但 ‘com.android.application’ 则是由 Android Gradle 来提供的。</p>
<p>那么，小结一下，要使用一个 Gradle 插件的话，先得在根目录下声明你要用的插件以及版本，当然也得指定插件的下载地址，然后在你具体的 Module 的 build.gradle 的开头通过 apply plugin 方式来应用插件，这个插件得有一个唯一区分开的 id 值。</p>
<h3 id="4-区分-Gradle-和-Android-Gradle"><a href="#4-区分-Gradle-和-Android-Gradle" class="headerlink" title="4. 区分 Gradle 和 Android Gradle"></a>4. 区分 Gradle 和 Android Gradle</h3><p><img src="https://upload-images.jianshu.io/upload_images/1924341-12857cb2ac1f591b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ProjectStructure.png">  </p>
<p>先来看张图，这个在 File -&gt; Project Structure -&gt; Project 打开，在这里可以配置 Gradle 和 Android Gradle 插件的版本。</p>
<p>最开始接触的时候，我看到这里是有些迷茫的，怎么有一个 Gradle 版本，又有一个 Android Gradle 版本。当别人问我你 Android Studio 使用的 Gradle 版本是多少时，我也傻乎乎的打开根目录下的 build.gradle 文件里，看到 <code>com.android.tools.build:gradle:2.3.3</code>，然后跟他说 2.3.3 版本，当初根本没搞清楚这两个有什么区别，一直以为是同一个东西。</p>
<p>所以，要搞清楚 Android Gradle 其实只是 Gradle 的一个插件，是 Google 基于 Gradle 提供的插件接口所做的一些扩展。  </p>
<p>所以，要查找 Android Gradle 的相关资料，自然就不是去 Gradle 官网了，而是要去 Android 官网找：  </p>
<p><a href="https://developer.android.google.cn/studio/releases/gradle-plugin" target="_blank" rel="noopener">https://developer.android.google.cn/studio/releases/gradle-plugin</a>  </p>
<p>由于 Gradle 更新换代很快，又经常提供一些新特性，所以 Android Gradle 插件也就跟随着发布了很多版本，所以，Android Gradle 的版本并不是可以任意更改的，因为它是基于每一个 Gradle 版本开发的，因此需要在对应的 Gradle 版本中才能使用。</p>
<p>这也是为什么，我们有时候直接修改根目录下的 build.gradle 中的 Android Gradle 版本时，会报一些错误说需要 Gradle 版本在多少在可以使用的原因，至于这些对应关系，官网当然有给出来了：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-df864d6b49e665b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="版本对应关系.png">  </p>
<p>举个例子，如果你 Gradle 版本使用的是 3.3，然后你在 Github 上 clone 了某个人的项目，他的项目中使用的 4.4 的 Gradle 版本 和 3.1.0 的 Android Gradle 插件，但是你发现在打开这个项目的时一直处于构建中，一直打不开。</p>
<p>你查了下原因，网上有教程说，让你将项目中的 gradle/wrapper 文件里的 Gradle 版本换成你本地项目中的 Gradle 版本，还跟你说因为它使用的版本你本地没有，而且被墙了，你下载需要很长时间，让你直接改成使用你本地的版本即可。</p>
<p>你改了后，发现，是可以打开项目了，但构建的时候又报错了，说你使用了 3.1.0 的 Android Gradle 插件，需要让你将 Gradle 版本改成 4.4 才可以正常构建，这 MMP 不是又绕回去了。</p>
<p>所以说，别听他放屁，搞清楚了 Gradle 和 Android Gradle 插件的关系之后。那为什么会一直在构建中，为什么会报错我们心里就有数了，要解决，没有其他办法，就是要将对应的版本下载下来。</p>
<p>所以，你应该去搜的是如何下载，Android Gradle 插件并没有被墙，如果想自行下载，可以参考我之前的博客: <a href="https://www.jianshu.com/p/28bb90e565de" target="_blank" rel="noopener">如何用Android Studio查看build.gradle源码</a>，而至于 Gradle 要如何下载，如果官网下载不了，那就去搜搜有没有相关的镜像吧。  </p>
<hr>
<p>本篇就先到这里了，还会有一篇下篇，下篇的内容就是侧重于介绍 build.gradle 里各种配置项的作用和意义了，还有就是如何自己写 Gradle 脚本来运行，敬请期待~</p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>再写个Gradle脚本干活去，解放双手</title>
    <url>/2018/05/20/Gradle/%E5%86%8D%E5%86%99%E4%B8%AAGradle%E8%84%9A%E6%9C%AC%E5%B9%B2%E6%B4%BB%E5%8E%BB%EF%BC%8C%E8%A7%A3%E6%94%BE%E5%8F%8C%E6%89%8B/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇<a href="https://www.jianshu.com/p/e0faba864cdd" target="_blank" rel="noopener">写个批处理来帮忙干活—遍历&amp;字符串处理</a>中，我们已经学习如何写批处理脚本来帮我们做一些简单的重复性工作，本篇继续来学习如何用 Gradle 写脚本，让它也来帮我们干活</p>
<h1 id="Gradle-脚本"><a href="#Gradle-脚本" class="headerlink" title="Gradle 脚本"></a>Gradle 脚本</h1><p>需求场景跟上一篇一样，只是需要脚本能够帮我们遍历某个目录下的文件，然后分别针对每个文件执行 java 命令，再输出新的命名格式的文件即可，因此脚本涉及的方面仍然是：文件夹的遍历操作、字符串处理、执行 java 命令。下面开始学习吧：  </p>
<h3 id="1-遍历指定文件夹下的文件"><a href="#1-遍历指定文件夹下的文件" class="headerlink" title="1. 遍历指定文件夹下的文件"></a>1. 遍历指定文件夹下的文件</h3><h5 id="1-1-files"><a href="#1-1-files" class="headerlink" title="1.1 files()"></a>1.1 files()</h5><p><strong>命令</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">files(file1, file2, file3, file4...) .each &#123;file -&gt;</span><br><span class="line">	println file.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：files() 方法可以理解成一个集合，通过参数往集合中添加元素，只要能将需要遍历的目录下的所有文件都通过参数，传给 files()，那么就可以直接通过 .each 来遍历集合中的每个元素，达到遍历文件夹的目的</p>
<p><strong>示例</strong>：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a19e2d07e083c304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="完整示例.png">    </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> dir = <span class="keyword">new</span> File(<span class="string">"C:\Users\suxq\Desktop\outputs"</span>)  </span><br><span class="line">files(dir.listFiles()).each &#123; file -&gt;</span><br><span class="line">    println file.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-38d29c813325b3f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle遍历示例.png">  </p>
<p>解释：可以结合 File 的 listFiles() 方法使用，这个方法刚好可以返回整个目录下的文件，刚好作为参数传给 files()，这样一来就可以达到遍历文件夹的目的了。  </p>
<p><strong>过滤</strong>：如果只想遍历目录下符合规则的文件，那么可以自定义过滤规则：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> outputs = file(<span class="string">"C:\\Users\\suxq\\Desktop\\outputs"</span>)</span><br><span class="line">files(dir.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">boolean</span> accept(File dir, String name) &#123;</span><br><span class="line">            <span class="comment">//自定义过滤规则</span></span><br><span class="line">            <span class="keyword">return</span> name.endsWith(<span class="string">".apk"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">.each &#123; file -&gt;</span><br><span class="line">    println file.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-fileTree"><a href="#1-2-fileTree" class="headerlink" title="1.2 fileTree()"></a>1.2 fileTree()</h5><p><strong>命令</strong>：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">fileTree(dirPath).each &#123; file -&gt;</span><br><span class="line">	println file.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：fileTree 使用会比 files 更简单，只需要传入目录的路径，即可对目录下的文件进行遍历  </p>
<p><strong>示例</strong>：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a19e2d07e083c304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="完整示例.png">  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def outputs = file(&quot;C:\\Users\\suxq\\Desktop\\outputs&quot;)</span><br><span class="line">fileTree(outputs).each &#123; file -&gt;</span><br><span class="line">	println file.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-38d29c813325b3f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle遍历示例.png">  </p>
<p><strong>过滤</strong>：如果不想遍历整个目录，那么 fileTree 方式也很容易自定义过滤规则：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> outputs = file(<span class="string">"C:\\Users\\suxq\\Desktop\\outputs"</span>)</span><br><span class="line">fileTree(outputs)&#123;</span><br><span class="line">	<span class="comment">//自定义过滤规则</span></span><br><span class="line">	include <span class="string">"*.apk"</span></span><br><span class="line">&#125;</span><br><span class="line">.each &#123; file -&gt;</span><br><span class="line">	println file.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：fileTrss 的自定义过滤规则使用也很方便</p>
<p><strong>注意</strong>：以上示例代码中，涉及到一些 groovy 语言的语法结构，Gradle 是基于 groovy 开发的，groovy 有一个闭包的概念，另外，groovy 支持方法的括号省略，方法的最后一个参数外移等特性，所以，如果上述代码看得不是很懂的话，可以到我之前写的一篇介绍 groovy 基础语法的博客看看：<a href="https://www.jianshu.com/p/501726c979b1" target="_blank" rel="noopener">学点Groovy来理解build.gradle代码</a>  </p>
<h5 id="1-3-java-实现"><a href="#1-3-java-实现" class="headerlink" title="1.3 java 实现"></a>1.3 java 实现</h5><p>由于 Gradle 是基于 groovy 开发的，而 groovy 又是基于 java 开发的，因此，想要遍历指定目录下的文件，你也可以完全用 java 来实现，照样能在 Gradle 脚本中运行，java 实现的就不给示例了</p>
<h3 id="2-字符串处理"><a href="#2-字符串处理" class="headerlink" title="2. 字符串处理"></a>2. 字符串处理</h3><p>由于 Gradle 基于 groovy 开发，而 groovy 又是基于 java 开发的，因此，对字符串的处理完全可以使用 java 的方式，如通过 <code>+</code>来拼接，或者通过 StringBuffer 对象来操作，或者直接使用 String 的 api 都可以。</p>
<p>所以，这一节就主要来讲讲，在 groovy 中可以表示为字符串的格式。</p>
<p>java 只支持用 <code>&quot;xxx&quot;</code> 双引号来表示字符串</p>
<p>groovy 支持使用 <code>&#39;xxx&#39;</code>, <code>&quot;xxx&quot;</code>, <code>&#39;&#39;&#39;xxx&#39;&#39;&#39;</code>,  <code>&quot;&quot;&quot;xxx&quot;&quot;&quot;</code>, <code>/xxx/</code>, <code>$/xxx/$</code> 即单引号，双引号等6种方法来表示字符串<br>它们之间的区别为：<code>&#39;xxx&#39;</code>, <code>&quot;xxx&quot;</code> 只支持单行字符串，不支持多行，剩下的四种都支持多行字符串，如下图<br> <img src="http://upload-images.jianshu.io/upload_images/1924341-cc18ea13326a0918.png" alt="Groovy字符串代码示例"><br> <img src="http://upload-images.jianshu.io/upload_images/1924341-0813184508bcdd70.png" alt="控制台输出结果">  </p>
<p>斜杠我也很少见，常见的是带有 <code>${}</code> 的字符串，比如： <code>println &quot;blog&#39;s url: ${blogUrl}&quot;</code> 这是 groovy 的 GString 特性，支持字符串插值，有点了类似于变量引用的概念，但注意，在 <code>&#39;...&#39;</code>, <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code> 单引号表示的字符串里不支持 <code>${}</code>。当然，如果你要使用 java 的方式，用 <code>+</code> 来拼接也可以。   </p>
<h3 id="3-执行-java-等命令"><a href="#3-执行-java-等命令" class="headerlink" title="3. 执行 java 等命令"></a>3. 执行 java 等命令</h3><p>在批处理脚本中直接写要运行的命令，终端就会自动去执行，但在 gradle 脚本中，如果也需要执行一些命令行下的指令时，就需要借助 Gradle 提供给我们接口。</p>
<h5 id="3-1-“xxx”-execute"><a href="#3-1-“xxx”-execute" class="headerlink" title="3.1 “xxx”.execute()"></a>3.1 “xxx”.execute()</h5><p><strong>命令</strong>：  <code>&quot;xxx&quot;.execute()</code>   </p>
<p><strong>解释</strong>：  “xxx” 就是需要执行的命令，比如 <code>svn --version</code>，<code>git --version</code>，<code>java -version</code>，<code>cmd dir</code> 等等，直接将需要执行的命令用字符串表示后调用 <code>.execute()</code> 方法，这个命令就可以执行了。</p>
<p><strong>切记：</strong> 虽然这种方式很简单，但也很有多问题：</p>
<ul>
<li>首先第一个，你要执行的这条命令必须在你电脑里配置了相关的环境变量，否则会报系统找不到指令的错误。</li>
<li>第二点，这种方式下，有时看不到输出的信息，比如 <code>svn --version</code> 可以在控制台中看到相关信息输出，但是 <code>java -version</code> 这条命令却在控制台中看不到，至于为什么，还没搞懂，有清楚的还望指点一下。</li>
</ul>
<p><strong>示例</strong>：  </p>
<ul>
<li><p>电脑配置了相关的环境变量，控制台可以看到相关信息  </p>
<p><code>println &quot;svn --version&quot;.execute().text.trim()</code>  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-0660ab9f51cb6d23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="svn示例.png">  </p>
<p>解释：text.trim() 是可以获取到命令执行之后的输出结果，所以可以直接将命令的执行结果打印出来查看命令的执行情况，如果需要这方面的需求的话，不然只需 “svn –version”.execute()  命令就会执行了。  </p>
</li>
<li><p>电脑配置了相关的环境变量，但控制台却看不到相关输出信息</p>
<p><code>println &quot;java -version&quot;.execute().text.trim()</code>  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5115805f251d7924.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java示例.png">  </p>
<p>解释：这点我也搞清楚，不懂为什么通过 text 就可以获取到 svn 命令的执行结果，但就获取不到 java 命令的执行结果。但，虽然控制台看不到信息，命令还是有成功执行的，我们可以测试一下：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> workDir = <span class="string">"C:\\users\\suxq\\desktop"</span></span><br><span class="line"><span class="string">"javac -d . A.java"</span>.execute([], <span class="keyword">new</span> File(workDir))</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5cf0b03fd9e74681.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java示例1.png">  </p>
<p>解释：我在桌面放一个 A.java 文件，而通过 <code>javac -d . A.java</code> 命令可以在当前路径下生成一个 A.calss 文件。所以，通过 “xxx”.execute() 方式确实可以正确执行指定命令，但有时可能在控制台看不到输出信息，至于原因我不清楚。</p>
<p>另外，execute() 这个方法可以接收两个参数，第一个参数我也不清楚，第二个参数是可以指定命令执行的工作路径，因为我把 A.java 放在桌面，所以我需要指定这条命令的工作路径是在桌面，不然的话，这条命令中的 A.java 就需要给出绝对路径。</p>
</li>
<li><p>电脑没有配置相关环境变量，脚本执行报错  </p>
<p><code>&quot;git --version&quot;.execute()</code>  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-637439666e3ad0ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git命令示例.png">  </p>
<p>解释：我电脑没有配置 git 的环境变量，因此，通过这种方式来执行命令的时候是会报错的。</p>
</li>
</ul>
<h5 id="3-2-task-xxx-type-Exec"><a href="#3-2-task-xxx-type-Exec" class="headerlink" title="3.2  task xxx(type: Exec) {}"></a>3.2  task xxx(type: Exec) {}</h5><p><strong>命令</strong>：<code>task xxx(type: Exec) {}</code>  </p>
<p><strong>解释</strong>：这种方式是官方给的教程里介绍的方式，<a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Exec.html" target="_blank" rel="noopener">官方链接跳转</a></p>
<p><strong>示例</strong>：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task sign4(<span class="string">type:</span>Exec) &#123;</span><br><span class="line">    group = sign</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置工作路径</span></span><br><span class="line">    workingDir <span class="string">'C:\\Users\\suxq\\Desktop'</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//执行 dir命令， /c 表示 cmd窗口执行完 dir 命令后立即关掉，至于 cmd 后可带哪些参数，可在终端下 cmd /? 查看</span></span><br><span class="line">    commandLine <span class="string">'cmd'</span>, <span class="string">'/c'</span>, <span class="string">'dir'</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行 java -version 命令</span></span><br><span class="line">    <span class="comment">//commandLine 'java', '-version'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行 svn --version 命令</span></span><br><span class="line">    <span class="comment">//commandLine 'svn', '--version'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行 adb devices 命令</span></span><br><span class="line">    <span class="comment">//commandLine 'cmd', '/c', 'adb devices'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：通过 Gradle 提供好的类型为 Exec 的 task，然后通过配置工作路径 workingDir, 需要执行的命令 commandLine，一个 Gradle 脚本就好了，然后通过 android studio 提供的 ui 界面执行或者 Gradle 的命令行形式直接执行这个 task 即可。</p>
<p>稍微介绍下上述一句话带过的 Gradle 脚本执行方式：  </p>
<p><strong>Android Studio方式</strong>：  </p>
<ol>
<li>新建 Gradle 脚本文件，如 sign.gradle，放在与你项目的 app 层级的 build.gradle 同级别即可</li>
<li>在 app 层级的 build.gradle 文件开头添加：apply from: ‘sign.gradle’  </li>
<li>在你自己建的 gradle 脚本文件中编写你的脚本代码，注意你自定义的 task 最好指定一个 group</li>
<li>此时在 Android Studio 右侧的 Gradle 面板中就可以找到你自行指定的 group 中的所有 task，点击即可执行</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f33c8b422c613433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="as执行gradle脚本示例.png">  </p>
<p>如果你的 Gradle 脚本文件中的 task 不指定一个 group 的话，那么在 Gradle 面板中就有的你找了</p>
<p><strong>gradle 命令行方式</strong>：</p>
<p>如果你电脑有配置好 Gradle 的环境变量，那么你直接在终端中输入命令：<code>gradlew task名</code> 即可，如上图中有 sign, sign2 等四个 task，终端下输入 <code>gradlew sign2</code> 就可以执行 sign2 的工作了。</p>
<p>如果电脑没配置 Gradle 环境变量，那每个项目下都会有一个 Gradle 文件夹，它支持我们执行命令，所以你也可以在 Android Studio 的 Terminal 中直接执行命令即可，打开它的时候路径默认为项目根目录的路径，在这里就可以执行 Gradle 的命令了。  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-d10612f0c937ac09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令行执行示例.png">  </p>
<h5 id="3-3-exec"><a href="#3-3-exec" class="headerlink" title="3.3 exec {}"></a>3.3 exec {}</h5><p><strong>命令</strong>：<code>exec {}</code>   </p>
<p><strong>解释</strong>：这个命令的用法可以说跟 3.2 介绍的方式一模一样，我个人针对这两个的区别理解就是，3.2 介绍的方式必须通过 task 方式去执行一个命令，但 exec{} 的方式可以通过方法也可以通过 task 方式，比较灵活，这是我的理解。  </p>
<p><strong>示例</strong>：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> sign() &#123;</span><br><span class="line">    <span class="comment">//设置命令执行结果的输出的地方</span></span><br><span class="line">    <span class="keyword">def</span> out = <span class="keyword">new</span> ByteArrayOutputStream()</span><br><span class="line">    <span class="comment">//通过 exec &#123;&#125; 方式来执行命令</span></span><br><span class="line">    exec &#123;</span><br><span class="line">        workingDir <span class="string">'C:\\users\\suxq\\desktop'</span></span><br><span class="line">        commandLine <span class="string">'cmd'</span>, <span class="string">'/c'</span>, <span class="string">'dir'</span></span><br><span class="line">        <span class="comment">//修改命令输出的地方，默认为控制台</span></span><br><span class="line">        standardOutput = out</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将命令的执行结果作为方法的返回值</span></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：def sign() 定义了一个方法，内部就可以通过 exec{} 来执行指定的命令，并且可以通过修改命令结果输出的地方来达到获取命令执行的结果的目的。而且，这个方法可以在你的 Gradle 脚本中在你需要的地方调用即可，而通常 task 之间只有前后依赖关系，而没有内部嵌套调用关系。</p>
<h3 id="4-完整示例"><a href="#4-完整示例" class="headerlink" title="4. 完整示例"></a>4. 完整示例</h3><p>学习完上述内容后，知道了如何遍历操作，如何处理字符串，如何通过 Gradle 执行命令，就差不多可以来写 Gradle 脚本，让它帮我们做些事了，还是跟上一篇相同的场景：    </p>
<p>场景：遍历指定路径目录下的所有 apk 文件，并通过一个 sign.jar 文件，分别对每个 apk 文件执行 java 命令来进行签名工作，sign.jar 接收两个参数，一个是需要签名的 apk，另外一个为输出的 apk，要求签名后的 apk 命名方式为将原文件名中的 unsign 替换成 google，并输出在跟 apk 同一个目录内即可。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a19e2d07e083c304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="完整示例.png">  </p>
<p>apk 路径：c:\users\suxq\desktop\outputs</p>
<p>sign.jar 路径：c:\users\suxq\desktop</p>
<p>java 签名命令示例(要求 sign.jar 和 apk 文件都在同一路径下，即可用如下命令)：</p>
<p><code>java -jar sign.jar meizi_1_3_0_debug_unsign.apk meizi_1_3_0_debug_google.apk</code>  </p>
<p><strong>Gradle 脚本</strong>  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task sign &#123;</span><br><span class="line">    group = sign</span><br><span class="line"></span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="keyword">def</span> signJar = <span class="string">"c:\\users\\suxq\\desktop\\sign.jar"</span></span><br><span class="line">        <span class="keyword">def</span> apkPath = <span class="string">'c:\\users\\suxq\\desktop\\outputs\\'</span></span><br><span class="line"></span><br><span class="line">        fileTree(file(apkPath))&#123;</span><br><span class="line">            include <span class="string">"*.apk"</span></span><br><span class="line">        &#125;</span><br><span class="line">        .each &#123;file -&gt;</span><br><span class="line">            <span class="keyword">def</span> outApk = file.name.replace(<span class="string">"unsign"</span>, <span class="string">"google"</span>)</span><br><span class="line">            <span class="comment">//由于场景是模拟的，因此这里就只是将最后执行的java命令输出，从输出的命令中就可以看出命令是否可以正确执行</span></span><br><span class="line">            <span class="keyword">def</span> java = <span class="string">"java -jar $&#123;signJar&#125; $&#123;file.name&#125; $&#123;outApk&#125;"</span></span><br><span class="line">            println java</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//实际场景下，执行这句代码，上面代码只是为了看整合之后的命令</span></span><br><span class="line">            <span class="comment">//"java -jar $&#123;signJar&#125; $&#123;file.name&#125; $&#123;outApk&#125;".execute()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-96faf18fdab5b5e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="完整示例3.png">  </p>
<p>效果：完美，可以解放双手，让脚本干活去吧~</p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>写个批处理来帮忙干活---遍历&字符串处理</title>
    <url>/2018/05/18/%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/%E5%86%99%E4%B8%AA%E6%89%B9%E5%A4%84%E7%90%86%E6%9D%A5%E5%B8%AE%E5%BF%99%E5%B9%B2%E6%B4%BB---%E9%81%8D%E5%8E%86&amp;%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>这次打算写几篇关于脚本方面的博客，主要是记录一下 Gradle 脚本和批处理脚本的一些写法，方便后续查阅。  </p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常开发过程中，一些较为重复的手工性工作，如果能让脚本来帮忙处理，自然是最好的，刚好之前有些工作有点过于重复且都是手工性去完成，所以就想着能否写个脚本来处理。  </p>
<p>因为我还是用的 windows 开发，所以最开始想到的就是批处理脚本，但写完后发现，重复性工作是可以交给脚本去处理了，但每次要执行这个脚本文件还得打开脚本所在的文件夹找到脚本点击去执行。  </p>
<p>emmm，因为我是开发 Android 的，电脑开机时 Android Stuido 就没关闭过，然后又想到 Gradle 的脚本可以直接通过 AS 来点击执行，这样一来，执行脚本，也就是敲代码过程中随手一个快捷键就搞定，简单、方便。</p>
<p>所以，这篇就稍微来记录下批处理脚本和 Gradle 脚本的一些写法，很基础简单，因为我的需求就是执行 java 命令来对某个文件夹下的 apk 文件分别进行签名，而后输出新的命名方式的 apk 文件。  </p>
<p>所以，脚本涉及到的操作也就只是文件夹的遍历、字符串的处理、命令的执行这几个方面而已，后续有新接触再慢慢补充。</p>
<h1 id="批处理脚本"><a href="#批处理脚本" class="headerlink" title="批处理脚本"></a>批处理脚本</h1><h3 id="1-遍历指定文件夹下的文件"><a href="#1-遍历指定文件夹下的文件" class="headerlink" title="1. 遍历指定文件夹下的文件"></a>1. 遍历指定文件夹下的文件</h3><h4 id="1-1-命令解释"><a href="#1-1-命令解释" class="headerlink" title="1.1 命令解释"></a>1.1 命令解释</h4><p><strong>命令： <code>for [参数] %%变量名 in （匹配符） do （执行的命令）</code></strong>  </p>
<p><strong>切记：每个指令之间必须以空格隔开，in 与 ( 之间有空格，do 与 （ 间也有空格，否则命令会无法成功执行</strong>    </p>
<p><strong>ps</strong>：本节只讲用批处理脚本执行 for 命令遍历文件夹的场景，因此以下分析每个指令意义时，不介绍其他含义</p>
<p><strong>[]</strong>：表示此项指令为可选  </p>
<p><strong>[参数]</strong>：参数取值一共有四种： <code>/d, /r, /l, /f</code>，加上无参数，所以一共五种场景  </p>
<ul>
<li>无参：遍历当前路径的文件夹下的文件，但也可在<code>(匹配符)</code>中指定路径</li>
<li>/d：遍历当前路径的文件夹下的文件夹，但也可在<code>(匹配符)</code>中指定路径  </li>
<li>/r [路径]：深度遍历指定路径下的所有文件，子目录中的文件也会被遍历到，如果没指定路径，默认当前路径</li>
<li>/l ：当使用参数 /l 时，需结合<code>(匹配符)</code>一起使用，此时 <code>()</code> 括号内部的用法规则为：<code>(start, step, end)</code>，此时的 for 命令作用等同于 java 语言中的 for 语句  </li>
<li>/f ：用于解析文件中的内容，本节不做介绍</li>
</ul>
<p><strong>%%变量名</strong>：作用类似于 <code>for(int i = 0; ; )</code> 中的 <code>int i = 0</code>，有些区别点的就是，批处理的 for 循环遍历每一个子项时，<code>%%变量名</code> &lt;=&gt; 每个子项，即 <code>&amp;&amp;变量名</code> 已经是指向具体的每个子项了  </p>
<p><strong>（匹配符）</strong>：在 in 指令之后 () 括号里的内容可表示为通配符，用于按照指定的规则过滤文件夹下的文件，如 (*.txt) 表示遍历文件夹内所有以 .txt 结尾的文件  </p>
<p><strong>(执行的命令)</strong>：前面的指令就可以取到文件夹内指定的每个子项了，那么接下去要对每个子项如何操作，就在这里写，类似于 java 的 for 命令后的 {} 大括号的作用  </p>
<h4 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h4><p><img src="https://upload-images.jianshu.io/upload_images/1924341-eca5e174e22b8170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="当前目录.png">  </p>
<p>以下示例基于上图中的文件路径，批处理脚本为 test.bat</p>
<ul>
<li>无参：<code>for %%i in (*) do ( echo %%i )</code></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6f5d5efdef6356b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="for无参命令示例.png">  </p>
<p>效果：遍历当前目录下的所有文件  </p>
<ul>
<li>无参指定路径：<code>for %%i in (c:\softwares\VisualBat\*.url) do ( echo %%i )</code>   </li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-1ff92bc4da9354d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="for无参指定路径命令示例.png">  </p>
<p>效果：遍历在<code>(匹配符)</code>中指定路径下的以 .url 结尾的文件  </p>
<ul>
<li>带参数 /d：<code>for /d %%i in (*) do ( echo %%i )</code></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-1a992c48a8a357e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="for参数d命令示例.png">  </p>
<p>效果：遍历当前目录下所有的文件夹  </p>
<ul>
<li>带参数 /d 指定路径：<code>for /d %%i in (c:\softwares\VisualBat\*) do ( echo %%i )</code>  </li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-b4b2cda8fd31b14f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="for参数d指定路径命令示例.png">  </p>
<p>效果：遍历指定目录下的所有文件夹，%%i 指向每个子文件夹的绝对路径</p>
<ul>
<li>带参数 /r ：<code>for /r %%i in (*.url) do ( echo %%i )</code></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-b829be8b50aed33c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="for参数r命令示例.png">  </p>
<p>效果：深度遍历当前路径下所有以 .url 结尾的文件，因为是深度遍历，因此 %%i 指向文件的绝对路径  </p>
<ul>
<li><p>带参数 /r 指定路径：<code>for /r c:\softwares\VisualBat\ %%i in (*.url) do ( echo %%i )</code></p>
<p>效果：同上图  </p>
</li>
<li><p>带参数 /l ：<code>for /l %%i in (1, 1, 5) do ( echo %%i )</code></p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-dce7e6c8948d1893.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="for参数l命令示例.png">  </p>
<p>效果：等效于 java 中的 <code>for (int i = 1; i &lt;= 5; i++)</code>语句，起始值，递增或递减，终止值都可自行设置  </p>
<ul>
<li>带参数 /d /r：<code>for /d /r %%i in (*) do ( echo %%i )</code></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-bc68f937b6a38e91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="for参数dr命令示例.png">  </p>
<p>效果：参数可结合使用，/d 表示遍历文件夹，/r 表示深度遍历，因此以上命令作用为深度遍历当前目录下的所有文件夹，包括子目录中的文件夹  </p>
<h3 id="2-临时变量的使用"><a href="#2-临时变量的使用" class="headerlink" title="2. 临时变量的使用"></a>2. 临时变量的使用</h3><h4 id="2-1-变量的基本用法"><a href="#2-1-变量的基本用法" class="headerlink" title="2.1 变量的基本用法"></a>2.1 变量的基本用法</h4><p><strong>命令：<code>set key=value</code></strong></p>
<p><strong>切记：<code>key=value</code> 三者之间绝对不能出现空格，不能为了像遵守 java 风格擅自给添加上空格，这与 java 的 <code>int a = 1</code> 声明变量不同，切记</strong></p>
<p><strong>变量使用：%key%</strong></p>
<p><strong>示例</strong>：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> name=dasuAndroidTv</span><br><span class="line"><span class="built_in">echo</span> %name%</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-3a3e2d4136a0a3b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="set命令示例.png">  </p>
<p>效果：name 可当做临时变量使用，使用时需用 %% 将变量名括起来使用  </p>
<p><strong>局限</strong>：不允许在 for 命令中类似上步中声明变量并直接使用，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /l %%i <span class="keyword">in</span> (0,1,5) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">set</span> name=dasuAndroidTv</span><br><span class="line">    <span class="built_in">echo</span> %name%</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-50009febcf368685.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="set命令示例2.png">  </p>
<p>效果：在 for 命令中声明临时变量，并直接通过 %key% 方式使用时会出现上图中的错误：ECHO 处于关闭状态，但如果 <code>set key=value</code> 临时变量的声明是放在 for 命令外部，for 命令内部只是使用的话，是可以的，如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> name=dasuAndroidTv</span><br><span class="line"><span class="keyword">for</span> /l %%i <span class="keyword">in</span> (0,1,5) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">echo</span> %name%</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-29cdda5c69c0f7ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="set命令示例3.png">  </p>
<p>效果：在 for 命令外部声明临时变量，for 命令内部只是使用，这种方式是允许的  </p>
<h4 id="2-2-变量在-for-命令中的用法"><a href="#2-2-变量在-for-命令中的用法" class="headerlink" title="2.2 变量在 for 命令中的用法"></a>2.2 变量在 for 命令中的用法</h4><p><strong>提问：那么如果要在 for 命令中才声明临时变量，并使用的话，该如何做？</strong>  </p>
<p><strong>for 命令中临时变量的使用：</strong>  </p>
<ol>
<li><strong>需启用变量延迟功能，命令：<code>setlocal enabledelayedexpansion</code></strong></li>
<li><strong>for 命令中的临时变量使用时用 <code>!key!</code> 感汉号括起来的形式代替 <code>%key%</code></strong></li>
<li>理由：不清楚，google 来的解决方案，感兴趣想深入研究的自行搜索   </li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line"><span class="built_in">set</span> name=dasu</span><br><span class="line"><span class="keyword">for</span> /l %%i <span class="keyword">in</span> (0, 1, 5) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">set</span> name=dasuAndroidTv </span><br><span class="line">    <span class="built_in">echo</span> !name!</span><br><span class="line">    <span class="built_in">echo</span> %name%</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-156580c1ace9f6c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="set命令示例4.png">  </p>
<p>效果：说得白一点，在 for 命令中通过 %name% 方式使用的临时变量，取的 name 这个临时变量的值会一直是它在 for 命令外赋值的内容，即使在 for 命令中通过 set 命令对这个变量又重新赋值，也不会生效。</p>
<p>那么，如果需要在 for 命令中通过 set 命令赋值后的临时变量能够马上拿来使用，需要两个步骤，一在文件开头启用变量延迟功能，命令：<strong><code>setlocal enabledelayedexpansion</code></strong>，二在 for 命令中通过 <strong><code>!name!</code></strong>方式来使用临时变量。</p>
<h3 id="3-字符串处理"><a href="#3-字符串处理" class="headerlink" title="3. 字符串处理"></a>3. 字符串处理</h3><h4 id="3-1-截取"><a href="#3-1-截取" class="headerlink" title="3.1 截取"></a>3.1 截取</h4><p><strong>命令：<code>%key:~[start,num]%</code></strong></p>
<p><strong>解释</strong>：当 <code>%key%</code> 中出现了 <code>:~</code>，则表示要对 key 指向的这个字符串做截取操作，截取操作支持以下几种形式：</p>
<ul>
<li>截取<strong>指定位置开始的 n 个字符串</strong>：<code>%key:~0,4%</code>，表示截取从下标 0 开始的之后 4 个字符</li>
<li>截取从<strong>指定位置开始的整个字符串</strong>：<code>%key:~4%</code>，表示截取从下标为 4 开始的整个字符串</li>
<li>截取<strong>通过倒数方式指定开始位置的整个字符串</strong>：<code>%key:~-2%</code>，表示截取从倒数第 2 个字符开始的整个字符串</li>
<li>截取<strong>通过倒数方式指定位置开始之后的 n 个字符串</strong>：<code>%key:-4,2%</code>，表示截取从倒数第 4 个字符开始的 2 个字符</li>
<li>正数倒数方式相结合：<code>%key:~2,-2%</code>，表示截取从下标 2 开始到倒数第 2 个之间的字符串</li>
</ul>
<p><strong>示例</strong>：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">rem (rem表示后面是注释的内容，类似于 java //)原始字符串</span><br><span class="line"><span class="built_in">set</span> name=dasuAndroidTv</span><br><span class="line"></span><br><span class="line">rem 注释内容：表示截取从下标 0 开始的之后 4 个字符，输出 dasu</span><br><span class="line"><span class="built_in">echo</span> %name:~0,4%</span><br><span class="line"></span><br><span class="line">rem 注释内容：表示截取从下标为 4 开始的整个字符串，输出 AndroidTv</span><br><span class="line"><span class="built_in">echo</span> %name:~4%  </span><br><span class="line"></span><br><span class="line">rem 注释内容：表示截取从倒数第 2 个字符开始的整个字符串，输出 Tv</span><br><span class="line"><span class="built_in">echo</span> %name:~-2%</span><br><span class="line"></span><br><span class="line">rem 注释内容：表示截取从倒数第 4 个字符开始的 2 个字符，输出 Android</span><br><span class="line"><span class="built_in">echo</span> %name:~4,-2%</span><br><span class="line"></span><br><span class="line">rem 注释内容：表示截取从下标 2 开始到倒数第 2 个之间的字符串，输出 id</span><br><span class="line"><span class="built_in">echo</span> %name:~-4,2%</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f6b658833dc648fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字符串截取命令示例.png">  </p>
<h4 id="3-2-拼接"><a href="#3-2-拼接" class="headerlink" title="3.2 拼接"></a>3.2 拼接</h4><p><strong>命令：<code>%key1%%key2%</code></strong></p>
<p><strong>解释</strong>：将要拼接的那个字符串直接跟在被拼接的后面即可，不需要任何拼接操作符</p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> name1=dasu</span><br><span class="line"><span class="built_in">set</span> name2=AndroidTv</span><br><span class="line"><span class="built_in">echo</span> %name1%%name2%  </span><br><span class="line">rem 这里是注释内容：输出 dasuAndroidTv</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-72430aab40b696bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字符串截取命令示例2.png">  </p>
<h4 id="3-3-替换"><a href="#3-3-替换" class="headerlink" title="3.3 替换"></a>3.3 替换</h4><p><strong>命令：<code>%key:被替换字符串=替换的字符串%</code></strong></p>
<p><strong>解释</strong>：不解释了，直接看示例，很容易明白</p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> name=whoAndroidTv</span><br><span class="line"><span class="built_in">echo</span> %name:who=dasu%</span><br><span class="line">rem 这里是注释内容：输出 dasuAndroid</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-9e759e6969d34134.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字符串替换命令示例.png">  </p>
<h4 id="3-4-文件特殊操作"><a href="#3-4-文件特殊操作" class="headerlink" title="3.4 文件特殊操作"></a>3.4 文件特殊操作</h4><p>如果是在 for 命令中遍历了某个文件夹下的文件，那么此时可以通过一些特殊命令来获取这个文件的各种信息，直接看示例：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (*.txt) <span class="keyword">do</span> (</span><br><span class="line">   <span class="built_in">echo</span> %%i</span><br><span class="line">   <span class="built_in">echo</span> %%~<span class="keyword">fi</span></span><br><span class="line">   <span class="built_in">echo</span> %%~di</span><br><span class="line">   <span class="built_in">echo</span> %%~pi</span><br><span class="line">   <span class="built_in">echo</span> %%~ni</span><br><span class="line">   <span class="built_in">echo</span> %%~xi</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">echo</span> %%~ti</span><br><span class="line">   <span class="built_in">echo</span> %%~zi</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-b2f30fecb4518db5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="特殊命令示例.png">  </p>
<p>解释： 在通过 for 命令遍历文件时，%%i 根据不同的 for 使用方式，内容也有所不同，具体见第 1 节。在上述这种用法下，%%i 指向了当前目录下每个文件名，完整的文件名。</p>
<p>那么，此时就可以通过一些特殊命令来取得文件的相关信息，比如：</p>
<ul>
<li><strong>%%~fi</strong>：表示获取该文件的绝对路径信息</li>
<li><strong>%%~di</strong>：表示获取该文件所在的盘符</li>
<li><strong>%%~pi</strong>：表示获取该文件的路径，不包含盘符的信息</li>
<li><strong>%%~ni</strong>：表示获取该文件的文件名，不包含扩展名信息</li>
<li><strong>%%~xi</strong>：表示获取该文件的扩展名</li>
<li><strong>%%~ti</strong>：表示获取该文件的上次修改时间</li>
<li><strong>%%~zi</strong>：表示获取该文件的大小</li>
</ul>
<h4 id="3-5-截取某个指定字符前的部分"><a href="#3-5-截取某个指定字符前的部分" class="headerlink" title="3.5 截取某个指定字符前的部分"></a>3.5 截取某个指定字符前的部分</h4><p>其他语言对字符串的处理基本都有类似 indexof 方法，在批处理中，可以用 for 语句对字符串进行处理来达到这种效果。  </p>
<p>示例：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set name=woshidasusu_android</span><br><span class="line">for /f &quot;delims=_&quot; %%i in (&apos;echo %name%&apos;) do (</span><br><span class="line">		echo %%i</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>输出：woshidasusu</p>
<h3 id="4-完整示例"><a href="#4-完整示例" class="headerlink" title="4. 完整示例"></a>4. 完整示例</h3><p>最后，我们来个具体场景，将本篇所学的知识用上一遍，巩固一下。</p>
<p>场景：遍历指定路径目录下的所有 apk 文件，并通过一个 sign.jar 文件，分别对每个 apk 文件执行 java 命令来进行签名工作，sign.jar 接收两个参数，一个是需要签名的 apk，另外一个为输出的 apk，要求签名后的 apk 命名方式为将原文件名中的 unsign 替换成 google，并输出在跟 apk 同一个目录内即可。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a19e2d07e083c304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="完整示例.png">  </p>
<p>apk 路径：c:\users\suxq\desktop\outputs</p>
<p>sign.jar 路径：c:\users\suxq\desktop</p>
<p>java 签名命令示例(要求 sign.jar 和 apk 文件都在同一路径下，即可用如下命令)：</p>
<p><code>java -jar sign.jar meizi_1_3_0_debug_unsign.apk meizi_1_3_0_debug_google.apk</code></p>
<p><strong>批处理脚本代码：</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> sign=c:\users\suxq\desktop\sign.jar</span><br><span class="line"><span class="built_in">set</span> apkPath=c:\users\suxq\desktop\outputs\</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (%apkPath%*.apk) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">set</span> oldApk=%%~nxi</span><br><span class="line">    <span class="built_in">set</span> outApk=!oldApk:unsign=google!</span><br><span class="line">    <span class="built_in">echo</span> java -jar %sign% !oldApk! !outApk!</span><br><span class="line">    rem 这里是注释内容：由于 apk 文件 和 sign.jar 文件都是虚拟的，因此真正执行时会报错，这里就只是将 java 整句命令输出，从整句命令就可以确认是否会正确执行，如果这些文件都是真的话。真的脚本应该将 <span class="built_in">echo</span> 去掉</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1924341-b267d226fbc883ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="完整示例2.png">  </p>
<p>效果：完美~</p>
<p>首先，遍历指定目录下的文件达到了，而且可以对文件名字符串进行处理，替换其中一些值，最后，可以根据指定位置的 sign.jar 文件，通过 java 命令来执行签名工作。</p>
<p>这个场景，刚好把我们今天学的关于批处理的遍历文件夹操作、临时变量使用、字符串的处理三者都包括在内，感兴趣的也去试试看吧~  </p>
]]></content>
      <categories>
        <category>批处理脚本</category>
      </categories>
  </entry>
  <entry>
    <title>发布开源库到JCenter的一些问题记录</title>
    <url>/2018/05/06/%E6%95%99%E7%A8%8B%E7%B1%BB/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0JCenter%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>这周末自己瞎折磨了下，如何发布开源库到 JCenter，然后这过程中碰到了一些问题，在此记录分享一下  </p>
<p>本篇是基于上一篇：<a href="https://www.jianshu.com/p/91a55d8f7055" target="_blank" rel="noopener">教你一步步发布一个开源库到 JCenter</a> 介绍的流程、步骤中所遇到的问题，所以没看过上一篇的，可以去看看哈~</p>
<ol>
<li><strong>Error:No service of type Factory<loggingmanagerinternal> available in ProjectScopeServices.</loggingmanagerinternal></strong>  </li>
</ol>
<p>原因：android-maven-gradle-plugin 插件的 bug  </p>
<p>解决：更换版本，本次测试出问题版本 1.3，更改为 1.4.1 后正常</p>
<p>做法：在根目录的 build.gradle 文件中修改插件版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>Error:Could not get unknown property ‘publishedGroupId’ for project ‘:tv’ of type org.gradle.api.Project.</strong>  </li>
</ol>
<p>原因：apply from ‘<a href="https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle&#39;" target="_blank" rel="noopener">https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle&#39;</a> 代码放错位置</p>
<p>解决：由于上述 apply from 代码的意思是使用存储在网上的脚本模板文件，模板文件中使用了很多还未声明的变量，所以 apply from 这行代码应该放置在 ext {} 变量声明代码块之后  </p>
<p>做法：  build.gradle 文件中以下几行代码应该按顺序来，第一行 apply from: ‘bintray-config.gradle’ 其实就是脚本模板文件中的变量声明，赋值代码，也就是 ext{} 代码块，只是将其单独放置于一个 gradle 文件中，这里也可以直接将 ext{} 代码替换掉   apply from: ‘bintray-config.gradle’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply from: &apos;bintray-config.gradle&apos;</span><br><span class="line">//ext&#123;&#125; 变量声明，赋值代码块必须在以下两个脚本模板文件之前</span><br><span class="line">apply from: &apos;https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle&apos;</span><br><span class="line">apply from: &apos;https://raw.githubusercontent.com/nuuneoi/JCenter/master/bintrayv1.gradle&apos;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Error:Cause: android.compileSdkVersion is missing!</strong></li>
</ol>
<p>原因：apply from: ‘<a href="https://raw.githubusercontent.com/nuuneoi/JCenter/master/bintrayv1.gradle&#39;" target="_blank" rel="noopener">https://raw.githubusercontent.com/nuuneoi/JCenter/master/bintrayv1.gradle&#39;</a> 代码放错位置  </p>
<p>解决：跟 2 的理由类似，这个脚本是用于将本地生成的 pom，aar 等文件上传至 bintray 仓库，但这个脚本的运行需要依赖于一些 android {} 块的属性配置；所以并不是所有 apply from 的代码都是放置于 build.gradle 的开头，这里建议将 第 2 中的三个 apply from 代码都放置于 build.gradle 文件末尾。  </p>
<p>以上 1-3 问题均是在上一篇中的步骤，第 2 步：配置本地 gradle 脚本插件，的过程中操作不当导致的  </p>
<ol start="4">
<li><strong>Execution failed for task ‘:tv :javadoc.</strong>  </li>
</ol>
<p>原因：执行 <code>gradlew install</code> 构建过程中出错，这是由于执行生成 javadoc 过程中出问题，至于为什么出问题可以具体查看日志，例如我这里：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-e04345f4c0ee0190.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GBKerror.png">  </p>
<p>我这里是由于在代码中有中文，所以导致的构建错误</p>
<p>解决：有没有其他解决方案我不清楚，我又不想将这些中文注释给删除掉，那么我只能将这个 javadoc 的 task 给关掉了，反正我上传到 JCenter 上的开源库也只是我自己在用，不需要 javadoc 文档  </p>
<p>做法：由于 javadoc 的 task 是在 bintray 提供的脚本模板文件中，所以只能修改这个模板文件，那么在上一篇的第 2 步：配置本地 gradle 脚本插件，就不能用 <code>apply from &#39;http://...&#39;</code> 的形式了，因为这种形式无法修改模板文件。</p>
<p>那么就需要在本地新建一个 <strong>installv1.gradle</strong> 文件，然后将这个脚本文件里的代码拷贝进这个新建的文件中：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将下面所有的 javadoc task 注释掉，不用这个功能</span><br><span class="line">apply plugin: &apos;com.jfrog.bintray&apos;</span><br><span class="line"></span><br><span class="line">version = libraryVersion</span><br><span class="line"></span><br><span class="line">if (project.hasProperty(&quot;android&quot;)) &#123; // Android libraries</span><br><span class="line">    task sourcesJar(type: Jar) &#123;</span><br><span class="line">        classifier = &apos;sources&apos;</span><br><span class="line">        from android.sourceSets.main.java.srcDirs</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//1. 这里是第1处</span><br><span class="line">//    task javadoc(type: Javadoc) &#123;</span><br><span class="line">//        source = android.sourceSets.main.java.srcDirs</span><br><span class="line">//        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))</span><br><span class="line">//    &#125;</span><br><span class="line">&#125; else &#123; // Java libraries</span><br><span class="line">    task sourcesJar(type: Jar, dependsOn: classes) &#123;</span><br><span class="line">        classifier = &apos;sources&apos;</span><br><span class="line">        from sourceSets.main.allSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2. 这里是第2处</span><br><span class="line">//task javadocJar(type: Jar, dependsOn: javadoc) &#123;</span><br><span class="line">//    classifier = &apos;javadoc&apos;</span><br><span class="line">//    from javadoc.destinationDir</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">artifacts &#123;</span><br><span class="line">//3. 这里是第3处</span><br><span class="line">//    archives javadocJar</span><br><span class="line">    archives sourcesJar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Bintray</span><br><span class="line">Properties properties = new Properties()</span><br><span class="line">properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())</span><br><span class="line"></span><br><span class="line">bintray &#123;</span><br><span class="line">    user = properties.getProperty(&quot;bintray.user&quot;)</span><br><span class="line">    key = properties.getProperty(&quot;bintray.apikey&quot;)</span><br><span class="line">    println user</span><br><span class="line">    println key</span><br><span class="line"></span><br><span class="line">    configurations = [&apos;archives&apos;]</span><br><span class="line">    pkg &#123;</span><br><span class="line">        repo = bintrayRepo</span><br><span class="line">        name = bintrayName</span><br><span class="line">        desc = libraryDescription</span><br><span class="line">        websiteUrl = siteUrl</span><br><span class="line">        vcsUrl = gitUrl</span><br><span class="line">        licenses = allLicenses</span><br><span class="line">        publish = true</span><br><span class="line">        publicDownloadNumbers = true</span><br><span class="line">        version &#123;</span><br><span class="line">            desc = libraryDescription</span><br><span class="line">            gpg &#123;</span><br><span class="line">                sign = true //Determines whether to GPG sign the files. The default is false</span><br><span class="line">                passphrase = properties.getProperty(&quot;bintray.gpg.password&quot;)</span><br><span class="line">                //Optional. The passphrase for GPG signing&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 module 下的 build.gradle 文件的末尾中，将原本的 apply from 代码换成下面的：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply from: &apos;bintray-config.gradle&apos;</span><br><span class="line">apply from: &apos;bintrayv1.gradle&apos;</span><br><span class="line">apply from: &apos;https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle&apos;</span><br></pre></td></tr></table></figure>

<p>上面两个 apply from 是指使用 本地脚本文件，最后一个 apply from 是指使用网络上的脚本文件，本地脚本文件可以任自己修改  </p>
<ol start="5">
<li><strong>提几点 bintray 网站操作的一些注意事项</strong> <ul>
<li>注册账号的时候 qq 邮箱不能使用，建议使用 gmail 邮箱</li>
<li>在 bintray 上创建完仓库后，也顺便将 package 创建了吧，package 对应着本地项目中一个 module，至于不创建 package，直接在本地执行上传操作能否可行，我没测试过</li>
<li>ext {} 变量声明的代码块里，具体哪些属性值可以不配置，我没测试过，但感觉还是按模板来，将每个属性都进行配置比较好</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>教程类</category>
      </categories>
  </entry>
  <entry>
    <title>教你一步步发布一个开源库到 JCenter</title>
    <url>/2018/05/06/%E6%95%99%E7%A8%8B%E7%B1%BB/%E6%95%99%E4%BD%A0%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0-JCenter/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>今天想来分享下，如何一步步自己发布一个开源库到 JCenter  </p>
<p>这方面的博客网上已经特别多了，所以本篇并不打算仅仅只是记录流程步骤而已，而是尽可能讲清楚，为什么需要有这个步骤，让大伙知其然的同时还知其所以然，那么掌握就会更深刻一点，所以本篇篇幅会很长。另外，本篇是参考、引用、借鉴了以下文章中的内容：  </p>
<blockquote>
<p><a href="https://inthecheesefactory.com/blog/how-to-upload-library-to-jcenter-maven-central-as-dependency/en" target="_blank" rel="noopener">How to distribute your own Android library through jCenter and Maven Central from Android Studio</a></p>
</blockquote>
<p>虽然是英文版，但有四级基础就可以基本看懂了，文章写得很全，很详</p>
<p>实在不想看英文版的，国内有中文版翻译，在<strong><em>《Android高级进阶》</em></strong>的第 9 章有完整版的中文翻译</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先得想清楚一件事：<strong>是不是只有写得很牛的开源库，或者只有牛人、大神才可以发布开源库到 JCenter呢？</strong>  </p>
<p>可能有些人觉得自己不是大神，自己写不出啥牛逼的开源库，所以不用发布到 JCenter 上给别人用。所以，得先想清楚，你为什么要发布一个开源库到 JCenter 上去？</p>
<p>学习也行；分享也行；自己用也行；总之，没什么规定说只有大神才可以发布；</p>
<p>其实，这里之所以叫做开源库，是因为发布到 JCenter 上之后，大伙都可以使用的原因。我更喜欢在《Android高级进阶》里的说法：函数库</p>
<p>我是带着这么一种想法的：</p>
<p>作为一个懒人，一些可以在多个项目中使用的公共基础模块，实在不想每次新建项目都手动去复制粘贴，或者手动去导 Module，所以就想着将这些公共基础模块打包发布到 JCenter，以后新建项目时只要配置下 build.gradle 就可以了</p>
<p>Q：你问我为啥不上传到私服？  </p>
<p>A：没钱    </p>
<p>Q：你问我那不怕代码被盗用？  </p>
<p>A：又不是什么牛逼的开源库，就是一些基本的公共模块如工具类，网络层封装等等，别人想用，我高兴还来不及，怕啥  </p>
<p>Q：你问我那这些基础模块为啥不用别人开源的，还要自己造轮子？</p>
<p>A：自己的用着顺手，自己的想怎么改就可以怎么改</p>
<p>Q：你问我那不怕发布的开源库代码太槽糕，被人骂？  </p>
<p>A：老哥，我又不是大神，我要不写这篇博客，都没人知道我发布了个开源库，反正就我自己使用，怕啥</p>
<p>Q：你问我…</p>
<p>A：老哥，别问了，赶快去发布一个试试看吧，万一以后你就是大神了呢，省得到时再现学</p>
<p>好了，接下去就开始讲发布的步骤了</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>先盗用开头分享的链接里的一张图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-3cb9b85a3c2d7efb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程.png">  </p>
<p>整个流程其实就是上图中介绍的这样，先本地打包成 jar 或 aar 文件，然后上传到 bintray 自己的仓库中，最后发布到 jcenter 上去就可以了。</p>
<p>除了第一步是在本地自己操作外，剩下的操作都是在网页上移移鼠标点一点就可以了</p>
<h3 id="第-0-步：JCenter-网址"><a href="#第-0-步：JCenter-网址" class="headerlink" title="第 0 步：JCenter 网址"></a>第 0 步：JCenter 网址</h3><p><a href="https://bintray.com/" target="_blank" rel="noopener">https://bintray.com/</a>  </p>
<p><a href="https://jcenter.bintray.com/" target="_blank" rel="noopener">https://jcenter.bintray.com/</a></p>
<p>为什么会有两个呢？那是因为，第一个是提供给我们可 ui 交互操作的网站，注册账号、配置仓库、发布等等操作都是在第一个网址上面操作，我们也只要记住第一个网站就可以了</p>
<p>第二个是存放这些开源库的网址，如果你想手动下载某个开源库的 jar，那么你可以直接在第二个网址后面加上开源库的路径即可</p>
<p>比如，我之前写过一篇 <a href="https://www.jianshu.com/p/28bb90e565de" target="_blank" rel="noopener">如何用Android Studio查看build.gradle源码</a>，某些情况下，Android Studio 并没有成功将 Android Gradle 插件的源码下载下来，我们又想去查看源码时，只能自己去下载。写那篇博客的时候 Android Studio 还是默认配置的 mavenCentral 作为开源库拉取来源的。</p>
<p>但现在新版的 Android Studio 已经改成默认配置 JCenter 作为开源库的来源了，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.squareup.okhttp:okhttp:2.4.0&apos;</span><br></pre></td></tr></table></figure>

<p>如果想手动下载 okhttp 的 jar 包，那么就是访问：<a href="https://jcenter.bintray.com/com/squareup/okhttp/okhttp/2.4.0/" target="_blank" rel="noopener">https://jcenter.bintray.com/com/squareup/okhttp/okhttp/2.4.0/</a>  </p>
<p>以此类推</p>
<h3 id="第-1-步：注册账号-amp-创建仓库"><a href="#第-1-步：注册账号-amp-创建仓库" class="headerlink" title="第 1 步：注册账号 &amp; 创建仓库"></a>第 1 步：注册账号 &amp; 创建仓库</h3><h5 id="1-1-注册账号"><a href="#1-1-注册账号" class="headerlink" title="1.1 注册账号"></a>1.1 注册账号</h5><p>打开 <a href="https://bintray.com/" target="_blank" rel="noopener">https://bintray.com/</a> 网站，注册一个账号，也可以选择直接 Github 账号授权登录，很简单，不贴图了。</p>
<h5 id="1-2-创建仓库"><a href="#1-2-创建仓库" class="headerlink" title="1.2 创建仓库"></a>1.2 创建仓库</h5><p>登录账号后，跟 Github 操作类似，bintray 允许你在网站上创建自己的仓库，可 public，可 private。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-ba409ef729313a17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建模块.png">  </p>
<p>创建仓库的操作跟 Github 是类似的，我就不演示了，我这里创建了一个叫 base-module 的空仓库。</p>
<p>接下去就跟 Github 的概念有点不一样了，在 Github 上我们一个仓库通常对应一个具体的项目，本地项目长啥样，Github 上的仓库基本也就长啥样。</p>
<p>在 bintray 这里，一个仓库我更倾向于把它就理解成仓库的意思，也就是作为容器的作用。创建完一个空仓库后，页面右下角会有一个 <strong>Add New Package</strong> 按钮，也就是仓库下面还有一层 package 的概念。</p>
<p>一个 package 就是一个可发布到 JCenter 上的开源包，而发布到 JCenter 上的内容是一些 pom，aar，jar 之类的文件，并不是整个项目。所以我们需要先创建一个 package 来准备给本地需要打包发布的 module 生成 pom，aar 等文件的存放地了。</p>
<h3 id="第-2-步：配置本地-gradle-脚本插件"><a href="#第-2-步：配置本地-gradle-脚本插件" class="headerlink" title="第 2 步：配置本地 gradle 脚本插件"></a>第 2 步：配置本地 gradle 脚本插件</h3><p>上传到 Github 上的是整个项目的源码，而上传到 bintray 上的是 pom， jar，arr 这类文件。</p>
<p>所以，在发布开源库到 JCenter 之前，我们需要先在本地将要发布的 Module 打包成 jar, aar。那么，在本地要怎么操作呢？就像 Google 提供了 Android Gradle 插件来方便开发者直接对项目进行编译一样，bintray 也提供了相对应的 gradle 插件，来方便我们直接在本地打包成 jar。</p>
<p>同样，Github 支持通过 Git 来将本地项目上传到 Github 上，而 bintray 也提供了对应的 gradle 脚本来让开发者将本地打包后的 jar 等上传至 bintray 网站上的仓库中。</p>
<p>这就是为什么我们需要在本地配置一些 gradle 插件的原因，一者方便开发者对项目进行编译、打包成所需的文件；二者通过它提供的桥梁上传至 bintray 网站上的仓库。</p>
<h5 id="2-1-配置-gradle-插件地址"><a href="#2-1-配置-gradle-插件地址" class="headerlink" title="2.1 配置 gradle 插件地址"></a>2.1 配置 gradle 插件地址</h5><p>使用 Android Gradle 插件，需要在根项目的 build.gradle 文件中配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	classpath &apos;com.android.tools.build:gradle:2.3.3&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的道理，要使用 bintray gradle 插件，同样也得在<strong>根项目的 build.gradle 文件中配置</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> dependencies &#123;</span><br><span class="line">	//Android Gradle 插件</span><br><span class="line">	classpath &apos;com.android.tools.build:gradle:2.3.3&apos;</span><br><span class="line">	//bintray 插件</span><br><span class="line">	classpath &apos;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.4&apos;</span><br><span class="line">	classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&apos;</span><br><span class="line">	//android-maven-gradle-plugin:1.3版本有bug，网上很多例子用的这个版本，编译的时候可能会出错，改一下版本就好了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，只是配置了插件的路径，那么使用插件的地方肯定就是在对应 module 下的 build.gradle 文件中了</p>
<h5 id="2-2-使用-gradle-插件"><a href="#2-2-使用-gradle-插件" class="headerlink" title="2.2 使用 gradle 插件"></a>2.2 使用 gradle 插件</h5><p>gradle 插件使用的地方都是在<strong>每个具体 module 下的 build.gradle 文件</strong>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &apos;com.android.library&apos;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是常见的 build.gradle 文件，这表示的是，将会使用 Android gradle 插件中 id 为 com.android.library 的 gradle 插件来将该 Module 构建成一个 library，而 build.gradle 里其他配置项如 android 等则表示构建该项目所需的一些配置，这是我对 gradle 的理解（不知道对不对）。</p>
<p>同样，因为上传到 bintray 的是一些 pom, jar 文件，所以我们也需要在这个 build.gradle 中使用 bintray 提供的插件来编译，打包项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//切记：以下代码必须放在 build.gradle 文件末尾</span><br><span class="line">apply from: &apos;https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle&apos;</span><br><span class="line">apply from: &apos;https://raw.githubusercontent.com/nuuneoi/JCenter/master/bintrayv1.gradle&apos;</span><br></pre></td></tr></table></figure>

<p>以上 apply from 指的是该 module 需要使用一个存储于网上的 gradle 脚本文件来根据各种配置项来编译、打包项目。</p>
<p>之所以这个 gradle 脚本文件存储在网络上，纯粹是因为 bintray 担心我们不知道怎么使用它提供的 gradle 插件来生成 pom, jar 等文件，所以连模板脚本都提供给我们了（这是我的理解）。</p>
<p>所以，你可以将 apply from 后面的链接在网页上输入看看，你会看到以下脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//以下代码大概瞄一眼即可，不用细看</span><br><span class="line">apply plugin: &apos;com.github.dcendents.android-maven&apos;</span><br><span class="line"></span><br><span class="line">group = publishedGroupId //开源库的 groupId</span><br><span class="line"></span><br><span class="line">install &#123;</span><br><span class="line">    repositories.mavenInstaller &#123;</span><br><span class="line">        // This generates POM.xml with proper parameters</span><br><span class="line">        pom &#123;</span><br><span class="line">            project &#123;</span><br><span class="line">                packaging &apos;aar&apos;//将项目打包成 aar</span><br><span class="line">                groupId publishedGroupId</span><br><span class="line">                artifactId artifact</span><br><span class="line"></span><br><span class="line">                // Add your description here</span><br><span class="line">                name libraryName</span><br><span class="line">                description libraryDescription</span><br><span class="line">                url siteUrl</span><br><span class="line"></span><br><span class="line">                // Set your license</span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        name licenseName</span><br><span class="line">                        url licenseUrl</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                developers &#123;</span><br><span class="line">                    developer &#123;</span><br><span class="line">                        id developerId</span><br><span class="line">                        name developerName</span><br><span class="line">                        email developerEmail</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                scm &#123;</span><br><span class="line">                    connection gitUrl</span><br><span class="line">                    developerConnection gitUrl</span><br><span class="line">                    url siteUrl</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个将项目打包成 arr，并生成项目的 pom.xml 文件的脚本，这些文件都是要上传到 bintray 网站上你的仓库中去的。</p>
<p>所以，如果你知道使用 bintray gradle 插件都需要进行哪些配置的话，你完全可以自己在 build.gradle 将上述脚本中所需的配置直接写上就好，不用使用 apply from；或者，你根据 apply from 后面的链接将脚本代码复制粘贴到 build.grale 文件中也行。</p>
<p>同样的道理，另外一个 apply from 所提供的 gradle 脚本内容我就不截图了，那个脚本的作用是用于将生成的 pom, aar 等文件上传至你的 bintray 网站的仓库中去的。</p>
<p>也就是说，<strong>bintray 提供了两个 gradle 插件，一个用于将本地项目编译，打包成 aar，并生成所需的 pom.xml 等文件；另一个用于将生成的这些文件都上传至你的 bintray 仓库中去。同时，bintray 还提供了两份脚本配置模板，如果不懂得怎么使用，就参照这两份模板来就行了</strong>。</p>
<h5 id="2-3-修改-gradle-脚本模板文件中的配置项"><a href="#2-3-修改-gradle-脚本模板文件中的配置项" class="headerlink" title="2.3 修改 gradle 脚本模板文件中的配置项"></a>2.3 修改 gradle 脚本模板文件中的配置项</h5><p>既然提供的仅仅是模板文件，那么具体的配置项肯定是需要我们根据自己的实际项目来进行配置的。有两种方式：</p>
<ul>
<li>不使用 apply from，直接将脚本模板文件里的代码拷贝至 build.gradle 中，然后根据具体项目，手动修改每一个配置项（略麻烦，不推荐）</li>
<li>脚本模板文件中，每一个配置项都使用了对应的变量来配置，那么我们只需在 build.gradle 中声明这些变量，并对变量进行赋值，就可以了</li>
</ul>
<p>Android Gradle 编译项目的用法其实就是第一种，但由于我们对 android 项目编译要配置的项都挺熟悉了，加上 Android Studio 会自动生成一些必要的配置项，所以并不麻烦。但由于对 bintray gradle 插件的配置项不熟，个人不建议这里也使用这种方式。</p>
<p>而第二种方式，如果你有兴趣再去网上搜索下其他的这类教程的文章，可能你会发现，很多文章都会让你在 build.gradle 文件中写这么一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//下一步会具体来看每个配置项含义</span><br><span class="line">ext &#123;</span><br><span class="line">    bintrayRepo = &apos;maven&apos;</span><br><span class="line">    bintrayName = &apos;fb-like&apos;</span><br><span class="line"></span><br><span class="line">    publishedGroupId = &apos;com.inthecheesefactory.thecheeselibrary&apos;</span><br><span class="line">    libraryName = &apos;FBLike&apos;</span><br><span class="line">    artifact = &apos;fb-like&apos;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以理解，为什么他们要你写这段代码了吧。因为 bintray 提供的脚本模板文件中，对它所需的配置项都使用了相对应的变量，那么我们如果直接使用脚本模板文件，就需要对这些变量进行声明并赋值，也就是说在 ext 中 声明的 bintrayRepo, libraryName 等等这些变量，其实都是因为它们在 bintray 提供的脚本模板文件中被使用了。</p>
<p>另外，由于 gradle 脚本是按顺序执行代码，所以声明这些变量的代码必须在 apply from 代码之前，否则如果先执行了 apply from，会报找不到相对应的变量错误。</p>
<p>还有一点，bintray gradle 插件源码我没去深入看，但要让项目生成对应的 pom 项目说明文件，以及打包成 aar，所以我猜测，这表明 bintray gradle 插件内部除了脚本模板上所列的各种配置项外，还需要 Android Gradle 插件的一些配置项，比如 build.gradle 里的 android 块配置项。</p>
<p>这也是为什么其他文章里提到说，要将 apply from 这几行代码放在 build.gradle 最后的原因。因为 gradle 脚本是按顺序执行代码，而 bintray gradle 插件的运行又依赖于一些 android 配置项，所以如果将 apply from 放在开头的话，会报找不到一些变量的错误。</p>
<h5 id="2-3-2-将变量的声明赋值代码写在单独的脚本文件中（可选）"><a href="#2-3-2-将变量的声明赋值代码写在单独的脚本文件中（可选）" class="headerlink" title="2.3.2 将变量的声明赋值代码写在单独的脚本文件中（可选）"></a>2.3.2 将变量的声明赋值代码写在单独的脚本文件中（可选）</h5><p>如果不想让 build.gradle 文件中有太多跟编译项目本身无关的代码，那么可以将跟 bintray gradle 插件相关的代码都单独写在另外一个 gradle 文件中，然后在该 build.gradle 开头通过 apply from 将那个 gradle 文件应用进来即可，有点类似于 import 的概念。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//build.gradle 文末</span><br><span class="line">//bintray-config.gradle 就是跟 build.gradle 同层目录下的一个 gradle 文件，里面就是单纯将 exe &#123;&#125; 这块代码里的变量声明和赋值拷贝至 bintray-config.gradle 文件里</span><br><span class="line">apply from: &apos;bintray-config.gradle&apos;</span><br><span class="line">apply from: &apos;https://raw.githubusercontent.com/nuuneoi/JCenter/master/bintrayv1.gradle&apos;</span><br><span class="line">apply from: &apos;https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle&apos;</span><br></pre></td></tr></table></figure>

<h3 id="第-3-步：设置-gradle-插件中各种配置项"><a href="#第-3-步：设置-gradle-插件中各种配置项" class="headerlink" title="第 3 步：设置 gradle 插件中各种配置项"></a>第 3 步：设置 gradle 插件中各种配置项</h3><p>第 2 步在于配置各种所需的 gradle 插件以及如何使用，至于脚本模板的每一行代码，感兴趣的可以去深究，但不去管也么事，反正大概知道两个脚本都干了什么事就行，怎么干的就不用去管了。</p>
<p>那么接下去就该了解一下，都需要对项目进行哪些属性的配置，这些插件才可以正常运行，才可以正常的将开源库上传至 bintray 上的仓库去：  </p>
<h5 id="3-1-各种基本配置项"><a href="#3-1-各种基本配置项" class="headerlink" title="3.1 各种基本配置项"></a>3.1 各种基本配置项</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    //bintray 网站上你创建的仓库的名字（必配项）</span><br><span class="line">    bintrayRepo = &apos;base-module&apos;</span><br><span class="line">    //在这个仓库下的 package name（必配项）</span><br><span class="line">    bintrayName = &apos;tv&apos;</span><br><span class="line">    //以上两项均只是指向 bintray 网站上你的仓库和仓库下的package</span><br><span class="line"></span><br><span class="line">    //publishedGroupId:artifact:libraryVersion 构成你开源库的唯一路径</span><br><span class="line">    //例如：com.dasu.tv:tv:0.0.1，在build.gradle里就可以根据这个路径来compile依赖库了</span><br><span class="line">    //以下三项均是必配项</span><br><span class="line">    publishedGroupId = &apos;com.dasu.tv&apos;</span><br><span class="line">    artifact = &apos;tv&apos;</span><br><span class="line">    libraryVersion = &apos;0.0.1&apos;</span><br><span class="line"></span><br><span class="line">    //以下三项只是对开源库的描述（应该不是必配项吧，没尝试过）</span><br><span class="line">    libraryName = &apos;tv&apos;</span><br><span class="line">    libraryDescription = &apos;dasu 封装的常用，可公用的 tvui 库&apos;</span><br><span class="line">    siteUrl = &apos;https://github.com/woshidasusu/base-module/tree/master/tv&apos;</span><br><span class="line"></span><br><span class="line">    //开源库对应的 github 地址，不知道可不可以不配，应该也是必配</span><br><span class="line">    gitUrl = &apos;https://github.com/woshidasusu/base-module.git&apos;</span><br><span class="line"></span><br><span class="line">    //开发者信息，也是必配的吧</span><br><span class="line">    developerId = &apos;dasu&apos;</span><br><span class="line">    developerName = &apos;dasu&apos;</span><br><span class="line">    developerEmail = &apos;295207731@qq.com&apos;</span><br><span class="line"></span><br><span class="line">    //这部分可以不用改，我也不大懂这些开源协议，但应该都一样</span><br><span class="line">    licenseName = &apos;The Apache Software License, Version 2.0&apos;</span><br><span class="line">    licenseUrl = &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos;</span><br><span class="line">    allLicenses = [&quot;Apache-2.0&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像 build.gradle 文件一样，有些属性必须配置后项目才可以正常编译，运行。要使用 bintray gradle 插件来进行生成对应的 pom，aar 文件，上传到 bintray 仓库等功能，也必须进行一些属性配置才行。</p>
<p>总之，对应在 bintray 仓库的信息肯定需要配置，发布到 JCenter 后的唯一路径也需要配置，开发者信息当然也需要，其他还需要一些开源库的描述信息以及开源协议信息。</p>
<h5 id="3-2-配置身份验证信息（敏感信息）"><a href="#3-2-配置身份验证信息（敏感信息）" class="headerlink" title="3.2 配置身份验证信息（敏感信息）"></a>3.2 配置身份验证信息（敏感信息）</h5><p>经常使用 Github 肯定还觉得需要关键的用户跟秘钥信息是不是，否则使用 Git 上传项目到 Github 上时没办法进行身份验证。</p>
<p>同样的道理，要将经过 bintray gradle 插件生成的 pom，aar 等上传到 bintray 仓库，同样需要进行身份验证，那么就配置一些用户名和 key 的关键信息，但这些信息又极其敏感，隐私，所以只能配置在本地文件中。</p>
<p>如果不修改那两份脚本模板文件的话，那么这些信息就需要配置在项目的根目录下面的 <strong>local.properties</strong> 文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//根目录下的local.properties文件 </span><br><span class="line">bintray.user= woshidasusu</span><br><span class="line">bintray.apikey= XXXXXXX</span><br></pre></td></tr></table></figure>

<p>bintray.user 就是你的 bintray 网站的登录账号，如果你用 Github 授权登录，就是你的 Github 账号。</p>
<p>bindtray.apikey 需要进入 bintray 网站你的设置里去查看：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-807b30b8f74afb82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="APIkey.png">  </p>
<p>可能你在看别人写的教程文章时，会发现他们在这里还配置了一个  </p>
<p>bintray.gpg.password=YOUR_GPG_PASSWORD  </p>
<p>这个应该是用于将 bintray 上的开源库同步发布到 mavenCentral 仓库里的验证信息吧，反正我测试过，我没配置这个，还是可以正常将本地开源库上传至 bintray 并发布到 JCenter 上面去。</p>
<h3 id="第-4-步：执行-gradle-脚本"><a href="#第-4-步：执行-gradle-脚本" class="headerlink" title="第 4 步：执行 gradle 脚本"></a>第 4 步：执行 gradle 脚本</h3><p>好了，bintray gradle 插件我们配置好了，它运行所需的各种属性我们也配置好了，那么接下去就只是执行它而已了</p>
<p>如果本地有配置 gradle 环境的话，那么直接在 cmd 中以命令行的形式执行脚本即可。</p>
<p>如果没有配置 gradle 环境，那么每个项目的根目录下都有个 gradle 文件夹，里面有 gradle 命名行执行所需的文件，所以可以直接在 Android Studio 的 Terminal 里直接以命令行的形式执行对应脚本即可，如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-bcb056d29fd6ba08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="terminal.png">  </p>
<p>那么如何运行 bintray gradle 插件的脚本呢？只需记录两条命令即可：</p>
<ul>
<li><strong>gradlew   install</strong>  </li>
<li><strong>gradlew   bintrayUpload</strong></li>
</ul>
<p><code>gradlew install</code> 用于将项目编译、打包生成 pom，aar 等文件；  </p>
<p><code>gradlew bintrayUpload</code> 用于将生成的 pom，aar 等文件上传至 bintray 仓库中；</p>
<p>跟编译、运行项目一样，当按顺序分别执行上述两条脚本命名时，如果运行成功，你可以在日志中看到 <code>BUILD SUCCESSFUL</code> 信息，同样，如果脚本运行出错，那么就需要根据日志查看是哪里的问题了，通常就是第 2 步跟第 3 步出了一些问题。  </p>
<p>另外，你还可以通过在 build 文件夹下面查看是否有生成对应的文件来判断 <code>gradlew install</code> 脚本有没有成功执行。然后直接在 bintray 网站你的仓库里查看文件是否有上传来判断 <code>gradlew bintrayUpload</code> 脚本是否有成功执行。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-863b87d875c2f1c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="outputs.png">  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-ac6c8f515f4f35dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="upload.png">  </p>
<h3 id="第-5-步：在-bintray-网站上将-package-发布到-JCenter"><a href="#第-5-步：在-bintray-网站上将-package-发布到-JCenter" class="headerlink" title="第 5 步：在 bintray 网站上将 package 发布到 JCenter"></a>第 5 步：在 bintray 网站上将 package 发布到 JCenter</h3><p><img src="https://upload-images.jianshu.io/upload_images/1924341-f9e6538346985144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发布到JCenter.png">  </p>
<p>接下去就是最后一步了，登录你的 bintray 账号，进入你的仓库里，找到上传的开源库，然后在页面右下角找到 <strong>Add to JCenter</strong> 按钮，点击进去，按照要求填写一下开源库说明，然后就静等几个小时，等收到 JCenter 发给你的审核通过邮件，那么就成功了。</p>
<p>那么这时候，你就可以愉快的在你的新项目中的 build.gradle 文件里直接通过 compile 来将你的开源库依赖到你项目中就可以了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上，就是怎么一步步的将自己的开源库打包发布到 JCenter 的步骤，小结一下，无外乎以下几点：  </p>
<ol>
<li>注册 bintray 账号（可用 Github 授权登录）  </li>
<li>在 bintray 上创建仓库，在仓库下创建 package</li>
<li>准备好本地需要打包发布的项目</li>
<li>在项目中配置 bintray gradle 插件，有两个，一个用于生成 aar，pom 等文件；一个用于将这些文件上传至 bintray 仓库；两个插件均在项目根目录下的 build.gradle 配置插件的 classPath 路径即可</li>
<li>在要打包发布的那个 Module 下的 build.grale 文件中配置两种插件的使用，可直接使用 apply from 配置存储在网上的脚本文件，也可将这脚本模板文件下载到本地使用</li>
<li>apply from 必须要在 build.gradle 文件末尾，另外 exe 代码块需要在 apply from 前面，因为脚本模板文件使用的各种变量需要在 exe 块中先进行声明，赋值</li>
<li>理解 exe 块中的各种配置项的含义</li>
<li>在 Android Studio 的 Terminal 面板直接执行 gradlew install, gradlew bintrayUpload 命令来执行脚本</li>
<li>脚本成功执行结束后，即可在 bintray 网站中找到 Add to JCenter 按钮发布到 JCenter，然后静等邮件消息  </li>
</ol>
<p>最后，还有一篇专门记录我自己在整个过程中遇到的一些问题以及解决方法记录：<br><a href="https://www.jianshu.com/p/a7b491c240ef" target="_blank" rel="noopener">发布开源库到JCenter的一些问题记录</a></p>
]]></content>
      <categories>
        <category>教程类</category>
      </categories>
  </entry>
  <entry>
    <title>一起撸个简单粗暴的Tv应用主界面的网格布局控件（下）</title>
    <url>/2018/05/02/Android-Tv/%E4%B8%80%E8%B5%B7%E6%92%B8%E4%B8%AA%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E7%9A%84Tv%E5%BA%94%E7%94%A8%E4%B8%BB%E7%95%8C%E9%9D%A2%E7%9A%84%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%8E%A7%E4%BB%B6%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>上一篇中我们已经一起学了怎么简单粗暴的撸个支持动态布局的网格控件出来，但在上一篇的介绍中，并没有学习实现网格控件的滑动效果，所以本篇就来讲讲，要如何让我们的网格控件可以支持自定义滑动策略。  </p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="https://upload-images.jianshu.io/upload_images/1924341-51acf54f0bda9948.gif?imageMogr2/auto-orient/strip" alt="当贝市场.gif">  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-218524f08ceefb17.gif?imageMogr2/auto-orient/strip" alt="TvGridLayout示例"></p>
<p>图一是Tv应用：当贝市场的主页  </p>
<p>图二是咱自己撸的简单粗暴的 Tv 应用主界面网格控件：TvGridLayout 的示例，每个 Tab 下，每一屏的卡位大小、位置都是动态计算出来的。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h4 id="第一步：定义布局数据结构"><a href="#第一步：定义布局数据结构" class="headerlink" title="第一步：定义布局数据结构"></a>第一步：定义布局数据结构</h4><h4 id="第二步：自定义-TvGridLayout"><a href="#第二步：自定义-TvGridLayout" class="headerlink" title="第二步：自定义 TvGridLayout"></a>第二步：自定义 TvGridLayout</h4><h4 id="第三步：自定义-Adapter"><a href="#第三步：自定义-Adapter" class="headerlink" title="第三步：自定义 Adapter"></a>第三步：自定义 Adapter</h4><h4 id="第四步：动态布局"><a href="#第四步：动态布局" class="headerlink" title="第四步：动态布局"></a>第四步：动态布局</h4><h4 id="第五步：初步使用"><a href="#第五步：初步使用" class="headerlink" title="第五步：初步使用"></a>第五步：初步使用</h4><p>以上内容是在上一篇中讲解的内容，所以如果还没有看过上一篇的，建议先阅读上一篇<a href="https://www.jianshu.com/p/9deba60113f7" target="_blank" rel="noopener">一起撸个简单粗暴的Tv应用主界面的网格布局控件（上）</a>。那么下面就开始我们今天的内容了：  </p>
<h4 id="第六步：内嵌-OverScroller-自定义滑动策略"><a href="#第六步：内嵌-OverScroller-自定义滑动策略" class="headerlink" title="第六步：内嵌 OverScroller 自定义滑动策略"></a>第六步：内嵌 OverScroller 自定义滑动策略</h4><p>首先，我们的网格控件是继承自 FrameLayout，那么它本身就是没有支持滑动的效果的，但是我们的网格控件又需要支持多屏显示，那么当焦点滑到当前屏之外时，自然就需要将下一屏的卡位滑动到屏幕内进行显示。</p>
<p>而实现滑动效果的方式有两种：</p>
<ul>
<li>将网格控件嵌套在 HorizontalScrollView</li>
<li>自己在网格控件内部实现滑动效果</li>
</ul>
<p>第一种方式实现最简单，我们只要将自己的网格控件 TvGridLayout 嵌套在 HorizontalScrollView 中，就可以实现滑动效果了。</p>
<p>虽然实现最简单，但缺点也很明显，就是滑动的策略只能按照 HorizontalScrollView 规则来，我们并没有办法进行修改。比如说，滑动的持续时长，滑动的距离，什么时候触发滑动等等。</p>
<p>产品的口味可是很刁钻的，单单使用默认的滑动策略，通常是很难满足产品的，虽然也可以通过一些反射等手段来修改 HorizontalScrollView 的默认实现，但有点复杂，且容易出问题。</p>
<p>本着不怕瞎折腾的精神，网格控件既然都已经自己撸了，那滑动的实现干脆也来自己撸好了。</p>
<h5 id="6-1-实现滑动的方式"><a href="#6-1-实现滑动的方式" class="headerlink" title="6.1 实现滑动的方式"></a>6.1 实现滑动的方式</h5><p>想要让一个控件滑动起来的方式很多很多：</p>
<ul>
<li>动画</li>
<li>ViewGroup#onLayout()</li>
<li>View#scrollTo(), View#scrollBy()</li>
<li>OverScroller</li>
<li>…</li>
</ul>
<p>动画也行，重新对子 View 布局，修改子 View 位置也行，调用 View 自带的 scrollTo(), scrollBy() 也行，或者直接用系统提供的滑动辅助类 OverScroller 也行，都行，方式很多，只要能够让控件动起来就行。所以，<strong>让 View 动起来一直就不是个问题，问题是要怎么滑，什么时候滑，滑多长，滑多久，这些问题才是撸个滑动功能的问题所在。</strong></p>
<h5 id="6-2-HorizontalScrollView-滑动原理"><a href="#6-2-HorizontalScrollView-滑动原理" class="headerlink" title="6.2 HorizontalScrollView 滑动原理"></a>6.2 HorizontalScrollView 滑动原理</h5><p>既然滑动要自己撸，那当然是要先参考一下 Google 大神的实现思路了，所以首先就先来看看 HorizontalScrollView 的滑动原理是怎样的？</p>
<p>有一点需要先提一下的是，由于我们是着重分析 Tv 应用的滑动效果，也就是说是由遥控器来触发的滑动效果，那么 HorizontalScrollView 内部跟手指触摸相关的滑动原理就不分析了，着重分析跟 Tv 相关的滑动原理即可。</p>
<p>而 Tv 应用由于都是通过遥控器事件即 KeyEvent 来进行 ui 的交互，那么，理所当然，要查看 HorizontalScrollView 的滑动原理的话，就需要跟着 <code>dispatchKeyEvent()</code> 走下去应该就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HorizontalScrollView#dispatchKeyEvent()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1. 如果事件没有被消耗掉，那么就交由滑动去处理</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.dispatchKeyEvent(event) || executeKeyEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">executeKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_DOWN) &#123;</span><br><span class="line">	<span class="keyword">switch</span> (event.getKeyCode()) &#123;</span><br><span class="line">         <span class="comment">//2. 事件是方向键左键时，那么就向左滑动</span></span><br><span class="line">		<span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_LEFT:</span><br><span class="line">			<span class="keyword">if</span> (!event.isAltPressed()) &#123;</span><br><span class="line">				handled = arrowScroll(View.FOCUS_LEFT);</span><br><span class="line">			&#125;</span><br><span class="line">            ...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">arrowScroll</span><span class="params">(<span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//3. 先寻找下个焦点的 view</span></span><br><span class="line">	View nextFocused = FocusFinder.getInstance().findNextFocus(<span class="keyword">this</span>, currentFocused, direction);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (nextFocused != <span class="keyword">null</span> &amp;&amp; isWithinDeltaOfScreen(nextFocused, maxJump)) &#123;</span><br><span class="line">        <span class="comment">//4. 根据下个焦点的位置，去计算是否需要进行滑动，需要的话那么计算滑动多长的距离</span></span><br><span class="line">		nextFocused.getDrawingRect(mTempRect);</span><br><span class="line">		offsetDescendantRectToMyCoords(nextFocused, mTempRect);</span><br><span class="line">		<span class="keyword">int</span> scrollDelta = computeScrollDeltaToGetChildRectOnScreen(mTempRect);</span><br><span class="line">        <span class="comment">//5. 根据计算出来的滑动距离去处理滑动逻辑</span></span><br><span class="line">		doScrollX(scrollDelta);</span><br><span class="line">		nextFocused.requestFocus(direction);</span><br><span class="line">	&#125; </span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScrollX</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delta != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//6. HorizontalScrollView默认是开启了平衡滑动，但可也通过接口关掉</span></span><br><span class="line">		<span class="keyword">if</span> (mSmoothScrollingEnabled) &#123;</span><br><span class="line">			smoothScrollBy(delta, <span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			scrollBy(delta, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">smoothScrollBy</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> (duration &gt; ANIMATED_SCROLL_GAP) &#123;</span><br><span class="line">        <span class="comment">//7. 如果处于边界情况，那么需要对计算出来的滑动长度进行修正，确保边界情况不会出问题</span></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> width = getWidth() - mPaddingRight - mPaddingLeft;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> right = getChildAt(<span class="number">0</span>).getWidth();</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> maxX = Math.max(<span class="number">0</span>, right - width);</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">		dx = Math.max(<span class="number">0</span>, Math.min(scrollX + dx, maxX)) - scrollX;</span><br><span class="line">		<span class="comment">//8. 上述步骤均只是用于计算需要滑动的距离值，计算出来后滑动的实现交由mScroller处理</span></span><br><span class="line">		mScroller.startScroll(scrollX, mScrollY, dx, <span class="number">0</span>);</span><br><span class="line">		postInvalidateOnAnimation();</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9. mScroller是OverScroller的实例</span></span><br><span class="line"><span class="keyword">private</span> OverScroller mScroller;</span><br></pre></td></tr></table></figure>

<p>HorizontalScrollView 的滑动原理，例如是如何计算滑动距离的以及都有哪些会触发滑动的场景等等，就不深入去分析了，这不是本篇的目的，以后有时间再抽空来梳理。</p>
<p>所以，只需要跟着遥控器事件 <code>dispatchKeyEvent()</code> 走下去后，就可以找到原来 HorizontalScrollView 内部是通过 OverScroller 来实现的滑动效果。</p>
<p>而且，梳理了 HorizontalScrollView 从接收到遥控器事件到最终实现滑动的一个整体的流程后，我们再自己撸滑动的功能时，也可以参考这个思路、这个流程来写，所以这也是阅读源码的好处，大伙有时间得多抽抽时间来阅读源码多学习学习。</p>
<h5 id="6-3-OverScroller-原理"><a href="#6-3-OverScroller-原理" class="headerlink" title="6.3 OverScroller 原理"></a>6.3 OverScroller 原理</h5><p>既然 HorizontalScrollView 内部是通过 OverScroller 来处理滑动的相关逻辑的，那么，我们也用 OverScroller 来做好了，向 Google 大佬模仿借鉴。</p>
<p>网上关于 OverScroller 的使用教程很多，本篇就不着重讲了，要理解一点的是，OverScroller 只是一个滑动辅助类。</p>
<p>说得白一点也就是，<strong>我们只需要告诉 OverScroller 我们想滑动多长的距离，多久时间滑完，那么，OverScroller 内部就会根据每一帧的时间去计算当前帧时滑动的进度</strong>。然后，我们再每一帧通过 OverScroller 计算出的滑动进度，去作用到需要滑动的 View 上面来达到滑动的效果。</p>
<p>如果有看过我前面几篇关于动画的博客分析的话，那么上面这点就会很清楚了。OverScroller 实现滑动的整个流程原理跟属性动画的 ValueAnimator 非常相似，两个类内部都没有任何涉及 ui 的操作，两个类的作用都是用于根据当前帧的时间计算当前帧时的进度值。</p>
<p>唯一有区别的点就是，ValueAnimator 内部会自己通过 Choreographer 去监听每一帧的屏幕刷新信号，然后内部在接收到每一帧信号时就会自动去根据当前帧时间计算；而 <strong>OverScroller 内部并没有任何监听屏幕刷新信号的逻辑，也就是说，如果要使用 OverScroller 的话，我们需要在接收到每一帧的屏幕刷新信号时手动去通知 OverScroller，它才可以正确去工作</strong>。</p>
<p>这就是为什么，大伙在网上搜 OverScroller 的使用教程时，基本每一篇都会提到说 OverScroller 需要跟 View 的 <code>computeScroll()</code> 一起使用的原因。</p>
<p><code>computeScroll()</code> 是 View 中的一个空方法，在 <code>draw()</code> 方法中被调用。所以，只要我们能够让需要滑动的 View 在滑动的这段时间内，每一帧都通知 View 进行重绘刷新，那么它每一帧就都会走到 <code>computeScroll()</code>，这样我们就可以在 <code>computeScroll()</code> 中手动去通知 OverScroller，它内部就可以根据当前帧时间去计算滑动的工作了。</p>
<p>这也是为什么，大伙搜 OverScroller 的使用教程时，基本每篇也说了，在调用了 <code>startScroll()</code> 之后需要紧接着调用 View 的 <code>postInvalidateOnAnimation()</code> ，否则滑动就会失效的原因。因为我们只有通知了 View 需要重绘，<code>computeScroll()</code> 才会被调用，才可以再手动去通知 OverScroller 进行工作。</p>
<h5 id="6-4-触发滑动的时机"><a href="#6-4-触发滑动的时机" class="headerlink" title="6.4 触发滑动的时机"></a>6.4 触发滑动的时机</h5><p>搞清了 OverScroller 的原理后，那么如果要在我们自己的网格控件里撸滑动逻辑的话，也可以大概清楚需要撸哪些代码了。</p>
<p>因为 OverScroller 只负责根据我们指定的滑动距离和持续时长，在每一帧里去计算滑动进度的工作。那么，到底需要滑动多长的距离，持续多久，什么时候触发滑动，这三者就是自定义有滑动效果控件需要撸出来的代码了。</p>
<p>我们只针对 Tv 应用的话，显然，滑动的时机就在于遥控器事件了，这是第一点。</p>
<p>HorizontalScorllView 是在 <code>dispatchKeyEvent()</code>中，每次都去检查是否需要滑动，而满足滑动的条件则是下个焦点的 View 是否在屏幕上是可见的，而滑动的距离则是将这个不可见的 View 滑动到刚刚好全部可见。当然，它内部还有其它滑动策略，比如整页滑等等，但这些就需要手动去调用相关接口。</p>
<p>仅仅使用 HorizontalScrollView 默认的滑动效果很难满足产品需求，就像开头的当贝市场的示例图，很明显，它的滑动策略跟 HorizontalScrollView  就是不一样的，它是焦点快接近边缘时，就会去触发滑动了，即使下个焦点的 View 还是全部可见时。</p>
<h5 id="6-5-自定义滑动策略"><a href="#6-5-自定义滑动策略" class="headerlink" title="6.5 自定义滑动策略"></a>6.5 自定义滑动策略</h5><p>滑动的时机、滑动的策略、滑动的距离，这些并不是一成不变的，而是取决于业务场景需求；也是因为这样，才想到要自己撸个滑动的功能出来。</p>
<p>下面我会举个例子，将代码思路讲一下，但并不一定适用于你，所以大伙根据自己的需求自己撸一个就行了。</p>
<p>由于 Tv 应用都是通过遥控器控制，因此滑动的时机就在 <code>dispatchKeyEvent()</code>中进行检测就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 事件如果没有被消耗掉，那么就交由滑动去处理</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.dispatchKeyEvent(event) || executeKeyEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的滑动策略：</span></span><br><span class="line"><span class="comment">//如果下个焦点的 View 属于另外一屏的话，那么就触发滑动</span></span><br><span class="line"><span class="comment">//滑动的距离为下一屏的宽度</span></span><br><span class="line"><span class="comment">//这里的下一屏是指上一篇提到的 ScreenEntity 数据模型，因为每个 Tab 下可能存在多屏数据，以屏作为单位来进行滑动，两焦点在两屏之间切换时，就触发滑动</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">executeKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> keyCode = event.getKeyCode();</span><br><span class="line">	<span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_DOWN) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_DPAD_LEFT) &#123;</span><br><span class="line">            <span class="comment">//2. 检测下个焦点的 View 是否是属于另一屏中，是的话，将当前切换的这两屏的下标保存在 sTwoInt中</span></span><br><span class="line">			<span class="keyword">if</span> (checkIfOnBorder(FOCUS_LEFT, sTwoInt)) &#123;</span><br><span class="line">				...</span><br><span class="line">                  <span class="comment">//3. 对外提供屏边界回调，当焦点在两屏之间切换时，触发回调</span></span><br><span class="line">				<span class="keyword">if</span> (mBorderListener != <span class="keyword">null</span> &amp;&amp; mBorderListener.onLeft(sTwoInt[<span class="number">0</span>], sTwoInt[<span class="number">1</span>])) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                 <span class="comment">//4. 如果外部在接收到屏切换回调时，没有拦截，那么就去触发滑动</span></span><br><span class="line">                 scrollToPage(sTwoInt[<span class="number">1</span>]);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述是提供了一种滑动策略的思路，滑动策略并不一定需要按照系统默认的来，也不一定要按照上述来，适合自己的业务场景就行，不然干嘛要瞎折腾来自己撸这个滑动。</p>
<p>上述的滑动策略思路是当焦点在两屏之间切换时触发滑动，滑动的距离为下一屏的宽度。这种策略就完全不同于系统默认的策略，因此 HorizontalScrollView 就排不上用场了，那么就自己撸吧，不就是滑动的时机和滑动的距离计算要自己撸嘛，不难。</p>
<h5 id="6-6-完工"><a href="#6-6-完工" class="headerlink" title="6.6 完工"></a>6.6 完工</h5><p>以上，就将需要撸一个滑动的控件的思路讲完了。</p>
<p>小结一下，如果大伙想要自己撸个滑动的功能的话，很简单，可以用动画、scrollTo() 等方式；</p>
<p>如果大伙选择使用 OverScroller 的话，那么有几点需要注意：</p>
<ul>
<li>OverScroller 只负责根据指定的滑动距离，持续时长来计算每一帧内的滑动进度</li>
<li>因此我们需要在每一帧的屏幕刷新信号事件中手动去通知 OverScroller 进行工作，并取得经过它计算得到的当前帧的滑动进度来手动应用到 View 上</li>
<li>这就是为什么使用 OverScroller 需要结合 <code>View#computeScroll()</code>一起使用，并且在调用了 <code>startScroll()</code> 之后需要紧接着调用 <code>View#postInvalidateOnAnimation()</code>的原因</li>
<li>一个完整的滑动功能需要包括：触发滑动的时机、滑动策略、滑动距离的计算、OverScroller 辅助计算、应用到 View 上</li>
<li>触发滑动的时机可以在 <code>dispatchKeyEvent()</code> 中进行检查是否满足滑动条件</li>
<li>满足滑动的条件和滑动策略以及滑动距离的计算基于具体业务需求而实现</li>
<li>整个流程设计可以参考 HorizontalScrollView 的源码  </li>
</ul>
<p>Github 链接：<a href="https://github.com/woshidasusu/TvUiDemo" target="_blank" rel="noopener">https://github.com/woshidasusu/TvUiDemo</a></p>
]]></content>
      <categories>
        <category>Android-TV</category>
      </categories>
  </entry>
  <entry>
    <title>一起撸个简单粗暴的Tv应用主界面的网格布局控件（上）</title>
    <url>/2018/04/30/Android-Tv/%E4%B8%80%E8%B5%B7%E6%92%B8%E4%B8%AA%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E7%9A%84Tv%E5%BA%94%E7%94%A8%E4%B8%BB%E7%95%8C%E9%9D%A2%E7%9A%84%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%8E%A7%E4%BB%B6%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>这一篇是真的隔了好久了~~，也终于可以喘口气来好好写博客了，这段时间实在是忙不过来了，迭代太紧。好，废话不多说，进入今天的主题。  </p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="https://upload-images.jianshu.io/upload_images/1924341-51acf54f0bda9948.gif?imageMogr2/auto-orient/strip" alt="当贝市场.gif">  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-218524f08ceefb17.gif?imageMogr2/auto-orient/strip" alt="TvGridLayout示例"></p>
<p>图一是Tv应用：当贝市场的主页  </p>
<p>图二是咱自己撸的简单粗暴的 Tv 应用主界面网格控件：TvGridLayout 的示例  </p>
<p>今天这篇就不讲源码，不讲原理了，来讲讲怎么简单粗暴的撸个网格控件出来。  </p>
<p>如果要你实现类似当贝市场主页的这种布局，你会怎么做？顶部的 Tab 栏先不管，就每个 Tab 下的卡位列表是不止一屏的，注意看，在同一个 Tab 下是可以左右切屏的；而且每个 Tab，每一屏下的卡位样式、大小是不一样的；</p>
<p>以前在 Github clone 别人开源的主页网格布局的项目时，发现，他们好多都是将网格的布局写死的，就直接在 xml 中写死第一个卡位小卡位，第二个卡位中卡位…</p>
<p>写死肯定是不行的，那么多 Tab，每个 Tab 下还可能会是多屏的，所以最好是要能够根据布局数据来动态计算网格的位置和大小。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>你问我为啥不用系统自带的 GridLayout 实现，为啥要自己撸一个？  </p>
<p>原因1：我忘记了，忘记有这个控件了~~  </p>
<p>原因2：事后大概过了下 GridLayout 基本使用，发现它比较适用于卡位样式是固定的场景，比如某个 Tab 下个网格布局，每个卡位的位置、大小都是固定的，那么用它就很容易实现。  </p>
<p>原因3：反正我就是想自己撸一个~  </p>
<p>好了，开始分析，要怎么来撸这么一个网格控件呢？  </p>
<h4 id="第一步：定义布局数据结构"><a href="#第一步：定义布局数据结构" class="headerlink" title="第一步：定义布局数据结构"></a>第一步：定义布局数据结构</h4><ul>
<li>ElementEntity</li>
</ul>
<p>首先，第一步，因为我们的网格控件是要支持根据布局数据来动态计算每个卡位的大小、位置信息的，那么布局数据就需要提供每个卡位的位置信息以及每屏的横纵，所以每个卡位的数据结构可以像下面这么定义：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElementEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;<span class="comment">//卡位坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;<span class="comment">//卡位坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> row;<span class="comment">//卡位长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> column;<span class="comment">//卡位宽度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String imgUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为咱撸的网格控件是要动态来计算卡位的大小、位置的，计算的方式有很多种，我们采取的是<strong>将当前屏按照布局数据平均划分成 n 个小格，统一以每个小格的左上角作为坐标起点，那么每个卡位就需要提供 x,y 的坐标起点，用于计算它的位置，以及 row, column 表示当前这个卡位横向占据了 row 个小格，竖直方向占据了 column 个小格。</strong>   </p>
<p>只要每个卡位提供了这些数据，那么就可以根据卡位各自不同的数据实现不同的卡位样式、大小了。  </p>
<ul>
<li>ScreenEntity</li>
</ul>
<p>然后卡位是属于每个 Tab 下的其中一屏里的，所以每一屏的所有卡位构成一组卡位列表，不同屏卡位列表应该是独立的，所以每一屏的数据结构可以这么定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> row;<span class="comment">//横向划分成几行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> column;<span class="comment">//竖直方向划分成几列</span></span><br><span class="line">    <span class="comment">//row, column 用于将当前屏平均划分成 row * column 个小格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ElementEntity&gt; elementList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使是同一个 Tab 下的每一屏的样式都是不一样的，所以每一屏要平均划分成几个小格，由每屏自己决定。</p>
<ul>
<li>MenuEntity</li>
</ul>
<p>每个 Tab 可以表示一个菜单，Tab 下有多屏的卡位，所以它的数据结构可以像下面这么定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ScreenEntity&gt; screenList;<span class="comment">//一个Tab 下可能有多屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>LayoutEntity</li>
</ul>
<p>主页是可能含有多个 Tab 的，所以主页的布局数据可以像下面这么定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuEntity&gt; menuList;<span class="comment">//可能含有多个 Tab 菜单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>json</li>
</ul>
<p>综上，汇总一下，主页的布局数据结构可以是长这个样子的：  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"menuList"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"menuName"</span>: <span class="string">"影视娱乐"</span>,</span><br><span class="line">            <span class="attr">"screenList"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"row"</span>: <span class="number">6</span>,</span><br><span class="line">                    <span class="attr">"column"</span>: <span class="number">4</span>,</span><br><span class="line">                    <span class="attr">"elementList"</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"x"</span>: <span class="number">3</span>,</span><br><span class="line">                            <span class="attr">"y"</span>: <span class="number">1</span>,</span><br><span class="line">                            <span class="attr">"row"</span>: <span class="number">3</span>,</span><br><span class="line">                            <span class="attr">"column"</span>: <span class="number">1</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"x"</span>: <span class="number">4</span>,</span><br><span class="line">                            <span class="attr">"y"</span>: <span class="number">1</span>,</span><br><span class="line">                            <span class="attr">"row"</span>: <span class="number">6</span>,</span><br><span class="line">                            <span class="attr">"column"</span>: <span class="number">1</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"x"</span>: <span class="number">2</span>,</span><br><span class="line">                            <span class="attr">"y"</span>: <span class="number">4</span>,</span><br><span class="line">                            <span class="attr">"row"</span>: <span class="number">3</span>,</span><br><span class="line">                            <span class="attr">"column"</span>: <span class="number">2</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"x"</span>: <span class="number">1</span>,</span><br><span class="line">                            <span class="attr">"y"</span>: <span class="number">1</span>,</span><br><span class="line">                            <span class="attr">"row"</span>: <span class="number">6</span>,</span><br><span class="line">                            <span class="attr">"column"</span>: <span class="number">1</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"x"</span>: <span class="number">2</span>,</span><br><span class="line">                            <span class="attr">"y"</span>: <span class="number">1</span>,</span><br><span class="line">                            <span class="attr">"row"</span>: <span class="number">3</span>,</span><br><span class="line">                            <span class="attr">"column"</span>: <span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这第一步很关键，尤其是每个卡位的数据结构和每一屏的数据结构定义，因为网格布局的动态实现就是根据这些数据来计算的。  </p>
<h4 id="第二步：自定义-TvGridLayout"><a href="#第二步：自定义-TvGridLayout" class="headerlink" title="第二步：自定义 TvGridLayout"></a>第二步：自定义 TvGridLayout</h4><p>想想，咱要撸的网格控件，一是要支持动态计算卡位大小、位置；二是支持卡位超出一屏，在屏幕外也能绘制，这样当切屏时就可以直接滑到下一屏显示了。</p>
<p>基于这两点，我们就不继承自 ViewGroup 然后全部自己写了，简单粗暴点，我们继承自 FrameLayout 就行，然后只要将计算出来的卡位位置通过 FrameLayout 的 LayoutParams 来指定在绝对坐标系下的位置，最后跟卡位样式的 View 一起添加进 FrameLayout 就可以了。</p>
<p>好，开工：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TvGridLayout</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">private</span> Adapter mAdapter;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TvGridLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(Adapter adapter)</span> </span>&#123;</span><br><span class="line">        mAdapter = adapter;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        	layoutChildren();<span class="comment">//动态计算每个卡位大小、位置进行布局</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//卡位信息来源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> </span>&#123; </span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想想，撸了一个网格控件，我们要怎么使用方便呢</p>
<p>这里参考了 RecyclerView 的思路，TvGridLayout 网格控件就只提供纯粹的布局功能，至于每个卡位长啥样，大小、位置等都交由 Adapter 去实现。</p>
<p>也就是说，要使用 TvGridLayout 网格控件时，我们只要像使用 RecyclerView 那样写一个继承自 TvGridLayout.Adapter 的 Adapter，然后实现它的抽象方法，向 TvGridLayout 提供必要的布局数据即可。</p>
<h4 id="第三步：自定义-Adapter"><a href="#第三步：自定义-Adapter" class="headerlink" title="第三步：自定义 Adapter"></a>第三步：自定义 Adapter</h4><p>那么，TvGridLayout 需要哪些必要的布局数据呢，换句话说，我们该怎么来定义 Adapter 的抽象方法呢？</p>
<p>想想，我们的网格控件是支持多屏的，而每一屏下都可以有多个卡位，所以我们需要总屏数和每屏下面的卡位数量：</p>
<ul>
<li><code>public abstract int getPageCount()</code></li>
<li><code>public abstract int getChildCount(int pageIndex)</code></li>
</ul>
<p>而且每一屏的样式是可以不一样的，换句话说，每一屏具体要平均划分成多少个小格，也就是几行几列，这些数据也是需要的，所以：</p>
<ul>
<li><code>public abstract int getPageRow(int pageIndex)</code>​</li>
<li><code>public abstract int getPageColumn(int pageIndex)</code>  </li>
</ul>
<p>大局的样式搞定了，接下去就是每个卡位了，卡位需要什么信息呢？其实就三点，位置、大小、长啥样。为了方便，我们可以将位置和大小信息经过一层转换后封装起来，那么：</p>
<ul>
<li><code>public abstract ItemCoordinate getChildCoordinate(int pageIndex, int childIndex)</code></li>
<li>​<code>public abstract View getChildView(int groupPosition, int childPosition, int childW, int childH);</code></li>
</ul>
<p>好，这样一来，TvGridLayout 所需的布局数据就都有了，使用过程中，只要继承 TvGridLayout.Adapter 然后实现相应的抽象方法，根据我们第一步里定义的数据结构，提供相对应的布局数据，那么布局的工作就都交由 TvGridLayout 内部去实现就好了。</p>
<p>来看一下整个代码：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getPageRow</span><span class="params">(<span class="keyword">int</span> pageIndex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getPageColumn</span><span class="params">(<span class="keyword">int</span> pageIndex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ItemCoordinate <span class="title">getChildCoordinate</span><span class="params">(<span class="keyword">int</span> pageIndex, <span class="keyword">int</span> childIndex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> View <span class="title">getChildView</span><span class="params">(<span class="keyword">int</span> groupPosition, <span class="keyword">int</span> childPosition, <span class="keyword">int</span> childW, <span class="keyword">int</span> childH)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getChildCount</span><span class="params">(<span class="keyword">int</span> pageIndex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getPageCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSwitchAdapter</span><span class="params">(Adapter newAdapter, Adapter oldAdapter)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式跟 RecyclerView 很类似，简单粗暴。有一点不同的是，在 RecyclerView.Adapter 里，我们的 item View 的大小是交由自己决定的，想多大就多大。但在这里，item View 的大小位置都是由服务端下发的布局数据决定的，而这些数据直接就交由 TvGridLayout 内部处理了，所以可以看到，<code>getChildView()</code> 方法的参数里，我们将当前卡位的大小传给 Adapter 了，这点跟平时使用中可能有点不一样。</p>
<h4 id="第四步：动态布局"><a href="#第四步：动态布局" class="headerlink" title="第四步：动态布局"></a>第四步：动态布局</h4><p>布局数据的数据结构定好了，TvGridLayout 也通过 Adapter 拿到所需的布局数据了，那么接下去就是要根据这些数据来进行动态计算，完成布局工作了。这些工作都是在 TvGridLayout 内部完成，触发布局工作的时机可以是在 <code>setAdapter()</code> 中，当外部传进来一个 Adapter 时，我们就可以进行布局工作了，方法命名为 <code>layoutChildren()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方便优化</span></span><br><span class="line">    layoutChildrenOfPages(<span class="number">0</span>, mAdapter.getPageCount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">layoutChildrenOfPages</span><span class="params">(<span class="keyword">int</span> fromPage, <span class="keyword">int</span> toPage)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取网格控件的宽度和高度（即每屏的大小）</span></span><br><span class="line">	<span class="keyword">int</span> contentWidth = mWidth - getPaddingLeft() - getPaddingRight();</span><br><span class="line">	<span class="keyword">int</span> contentHeight = mHeight - getPaddingTop() - getPaddingBottom();</span><br><span class="line">    <span class="comment">//2. 遍历每一屏</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = fromPage; j &lt; toPage; j++) &#123;</span><br><span class="line">        <span class="comment">//3. 获取第j屏的行数和列数</span></span><br><span class="line">     	<span class="keyword">int</span> column = mAdapter.getPageColumn(j);<span class="comment">//列数</span></span><br><span class="line">    	<span class="keyword">int</span> row = mAdapter.getPageRow(j);<span class="comment">//行数</span></span><br><span class="line">        <span class="comment">//4. 根据行数和列数以及网格控件的大小，将当前j屏平均划分成 column * row 个小格</span></span><br><span class="line">     	<span class="keyword">float</span> itemWidth = (contentWidth) * <span class="number">1.0f</span> / column;<span class="comment">//每个小格的宽度</span></span><br><span class="line">        <span class="keyword">float</span> itemHeight = (contentHeight) * <span class="number">1.0f</span> / row;<span class="comment">//每个小格的高度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pageWidth = <span class="number">0</span>;<span class="comment">//每屏的宽度不一定是充满网格控件的宽度的，有可能当前屏宽度只有一半，所以需要记录当前屏的宽度具体是多少</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">//5. 遍历当前j屏下的每个卡位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mAdapter.getChildCount(j); i++) &#123;</span><br><span class="line">            <span class="comment">//6. 获取当前卡位的位置、大小信息</span></span><br><span class="line">            ItemCoordinate childCoordinate = mAdapter.getChildCoordinate(j, i);</span><br><span class="line">            <span class="keyword">if</span> (childCoordinate == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//7. 如果当前卡位没有对应的位置大小信息</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pointStartX = childCoordinate.start.x;</span><br><span class="line">            <span class="keyword">int</span> pointStartY = childCoordinate.start.y;</span><br><span class="line">            <span class="keyword">int</span> pointEndX = childCoordinate.end.x;</span><br><span class="line">            <span class="keyword">int</span> pointEndY = childCoordinate.end.y;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//8. 根据卡位的布局信息（位置，长度）计算卡位的大小</span></span><br><span class="line">            <span class="keyword">int</span> width = (<span class="keyword">int</span>) ((pointEndX - pointStartX) * itemWidth);</span><br><span class="line">            <span class="keyword">int</span> height = (<span class="keyword">int</span>) ((pointEndY - pointStartY) * itemHeight);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//9. 根据卡位的布局信息（位置，长度）计算卡位的位置，直接计算处于父控件坐标系下的绝对位置</span></span><br><span class="line">            <span class="keyword">int</span> marginLeft = (<span class="keyword">int</span>) (pointStartX * itemWidth + contentWidth * j);</span><br><span class="line">            <span class="keyword">int</span> marginTop = (<span class="keyword">int</span>) (pointStartY * itemHeight);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (marginLeft &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                marginLeft = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (marginTop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                marginTop = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//10. 获取卡位的样式，想长啥样，Adapter 自己决定</span></span><br><span class="line">            View view = mAdapter.getChildView(j, i, width, height);</span><br><span class="line">            <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//11. 如果当前位置的卡位没有配置，那么就不参与布局中</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//12. 通过 LayoutParams 来进行布局，参数传进卡位大小，</span></span><br><span class="line">            LayoutParams params = <span class="keyword">new</span> LayoutParams(width - mItemSpace * <span class="number">2</span>, height - mItemSpace * <span class="number">2</span>);<span class="comment">//扣除间距</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//13. 通过 leftMargin,topMargin 来决定卡位的位置</span></span><br><span class="line">            params.topMargin = marginTop + mItemSpace;</span><br><span class="line">            params.leftMargin = marginLeft + mItemSpace;</span><br><span class="line">            <span class="comment">//14. 将卡位信息直接存储在卡位的 LayoutParams 中，方便后续直接使用</span></span><br><span class="line">            params.itemCoordiante = childCoordinate;</span><br><span class="line">            params.pageIndex = j;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//15. 记录当前屏的长度，因为每一屏不一定会充满整个父控件，可能一个Tab下有三屏，但第二屏只配置了一半的卡位</span></span><br><span class="line">            <span class="keyword">int</span> maxWidth = marginLeft + width - contentWidth * j;</span><br><span class="line">            pageWidth = Math.max(pageWidth, maxWidth);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//16. 记录这个 Tab 下的网格控件的总长度</span></span><br><span class="line">            <span class="keyword">int</span> maxRight = marginLeft + width;</span><br><span class="line">            mRightEdge = Math.max(mRightEdge, maxRight);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//17. 记录每一屏的第一个卡位，方便后续如果需要操作默认焦点</span></span><br><span class="line">            <span class="keyword">if</span> (childCoordinate.start.x == <span class="number">0</span> &amp;&amp; childCoordinate.start.y == <span class="number">0</span>) &#123;</span><br><span class="line">                mFirstChildOfPage.put(j, view);</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//18. 添加进父容器中，完成布局</span></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; childCoordinate.start.x == <span class="number">0</span> &amp;&amp; childCoordinate.start.y == <span class="number">0</span>) &#123;</span><br><span class="line">                addView(view, <span class="number">0</span>, params);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addView(view, params);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态计算的布局逻辑看代码注释吧，注释很详细了~</p>
<p>另外，我们将卡位的位置、大小信息封装到 ItemCoordinate 中去了，这是为了方便使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemCoordinate</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Point start;<span class="comment">//左上角坐标</span></span><br><span class="line">	<span class="keyword">public</span> Point end;<span class="comment">//右下角坐标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 只要有左上角和有下角坐标，就可以确定卡位的位置和大小了。另外，这里的坐标系并不是 Android 意义上的坐标系，它是以每个小格为单元的坐标系，并不是具体的 px 数值，画张图看看就容易理解了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-083c7683c7f8c27f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="坐标系.png"></p>
<p>还有，我们自定义了一个 LayoutParams 继承自 FrameLayout.LayoutParams，没什么特别的，就单纯是为了将一些卡位的信息直接跟卡位绑定存储起来，方便后续需要的时候直接使用，而不至于还得自己创建一个 map 来维护管理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span>.<span class="title">LayoutParams</span> </span>&#123;</span><br><span class="line">	ItemCoordinate mItemCoordinate;<span class="comment">//卡位的位置、大小信息</span></span><br><span class="line">	<span class="keyword">int</span> pageIndex;<span class="comment">//卡位属于哪一屏的</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第五步：初步使用"><a href="#第五步：初步使用" class="headerlink" title="第五步：初步使用"></a>第五步：初步使用</h4><p>好了，到这里，一个简单粗暴的网格控件就实现了，支持根据布局数据动态计算卡位位置、大小；支持一个 Tab 下有多屏，每屏的大小、样式都可以由自己决定；</p>
<p>想想，其实实现很简单，就是要定义好布局数据的数据结构，然后服务端需要提供每一屏以及每一个卡位的位置、大小信息，最后类似于 RecyclerView 的用法，使用时自己写一个 Adapter 来提供对应数据以及卡位的 View，就没了。</p>
<p>但到这里，其实控件是不支持滑动的。</p>
<p>因为我们到这里写的 TvGridLayout 并没有去处理滑动的工作，当然滑不了了，那想要让它滑动，也特别简单，修改一下 xml 布局文件，在 TvGridLayout 外层放一个 HorizontalScrollView  控件，那么它就可以滑动了。</p>
<p>不过，这种滑动有一些不足是，滑动的策略只能按照系统的来，滑动的时长不能修改。这样的话，可能会没法满足产品那刁钻的口味。既然，网格控件都自己撸了，那干脆滑动也自己实现好了，这样想怎么滑就怎么滑，想滑多远就滑多远，想滑多久就多久，还怕伺候不好产品么。</p>
<p>不过，本篇篇幅已经很长了，怎么自己实现滑动，就放到下一篇再来讲吧。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>最后，再总结一下咱自己撸出来的这个网格控件：</p>
<ul>
<li>优点：简单、粗暴，支持多屏，支持动态设置不同屏的样式、大小，支持动态设置卡位的位置、大小</li>
<li>优点：等下篇讲完自己撸个滑动的功能，那么就支持想怎么滑就怎么滑，不怕伺候不了产品</li>
<li>优点：支持每屏卡位不一定要全部充满屏，屏大小不一定要充满父控件</li>
<li>缺点：不成熟、不稳定，可能存在一些问题</li>
<li>缺点：还没有复用之类的考量，所有屏的所有的卡位都是在设置完 <code>setAdapter()</code> 之后就全部绘制出来了</li>
<li>缺点：需要服务端提供布局数据</li>
</ul>
<p>不管了，反正先撸个简单、粗暴的控件出来再说，以后再一步步慢慢优化~</p>
<p>等后面找时间梳理完自定义 View 的测量、布局、绘制流程原理，ViewGroup 的原理，焦点机制原理，这些要是都梳理清楚之后，这个控件肯定能得到极大的升华的，期待中~~    </p>
<p>下一篇跳转：<a href="https://www.jianshu.com/p/c7da8d36be21" target="_blank" rel="noopener">一起撸个简单粗暴的Tv应用主界面的网格布局控件（下）</a></p>
<p>Github 链接：<a href="https://github.com/woshidasusu/TvUiDemo" target="_blank" rel="noopener">https://github.com/woshidasusu/TvUiDemo</a></p>
]]></content>
      <categories>
        <category>Android-TV</category>
      </categories>
  </entry>
  <entry>
    <title>分享两个提高效率的AndroidStudio小技巧</title>
    <url>/2018/03/31/%E6%95%99%E7%A8%8B%E7%B1%BB/%E5%88%86%E4%BA%AB%E4%B8%A4%E4%B8%AA%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84AndroidStudio%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 hongyangAndroid （鸿洋）独家发布</strong>  </p>
</blockquote>
<p>这次分享两个 Android Studio 的小技巧，能够有效提高效率和减少犯错，尤其是在团队协作开发中。  </p>
<ol>
<li><strong>Getter 模板修改–自动处理 null 判断</strong>  </li>
<li><strong>格式化代码自动整理方法位置–广度 or 深度</strong>   </li>
</ol>
<p>好了，下面优先介绍下这两个小技巧有什么作用，然后再给出使用教程，想直接看教程的可以直接跳到最后。  </p>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><ol>
<li>Getter 模板修改  </li>
</ol>
<p>开发过程中，经常会遇到空指针异常，尤其是在线上 bug 中，由于未进行 null 判断处理导致的 bug 比例肯定不低。  </p>
<p>另外，model 层经常需要根据服务端接口返回的数据结构进行建模，实体类中常见的有 <strong>String</strong> 类型和 <strong>List</strong> 类型的字段。而服务端的接口文档里通常都会说明哪些字段不会为空，所以移动端建模后使用相应的实体类数据时，很少或者说会经常性忘记去做 null 判断处理。  </p>
<p>正常场景下，也许测不出 null 异常的问题，但如果服务器出了问题，返回了错误的数据，或者在某些特殊的场景下，某些字段的值偏偏就是 null，那么此时如果在使用的地方没有进行 null 判断处理，经常就会有问题出现，如果 app 刚好又有缓存策略，那么可能会导致特别严重的问题。  </p>
<p>鉴于此，我是建议，在建模创建实体类时，如果有 <strong>String</strong> 类型和 <strong>List</strong> 类型的变量时，这些类型的 <strong>getXXX()</strong> 方法中直接进行 null 判断处理，确保不会返回 null 值，这样外部使用时就不用再去进行 null 判断处理。如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String mString;</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; mList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果String类型的字段为空，那么返回""，外部在使用getString().equal()等之类方法时如果忘记进行null判断，也不会造成空指针异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mString == <span class="keyword">null</span> ? <span class="string">""</span> : mString;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果List类型字段为空，那么返回空列表。外部在使用getList().get(i)或者getList().size()等时如果忘记进行null判断，也不会造成空指针异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样处理的好处是统一在实体类内部进行 null 判断处理，外部使用的地方无需再一个个的去进行 null 判断处理，如果外部使用时忘记进行 null 判断处理，也不会导致空指针异常。  </p>
<p>但，如果每次创建完实体类后都靠开发人员的主观意识来为对应的 getXXX() 方法增加相应的 null 判断处理代码，很不靠谱。<strong>一切靠主观意识来遵守的规范都不靠谱，总会由于各种原因，如任务赶，太久未接触等等而忘记。</strong>  </p>
<p>所以，<strong>推荐 getXXX() 方法都通过 Android Studio 来自动生成相应代码，那么，就可以通过修改 AS 的 Getter 方法的模板文件，来达到自动生成相应的 null 判断处理代码</strong>，以工具代替手工，一提供效率，二强制遵守规范，三解决靠主观意识不靠谱问题。  </p>
<hr>
<ol start="2">
<li>格式化代码自动整理方法位置</li>
</ol>
<p>当 app 经过越来越多的迭代，增加越来越多的功能时，项目难免会逐渐庞大起来，有些类里的代码会渐渐多了起来。</p>
<p>为了易于阅读，通常对类里的代码会根据各自的职能划分到一个个方法中，尽量遵守方法的单一职责，这样一来，各个方法之间难免会有关联关系，a 方法调用了 b,c 方法，b  方法调用了 d 方法，等等。</p>
<p>这么多的方法，如果不按照一定的规范来整理、摆放的话，当类里的方法越来越多时，这些方法位置杂乱无章的摆放会给 review 人员的阅读，或者过了很长一段时间后本人回来自己阅读时造成一定的障碍。</p>
<p>常见的是规范有一种是按照权限来归纳整理，private 方法集中在一起，public 方法集中在一起。</p>
<p>还有一种规范是按照就近原则摆放，a 方法调用了 b 方法，那么 b 方法位置就尽量靠近 a，我个人倾向于这一种规范，这样在熟悉一个类里的代码时，从上往下慢慢过下来即可，不同跳过来跳过去的。  </p>
<p>那么，同样的问题，靠开发人员的主观意识来遵守这种规范是很不靠谱的。写代码过程中，新建了一个方法时，并不会特别特意的去考虑要将它放在哪，基本就是就近放，这样也还好，还算稍微有些关联，有些顺序。</p>
<p>但，如果是在后期新增功能，在旧代码中又去新建方法时，如果对这个类不熟悉，这时候通常都不会去仔细的考虑新写的方法应该要放在哪，要么就是放最后，要么随手就近，久而久之，类里的方法就会越来越杂乱无章。  </p>
<p><strong>所以，一切靠主观意识来遵守规范的行为都不靠谱。</strong>  </p>
<p>鉴于此，<strong>推荐打开 Android Studio 自动整理方法位置的功能，借助工具来遵守规范，提高效率的同时也能写出优美的代码。</strong>  </p>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><h3 id="Getter模板修改教程"><a href="#Getter模板修改教程" class="headerlink" title="Getter模板修改教程"></a>Getter模板修改教程</h3><ol>
<li>随便建个类，写几个属性，然后按快捷键 <strong>Alt + Insert</strong> 或在代码区域 <strong>右键 -&gt; Generate -&gt; Getter，</strong>然后会有一个弹框：</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-d568cdffa6253e4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一步">  </p>
<ol start="2">
<li>此时先不要点击 OK 键，先点击右上角的 <strong>…</strong> <strong>的图标</strong>，来修改模板文件：  </li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-b5eeb525851d6209.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二步.png">  </p>
<ol start="3">
<li>此时只有一份 AS 默认的生成 Getter 方法的模板，要对这份模板进行修改，所以接下去可以选择新建一份新的模板文件或者在原文件上修改都可以，比如我新建了一份 NotNull_getter 模板文件：</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-cc0daa4bc6609c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第三步">  </p>
<ol start="4">
<li>模板文件需要修改的地方就仅仅是在<strong>$(name){…}</strong> 代码块里的 return 生成规则，原本规则是统一返回字段值本身，根据规范新增两条规则：增加 String 类型和 List 类型的生成规则。以下是修改后的整个模板文件代码，可以拷贝过去直接使用：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if($field.modifierStatic)</span><br><span class="line">static ##</span><br><span class="line">#end</span><br><span class="line">$field.type ##</span><br><span class="line">#set($name = $StringUtil.capitalizeWithJavaBeanConvention($StringUtil.sanitizeJavaIdentifier($helper.getPropertyName($field, $project))))</span><br><span class="line">#if ($field.boolean &amp;&amp; $field.primitive)</span><br><span class="line">  #if ($StringUtil.startsWithIgnoreCase($name, &apos;is&apos;))</span><br><span class="line">    #set($name = $StringUtil.decapitalize($name))</span><br><span class="line">  #else</span><br><span class="line">    is##</span><br><span class="line">#end</span><br><span class="line">#else</span><br><span class="line">  get##</span><br><span class="line">#end</span><br><span class="line">$&#123;name&#125;() &#123;</span><br><span class="line">  #if ($field.string)</span><br><span class="line">     return $field.name == null ? &quot;&quot; : $field.name;</span><br><span class="line">  #else </span><br><span class="line">    #if ($field.list)</span><br><span class="line">    if ($field.name == null) &#123;</span><br><span class="line">        return new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    return $field.name;</span><br><span class="line">    #else </span><br><span class="line">    return $field.name;</span><br><span class="line">    #end</span><br><span class="line">  #end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>建完新模板文件后点击 OK 键，以后通过<strong>右键</strong> <strong>-&gt; Generate -&gt; Getter</strong> 来生成 getXXX() 方法时，注意一下模板文件选择是否正确，一般首次选择后以后都是默认上一次的:  </li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-489d9186e775a615.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第五步">  </p>
<ol start="6">
<li>效果，getXXX() 方法都是 AS 自动生成，而且根据修改后的模板，也能保证 String 类型和 List 类型都不会返回null值。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5017663bdb7a4d0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果">  </p>
<hr>
<h3 id="格式化代码自动整理方法位置教程"><a href="#格式化代码自动整理方法位置教程" class="headerlink" title="格式化代码自动整理方法位置教程"></a>格式化代码自动整理方法位置教程</h3><ol>
<li>先开启自动整理方法位置的功能，位置：<br><strong>File -&gt; Settings -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Arrangement</strong>    </li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-7664b2eefe5cee7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="功能开启">  </p>
<p>如上图的 2,3 点功能，默认都是关闭的。  </p>
<p><strong>第 2 点功能：Keep overridden methods together – keep order</strong>  </p>
<p>意思是将由 override 标志的方法都集中放置，建议将此功能开启，override 的方法通常要么是系统的一些回调方法，要么是我们自己定义的一些接口，这部分方法本身就有一定的关联性，集中在一起很合理。  </p>
<p>注意，AS支持两种规则，一种是 keep order（按原有顺序），一种是 order by name（按照方法字母表顺序）。至于哪一种较合适，个人喜好，我是选择的 keep order。   </p>
<p><strong>第3点功能：Keep dependent methods together</strong> </p>
<p>意思是将相关的方法按照某则规则放在一起，AS支持两种规则：  </p>
<p><strong>breadth-first order &amp; depth-first order</strong>   </p>
<p>我的理解，说得通俗点也就是广度优先和深度优先，这个功能建议开启。  </p>
<p>举个例子，假设一个类里有这么几个方法，a 调用了 b, c, d, 而 b 调用了 e, f，如果是按照广度优先来整理这些方法的位置时，breadth-first order:    </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a61611ca05b2a58c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="广度优先">    </p>
<p>广度优先整理后的方法顺序：a, b, c, d, e, f。也就是说，方法 a 里面调用了三个方法，那么优先将这三个方法摆放在方法 a 下方，此时并不去考虑这三个方法里是否还调用了其他方法。等过完方法 a，那么以同样的道理再去整理方法 b 中调用的方法的位置。  </p>
<p>但如果是深度优先，那么整理后的方法顺序就不同了，如下，depth-first order：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5d4f627286ad06d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="深度优先">  </p>
<p>深度优先整理后的方法顺序：a, b, e, f, c, d。也就是说，方法 a 内调用了三个方法，第一个方法是 b, 然后方法 b 又调用了 e, f。所以方法 b 紧接着 a 方法下面摆放，方法 e, f 紧接着方法 b 下面摆放，直到 e, f 里都没有其他方法了。然后再重新回到方法 a 内继续往下过方法 c 的位置，以此类推。  </p>
<p>两种规则有各自的好处，广度优先侧重于优先梳理每个方法的大体工作；而深度优先则侧重于梳理每个方法的实现细节，流程步骤；</p>
<p>目前我是选择广度优先，因为我更侧重于关注每个方法大体的工作，对于一个不熟悉的方法，大概过一下它里面的每个方法大体上做了什么，就能大概理解这个方法的大体工作。  </p>
<ol start="2">
<li>以上仅仅只是开启功能而已，而要借助 Android Studio 来自动整理方法位置，就是通过 AS 的格式化代码功能，快捷键也就是 <strong>Ctrl + Alt + L</strong> 。但这个格式化操作默认是没有启动对方法进行整理的操作的，每次按完快捷键后会有如下提示：  </li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-0e61742bb89c1e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="功能开启2">  </p>
<p>重点在底部那行灰色的字体，通过快捷键 <strong>Ctrl + Alt + Shift + L</strong> 可以打开配置 dialog：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-3b91c79f6eec4c09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置">  </p>
<p><strong>Rearrange code</strong> 默认是没有勾选的，所以想要启用整理方法的功能，需要将这个勾选上，以后在通过 <strong>Ctrl + Alt + L</strong> 来格式化代码时，AS 就会根据我们在第一个步骤中设定的规则来自动整理方法的位置。  </p>
]]></content>
      <categories>
        <category>教程类</category>
      </categories>
  </entry>
  <entry>
    <title>如何用Android Studio查看build.gradle源码</title>
    <url>/2018/03/31/Gradle/%E5%A6%82%E4%BD%95%E7%94%A8Android-Studio%E6%9F%A5%E7%9C%8Bbuild-gradle%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p><strong>2019-7-30 更新：</strong><br>感谢评论区指出，gradle源码下载地址：<a href="http://services.gradle.org/distributions/" target="_blank" rel="noopener">http://services.gradle.org/distributions/</a></p>
<hr>
<p>上一篇博客里讲过 build.gradle 里的每一行代码基本都是在调用一个方法，既然是这样，我们就可以用 android studio(下面简称as) 去查看它源码的方法注释说明，这样就可以理解每个方法是做什么的了，就算是在大神的 build.gradle 遇见一些没看懂的代码，也可以点进去看方法介绍来理解。就像我们在查看 SDK 里的各种方法一样。    </p>
<p>但是有个问题，应该也有小伙伴跟我一样吧，每次在大神的 build.gradle 看到一堆不懂的代码时，按住 <code>Ctrl</code> 键后，鼠标移到代码上时有个跳转的手势时总是很开心，总是心想原来可以看源码啊，那就点进去看看介绍，看这个是干嘛的吧。可是每次一点进去，打开的却是 class 代码文件，顶多就只有方法名，一点注释都没有，而且方法参数命名还混淆过，也猜不出来是干嘛的。又不懂怎么去官方文档里查找，只能去网上用关键字查找，找出来的又跟自己碰到的问题不一样，越找越气干脆不找了，放一边去，以后再说。  </p>
<p>是吧，如果可以直接通过 as 看源码的注释该多好。好了，废话到这，下面开始正文。    </p>
<hr>
<h1 id="系列索引"><a href="#系列索引" class="headerlink" title="系列索引"></a>系列索引</h1><p>build.gradle系列一：<a href="http://www.jianshu.com/p/a3805905a5c7" target="_blank" rel="noopener">看不懂的build.gradle代码</a><br>build.gradle系列二：<a href="http://www.jianshu.com/p/501726c979b1" target="_blank" rel="noopener">学点Groovy来理解build.gradle代码</a><br>build.gradle系列三：<a href>如何用Adnroid Studio查看build.gradle源码</a><br>…  </p>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们来举个例子，就像系列一的博客里介绍的 build.gradle 里有这样一段代码：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-d46a0d67f548a7aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build.gradle"><br>咦！这代码是第一次在 build.gradle 里看见过，是什么意思呢？不怕，我有绝招：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-5d5db8368916117f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Ctrl + 左键"><br>Android Studio大法—看源码，还有什么是不能通过看源码注释解决的么<br><img src="http://upload-images.jianshu.io/upload_images/1924341-4b6cd41069f7fa21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BaseExtension.class"><br>是跳到源码了，可是为什么没有方法的注释说明呢，这方法是什么鬼谁知道啊。再仔细看看 as 的提示，原来打开的是个 class 文件啊。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-c55417ff2530580f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="as提示"><br>as 的提示那里应该会有个下载和选择源码位置的按钮的啊，搞不懂为什么不出现。  </p>
<p>另外，我们知道，as 一般会默认先打开 xxx-sources.jar 也就是 xxx 的 java 文件源码，如果没有源码文件，才会打开 xxx.jar 的 class 代码。我们看一下，打开的是什么文件。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-9692f8b22bf2eda3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle-2.3.0.jar"><br>没错，as 打开的是 gradle-2.3.0.jar，说明 as 没有找到 gradle-2.3.0-sources.jar 源码文件，我们看一下到底是不是这样<br><img src="http://upload-images.jianshu.io/upload_images/1924341-53c68923912bf799.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="as标题栏"><br>as 标题栏会显示你当前打开的文件的具体位置，好了，知道了 gradle-2.3.0.jar 在电脑里的位置了，我们到那个目录下看看<br><img src="http://upload-images.jianshu.io/upload_images/1924341-f9da8ad2908b540e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle-2.3.0.jar本地路径"><br>只有一个 gradle-2.3.0.jar 文件和一个 pom 文件，正常的话应该还要有个 xxx-sources.jar 文件才对，就像下面这样<br><img src="http://upload-images.jianshu.io/upload_images/1924341-f7700195cd081102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三个文件"><br>因为这里没有 gradle-2.3.0-sources.jar 文件，所以 as 没办法打开带有方法注释的源码文件了。既然知道问题，那么就好解决了，as 的提示条也没有下载的按钮，那我们就自己去下载好了<br><img src="http://upload-images.jianshu.io/upload_images/1924341-ac54a39b3846d1d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="seach.maven.org"><br>打开 maven 网站，在这里可以下载 gradle 插件。在搜索框中输入 <code>com.android.tools.build</code>，为什么输入这个，你打开 project 下的 build.gradle 文件看看就知道了<br><img src="http://upload-images.jianshu.io/upload_images/1924341-4796f2199f748565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="com.android.tools.build"><br><img src="http://upload-images.jianshu.io/upload_images/1924341-374001fbc95ace5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="search result"><br>这些就是 gradle 插件，我们在根目录下的 build.gradle 配置的 gradle 版本其实就是来这里下载的，应该是吧。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-b9b6f2c35d82ede4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载的文件"><br>下载后得到的就是这些文件了，接下去就是找到相应文件的位置，复制一份过去<br><img src="http://upload-images.jianshu.io/upload_images/1924341-139f310de6d6dfc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle的本地路径"><br>打开相应的插件文件夹，选择相应的版本，最后将下载的 xxx-sources.jar 复制一份进去，最后的样子如下<br><img src="http://upload-images.jianshu.io/upload_images/1924341-9dbac486701a27fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三个文件"><br>好了，大功告成，我们再打开 as，记得 ReBuild 一下，然后再试试查看 build.gradle 源码会是什么样子<br><img src="http://upload-images.jianshu.io/upload_images/1924341-327042d04c7edab6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BaseExtension.java"><br><img src="http://upload-images.jianshu.io/upload_images/1924341-5723f731293b39a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LintOptions.java"><br>翻译一下英文大概就是说， lintOptions.abortOnError = false 是设置即使 lint 检查时发现错误也不停止构建程序的运行。  </p>
<p>这种方法比去官方的 api 文档里查阅方便多了吧。再来看看几个效果。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-19e3e3f8353694db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BaseExtension.java"><br>这里就可以看到源码里介绍 Plugin 的值都有哪些，分别对应哪个类，该去哪个类看它的作用是什么，干什么的。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-3024eb6a6819fd42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AndroidConfig.java"><br>借助 as，我们甚至可以很容易的查到 <code>android{...}</code> 这个括号里能使用的方法都有哪些，如果要看各自的作用是干什么的，再继续点进去查看注释就行了。是不是发现，我们在 build.gradle 里的 <code>android{...}</code> 使用过的标签名原来都在这里的啊。  </p>
<p>以后就算是再碰到大神的 build.gradle 文件里各种没看见过的标签名，不用再担心看不懂了。不懂就看源码注释嘛，so easy!  </p>
<p>当然，大神的 build.gradle 文件里还是会出现一些 groovy 代码或者是 task 之类的，这些就不是 gradle 源码里能够查到的了，需要稍微了解一下 groovy 和 gradle 语言的基础，有兴趣的可以继续阅读下我写的这个系列里的相关博客，当然能力不够，如果你希望更好的学习，网上资料也很多。   </p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>学点Groovy来理解build.gradle代码</title>
    <url>/2018/03/29/Gradle/%E5%AD%A6%E7%82%B9Groovy%E6%9D%A5%E7%90%86%E8%A7%A3build-gradle%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>在写这篇博客时，搜索参考了很多资料，网上对于 Groovy 介绍的博客已经特别多了，所以也就没准备再详细的去介绍 Groovy，本来也就计划写一些自己认为较重要的点。后来发现了 Groovy 的官方文档后，发现其实官方的介绍特别的全面，详细。但可惜的是我的英语不好，看英文文档有些费时间，但还是推荐有能力的人去参照官方文档来学习，后期如果有时间的话，我也计划试着翻译一些官方的文档来学习，记录一下。  </p>
<p>所以，这篇的侧重点不是在介绍 groovy 的基本语法，而是介绍跟 build.gradle 比较相关的一些知识点吧，另外在末尾会附上一些 groovy 学习链接，有兴趣的可以继续去学习。</p>
<hr>
<h1 id="系列索引"><a href="#系列索引" class="headerlink" title="系列索引"></a>系列索引</h1><p>build.gradle系列一：<a href="http://www.jianshu.com/p/a3805905a5c7" target="_blank" rel="noopener">看不懂的build.gradle代码</a><br>build.gradle系列二：<a href="http://www.jianshu.com/p/501726c979b1" target="_blank" rel="noopener">学点Groovy来理解build.gradle代码</a><br>build.gradle系列三：<a href="http://www.jianshu.com/p/28bb90e565de" target="_blank" rel="noopener">如何用Android Studio查看build.gradle源码</a><br>…  </p>
<hr>
<p>开始学习 Groovy 前，引用徐宜生的《Android群英传：神兵利器》书中的一句话来介绍 Groovy：  </p>
<blockquote>
<p>Groovy 对于 Gradle，就好比 Java 对于 Android。了解一些基本的 Groovy 知识，对于掌握 Gradle 是非常有必要的。  </p>
</blockquote>
<h1 id="Groovy-是什么"><a href="#Groovy-是什么" class="headerlink" title="Groovy 是什么"></a>Groovy 是什么</h1><p>Groovy 是一种脚本语言，既然是脚本语言，那么它也就有脚本语言的那些特点：使用动态类型、末尾不用分号等等。另外，它又是基于 Java 上设计的语言，也就是 Groovy 兼容 Java，可以使用 JDK 里的各种方法，你可以在 Groovy 文件里写 Java 代码里，照样可以正常编译运行。  </p>
<h1 id="Groovy-语法"><a href="#Groovy-语法" class="headerlink" title="Groovy 语法"></a>Groovy 语法</h1><p>关于语法的详细的介绍在末尾有链接，这里就只是挑出我认为比较重要的，而且跟 java 有区别的，在阅读代码时可能会看不懂的一些语法进行记录。  </p>
<h3 id="1-注释、标识符方面跟-Java-基本一样。"><a href="#1-注释、标识符方面跟-Java-基本一样。" class="headerlink" title="1.注释、标识符方面跟 Java 基本一样。"></a>1.注释、标识符方面跟 Java 基本一样。</h3><h3 id="2-基本数据类型，运算方面"><a href="#2-基本数据类型，运算方面" class="headerlink" title="2.基本数据类型，运算方面"></a>2.基本数据类型，运算方面</h3><p>这方面在 build.gradle 文件里也不怎么常见到使用，因为 groovy 是动态类型，定义任何类型都可以只使用 def 来定义，所以如果使用具体的比如 char, int 等类型时需要强制转换吧。有需要的可以自己查阅末尾的参考链接。  </p>
<h3 id="3-字符串方面"><a href="#3-字符串方面" class="headerlink" title="3.字符串方面"></a>3.字符串方面</h3><p>java 只支持用 <code>&quot;...&quot;</code> 双引号来表示字符串</p>
<p>groovy 支持使用 <code>&#39;...&#39;</code>, <code>&quot;...&quot;</code>, <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>,  <code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>, <code>/.../</code>, <code>$/.../$</code> 即单引号，双引号等6种方法来表示字符串<br>至于各种表示方法有什么区别，具体可以参考末尾的链接，这里简单提提，<code>&#39;...&#39;</code>, <code>&quot;...&quot;</code> 只支持单行字符串，不支持多行，剩下的四种都支持多行字符串，如下图<br> <img src="http://upload-images.jianshu.io/upload_images/1924341-cc18ea13326a0918.png" alt="Groovy字符串代码示例"><br> <img src="http://upload-images.jianshu.io/upload_images/1924341-0813184508bcdd70.png" alt="控制台输出结果">  </p>
<p>斜杠我也很少见，常见的是带有 <code>${}</code> 的字符串，比如： <code>println &quot;blog&#39;s url: ${blogUrl}&quot;</code> 这是 groovy 的 GString 特性，支持字符串插值，有点了类似于变量引用的概念，但注意，在 <code>&#39;...&#39;</code>, <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code> 单引号表示的字符串里不支持 <code>${}</code>。当然，如果你要使用 java 的方式，用 <code>+</code> 来拼接也可以。  </p>
<h3 id="4-集合方面（List、Map）"><a href="#4-集合方面（List、Map）" class="headerlink" title="4.集合方面（List、Map）"></a>4.集合方面（List、Map）</h3><p><strong>定义和初始化</strong><br>定义很简单，List 的话使用 <code>[]</code> 定义，各项用 <code>,</code> 隔开即可。Map 的话使用 <code>[:]</code>，各项也是用 <code>,</code> 隔开，如： </p>
<pre><code>def numList = [1, 2, 3]  //List
def map [1:&quot;dasu&quot;, dasu:24] //Map, : 前是key，如1， : 后是value, 如dasu</code></pre><p>有一点跟 java 不同的是， groovy 集合里不要求每一项都是同类型，比如可以这样定义 <code>def list = [1, &#39;dasu&#39;, true]</code>，集合里包含数字，字符串，布尔值三种类型。  </p>
<p><strong>使用</strong><br>通过下标操作符 <code>[]</code> 读写元素值，并使用正索引值访问列表元素或负索引值从列表尾部访问元素，也可以使用范围，或使用左移 <code>&lt;&lt;</code> 追加列表元素，如  </p>
<pre><code>//========= List 使用 ================
println numList[1]  //输出 1
println numList[-1] //输出 3

numList[2] = 4    // println numList[2]将输出 4
numList[3] = 5
numList &lt;&lt; &quot;dasu&quot; //现在numList = [1, 2, 4, 5, &quot;dasu&quot;]

//========== Map 使用 ================
println map[1]       //输出 dasu
println map.dasu     //输出 24, key是字符串的话可以这样访问
map[3] = &quot;I am dasu&quot; // 在map里加入一个[3:&quot;I am dasu&quot;]项</code></pre><p>跟 java 不同的是， groovy 并不存在下标访问越界，当下标为负数时则从右开始算起，当指定的下标没有存放值时返回 null。  </p>
<h3 id="5-数组方面"><a href="#5-数组方面" class="headerlink" title="5.数组方面"></a>5.数组方面</h3><p>groovy 其实没有严格区分数组和集合，数组的定义和使用方法跟集合一样，只是你需要强制声明为数组，否则默认为集合，如  </p>
<pre><code>String[] arrStr = [&apos;Ananas&apos;, &apos;Banana&apos;, &apos;Kiwi&apos;]  
def numArr = [1, 2, 3] as int[] //as 是 groovy 关键字
</code></pre><p>上面的初始化方式是不是跟 java 不一样，这一点需要注意下，java 是用 <code>{}</code> 来初始化，但在 groovy 里面， <code>{}</code> 表示的是闭包，所以这点需要注意一下。  </p>
<hr>
<p>上面的是 groovy 与 java 不同的一些基本语法，下面介绍一些我自己认为是 groovy 比较重要的特性，如果要看懂 build.gradle 里的代码，明白下面介绍的会比较有帮助。  </p>
<h3 id="6-方法的简化使用"><a href="#6-方法的简化使用" class="headerlink" title="6.方法的简化使用"></a>6.方法的简化使用</h3><p><strong>方法的括号可以省略</strong>  </p>
<p>groovy 定义方法时可以不声明返回类型和参数类型，也可以不需要 return 语句，最后一行代码默认就是返回值。<br>而在调用方法时可以将括号省略，不省略的时候如下    </p>
<pre><code>def add(a, b) {
    a + b
}
println add(1,2)  //输出 3
</code></pre><p>上面的方式不陌生吧，再来看看下面的代码  </p>
<pre><code>println add 1, 2 //输出 3, add方法同上
</code></pre><p>上面就是调用方法时省略掉圆括号的写法，再来看一种情况  </p>
<pre><code>def getValue(Map map) {
    map.each {
        println it.key + &quot;:&quot; + it.value
    }
}
def map = [author:&quot;dasu&quot;]
getValue(map) //输出 author:dasu</code></pre><p>这次定义一个参数为 map 类型的方法，如果我们在调用方法的时候才对参数进行定义和初始化会是什么样的呢？如下  </p>
<pre><code>getValue(author: &quot;dasu&quot;) //输出 author:dasu</code></pre><p>之前说过了，groovy 调用方法时可以将括号省略掉，这样一来再看下  </p>
<pre><code>getValue author: &quot;dasu&quot; //输出 author:dasu</code></pre><p>这样子的格式是不是看着觉得很眼熟，没错，就是 build.gradle 里的第一行代码。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-d28331899147847c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build.gradle"><br>如果有看过我的上一篇 <a href="http://www.jianshu.com/p/a3805905a5c7" target="_blank" rel="noopener">build.gradle</a> 博客的话，现在对疑问1是不是就有些理解了呢。  </p>
<p>上图那代码如果把省略的括号补上的话，大家应该就会熟悉点了  </p>
<pre><code>// apply plugin: &apos;com.android.application&apos;  等效于
def map = [plugin: &apos;com.android.application&apos;]
apply(map)
</code></pre><p>调用了 apply() 方法，该方法传入一个 map 参数，我们来看看是不是这样，用as查看下源码，如下<br><img src="http://upload-images.jianshu.io/upload_images/1924341-2f84f2bb58ecc672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PluginAware.java"><br>没错吧，apply() 其实是个方法，参数为 map 类型，而且 key 的取值也给你规定了 <code>from</code>, <code>plugin</code>, <code>to</code> 三种，是不是确实在别人的 build.gradle 代码里也有看见过类似 <code>apply from ***</code>，这样一来就明白多了吧。  </p>
<p>好了，然后你再重新去看一下 build.gradle 里的代码，是不是对每一行的代码都有了新的看法了。  </p>
<p>其实 build.gradle 里的每一行代码都是在调用一个方法，比如下面这些我们常见的：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-f0d802f0be4c01ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build.gradle"><br>每一行都是在调用一个方法，前面是方法名，后面是方法的参数，只是把括号省略掉了而已，感兴趣的你可以再自己用as点进去看看源码是不是这样。  </p>
<p><strong>方法最后一个参数是闭包可以提取出来接到后面</strong>  </p>
<p>闭包是 groovy 的一大特性，我理解也不深，也讲不大清楚，感兴趣的可自行网上查阅学习，简单的说就是一个用 <code>{..}</code> 包起来的代码块，比如 build.gradle 里的 <code>defaultConfig{...}</code>, <code>buildTypes{...}</code>, <code>dependencies{...}</code> 等等这些大括号包起来的代码块就是闭包，闭包代码块最后一句代码作为闭包的返回值。  </p>
<p>当闭包作为方法的最后一个参数，可以将闭包从参数圆括号中提取出来接在最后，如果闭包是唯一的一个参数，则方法参数所在的圆括号也可以省略。对于有多个闭包参数的，只要是在参数声明最后的，均可以按上述方式省略，举个例子。  </p>
<pre><code>//定义 add 方法
def add(a, Closure c) {
println a + c.call()
}
//调用方法
add(1, {1+1}) //输出 3</code></pre><p>上面定义一个 add 方法，最后一个参数为闭包，调用的时候传入一个闭包，闭包的最后一行代码 <code>1+1</code> 作为闭包返回值返回，闭包返回值作为方法的第二个参数传入方法中计算加法，所以最终输出3。上面的调用也可以写成下面的方式：  </p>
<pre><code>add(1){
    1+2
} //输出 4</code></pre><p>注意，这是调用 add() 方法，而不是在定义，1 是第一个参数，括号后的闭包 <code>{ 1+2 }</code> 是方法的第二个参数，这就是 groovy 的特性，闭包可以提取出来。那么再想想，如果方法只有一个闭包参数，再结合 groovy 可以省略掉括号的特性，这样子调用一个方法将会是什么样子呢？  </p>
<pre><code>//定义 method 方法
def method(Closure c) {
    println c.call()
}
//调用方法
method {
    I&apos;m dasu
} //输出 I&apos;m dasu</code></pre><p>是不是又感觉很熟悉，对吧，就是 build.gradle 里的 <code>defaultConfig{...}</code>, <code>buildTypes{...}</code>, <code>dependencies{...}</code> 等等这些。  </p>
<p>所以，结合上面讲的两点：可以省略方法括号和闭包可以提取接到括号后面，这样一来， build.gradle 里的代码其实就是在调用各种方法，<code>defaultConfig</code> 是一个方法，<code>compileSdkVersion</code> 也是一个方法。 build.gradle 里的每一行代码前面是方法名，后面则是方法需要的参数，参数有的是基本类型，有的则是闭包类型。  </p>
<p><strong>集合遍历 each/all</strong><br>就先把上一篇博客里的在一段在 build.gradle 里很常见的代码贴出来  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-bd80909468a07515.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重名名apk代码">  </p>
<p>这段代码作用就是对打包生成的 apk 按照规定的格式进行重命名，在很多大神的 build.gradle 里都会遇见过，其实这一段代码就是 groovy 代码，<code>all</code> 和 <code>each</code> 是集合的一种操作，<code>all</code> 后面跟着的是一个参数为 <code>variant</code> 的闭包，表示对 <code>applicationVariants</code> 集合里所有的对象都运行后面的闭包，同理 <code>each</code> 后面也是跟着一个参数为 <code>output</code> 的闭包，类似于 java 里的 for 循环操作。所以这里要理解的应该是 <code>applicationVariants</code> 代表的是什么，这点我也还不是很懂，后面如果搞懂了的话会在之后的博客里介绍出来。  </p>
<p>另外，我还有个疑问来着， <code>all</code> 操作和 <code>each</code> 操作有什么区别么，感觉都是对集合里所有的元素进行操作，如果有懂的能够告知就太感谢了，查了挺多资料貌似还不是很明白。  </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.groovy-lang.org/documentation.html" target="_blank" rel="noopener">官方文档</a><br><a href="http://ifeve.com/groovy-syntax/" target="_blank" rel="noopener">Groovy语言规范-语法（官方文档翻译）</a><br><a href="https://my.oschina.net/wstone/blog/389449" target="_blank" rel="noopener">Groovy操纵集合秘籍</a>  </p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>看不懂的 build.gradle 代码</title>
    <url>/2018/03/28/Gradle/%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84-build-gradle-%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>Android Studio 这么强大的工具，就算我们不懂 gradle, groovy， 也照样能借助AS对 Android 项目进行编译、调试、运行、打包等操作。build.gradle 这个文件接触这么久了，基本的项目配置也基本很熟悉了，毕竟每次自动创建的 build.gradle 里的代码就那么几项配置，看一下那些英文单词也基本猜到是什么配置。  </p>
<p><strong>但是，不知道你们会不会跟我一样，在 github 上 clone 大神的项目后，总会发现他们的 build.gradle 里多了很多平常没看见过的代码，而且还看不懂代码要做什么；</strong>  </p>
<p>或者是比如当需要进行签名时，网上资料会让你在 Android 标签内加个 signingConfigs， 然后在它里面进行各种配置，比如 storeFile, keyAlias 等等之类的。还有其他类似这种情况，比如当需要打包时，在哪个地方加个什么标签再对它进行各种配置之类的。<strong>不知道你们会不会也跟我一样会有这样的疑问，这个标签名怎么来的，为什么要放在这个位置，它里面有哪些属性可以进行配置？</strong>  </p>
<p>疑惑久了，总想去了解下这是为什么，所以花了一段时间来学习 gradle 的相关知识，这次在这里记录也分享一下，如果有错的地方，还望指点一下。  </p>
<p>本次计划是写个 gradle 系列博客，大概会有3-4篇，第一篇只是简单的针对某个具体的 build.gradle 文件代码进行注释解释以及抛出一些疑问，当然这个 build.gradle 不会是AS自动创建的那么简单的代码。然后再写1-2篇介绍 gradle, groovy， 相关的资料网上很多，所以不会写得很基础，大概是挑选一些我认为比较重要的知识点进行介绍。最后在前面的基础上，对 build.gradle 里面的代码进行分析讲解，比如介绍说都有哪些标签，哪里去找这些标签等等。  </p>
<p>好了，废话就唠叨到这，下面就开始正文。  </p>
<hr>
<h1 id="系列索引"><a href="#系列索引" class="headerlink" title="系列索引"></a>系列索引</h1><p>build.gradle系列一：看不懂的build.gradle代码<br>build.gradle系列二：<a href="http://www.jianshu.com/p/501726c979b1" target="_blank" rel="noopener">学点Groovy来理解build.gradle代码</a><br>build.gradle系列三：<a href="http://www.jianshu.com/p/28bb90e565de" target="_blank" rel="noopener">如何用Android Studio查看build.gradle源码</a><br>…</p>
<hr>
<h1 id="build-Gradle"><a href="#build-Gradle" class="headerlink" title="build.Gradle"></a>build.Gradle</h1><p>这个 build.Gradle 文件来自 drakeet 大神的 <a href="https://github.com/drakeet/Meizhi" target="_blank" rel="noopener">Meizi</a> 项目<br>我直接在代码上加注释，参照着注释看代码就行，是不是发现有很多代码平时都没看见过。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Model都有各自的build.gradle，这里声明该Model作为主项目，常见的还有另一个取值：</span><br><span class="line">//apply plugin: &apos;com.android.library&apos; 声明该Model作为库使用，当然还有其他取值，后面博客会介绍</span><br><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line"></span><br><span class="line">//这里是在as里引入一个retrolambda插件，具体我也不大懂，可以看看这篇博客： </span><br><span class="line">//http://blog.csdn.net/zhupumao/article/details/51934317?locationNum=12</span><br><span class="line">apply plugin: &apos;me.tatarka.retrolambda&apos;</span><br><span class="line"></span><br><span class="line">//这里是groovy的代码了，定义了一个获取时间的方法，groovy是兼容java，它可以直接使用jdk里的方法</span><br><span class="line">def releaseTime() &#123;</span><br><span class="line">    return new Date().format(&quot;yyyy-MM-dd&quot;, TimeZone.getTimeZone(&quot;UTC&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//file()是Project.java里的一个方法，这里定义一个File类型的对象，Project后面博客会介绍到</span><br><span class="line">def keyStore = file(&apos;meizhi.keystore&apos;)</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    //这个大家应该很熟悉了，有疑问的应该是后面的代码，这里表示获取一些全局变量</span><br><span class="line">    //这些变量的值在根目录下的build.gradle中定义，具体可以看看这篇博客：</span><br><span class="line">    //http://blog.csdn.net/fwt336/article/details/54613419</span><br><span class="line">    compileSdkVersion rootProject.ext.android.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.ext.android.buildToolsVersion</span><br><span class="line"></span><br><span class="line">    //同理，这里都是通过获取全局设置的变量值来进行相关配置，这样做的好处在于当</span><br><span class="line">    //你的项目里有多个model时，可以方便修改这些公共的配置，只需要修改一个地方就可以同步了</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId rootProject.ext.android.applicationId</span><br><span class="line">        minSdkVersion rootProject.ext.android.minSdkVersion</span><br><span class="line">        targetSdkVersion rootProject.ext.android.targetSdkVersion</span><br><span class="line">        versionCode rootProject.ext.android.versionCode</span><br><span class="line">        versionName rootProject.ext.android.versionName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里应该是设置打包后的apk里的META-INF移除指定的文件吧</span><br><span class="line">    packagingOptions &#123;</span><br><span class="line">        exclude &apos;META-INF/DEPENDENCIES.txt&apos;</span><br><span class="line">        //省略部分exclude 代码...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //关闭指定的lint检查</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        disable &apos;MissingTranslation&apos;, &apos;ExtraTranslation&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //lint检查到错误时不中断编译，好像是说lint检查是为优化代码，发现的错误其实并不会导致程序异常</span><br><span class="line">    //所以有的时候及时发现Lint检查错误还是可以直接运行查看效果</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        abortOnError false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //签名的相关配置</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        //这个标签名可以随意命名，这里的作用大概类似于定义一个对象，该对象里设置好了签名需要的各种配置</span><br><span class="line">        //可以定义不止一种配置的签名对象，例如常见的还有 debug&#123;...&#125;, release&#123;...&#125;，然后在buildTypes&#123;&#125;里</span><br><span class="line">        //通过 signingConfigs.app1 进行调用</span><br><span class="line">        app1 &#123;</span><br><span class="line">            //签名的相关配置，网上资料很多，STOREPASS, KEYALIAS, KEYPASS 这些常量是定义在</span><br><span class="line">            //gradle.properties 文件里，如果没有该文件手动创建即可，这样可以保证安全</span><br><span class="line">            //只有定义在 gradle.properties 里的常量才可以直接通过常量名引用</span><br><span class="line">            storeFile file(&apos;meizhi.keystore&apos;)</span><br><span class="line">            storePassword project.hasProperty(&apos;STOREPASS&apos;) ? STOREPASS : &apos;&apos;</span><br><span class="line">            keyAlias project.hasProperty(&apos;KEYALIAS&apos;) ? KEYALIAS : &apos;&apos;</span><br><span class="line">            keyPassword project.hasProperty(&apos;KEYPASS&apos;) ? KEYPASS : &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //编译，打包的项目配置</span><br><span class="line">    buildTypes &#123;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            //在 BuildConfig 里自定义一个 boolean 类型的常量</span><br><span class="line">            //更多资料可以查看：http://stormzhang.com/android/2015/01/25/gradle-build-field/ </span><br><span class="line">            buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;true&quot;</span><br><span class="line">            </span><br><span class="line">            debuggable true</span><br><span class="line">            applicationIdSuffix &quot;.debug&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        release &#123;</span><br><span class="line">            buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot;</span><br><span class="line"></span><br><span class="line">            debuggable false</span><br><span class="line">            </span><br><span class="line">            //开启混淆</span><br><span class="line">            minifyEnabled true</span><br><span class="line">            //删除无用的资源</span><br><span class="line">            shrinkResources true</span><br><span class="line">            //混淆文件</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">            if (keyStore.exists()) &#123;</span><br><span class="line">                println &quot;Meizhi: using drakeet&apos;s key&quot;</span><br><span class="line">                //根据在signingConfigs.app1里的签名配置进行签名</span><br><span class="line">                signingConfig signingConfigs.app1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                println &quot;Meizhi: using default key&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //这段代码应该会在大神的项目里挺常见的，我在很多项目里都看见过了</span><br><span class="line">            //这也是groovy的代码，这里的代码作用是重命名最后打包出来的apk</span><br><span class="line">            //根据 def fileName 设置的格式来命名，$&#123;&#125;表示的是某个变量的引用</span><br><span class="line">            //例如根据设置的格式最后apk命名可能是： Meizhi_v1.0.0_2017-03-28_fir.apk</span><br><span class="line">            //至于 applicationVariants 这些变量含义后面博客会介绍</span><br><span class="line">            applicationVariants.all &#123; variant -&gt;</span><br><span class="line">                variant.outputs.each &#123; output -&gt;</span><br><span class="line">                    def outputFile = output.outputFile</span><br><span class="line">                    if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) &#123;</span><br><span class="line">                        def fileName = &quot;Meizhi_v$&#123;defaultConfig.versionName&#125;_$&#123;releaseTime()&#125;_$&#123;variant.productFlavors[0].name&#125;.apk&quot;</span><br><span class="line">                        output.outputFile = new File(outputFile.parent, fileName)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //这里的作用跟 singingConfigs 差不多，只是为不同的 flavor 设置一些属性</span><br><span class="line">        //常见的设置比如设置不同的渠道编号，设置不同的 api 服务器等等</span><br><span class="line">        productFlavors &#123;</span><br><span class="line">            fir &#123;</span><br><span class="line">                //这个的作用是将 AndroidManifest.xml 里的占位符 ￥&#123;UMENG_CHANNEL_VALUE&#125; 的值替换成fir</span><br><span class="line">                manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;fir&quot;]</span><br><span class="line">            &#125;</span><br><span class="line">            GooglePlay &#123;</span><br><span class="line">                manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;GooglePlay&quot;]</span><br><span class="line">            &#125;</span><br><span class="line">            Umeng &#123;</span><br><span class="line">                manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;Umeng&quot;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置JDK的版本通过compileOptions</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //lint的相关配置吧</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        disable &quot;InvalidPackage&quot;</span><br><span class="line">        lintConfig file(&quot;lint.xml&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里就不用说了</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">    compile project(&quot;:libraries:headsupcompat&quot;)</span><br><span class="line">    compile project(&quot;:libraries:smooth-app-bar-layout&quot;)</span><br><span class="line">    //as默认会去下载传递依赖，下面是指定不需要去下载传递依赖</span><br><span class="line">    compile (&apos;com.squareup.retrofit2:retrofit:2.1.0&apos;) &#123;</span><br><span class="line">        exclude module: &apos;okhttp&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    retrolambdaConfig &apos;net.orfjackal.retrolambda:retrolambda:2.3.0&apos;</span><br><span class="line">    //省略部分compile代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>1.apply plugin: ‘com.android.application’ 听说这是调用一个方法？  </p>
<p>2.rootProject.ext.android.compileSdkVersion, 不用 ext 来设置全局变量是否可以？  </p>
<p>3.defaultConfig{}, packagingOptions{}, signingConfigs{}, buildTypes{} 等等这些，我怎么知道 Android{} 里都有哪些可以使用？  </p>
<p>…</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>·徐宜生写的《Android群英传：神兵利器》第4章：与Gradle的爱恨情仇<br>·<a href="http://blog.csdn.net/zhupumao/article/details/51934317?locationNum=12" target="_blank" rel="noopener">retrolambda使用教程</a><br>·<a href="http://blog.csdn.net/fwt336/article/details/54613419" target="_blank" rel="noopener">Gradle配置全局变量</a><br>·<a href="http://stormzhang.com/android/2015/01/25/gradle-build-field/" target="_blank" rel="noopener">GRADLE自定义你的BUILDCONFIG</a>  </p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>View.animate()动画ViewPropertyAnimator原理解析</title>
    <url>/2018/03/25/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/View-animate()%E5%8A%A8%E7%94%BBViewPropertyAnimator%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</strong>  </p>
</blockquote>
<p>这次想来讲讲 <strong>View.animate()</strong>，这是一种超好用的动画实现方式，用这种方式来实现常用的动画效果非常方便，但在某些场景下会有一个坑，所以这次就来梳理一下它的原理。  </p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>首先，先来看一段代码：  </p>
<pre><code>mView.animate().sacleX(1.2f).scaleY(1.2f).alpha(0.5f).setDuration(1000).start();  </code></pre><p>可能有些人还没接触过这个，但并不妨碍首次理解上述代码。单从方法名上来看，上述代码就是一个实现了持续 1s 的放大 &amp; 透明度结合的动画，是不是发现使用起来特别简单，一行代码就搞定。  </p>
<p>当然，上述的动画效果也可以通过 <strong>ValueAnimator</strong> 或 <strong>ObjectAnimator</strong> 来实现，只是可能没法像上述一样一行代码就搞定。如果用 <strong>Animation</strong> 来实现，那么需要的代码就更多了。  </p>
<p>所以，我们的问题就来了：  </p>
<p><strong>Q1：动画基本可以分为 Animator 和 Animation 两大类，而 View.animate() 返回的是一个 ViewPropertyAnimator 类型的对象，这个类并没有继承自任何类，那么它实现动画的原理又是什么呢？单从命名上看好像是通过 Animator 实现，那么真的是这样么？</strong>  </p>
<p><strong>Q2：开头说了，使用这种方式实现的动画在某些场景下会有一个坑，这个坑又是什么，是在什么场景下的呢？</strong>  </p>
<p>好了，下面就开始来跟着源码一起学习吧：  </p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>ps:本篇阅读的源码版本都是 android-25，版本不一样，源码可能会有些许差别，大伙自己过的时候注意一下。  </p>
<p>那么，源码阅读的着手点就跟之前几篇分析动画的一样，从 <code>start()</code> 开始一步步跟踪下去就行了。 </p>
<pre><code>//ViewPropertyAnimator#start()
public void start() {
    mView.removeCallbacks(mAnimationStarter);
    startAnimation();
}</code></pre><p>代码很少就两行，第二行是调用了一个方法，看方法名可以猜测应该是去处理动画开始的工作，那么在动画开始前还移除了一个回调，但要搞清楚第一行的代码是干嘛用的，我们得先知道两个变量的含义，首先是第一个 mView：  </p>
<pre><code>//ViewPropertyAnimator构造函数
ViewPropertyAnimator(View view) {
    mView = view;
    view.ensureTransformationInfo();
}</code></pre><p>mView 是一个成员变量，在构造函数中被赋值，还记得吧，要用这种方式实现动画时，都得先调用 <strong>View.animate()</strong> 来创造一个 ViewPropertyAnimator 对象，所以去 View 的 <code>animate()</code> 方法里瞧瞧：  </p>
<pre><code>//View#animate() 
public ViewPropertyAnimator animate() {
    if (mAnimator == null) {
        mAnimator = new ViewPropertyAnimator(this);
    }
    return mAnimator;
}</code></pre><p>这个方法里会去创建一个 ViewPropertyAnimator 对象，并将 View 自身 this 作为参数传递进去，也就是说，在 ViewPropertyAnimator 里的 mView 变量其实指向的就是要进行动画的那个 View。  </p>
<p>知道了 mView 其实就是需要进行动画的那个 View 后，接下去来看看另一个变量 mAnimationStarter 是什么了：  </p>
<pre><code>//ViewPropertyAnimator.mAnimationnStarter
private Runnable mAnimationStarter = new Runnable() {
    @Override
    public void run() {
        startAnimation();
    }
};</code></pre><p>这个 Runnable 就是一个启动动画的工作，emmm，这样就有点奇怪了，我们再回过头来看看 <code>start()</code> 方法：  </p>
<pre><code>//ViewPropertyAnimator#start()
public void start() {
    mView.removeCallbacks(mAnimationStarter);
    startAnimation();
}</code></pre><p><strong>为什么明明方法的第二行就会去执行 <code>startAnimation()</code> 了，第一行却又要去取消一个执行 <code>startAnimation()</code> 的 Runnable 呢？</strong>  </p>
<p>只能说明，在我们调用 <code>start()</code> 之前，ViewPropertyAnimator 内部就已经预先安排了一个会执行 <code>startAnimation()</code> 的 Runnable 进入待执行状态，所以在调用了 <code>start()</code> 之后先去取消这个 Runnable 才会有意义。  </p>
<p>那么，又是哪里会去触发安排一个 Runnable 呢？  </p>
<p>回头再看看我们使用这种方式来实现动画效果是怎么用的：  </p>
<pre><code>mView.animate().sacleX(1.2f).scaleY(1.2f).alpha(0.5f).setDuration(1000).start();  </code></pre><p>首先，通过 <code>View.animate()</code> 先创建一个 ViewPropertyAnimator 对象，中间设置了一系列动画行为，最后才调用了 <code>start()</code>。那么，有机会去触发安排一个待执行的 Runnable 操作也只能发生在中间的这些方法里了，那么我们选择一个跟进去看看，<code>scaleX()</code>：  </p>
<pre><code>//ViewPropertyAnimator#scaleX()
public ViewPropertyAnimator scaleX(float value) {
    animateProperty(SCALE_X, value);
    return this;
}</code></pre><p>继续跟进去看看：  </p>
<pre><code>//ViewPropertyAnimator#animateProperty()
private void animateProperty(int constantName, float toValue) {
    float fromValue = getValue(constantName);
    float deltaValue = toValue - fromValue;
    animatePropertyBy(constantName, fromValue, deltaValue);
}</code></pre><p>至于各个参数是什么意思，我们后面再来分析，目前我们是想验证是不是这些封装好的动画接口内部会去触发一个待执行的 Runnable 操作，所以优先继续跟踪下去：  </p>
<pre><code>//ViewPropertyAnimator#animatePropertyBy()
private void animatePropertyBy(int constantName, float startValue, float byValue){
    ...
    mView.removeCallbacks(mAnimationStarter);
    mView.postOnAnimation(mAnimationStarter);
}</code></pre><p>终于找到了，而且不仅仅是 <code>scaleX()</code> 方法，其他封装好的动画接口如 <code>scaleY()</code>，<code>alpha()</code>，<code>translationX()</code> 等等所有这一系列的方法内部最终都会走到 <code>animatePropertyBy()</code> 里去。而在这个方法最后都会先将待执行的 Runnable 先移除掉，再重新 post。  </p>
<p>要理解这么做的用意，得先明白 View 的这两个方法：<code>removeCallbacks()</code>，<code>postOnAnimation()</code> 是干嘛用的。这里我就不跟下去了，直接给大伙说下结论：  </p>
<p>通过 <code>postOnAnimation()</code> 传进去的 Runnable 并不会被马上执行，而是要等到下一个屏幕刷新信号来的时候才会被取出来执行。</p>
<p>那么，将这些串起来，也就是说，<strong>仅仅只是 <code>View.animate().scaleX()</code> 这样使用时，就算不主动调用 <code>start()</code> ，其实内部也会自动安排一个 Runnable，最迟在下一个屏幕刷新信号来的时候，就会自动去调用 <code>startAnimation()</code> 来启动动画。</strong>  </p>
<p><strong>但如果主动调用了 <code>start()</code>，内部就需要先将安排好的 Runnable 操作取消掉，然后直接调用 <code>startAnimation()</code> 来启动动画。</strong>  </p>
<p>那么，接下去就来看看是如何启动动画的，<code>startAnimation()</code>：  </p>
<pre><code>//ViewPropertyAnimator#startAnimation()
private void startAnimation() {
    //1. 这里我还没搞懂，也不清楚什么场景下会满足这里的条件，直接 return。所以，本篇接下去的分析都是基于假设会直接跳过这里，后面如果搞懂了再来填坑。 
    if (mRTBackend != null &amp;&amp; mRTBackend.startAnimation(this)) {
        return;
    }
    ...

    //2. 创建一个 0.0-1.0 变化的 ValueAnimator
    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);

    //3. 将当前 mPengingAnimations 里保存的一系列动画全都取出来，作为同一组一起执行一起结束的动画
    ArrayList&lt;NameValuesHolder&gt; nameValueList =
            (ArrayList&lt;NameValuesHolder&gt;) mPendingAnimations.clone();
    ...

    //4. 创建一个新的 PropertyBundle 来保存这一组动画，以ValueAnimator作为key来区分
    mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));

    //5. 提供动画开始前，结束后的操作回调
    if (mPendingSetupAction != null) {
        mAnimatorSetupMap.put(animator, mPendingSetupAction);
        mPendingSetupAction = null;
    }
    ...

    //6. 对ValueAnimator进行 Listener、StartDelay、Duration、Interpolator 的设置
    animator.addUpdateListener(mAnimatorEventListener);
    animator.addListener(mAnimatorEventListener);
    ...

    //7. 启用ValueAnimator.start()
    animator.start();
}</code></pre><p>上述代码可以先不用细看，我们稍后再来一块一块慢慢过，我已经将整个方法里做的事大概划分成了 7 件，首先有一点需要提一下，方法内其实是通过 ValueAnimator 来实现的。   </p>
<p>上一篇博客<a href="https://www.jianshu.com/p/46f48f1b98a9" target="_blank" rel="noopener">属性动画 ValueAnimator 运行原理全解析</a>中，我们已经将 ValueAnimator 的运行原理分析完了，感兴趣的可以回去看看，这里大概提几点结论：  </p>
<blockquote>
<p>ValueAnimator 内部其实并没有进行任何 ui 操作，它只是提供了一种机制，可以根据设定的几个数值，如 0-100，内部自己在每一帧内，根据当前时间，第一帧的时间，持续时长，以及插值器规则，估值器规则来计算出在当前帧内动画的进度并映射到设定的数值区间，如 0-100 区间内映射之后的数值应该是多少。  </p>
<p>既然 ValueAnimator 并没有进行任何 ui 操作，那么要用它来实现动画效果，只能自己在 ValueAnimator 提供的每一帧的回调里（AnimatorUpdateListener），自己取得 ValueAnimator 计算出的数值，来自行应用到需要进行动画效果的那个 View 上。  </p>
</blockquote>
<p>想想自己使用 ValueAnimator 的时候是不是这样，我们并没有将 View 作为参数传递给 ValueAnimator，所以它内部也就没有持有任何 View 的引用，自然做不了任何 ui 操作。  </p>
<p>所以看看 <code>startAnimation()</code> 方法里的，我标出来的第 2、6、7点：  </p>
<pre><code>//ViewPropertyAnimator#startAnimation()
private void startAnimation() {
    ...

    //2. 创建一个 0.0-1.0 变化的 ValueAnimator
    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);

    ...
    //6. 对ValueAnimator进行 Listener、StartDelay、Duration、Interpolator 的设置
    animator.addUpdateListener(mAnimatorEventListener);
    animator.addListener(mAnimatorEventListener);
    ...

    //7. 启用ValueAnimator.start()
    animator.start();
}</code></pre><p>所以，ViewPropertyAnimator 其实是通过 <code>ValueAnimator.ofFloat(1.0f)</code>，也就是借助 ValueAnimator 的机制，来计算每一帧动画进度在 0-1 内对应的数值。然后在它的每一帧的回调里再去进行 view 的 ui 操作来达到动画效果，那么 ui 操作也就是在 mAnimatorEventListener 里做的事了，跟进去看看：  </p>
<pre><code>//ViewPropertyAnimator.mAnimatorEventListener
private AnimatorEventListener mAnimatorEventListener = new AnimatorEventListener();  

private class AnimatorEventListener implements Animator.AnimatorListener, ValueAnimator.AnimatorUpdateListener {
    ...

    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        ...

        //1. 取出 ValueAnimator 计算出的当前帧的动画进度    
        float fraction = animation.getAnimatedFraction();

        //2. 根据取得的动画进度，进行一系列view的ui操作，来达到动画效果
        ...
    }
}</code></pre><p>省略了绝大部分代码，等会会再来慢慢过，这样省略后比较容易梳理出整个流程，优先将流程梳理清楚，再来分析每个步骤具体干的活。  </p>
<p>所以，可以看到，ViewPropertyAnimator 确实是在 ValueAnimator 的每一帧的回调中，取得 VauleAnimator 机制计算出来的动画进度值，然后自行进行 ui 操作来达到动画效果。  </p>
<p>那么，到这里，整个流程就已经梳理出来了，我们先来<strong>梳理一下目前的信息</strong>：  </p>
<ol>
<li><p><strong>通过 <code>View.animate().scaleX(1.2f).start()</code> 实现的动画，如果外部没有手动调用 <code>start()</code> 方法，那么 ViewPropertyAnimator 内部最迟会在下一帧的时候自动调用 <code>startAnimation()</code> 来启动动画。</strong>  </p>
</li>
<li><p><strong>ViewPropertyAnimator 实现下一帧内自动启动动画是通过 <code>View.postOnAnimation()</code> 实现，View 的这个方法会将传递进来的 Runnable 等到下一帧的时候再去执行。</strong>  </p>
</li>
<li><p><strong>如果外部手动调用了 <code>start()</code>，那么内部会先将第 2 步中安排的自动启动动画的 Runnable 取消掉，然后直接调用 <code>startAnimation()</code> 启动动画。</strong>  </p>
</li>
<li><p><strong><code>startAnimation()</code> 启动动画，实际上是借助 ValueAnimator 的机制，在 <code>onAnimationUpdate()</code> 里取得每一帧内的动画进度时，再自行进行对应的 ui 操作来达到动画效果。</strong></p>
</li>
<li><p><strong>ValueAnimator 只是会根据当前时间，动画第一帧时间，持续时长，插值器规则，估值器规则等来计算每一帧内的当前动画进度值，然后根据关键帧机制来映射到设定的范围内的数值，最后通过每一帧的进度回调，供外部使用，它本身并没有任何 ui 操作（详情可看上一篇博客）。</strong></p>
</li>
</ol>
<p>好了，流程上已经梳理清理了，接下去就是细节问题了，ViewPropertyAnimator 取得了每一帧对应的动画进度时又是<strong>如何进行的 ui 操作的呢</strong>？<code>View.animate()</code> 后面是支持一系列的动画操作，如 <code>scaleX()</code>，<code>alpha()</code> 等一起执行的，那么<strong>内部又是如何区分，维护的呢</strong>？  </p>
<p>我们还是按照流程来一步步详细的分析，<strong>View.animate()</strong> 方式实现的动画，流程上是<strong><em>设置动画行为–启动动画–每一帧进度回调中进行ui操作</em></strong>。所以，下面就先看看第一个步骤，跟着 <code>scaleX()</code> 进去看看：  </p>
<pre><code>//ViewPropertyAnimator#scaleX()
public ViewPropertyAnimator scaleX(float value) {
    //1. 第一个参数用于区分不同的动画，第二个参数设定动画最后一帧的值
    animateProperty(SCALE_X, value);
    return this;
}

//ViewPropertyAnimator#animateProperty()
private void animateProperty(int constantName, float toValue) {
    //2. 第一步先取得该种动画行为下的默认第一帧值，最后一帧值就是参数传递进来
    float fromValue = getValue(constantName);
    //3. 计算出动画的变化数值
    float deltaValue = toValue - fromValue;
    animatePropertyBy(constantName, fromValue, deltaValue);
}

//ViewPropertyAnimator#getValue()
private float getValue(int propertyConstant) {
    final RenderNode node = mView.mRenderNode;
    switch (propertyConstant) {
        ...
        //4. 直接通过 getScaleX() 取得当前 view 的默认属性值
        case SCALE_X:
            return node.getScaleX();
        ...
    }
    return 0;
}</code></pre><p>上述代码作用，其实也就只是取得对应动画行为下的第一帧的属性值，然后根据设定的最后一帧属性值来计算出动画变化的数值，最终作为参数传递给 <code>animatePropertyBy()</code>，所以最关键的任务肯定在这个方法里，但要捋清楚这个方法里的代码前，还需要先了解一些变量以及内部类的含义：  </p>
<p>ViewPropertyAnimator 内部有两个数据结构类 <strong>NameValuesHolder</strong> 和 <strong>PropertyBundle</strong>，都是用于存储各种动画信息的，除此之外，还有一系列成员变量的列表，如 <strong>mPendingAnimations</strong>，<strong>mAnimatorMap</strong> 等。要搞清楚这些的含义，还得先搞懂 <code>View.animate()</code> 是支持如何使用的。  </p>
<p>这么说吧，还是拿开头的示例代码来说明：  </p>
<pre><code>mView.animate().scaleX(1.2f).scaleY(1.2f).alpha(0.5f).setDuration(1000).start();</code></pre><p>ViewPropertyAnimator 亮点就是支持链式调用一系列不同的动画一起执行，所以需要注意一点，一旦像上述那样使用，那么设定的这一系列动画就会是一起执行一起结束的。  </p>
<p>那么，有可能存在这种场景：先设置了一系列动画执行，如果在这一系列的动画执行结束前，又通过 <code>View.animate()</code> 设置了另外一系列一起执行的动画效果，那么这时就会有两组动画都在运行中，每组动画都可能含有多种类型的动画，所以内部就需要以每组为单位来保存信息，确保每组动画可以互不干扰，这就是 PropertyBundle 这个类的作用了:  </p>
<pre><code>//ViewPropertyAnimator$PropertyBundle
private static class PropertyBundle {
    int mPropertyMask;
    ArrayList&lt;NameValuesHolder&gt; mNameValuesHolder;

    ...
}</code></pre><p>这样解释完，再来看这个类，这样理解两个成员变量的含义就容易多了，首先 mNameValuesHolder 是一个 ArrayList 对象，显然就是用来存储这一组动画里的那一系列不同类型的动画；那具体存在列表里都有哪些类型的动画呢，就是另一个成员变量 mPropertyMask 来进行标志了。  </p>
<p>而列表里存的这一组动画里的不同类型的动画，所以 NamaValuesHolder 这个类的作用就是用于区分各种不同类型的动画了：  </p>
<pre><code>//ViewPropertyAnimator$NameValuesHolder
static class NameValuesHolder {
    int mNameConstant;
    float mFromValue;
    float mDeltaValue;
    ...
}</code></pre><p>第一个成员变量 mNameConstant 就是用于区分不同类型的动画，在 ViewPropertyAnimator 内部定义了一系列常用动画的常量，mNameConstant 这个变量的取值就在这些常量中，如开头出现 SCALE_X。而另外两个变量表示的就是这种类型的动画要进行变化的数值信息。  </p>
<p>另外，ViewPropertyAnimator 支持设置一系列不同类型的动画，那么它是以什么为依据来决定哪一系列的动画作为第一组，哪一系列作为第二组呢？其实很简单，就是以 <code>startAnimation()</code> 被调用为依据。那么，成员变量 mPendingAnimations 的作用也就出来了。  </p>
<p>每一次调用 <code>scaleX()</code> 等等之类的方法时，都会创建一个 NameValuesHolder 对象来保存对应这种类型的动画信息，然后保存在 mPendingAnimations 列表中。<code>scaleY()</code> 等这些方法不断被调用，mPendingAnimations 就会保存越来越多的待执行的不同类型的动画。而一旦 <code>startAnimation()</code> 方法被调用时，就会将当前 mPendingAnimations 列表里存的这一系列动画作为同一组一起执行一起结束的动画保存到一个新的 PropertyBundle 对象里。然后清空 mPendingAnimations，直到下一次 <code>startAnimation()</code> 被调用时，再次将 mPendingAnimations 中新保存的一系列动画作为另外一组动画保存到新的 PropertyBundle 中去。  </p>
<p>那么，最后还需要有一个变量来保存并区分这一组一组的动画，这就是 mAnimatorMap 变量的作用了。  </p>
<pre><code>private HashMap&lt;Animator, PropertyBundle&gt; mAnimatorMap = new HashMap&lt;Animator, PropertyBundle&gt;();</code></pre><p>看一下定义，没错吧，PropertyBundle 保存的是一组动画里一起开始一起结束的一系列动画，所以 mAnimatorMap 是以 Animator 为 Key 区分每一组动画的。  </p>
<p>捋清楚了这些内部类和变量的作用，我们下面再来看之前分析的调用了 <code>scaleX()</code> 后，内部跟到了 <code>animatePropertyBy()</code>，那么我们继续跟下去看看：   </p>
<pre><code>//ViewPropertyAnimator#animatePropertyBy()
private void animatePropertyBy(int constantName, float startValue, float byValue) {
    //1. mAnimatorMap 存放着一组一组正在运行中的动画
    if (mAnimatorMap.size() &gt; 0) {
        Animator animatorToCancel = null;
        Set&lt;Animator&gt; animatorSet = mAnimatorMap.keySet();
        for (Animator runningAnim : animatorSet) {
            // 2. bundle 保存着当前这一组动画里的一系列正在运行中的不同类型的动画
            PropertyBundle bundle = mAnimatorMap.get(runningAnim);
            if (bundle.cancel(constantName)) {
                if (bundle.mPropertyMask == NONE) {    
                    animatorToCancel = runningAnim;
                    break;
                }
            }
        }
        if (animatorToCancel != null) {
            animatorToCancel.cancel();
        }
    }
    // 3. 所以上述1 2步的工作就是要将当前constantName类型的动画取消掉

    //4. 创建一个 NameValuesHolder 对象用于保存当前constantName类型的动画信息
    NameValuesHolder nameValuePair = new NameValuesHolder(constantName, startValue, byValue);
    //5. 将该类型的动画信息保存到 mPendingAnimations 中
    mPendingAnimations.add(nameValuePair);

    //6. 安排一个自动开启动画的Runnable，最迟在下一帧触发
    mView.removeCallbacks(mAnimationStarter);
    mView.postOnAnimation(mAnimationStarter);
}</code></pre><p>上述代码里从第 4-6 的步骤应该都清楚了吧，每次调用 <code>scaleX()</code> 之类的动画，内部需要先创建一个 NameValuesHolder 对象来保存该类型的动画行为（第4步），然后将该类型动画添加到 mPendingAnimations 列表中（第5步）来作为组成一系列一起开始一起结束的动画，最后会自动安排一个最迟在下一帧内自动启动动画的 Runnable（第6步）。  </p>
<p>那么第 1-3 步又是干嘛的呢？  </p>
<p>是这样的，上面说过，可能会存在一组一组都在运行中的动画，每一组都有一系列不同类型的动画，那么就有可能出现同一种类型的动画，比如 <code>scaleX()</code>，既在第一组里，又在第二组里。很显然，ViewPropertyAnimator 里的所有动画都是作用于同一个 View 上，而不同组的动画又有可能同一时刻都在运行中，那么，一个 View 的同一种类型动画有可能在同一时刻被执行两次么？说得白一点，一个 View 的大小如果在同一帧内先放大 1.2 倍，同时又放大 1.5 倍，那这个 View 呈现出来的效果肯定特别错乱。    </p>
<p>所以，ViewPropertyAnimator 里所有的动画，在同一时刻，同一类型的动画只支持只有一个处于正在运行中的状态，这也就是第 1-3 步的意义，它需要去遍历当前每一组里的每一个动画，如果类型跟当前设定的动画类型一致，那么就将之前的动画取消掉，以最近设定的这次为准。  </p>
<p>好了，<code>scaleX()</code> 这些设定动画的行为，内部实现的细节我们已经分析完了，下面就继续看看下一个流程，启动动画里都干了啥，<code>startAnimation()</code> ：</p>
<pre><code>//ViewPropertyAnimator#startAnimation()
private void startAnimation() {
    //1. 这里我还没搞懂，也不清楚什么场景下会满足这里的条件，直接 return。所以，本篇接下去的分析都是基于假设会直接跳过这里，后面如果搞懂了再来填坑。 
    if (mRTBackend != null &amp;&amp; mRTBackend.startAnimation(this)) {
        return;
    }
    mView.setHasTransientState(true);

    //2. 创建一个 0.0-1.0 变化的 ValueAnimator
    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);

    //3. 将当前 mPengingAnimations 里保存的一系列动画全都取出来，作为同一组一起执行一起结束的动画
    ArrayList&lt;NameValuesHolder&gt; nameValueList =
            (ArrayList&lt;NameValuesHolder&gt;) mPendingAnimations.clone();
    mPendingAnimations.clear();
    int propertyMask = 0;
    int propertyCount = nameValueList.size();
    //3.1 遍历这一系列动画，将这些动画都有哪些类型的动画标志出来
    for (int i = 0; i &lt; propertyCount; ++i) {
        NameValuesHolder nameValuesHolder = nameValueList.get(i);
        propertyMask |= nameValuesHolder.mNameConstant;
    }

    //4. 创建一个新的 PropertyBundle 来保存这一组动画，以ValueAnimator作为key来区分
    mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));

    //5. 提供动画开始前，结束后的操作回调
    if (mPendingSetupAction != null) {
        mAnimatorSetupMap.put(animator, mPendingSetupAction);
        mPendingSetupAction = null;
    }
    if (mPendingCleanupAction != null) {
        mAnimatorCleanupMap.put(animator, mPendingCleanupAction);
        mPendingCleanupAction = null;
    }
    if (mPendingOnStartAction != null) {
        mAnimatorOnStartMap.put(animator, mPendingOnStartAction);
        mPendingOnStartAction = null;
    }
    if (mPendingOnEndAction != null) {
        mAnimatorOnEndMap.put(animator, mPendingOnEndAction);
        mPendingOnEndAction = null;
    }

    //6. 对ValueAnimator进行 Listener、StartDelay、Duration、Interpolator 的设置
    animator.addUpdateListener(mAnimatorEventListener);
    animator.addListener(mAnimatorEventListener);
    if (mStartDelaySet) {
        animator.setStartDelay(mStartDelay);
    }
    if (mDurationSet) {
        animator.setDuration(mDuration);
    }
    if (mInterpolatorSet) {
        animator.setInterpolator(mInterpolator);
    }

    //7. 启用ValueAnimator.start()
    animator.start();
}</code></pre><p>第 1 步我还没搞清楚，就先暂时跳过吧。  </p>
<p>第 2-4 步就是我们上面有说过的，当 <code>startAnimation()</code> 被调用时，将当前保存在 mPendingAnimations 列表里所有的动画都作为同一组一起开始一起结束的动画，保存到一个新的 PropertyBundle 对象中，每一组动画什么时候开始，结束，以及每一帧的进度都是借助 ValueAnimator 机制实现，所以每一组动画就以不同的 ValueAnimator 对象作为 key 值保存到 mAnimatorMap 中相户区分，独立出来。  </p>
<p>第 5 步是 ViewPropertyAnimator 支持的接口，都是供外部根据需要使用，比如 mPendingOnStartAction 就是表示会在这一组动画开始的时候被执行，时机跟 <code>onAnimationStart()</code> 相同，外部使用的时候调用 <code>withStartAction()</code> 就可以了。那么为什么需要提供这样的接口呢？  </p>
<p>这是因为，如果我们想要在动画开始或结束的时候做一些事，如果我们是这样使用：  </p>
<pre><code>mView.animate().scaleX(1.2f)
    .setListener(new AnimatorListenerAdapter() {
        @Override
        public void onAnimationStart(Animator animation) {
            //do something
        }
    }).start();  </code></pre><p>没错，这样写的话，确实可以实现在动画前去执行我们指定的工作。但这样会有一个问题，因为 ViewPropertyAnimator 动画是支持多组动画同时进行中的，如果像上面这样写的话，那么每一组动画在开始之前就都会去回调这个 <code>onAnimationStart()</code> 方法，去做相同的事。  </p>
<p>如果我们只希望当前一组动画去执行这些动画开始前的工作，其他组动画不用去执行，那么这时候就可以使用 <code>withStartAction()</code> 来实现。</p>
<p>这就是第 5 步的用意。  </p>
<p>第 6-7 步也就是对 ValueAnimator 做各种配置，如持续时长，延迟开始时间，插值器等等，最后调用 <code>ValueAnimator.start()</code> 来启动。  </p>
<p>好，启动动画的具体的工作我们也分析完了，剩下最后一个流程了，在每一帧的回调中如何进行 ui 操作并且应用一系列的动画。那么，最后就看看 AnimatorEventListener:  </p>
<pre><code>//ViewPropertyAnimator.mAnimatorEventListener

private class AnimatorEventListener implements Animator.AnimatorListener, ValueAnimator.AnimatorUpdateListener {
    ...

    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        //1. 取出跟当前 ValueAnimator 绑定的那一组动画
        PropertyBundle propertyBundle = mAnimatorMap.get(animation);
        ...

        //省略一堆没看懂的代码，跟硬件加速有关
        ...

        //2. 获取 ValueAnimator 机制计算出的当前帧的动画进度
        float fraction = animation.getAnimatedFraction();
        int propertyMask = propertyBundle.mPropertyMask;
        ...

        //3. 遍历这一组动画里的所有动画，分别根据不同类型的动画进行不同的 ui 操作来实现动画效果
        ArrayList&lt;NameValuesHolder&gt; valueList = propertyBundle.mNameValuesHolder;
        if (valueList != null) {
            int count = valueList.size();
            for (int i = 0; i &lt; count; ++i) {
                //3.1 取出第i个动画
                NameValuesHolder values = valueList.get(i);
                //3.2 根据ValueAnimator计算的当前帧动画进度，以及第i个动画的第一帧的属性值和变化的值来计算出当前帧时的属性值是多少
                float value = values.mFromValue + fraction * values.mDeltaValue;

                //3.3 如果是 alpha 动画，通过View的set方法来修改alpha值，否则调用setValue方法
                if (values.mNameConstant == ALPHA) {
                    alphaHandled = mView.setAlphaNoInvalidation(value);
                } else {
                    setValue(values.mNameConstant, value);
                }
            }
        }

        //省略alpha动画的一些辅助处理
        ...

        //4. 进度回调，通知外部
        if (mUpdateListener != null) {
            mUpdateListener.onAnimationUpdate(animation);
        }
    }
}</code></pre><p>这个方法做的事也很明确了，上述代码中的注释大概也说完了。也就是说 ViewPropertyAnimator 动画内部在 ValueAnimator 的每一帧回调中，取出跟 ValueAnimator 绑定的那一组动画，以及当前帧的动画进度，然后再遍历当前组的所有动画，分别计算出每个动画当前帧的属性值，如果不是 alpha 动画的话，直接调用 <code>setValue()</code> 方法来进行 ui 操作达到动画效果，如果是 alpha 动画，则调用 view 的一个 set 方法来实现。  </p>
<p>那么，下面再继续看看 <code>setValue()</code> ：  </p>
<pre><code>//ViewPropertyAnimator#setValue()
private void setValue(int propertyConstant, float value) {
    final View.TransformationInfo info = mView.mTransformationInfo;
    final RenderNode renderNode = mView.mRenderNode;
    switch (propertyConstant) {
        case TRANSLATION_X:
            renderNode.setTranslationX(value);
            break;
        ...
        case SCALE_X:
            renderNode.setScaleX(value);
            break;
        case SCALE_Y:
            renderNode.setScaleY(value);
            break;
        ...
    }
}</code></pre><p>省略了一堆类似的代码，这个方法里，就全部都是根据不同类型的动画，取得当前 View 的 mRenderNode 对象，然后分别调用相应的 setXXX 方法，如 SCALE_X 动画，就调用 <code>setScaleX()</code> 方法来进行 ui 操作达到动画效果。  </p>
<p>以上，<code>View.animate()</code> 这种方式实现的动画，也就是 ViewPropertyAnimator 动画，的整个流程以及流程里每个步骤的工作，我们到此就全部梳理清楚了。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后，就来进行一下总结：  </p>
<ol>
<li><p><strong><code>View.animate()</code> 这种方式实现的动画其实是 ViewPropertyAnimator 动画。</strong>  </p>
</li>
<li><p><strong>ViewPropertyAnimator 并不是一种动画，它没有继承自 Animator 或者 Animation，它其实只是一个封装类，将常用的动画封装起来，对外提供方便使用的接口，内部借助 ValueAnimator 机制。</strong>  </p>
</li>
<li><p><strong>ViewPropertyAnimator 动画支持自动启动动画，如果外部没有明确调用了 <code>start()</code>，那么内部会安排一个 Runnable 操作，最迟在下一帧内被执行，这个 Runnable 会去启动动画。</strong>  </p>
</li>
<li><p><strong>当然，如果外部手动调用了 <code>start()</code>，那么自动启动动画就没意义了，内部会自己将其取消掉。</strong>  </p>
</li>
<li><p><strong>ViewPropertyAnimator 对外提供的使用动画的接口非常方便，如 <code>scaleX()</code> 表示 x 的缩放动画，<code>alpha()</code> 表示透明度动画，而且支持链式调用。</strong>  </p>
</li>
<li><p><strong>由于支持链式调用，所以它支持一系列动画一起开始，一起执行，一起结束。那么当这一系列动画还没执行完又重新发起了另一系列的动画时，此时两个系列动画就需要分成两组，每一组动画互不干扰，可以同时执行。</strong>  </p>
</li>
<li><p><strong>但如果同一种类型的动画，如 SCALE_X，在同一帧内分别在多组里都存在，如果都同时运行的话，View 的状态会变得很错乱，所以 ViewPropertyAnimator 规定，同一种类型的动画在同一时刻只能有一个在运行。</strong>  </p>
</li>
<li><p><strong>也就是说，多组动画可以处于并行状态，但是它们内部的动画是没有交集的，如果有交集，比如 SCALE_X 动画已经在运行中了，但是外部又新设置了一个新的 SCALE_X 动画，那么之前的那个动画就会被取消掉，新的 SCALE_X 动画才会加入新的一组动画中。</strong>  </p>
</li>
<li><p><strong>由于内部是借助 ValueAnimator 机制，所以在每一帧内都可以接收到回调，在回调中取得 ValueAnimator 计算出的当前帧的动画进度。</strong>  </p>
</li>
<li><p><strong>取出当前帧的动画进度后，就可以遍历跟当前 ValueAnimator 绑定的那一组动画里所有的动画，分别根据每一个动画保存的信息，来计算出当前帧这个动画的属性值，然后调用 View 的 mRenderNode 对象的 setXXX 方法来修改属性值，达到动画效果。</strong>  </p>
</li>
</ol>
<p>还有一些细节并没有归纳到总结中，如果只看总结的小伙伴，有时间还是建议可以慢慢跟着本文过一遍。  </p>
<h1 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h1><p><strong>Q1：开头说了，使用这种方式实现的动画在某些场景下会有一个坑，这个坑又是什么，是在什么场景下的呢？</strong>  </p>
<p>开头说过使用这种方式实现的动画，在某些场景下会存在一些坑。本来以为这篇里也能顺便说清楚，但单单只是原理梳理下来，篇幅就很长了，那么也当做遗留问题，留到之后的文章中来好好说下吧。可以先说下是什么坑：  </p>
<p>如果当前界面有使用 RecyclerView 控件，然后又对它的 item 通过 <code>View.animate()</code> 方式实现了一些动画效果，比如很常见的 Tv 应用的主页，界面会有很多卡位，然后每个卡位获得焦点时一般都需要放大的动画，此时这个卡位就是 RecyclerView 的 item，放大动画可以通过 <code>View.animate()</code> 方式来实现。  </p>
<p>在这种场景下，可能会存在这么一种现象，当界面刷新时，如果此时有进行遥控器的方向键按键事件，那么可能会有一些卡位的缩放动画被中断的现象。为什么会出现这种现象，再找个时间来梳理清楚。  </p>
<p><strong>Q2：View 的 mRenderNode 对象又是个什么东西？它的 setXXX 方法又是如何修改 View 的属性值来达到动画效果的？</strong></p>
<p>还有第二个遗留问题，虽然本篇梳理了 ViewPropertyAnimator 动画的流程和原理，但到最后，我们其实只知道它内部借助了 ValueAnimator 机制来计算每一帧的动画进度，然后在每一帧的回调中先获取 View 的 mRenderNode 对象，再调用相应的 setXXX 方法来修改属性值达到动画效果。但这个 mRenderNode 是个什么东西，又是如何修改 view 的状态来达到动画效果的这点就还需要找个时间来梳理了。</p>
<p>所以到最后，ViewPropertyAnimator 内部的流程和原理虽然已经清楚了，但具体要不要将这个动画归纳到属性动画中，我就不大清楚了。虽然它内部是借助了 ViewAnimator 机制，但 ValueAnimator 其实并没有任何的 ui 操作，ObjectAnimator 才会去通过反射来调用相关的 setXXX 方法来修改属性值，这个过程才是 ui 操作，最后才会有相应的动画效果呈现出来。这点还有待继续研究。    </p>
]]></content>
      <categories>
        <category>Android源码解析</category>
      </categories>
  </entry>
  <entry>
    <title>属性动画 ValueAnimator 运行原理全解析</title>
    <url>/2018/03/18/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB-ValueAnimator-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</strong>  </p>
</blockquote>
<p>最近下班时间都用来健身还有看书了，博客被晾了一段时间了，原谅我<del>~</del>  </p>
<h1 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h1><p>好，废话不多说，之前我们已经分析过 <a href="https://www.jianshu.com/p/48317612c164" target="_blank" rel="noopener">View 动画 Animation 运行原理解析</a>，那么这次就来学习下属性动画的运行原理。  </p>
<p><strong>Q1：我们知道，Animation 动画内部其实是通过 ViewRootImpl 来监听下一个屏幕刷新信号，并且当接收到信号时，从 DecorView 开始遍历 View 树的绘制过程中顺带将 View 绑定的动画执行。那么，属性动画（Animator）原理也是这样么？如果不是，那么它又是怎么实现的？</strong>  </p>
<p><strong>Q2：属性动画（Animator）区别于 Animation 动画的就是它是有对 View 的属性进行修改的，那么它又是怎么实现的，原理又是什么？</strong>  </p>
<p><strong>Q3：属性动画（Animator）调用了 <code>start()</code> 之后做了些什么呢？何时开始处理当前帧的动画工作？内部又进行了哪些计算呢？</strong></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>属性动画的使用，常接触的其实就是两个类 <strong>ValueAnimator</strong>， <strong>ObjectAnimator</strong>。其实还有一个 <strong>View.animate()</strong>，这个内部原理也是属性动画，而且它已经将常用的动画封装好了，使用起来很方便，但会有一个坑，我们留着下一篇来介绍，本篇着重介绍属性动画的运行原理。  </p>
<p>先看看基本的使用步骤：  </p>
<pre><code>//1.ValueAnimator用法  
ValueAnimator animator = ValueAnimator.ofInt(500);
animator.setDuration(1000);
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
               int value = (int) animation.getAnimatedValue();
               mView.setX(value);  
         }
 });
animator.start();

//2.ObjectAnimator用法
ObjectAnimator animator = ObjectAnimator.ofInt(mView, &quot;X&quot;, 500).setDuration(1000).start();</code></pre><p>这样你就可以看到一个执行了 1s 的平移动画，那么接下去就该开始跟着源码走了，我们需要梳理清楚，这属性动画是什么时候开始执行，如何执行的，真正生效的地方在哪里，怎么持续 1s 的，内部是如何进行计算的。  </p>
<p>在之前分析 Animation 动画运行原理后，我们也接着分析了 <a href="https://www.jianshu.com/p/0d00cb85fdf3" target="_blank" rel="noopener">Android 屏幕刷新机制</a>，通过这两篇，我们知道了 Android 屏幕刷新的关键其实是 Choreographer 这个类，感兴趣的可以再回去看看，这里提几点里面的结论：  </p>
<blockquote>
<p>我们知道，Android 每隔 16.6ms 会刷新一次屏幕，也就是每过 16.6ms 底层会发出一个屏幕刷新信号，当我们的 app 接收到这个屏幕刷新信号时，就会去计算屏幕数据，也就是我们常说的测量、布局、绘制三大流程。这整个过程关键的一点是，app 需要先向底层注册监听下一个屏幕刷新信号事件，这样当底层发出刷新信号时，才可以找到上层 app 并回调它的方法来通知事件到达了，app 才可以接着去做计算屏幕数据之类的工作。   </p>
<p>而注册监听以及提供回调接口供底层调用的这些工作就都是由 Choreographer 来负责，Animation 动画的原理是通过当前 View 树的 ViewRootImpl 的 <code>scheduleTraversals()</code> 方法来实现，这个方法的内部逻辑会走到 Choreographer 里去完成注册监听下一个屏幕刷新信号以及接收到事件之后的工作。  </p>
<p>需要跟屏幕刷新信号打交道的话，归根结底最后都是通过 Choreographer 这个类。  </p>
</blockquote>
<p>那么，当我们在过属性动画（Animator）的流程源码时，我们就有一个初步的目标了，至少我们知道了需要跟踪到 Choreographer 里才可以停下来。至于属性动画的流程原理是跟 Animation 动画流程一样通过 ViewRootImpl 来实现的呢？还是其他的方式？这些就是我们这次过源码需要梳理出来的了，那么下面就开始过源码吧。  </p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>ps：本篇分析的源码基于 android-25 版本，版本不一样，源码可能会有些差别，大伙自己过的时候注意一下。  </p>
<p>过动画源码的着手点应该都很简单，跟着 <code>start()</code> 一步步追踪下去梳理清楚就可以了。  </p>
<p>我们知道 ObjectAnimator 是继承的 ValueAnimator，那么我们可以直接从 ValueAnimator 的 <code>start()</code> 开始看，等整个流程梳理清楚后，再回过头看看 ObjectAnimator 的 <code>start()</code> 多做了哪些事就可以了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-60cbc9493105a9ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ValueAnimator#start.png"><br>很简单，调用了内部的 <code>start(boolean)</code> 方法，  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-fe3b2cc9c5c9f898.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ValueAnimator#start(boolean).png"><br>前面无外乎就是一些变量的初始化，然后好像调用了很多方法，emmm，其实我们并没有必要每一行代码都去搞懂，我们主要是想梳理整个流程，那么单看方法命名也知道，我们下面就跟着 <code>startAnimation()</code> 进去看看（但记得，如果后面跟不下去了，要回来这里看看我们跳过的方法是不是漏掉了一些关键的信息）：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-2ef0af810900a398.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ValueAnimator#startAnimation.png"><br>这里调用了两个方法，<code>initAnimation()</code> 和 <code>notifyStartListeners()</code>，感觉这两处也只是一些变量的初始化而已，还是没涉及到流程的信息啊，不管了，也还是先跟进去确认一下看看：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-c4193e1187a53487.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ValueAnimator#initAnimation.png"><br>确实只是进行一些初始化工作而已，看看另外一个：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-ec4eb9a42e7e6743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ValueAnimator#notifyStartListeners.png"><br>这里也只是通知动画开始，回调 listener 的接口而已。  </p>
<p>emmm，我们从 <code>start()</code> 开始一路跟踪下来，发现到目前为止都只是在做动画的一些初始化工作而已，而且跟到这里很明显已经是尽头了，下去没有代码了，那么动画初始化之后的下一个步骤到底是在哪里进行的呢？还记得我们前面在 <code>start(boolean)</code> 方法里跳过了一些方法么？也许关键就是在这里，那么再回头过去看看：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-0368e986f1aec412.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ValueAnimator#start(boolean)2.png"><br>我们刚才是根据方法命名，想当然的直接跟着 <code>startAnimation()</code> 走下去了，既然这条路走到底没找到关键信息，那么就折回头看看其他方法。这里调用了 AnimationHandler 类的 <code>addAnimationFrameCallback()</code>，新出现了一个类，看命名应该是专门处理动画相关的，而且还是单例类，跟进去看看：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-c9571db6762a9a1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AnimationHandler#addAnimationFrameCallback.png"><br>首先第二个参数 delay 取决于我们是否调用了 <code>setStartDelay()</code> 来设置动画的延迟执行，假设目前的动画都没有设置，那么 delay 也就是 0，所以这里着重看一下前面的代码。  </p>
<p>mAnimationCallbacks 是一个 ArrayList，每一项保存的是 AnimationFrameCallback 接口的对象，看命名这是一个回调接口，那么是谁在什么时候会对它进行回调呢？根据目前仅有的信息，我们并没有办法看出来，那么可以先放着，这里只要记住第一个参数之前传进来的是 this，也就是说如果这个接口被回调时，那么 ValueAnimator 对这个接口的实现将会被回调。    </p>
<p>接下去开始按顺序过代码了，当 mAnimationCallbacks 列表大小等于 0 时，将会调用一个方法，很明显，如果动画是第一次执行的话，那么这个列表大小应该就是 0，因为将 callback 对象添加到列表里的操作是在这个判断之后，所以这里我们可以跟进看看：<br><img src="https://upload-images.jianshu.io/upload_images/1924341-90a74eb4a5f4e0a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AnimationHandler#getProvider.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5563b60614c3155c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MyFrameCallbackProvider#postFrameCallback.png"></p>
<p>哇，这么快就看到 Choreographer 了，感觉我们好像已经快接近真相了，继续跟下去：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-203095f117c18d97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Choreographer#postFrameCallback.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-5f4bc75b01d32c82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Choreographer#postFrameCallbackDelayed.png"></p>
<p>所以内部其实是调用了 <code>postCallbackDelayedInternal()</code> 方法，如果有看过我写的上一篇博客 <strong><em>Android 屏幕刷新机制</em></strong>，到这里是不是已经差不多可以理清了，有时间的可以回去看看，我这里概括性地给出些结论。  </p>
<p>Choreographer 内部有几个队列，上面方法的第一个参数 CALLBACK_ANIMATION 就是用于区分这些队列的，而每个队列里可以存放 FrameCallback 对象，也可以存放 Runnable 对象。Animation 动画原理上就是通过 ViewRootImpl 生成一个 <code>doTraversal()</code> 的 Runnable 对象（其实也就是遍历 View 树的工作）存放到 Choreographer 的队列里的。而这些队列里的工作，都是用于在接收到屏幕刷新信号时取出来执行的。但有一个关键点，Choreographer 要能够接收到屏幕刷新信号的事件，是需要先调用 Choreographer 的 <code>scheduleVsyncLocked()</code> 方法来向底层注册监听下一个屏幕刷新信号事件的。  </p>
<p>而如果继续跟踪 <code>postCallbackDelayedInternal()</code> 这个方法下去的话，你会发现，它最终就是走到了 <code>scheduleVsyncLocked()</code> 里去，这些在上一篇博客 Android 屏幕刷新机制里已经梳理过了，这里就不详细讲了。  </p>
<p><strong>那么，到这里，我们就可以先来梳理一下目前的信息了：</strong>  </p>
<p>当 ValueAnimator 调用了 <code>start()</code> 方法之后，首先会对一些变量进行初始化工作并通知动画开始了，然后 ValueAnimator 实现了 AnimationFrameCallback 接口，并通过 AnimationHander 将自身 this 作为参数传到 mAnimationCallbacks 列表里缓存起来。而 AnimationHandler 在 mAnimationCallbacks 列表大小为 0 时会通过内部类 MyFrameCallbackProvider 将一个 mFrameCallback 工作缓存到 Choreographer 的待执行队列里，并向底层注册监听下一个屏幕刷新信号事件。  </p>
<p>当屏幕刷新信号到的时候，Choreographer 的 <code>doFrame()</code> 会去将这些待执行队列里的工作取出来执行，那么此时也就回调了 AnimationHandler 的 mFrameCallback 工作。  </p>
<p>那么到目前为止，我们能够确定，当动画第一次调用 <code>start()</code>，这里的第一次应该是指项目里所有的属性动画里某个动画第一次调用 <code>start()</code>，因为 AnimationHandler 是一个单例类，显然是为所有的属性动画服务的。如果是第一次调用了 <code>start()</code>，那么就会去向底层注册监听下一个屏幕刷新信号的事件。所以动画的处理逻辑应该就是在接收到屏幕刷新信号之后回调到的 mFrameCallback 工作里会去间接的调用到的了。  </p>
<p>那么，接下去就继续看看，<strong>当接收到屏幕刷新信号之后，mFrameCallback 又继续做了什么</strong>：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6902a27ce29d4321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AnimationHandler#mFrameCallback.png"><br>其实就做了两件事，一件是去处理动画的相关工作，也就是说要找到动画真正执行的地方，跟着 <code>doAnimationFrame()</code> 往下走应该就行了。而剩下的代码就是处理另外一件事：继续向底层注册监听下一个屏幕刷新信号。  </p>
<p>先讲讲第二件事，我们知道，动画是一个持续的过程，也就是说，每一帧都应该处理一个动画进度，直到动画结束。既然这样，我们就需要在动画结束之前的每一个屏幕刷新信号都能够接收到，所以在每一帧里都需要再去向底层注册监听下一个屏幕刷新信号事件。所以你会发现，上面代码里参数是 this，也就是 mFrameCallback 本身，结合一下之前的那个流程，这里可以得到的信息是：  </p>
<p>当第一个属性动画调用了 <code>start()</code> 时，由于 mAnimationCallbacks 列表此时大小为 0，所以直接由 <code>addAnimationFrameCallback()</code> 方法内部间接的向底层注册下一个屏幕刷新信号事件，然后将该动画加入到列表里。而当接收到屏幕刷新信号时，mFrameCallback 的 <code>doFrame()</code> 会被回调，该方法内部做了两件事，一是去处理当前帧的动画，二则是根据列表的大小是否不为 0 来决定继续向底层注册监听下一个屏幕刷新信号事件，如此反复，直至列表大小为 0。  </p>
<p>所以，这里可以猜测一点，如果当前动画结束了，那么就需要将其从 mAnimationCallbacks 列表中移除，这点可以后面跟源码过程中来验证。<br>那么，下去就是跟着 <code>doAnimationFrame()</code> 来看看，属性动画是怎么执行的：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-f3d2c7179c4b00ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AnimationHandler#doAnimationFrame.png"><br>这里概括下其实就做了两件事：  </p>
<p>一是去循环遍历列表，取出每一个 ValueAnimator，然后判断动画是否有设置了延迟开始，或者说动画是否到时间该执行了，如果到时间执行了，那么就会去调用 ValueAnimator 的 <code>doAnimationFrame()</code>；  </p>
<p>二是调用了 <code>cleanUpList()</code> 方法，看命名就可以猜测是去清理列表，那么应该也就是处理掉已经结束的动画，因为 AnimationHandler 是为所有属性动画服务的，同一时刻也许有多个动画正在进行中，那么动画的结束肯定有先后，已经结束的动画肯定要从列表中移除，这样等所有动画都结束了，列表大小变成 0 了，mFrameCallback 才可以停止向底层注册监听下一个屏幕刷新信号事件，AnimationHandler 才可以进入空闲状态，不用再每一帧都去处理动画的工作。  </p>
<p>那么，我们优先看看 <code>cleanUpList()</code>，因为感觉它的工作比较简单，那就先梳理掉：<br><img src="https://upload-images.jianshu.io/upload_images/1924341-0fe44d5fcc44b216.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AnimationHandler#cleanUpList.png"><br>猜测正确，将列表中为 null 的对象都移除掉，那么我们就可以继续进一步猜测，动画如果结束的话，会将自身在这个列表中的引用赋值为 null，这点可以在稍微跟踪动画的流程中来进行确认。  </p>
<p>清理的工作梳理完，那么接下去就是继续去跟着动画的流程了，还记得我们上面提到了另一件事是遍历列表去调用每个动画 ValueAnimator 的 <code>doAnimationFrame()</code> 来处理动画逻辑么，那么我们接下去就跟进这个方法看看：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-36ac0bcd52571982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ValueAnimator#doAnimationFrame.png"><br>上面省略了部分代码，省略的那些代码跟动画是否被暂停或重新开始有关，本篇优先梳理正常的动画流程，这些就先不关注了。  </p>
<p>稍微概括一下，这个方法内部其实就做了三件事：<br>一是处理第一帧动画的一些工作；  </p>
<p>二是根据当前时间计算当前帧的动画进度，所以动画的核心应该就是在 <code>animateBaseOnTime()</code> 这个方法里，意义就类似 Animation 动画的 <code>getTransformation()</code>方法；  </p>
<p>三是判断动画是否已经结束了，结束了就去调用 <code>endAnimation()</code>，按照我们之前的猜测，这个方法内应该就是将当前动画从 mAniamtionCallbacks 列表里移除。  </p>
<p>我们先来看动画结束之后的处理工作，因为上面才刚梳理了一部分，趁着现在大伙还有些印象，而且这部分工作会简单易懂点，先把简单的吃掉：<br><img src="https://upload-images.jianshu.io/upload_images/1924341-d81a2431999ae270.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ValueAnimator#endAnimation.png"></p>
<p>很简单，两件事，一是去通知说动画结束了，二是调用了 AniamtionHandler 的 <code>removeCallback()</code>，继续跟进看看：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-3cb106d909aeb520.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AnimationHandler#removeCallback.png"><br>我们之前的猜测在这里得到验证了吧，如果动画结束，那么它会将其自身在 AnimationCallbacks 列表里的引用赋值为 null，然后移出列表的工作就交由 AnimationHandler 去做。我们说了，AnimationHandler 是为所有的属性动画服务的，那么当某个动画结束的话，就必须进行一些资源清理的工作，整个清理的流程逻辑就是我们目前梳理出来的这样。  </p>
<p>好，搞定了一个小点了，那么接下去继续看剩下的两件事，先看第一件，<strong>处理动画第一帧的工作问题</strong>：  </p>
<p>参考 Animation 动画的原理，第一帧的工作通常都是为了记录动画第一帧的时间戳，因为后续的每一帧里都需要根据当前时间以及动画第一帧的时间还有一个动画持续时长来计算当前帧动画所处的进度，Animation 动画我们梳理过了，所以这里在过第一帧的逻辑时应该就会比较有条理点。我们来看看，属性动画的第一帧的工作是不是跟 Animation 差不多：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a4fcedaa09c5f41a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ValueAnimator#doAnimationFrame2.png"></p>
<p>emmm，看来比 Animation 动画复杂多了，大体上也是干了两件事：  </p>
<p>一是调用了 AnimationHandler 的 <code>addOneShotCommitCallback()</code> 方法，具体是干嘛的我们等会来分析；  </p>
<p>二就是记录动画第一帧的时间了，mStartTime 变量就是表示第一帧的时间戳，后续的动画进度计算肯定需要用到这个变量。至于还有一个 mSeekFraction 变量，它的作用有点类似于我们用电脑看视频时，可以任意选择从某个进度开始观看。属性动画有提供了一个接口 <code>setCurrentPlayTime()</code>。  </p>
<pre><code>ValueAnimator animator = ValueAnimator.ofInt(0, 100);
animator.setDuration(4000);
animator.start();</code></pre><p>举个例子，。这是一个持续 4s 从 0 增长到 100 的动画，如果我们调用了 <code>start()</code>，那么 mSeekFraction 默认值是 -1，所以 mStartTime 就是用当前时间作为动画的第一帧时间。如果我们调用了 <code>setCurrentPlayTime(2000)</code>，意思就是说，我们希望这个动画从 2s 开始，那么它就是一个持续 2s(4-2) 的从 50 增长到 100 的动画（假设插值器为线性），所以这个时候，mStartTime 就是以比当前时间还早 2s 作为动画的第一帧时间，后面根据 mStartTime 计算动画进度时，就会发现原来动画已经过了 2s 了。  </p>
<p>就像我们看电视时，我们不想看片头，所以直接选择从正片开始看，类似的道理。  </p>
<p>好了，还记得前面说了处理动画第一帧的工作大体上有两件事，另一件是调用了一个方法么。我们回头来看看，这里又是做了些什么：<br><img src="https://upload-images.jianshu.io/upload_images/1924341-b15e728ecf78a2e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AnimationHandler#addOneShotCommitCallback.png"></p>
<p>只是将 ValueAnimator 添加到 AnimationHandler 里的另一个列表中去，可以过滤这个列表的变量名看看它都在哪些地方被使用到了：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-476edd8214ea2e02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AnimationHandler#doAnimationFrame2.png"><br>这地方还记得吧，我们上面分析的那一大堆工作都是跟着 <code>callback.doAnimationFrame(frameTime)</code> 这行代码走进去的，虽然内部做的事我们还没全部分析完，但我们这里可以知道，等内部所有事都完成后，会退回到 AnimationHandler 的 <code>doAnimationFrame()</code> 继续往下干活，所以再继续跟下去看看：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-0cfebf5690d83163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AnimationHandler#postCommitCallback.png"><br>上面说过，Choreographer 内部有多个队列，每个队列里都可以存放 FrameCallback 对象，或者 Runnable 对象。这次是传到了另一个队列里，传进的是一个 Runnable 对象，我们看看这个 Runnable 做了些什么：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-451fa0f066aab715.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AnimationHandler#commitAnimationFrame.png"></p>
<p>ValueAnimator 实现了 AnimationFrameCallback 接口，这里等于是回调了 ValueAnimator 的方法，然后将其从队列中移除。看看 ValueAnimator 的实现做了些什么：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-4e04ad4a44cc22e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ValueAnimator#commitAnimationFrame.png"></p>
<p>好嘛，这里说穿了其实也是在修正动画的第一帧时间 mStartTime。那么，其实也就是说，ValueAnimator 的 <code>doAnimationFrame()</code> 里处理第一帧工作的两件事全部都是用于计算动画的第一帧时间，只是一件是根据是否 “跳过片头”( <code>setCurrentPlayTime()</code>) 计算，另一件则是这里的修正。  </p>
<p>那么，<strong>这里为什么要对第一帧时间 mStartTime 进行修正呢？</strong>  </p>
<p>大伙有时间可以去看看 AnimationFrameCallback 接口的 <code>commitAnimationFrame()</code> 方法注释，官方解释得特别清楚了，我这里就不贴图了，直接将我的理解写出来：  </p>
<p>其实，这跟属性动画通过 Choreographer 的实现原理有关。我们知道，屏幕的刷新信号事件都是由 Choreographer 负责，它内部有多个队列，这些队列里存放的工作都是用于在接收到信号时取出来处理。那么，这些队列有什么区别呢？  </p>
<p>其实也就是执行的先后顺序的区别，按照执行的先后顺序，我们假设这些队列的命名为：1队列 &gt; 2队列 &gt; 3队列。我们本篇分析的属性动画，AnimationHandler 封装的 mFrameCallback 工作就是放到 1队列里的；而之前分析的 Animation 动画，它通过 ViewRootImpl 封装的 <code>doTraversal()</code> 工作是放到 2队列里的；而上面刚过完的修正动画第一帧时间的 Runnable 工作则是放到 3队列里的。  </p>
<p>也就是说，当接收到屏幕刷新信号后，属性动画会最先被处理。然后是去计算当前屏幕数据，也就是测量、布局、绘制三大流程。但是这样会有一个问题，如果页面太过复杂，绘制当前界面时花费了太多的时间，那么等到下一个屏幕刷新信号时，属性动画根据之前记录的第一帧时间戳计算动画进度时，会发现丢了开头的好几帧，明明动画没还执行过。所以，这就是为什么需要对动画第一帧时间进行修正。  </p>
<p>当然，如果动画已经开始了，在动画中间某一帧，就不会去修正了，这个修正，只是针对动画的第一帧时间。因为，如果是在第一帧发现绘制界面太耗时，丢了开头几帧，那么我们可以通过延后动画开始的时机来达到避免丢帧。但如果是在动画执行过程中才遇到绘制界面太耗时，那不管什么策略都无法避免丢帧了。  </p>
<hr>
<h2 id="小结1："><a href="#小结1：" class="headerlink" title="小结1："></a>小结1：</h2><p>好了，到这里，大伙先休息下，我们来梳理一下目前所有的信息，不然我估计大伙已经忘了上面讲过什么了：  </p>
<ol>
<li><p><strong>ValueAnimator 属性动画调用了 <code>start()</code> 之后，会先去进行一些初始化工作，包括变量的初始化、通知动画开始事件；</strong>  </p>
</li>
<li><p><strong>然后通过 AnimationHandler 将其自身 this 添加到 mAnimationCallbacks 队列里，AnimationHandller 是一个单例类，为所有的属性动画服务，列表里存放着所有正在进行或准备开始的属性动画；</strong>  </p>
</li>
<li><p><strong>如果当前存在要运行的动画，那么 AnimationHandler 会去通过 Choreographer 向底层注册监听下一个屏幕刷新信号，当接收到信号时，它的 mFrameCallback 会开始进行工作，工作的内容包括遍历列表来分别处理每个属性动画在当前帧的行为，处理完列表中的所有动画后，如果列表还不为 0，那么它又会通过 Choreographer 再去向底层注册监听下一个屏幕刷新信号事件，如此反复，直至所有的动画都结束。</strong>  </p>
</li>
<li><p><strong>AnimationHandler 遍历列表处理动画是在 <code>doAnimationFrame()</code> 中进行，而具体每个动画的处理逻辑则是在各自，也就是 ValueAnimator 的 <code>doAnimationFrame()</code> 中进行，各个动画如果处理完自身的工作后发现动画已经结束了，那么会将其在列表中的引用赋值为空，AnimationHandler 最后会去将列表中所有为 null 的都移除掉，来清理资源。</strong>  </p>
</li>
<li><p><strong>每个动画 ValueAnimator 在处理自身的动画行为时，首先，如果当前是动画的第一帧，那么会根据是否有”跳过片头”（<code>setCurrentPlayTime()</code>）来记录当前动画第一帧的时间 mStartTime 应该是什么。</strong>  </p>
</li>
<li><p><strong>第一帧的动画其实也就是记录 mStartTime 的时间以及一些变量的初始化而已，动画进度仍然是 0，所以下一帧才是动画开始的关键，但由于属性动画的处理工作是在绘制界面之前的，那么有可能因为绘制耗时，而导致 mStartTime 记录的第一帧时间与第二帧之间隔得太久，造成丢了开头的多帧，所以如果是这种情况下，会进行 mStartTime 的修正。</strong>  </p>
</li>
<li><p><strong>修正的具体做法则是当绘制工作完成后，此时，再根据当前时间与 mStartTime 记录的时间做比较，然后进行修正。</strong>  </p>
</li>
<li><p><strong>如果是在动画过程中的某一帧才出现绘制耗时现象，那么，只能表示无能为力了，丢帧是避免不了的了，想要解决就得自己去分析下为什么绘制会耗时；而如果是在第一帧是出现绘制耗时，那么，系统还是可以帮忙补救一下，修正下 mStartTime 来达到避免丢帧。</strong>  </p>
</li>
</ol>
<p>好了，休息结束，我们继续，还有一段路要走，其实整个流程目前大体上已经出来了，只是缺少了当前帧的动画进度具体计算实现细节，这部分估计会更让人头大。  </p>
<p>之前分析 ValueAnimator 的 <code>doAnimationFrame()</code> 时，我们将其概括出来主要做了三件事：一是处理第一帧动画的工作；二是根据当前时间计算并实现当年帧的动画工作；三是根据动画是否结束进行一些资源清理工作；一三我们都分析了，下面就来过过第二件事，<code>animateBasedOnTime()</code>：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-b2248e27890e5eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ValueAnimator#animateBaseOnTime.png"></p>
<p>从这里开始，就是在计算当前帧的动画逻辑了，整个过程跟 Animation 动画基本上差不多。上面的代码里，我省略了一部分，那部分是用于根据是否设置的 mRepeatCount 来处理动画结束后是否需要重新开始，这些我们就不看了，我们着重梳理一个正常的流程下来即可。  </p>
<p>所以，概括一下，这个方法里其实也就是做了三件事：  </p>
<p>一是，根据当前时间以及动画第一帧时间还有动画持续的时长来计算当前的动画进度。  </p>
<p>二是，确保这个动画进度的取值在 0-1 之间，这里调用了两个方法来辅助计算，我们就不跟进去了，之所以有这么多的辅助计算，那是因为，属性动画支持 <code>setRepeatCount()</code> 来设置动画的循环次数，而从始至终的动画第一帧的时间都是 mStrtTime 一个值，所以在第一个步骤中根据当前时间计算动画进度时会发现进度值是可能会超过 1 的，比如 1.5, 2.5, 3.5 等等，所以第二个步骤的辅助计算，就是将这些值等价换算到 0-1 之间。  </p>
<p>三就是最重要的了，当前帧的动画进度计算完毕之后，就是需要应用到动画效果上面了，所以 <code>animateValue()</code> 方法的意义就是类似于 Animation 动画中的 <code>applyTransformation()</code>。  </p>
<p>我们都说，属性动画是通过修改属性值来达到动画效果的，那么我们就跟着 <code>animateValue()</code> 进去看看：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-97fe4c2e674a1688.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ValueAnimator#animateValue.png"></p>
<p>这里干的活我也大概的给划分成了三件事：  </p>
<p>一是，根据插值器来计算当前的真正的动画进度，插值器算是动画里比较重要的一个概念了，可能平时用的少，如果我们没有明确指定使用哪个插值器，那么系统通常会有一个默认的插值器。  </p>
<p>二是，根据插值器计算得到的实际动画进度值，来映射到我们需要的数值。这么说吧，就算经过了插值器计算之后，动画进度值也只是 0-1 区间内的某个值而已。而我们通常需要的并不是 0-1 的数值，比如我们希望一个 0-500 的变化，那么我们就需要自己在拿到 0-1 区间的进度值后来进行转换。第二个步骤，大体上的工作就是帮助我们处理这个工作，我们只需要告诉 ValueAnimator 我们需要 0-500 的变化，那么它在拿到进度值后会进行转换。  </p>
<p>三就只是通知动画的进度回调而已了。  </p>
<p>流程上差不多已经梳理出来了，不过我个人对于内部是如何根据拿到的 0-1 区间的进度值转换成我们指定区间的数值的工作挺感兴趣的，那么我们就稍微再深入去分析一下好了。这部分工作主要就是调用了 <code>mValues[i].calculateValue(fraction)</code> 这一行代码来实现，mValues 是一个 PropertyValuesHolder 类型的数组，所以关键就是去看看这个类的 <code>calculateValue()</code> 做了啥：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-ed2f4ce15f14d9b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PropertyValuesHolder#calculateValue.png"></p>
<p>我们在使用 ValueAnimator 时，注册了动画进度回调，然后在回调里取当前的值时其实也就是取到上面那个 mAnimatedValue 变量的值，而这个变量的值是通过 <code>mKeyframes.getValue()</code> 计算出来的，那么再继续跟进看看：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6ae407edfc0f470d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KeyFrames#getValue.png"></p>
<p>KeyFrames 是一个接口，那么接下去就是要找找哪里实现了这个接口：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-72f3e29487b34f14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PropertyValuesHolder#setIntValues.png"></p>
<p>具体的找法，可以在 PropertyValuesHolder 这个类里利用 <code>Ctrl + F</code> 过滤一下 <code>mKeyframes =</code>来看一下它在哪些地方被实例化了。匹配到的地方很多，但都差不多，都是通过 KeyframeSet 的 ofXXX 方法实例化得到的对象，那么具体的实现应该就是在 KeyframeSet 这个类里了。  </p>
<p>在跟进去看之前，有一点想提一下，大伙应该注意到了吧，mKeyframes 实例化的这些地方，<code>ofInt()</code>，<code>onFloat()</code> 等等是不是很熟悉。没错，就是我们创建属性动画时相似的方法名， 其实 <code>ValueAnimator.ofInt()</code> 内部会根据相应的方法来创建 mKeyframes 对象，也就是说，在实例化属性动画时，这些 mKeyframes 也顺便被实例化了。想确认的，大伙可以自己去跟下源码看看，我这里就不贴了。  </p>
<p>好了，接下去看看 KeyframeSet 这个类的 <code>ofInt()</code> 方法，看看它内部具体是创建了什么：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-271400f60db0d636.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KeyframeSet#ofInt.png"></p>
<p>这里又涉及到新的机制了吧，Keyframe，KeyframeSet，Keyframes 这些大伙感兴趣可以去查查看，我也没有深入去了解。但看了别人的一些介绍，这里大概讲一下。直接从翻译上来看，这个也就是指关键帧，就像一部电影由多帧画面组成一样的道理，动画也是由一帧帧组成的。  </p>
<p>还记得，我们为啥会跟到这里来了么。动画在处理当前帧的工作时，会去计算当前帧的动画进度，然后根据这个 0-1 区间的进度，映射到我们需要的数值，而这个映射之后的数值就是通过 mKeyframes 的 <code>getValue()</code> 里取到的，mKeyframes 是一个 KeyframeSet 对象，在创建属性动画时也顺带被创建了，而创建属性动画时，我们会传入一个我们想要的数值，如 <code>ValueAnimator.ofInt(100)</code> 就表示我们想要的动画变化范围是 0-100，那么这个 100 在内部也会被传给 <code>KeyframeSet.ofInt(100)</code>，然后就是进入到上面代码块里的创建工作了。  </p>
<p>在这个方法里，100 就是作为一个关键帧。那么，对于一个动画来说，什么才叫做关键帧呢？很明显，至少动画需要知道从哪开始，到哪结束，是吧？所以，对于一个动画来说，至少需要两个关键帧，如果我们调用 <code>ofInt(100)</code> 只传进来一个数值时，那么内部它就默认认为起点是从 0 开始，传进来的 100 就是结束的关键帧，所以内部就会自己创建了两个关键帧。  </p>
<p>那么，这些关键帧又是怎么被动画用上的呢？这就是回到我们最初跟踪的 <code>mKeyframes.getValue()</code> 这个方法里去了，看上面的代码块，<code>KeyframeSet.ofInt()</code> 最后是创建了一个 IntKeyframeSet 对象，所以我们跟进这个类的 <code>getValue()</code> 方法里看看它是怎么使用这些关键帧的：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-c59da0d813fc3bb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IntKeyframeSet#getValue.png"></p>
<p>所以关键的工作就都在 <code>getIntValue()</code> 这里了，参数传进来还记得是什么吧，就是经过插值器计算之后当前帧的动画进度值，0-1 区间的那个值，<code>getIntValue()</code> 这个方法的代码有些多，我们一块一块来看，先看第一块：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-85239064d60be497.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IntKeyframeSet#getIntValue.png"></p>
<p>当关键帧只有两帧时，我们常使用的 <code>ValueAnimator.ofInt(100)</code>， 内部其实就是只创建了两个关键帧，一个是起点 0，一个是结束点 100。那么，在这种只有两帧的情况下，将 0-1 的动画进度值转换成我们需要的 0-100 区间内的值，系统的处理很简单，如果没有设置估值器，也就是 mEvaluator，那么就直接是按比例来转换，比如进度为 0.5，那按比例转换就是 (100 - 0) * 0.5 = 50。如果有设置估值器，那就按照估值器定的规则来，估值器其实就是类似于插值器，属性动画里才引入的概念，Animation 动画并没有，因为只有属性动画内部才帮我们做了值转换工作。  </p>
<p>上面是当关键帧只有两帧时的处理逻辑，那么当关键帧超过两帧的时候呢：<br><img src="https://upload-images.jianshu.io/upload_images/1924341-b0ba7e86e2e0f250.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IntKeyframeSet#getIntValue2.png"><br>当关键帧超过两帧时，分三种情况来处理：第一帧的处理；最后一帧的处理；中间帧的处理；  </p>
<p>那么，什么时候关键帧会超过两帧呢？其实也就是我们这么使用的时候：<code>ValueAnimator.ofInt(0, 100, 0, -100, 0)</code>，类似这种用法的时候关键帧就不止两个了，这时候数量就是根据参数的个数来决定的了。  </p>
<p>那么，我们再来详细看看三种情况的处理逻辑，首先是第一帧的处理逻辑：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-c0ed02e31c55342d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IntKeyframeSet#getIntValue3.png"></p>
<p>fraction &lt;= 0f 表示的应该不止是第一帧的意思，但除了理解成第一帧外，我不清楚其他场景是什么，暂时以第一帧来理解，这个应该影响不大。  </p>
<p>处理的逻辑其实也很简单，还记得当只有两个关键帧时是怎么处理的吧。那在处理第一帧的工作时，只需要将第二帧当成是最后一帧，那么第一帧和第二帧这样也就可以看成是只有两帧的场景了吧。但是参数 fraction 动画进度是以实际第一帧到最后一帧计算出来的，所以需要先对它进行转换，换算出它在第一帧到第二帧之间的进度，接下去的逻辑也就跟处理两帧时的逻辑是一样的了。  </p>
<p>同样的道理，在处理最后一帧时，只需要取出倒数第一帧跟倒数第二帧的信息，然后将进度换算到这两针之间的进度，接下去的处理逻辑也就是一样的了。代码我就不贴了。  </p>
<p>但处理中间帧的逻辑就不一样了，因为根据 0-1 的动画进度，我们可以很容易区分是处于第一帧还是最后一帧，无非一个就是 0，一个是 1。但是，当动画进度值在 0-1 之间时，我们并没有办法直接看出这个进度值是落在中间的哪两个关键帧之间，如果有办法计算出当前的动画进度处于哪两个关键帧之间，那么接下去的逻辑也就是一样的了，所以关键就是在于找出当前进度处于哪两个关键帧之间：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-932636c134f75585.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IntKeyframeSet#getIntValue4.png"></p>
<p>系统的找法也很简单，从第一帧开始，按顺序遍历每一帧，然后去判断当前的动画进度跟这一帧保存的位置信息来找出当前进度是否就是落在某两个关键帧之间。因为每个关键帧保存的信息除了有它对应的值之外，还有一个是它在第一帧到最后一帧之间的哪个位置，至于这个位置的取值是什么，这就是由在创建这一系列关键帧时来控制的了。  </p>
<p>还记得是在哪里创建了这一系列的关键帧的吧，回去 KeyframeSet 的 <code>ofInt()</code> 里看看：<br><img src="https://upload-images.jianshu.io/upload_images/1924341-26e403bdc022eca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KeyframeSet#ofInt2.png"></p>
<p>在创建每个关键帧时，传入了两个参数，第一个参数就是表示这个关键帧在整个区域之间的位置，第二参数就是它表示的值是多少。看上面的代码， i 表示的是第几帧，numKeyframes 表示的是关键帧的总数量，所以 i/(numKeyframes - 1) 也就是表示这一系列关键帧是按等比例来分配的。  </p>
<p>比如说， <code>ValueAnimator.ofInt(0, 50, 100, 200)</code>，这总共有四个关键帧，那么按等比例分配，第一帧就是在起点位置 0，第二帧在 1/3 位置，第三帧在 2/3 的位置，最后一帧就是在 1 的位置。  </p>
<hr>
<h2 id="小结2："><a href="#小结2：" class="headerlink" title="小结2："></a>小结2：</h2><p>到这里，我们再来梳理一下后面部分过的内容：  </p>
<ol>
<li><p><strong>当接收到屏幕刷新信号后，AnimationHandler 会去遍历列表，将所有待执行的属性动画都取出来去计算当前帧的动画行为。</strong>  </p>
</li>
<li><p><strong>每个动画在处理当前帧的动画逻辑时，首先会先根据当前时间和动画第一帧时间以及动画的持续时长来初步计算出当前帧时动画所处的进度，然后会将这个进度值等价转换到 0-1 区间之内。</strong>    </p>
</li>
<li><p><strong>接着，插值器会将这个经过初步计算之后的进度值根据设定的规则计算出实际的动画进度值，取值也是在 0-1 区间内。</strong>  </p>
</li>
<li><p><strong>计算出当前帧动画的实际进度之后，会将这个进度值交给关键帧机制，来换算出我们需要的值，比如 ValueAnimator.ofInt(0, 100) 表示我们需要的值变化范围是从 0-100，那么插值器计算出的进度值是 0-1 之间的，接下去就需要借助关键帧机制来映射到 0-100 之间。</strong>  </p>
</li>
<li><p><strong>关键帧的数量是由 ValueAnimator.ofInt(0, 1, 2, 3) 参数的数量来决定的，比如这个就有四个关键帧，第一帧和最后一帧是必须的，所以最少会有两个关键帧，如果参数只有一个，那么第一帧默认为 0，最后一帧就是参数的值。当调用了这个 ofInt() 方法时，关键帧组也就被创建了。</strong>  </p>
</li>
<li><p><strong>当只有两个关键帧时，映射的规则是，如果没有设置估值器，那么就等比例映射，比如动画进度为 0.5，需要的值变化区间是 0-100，那么等比例映射后的值就是 50，那么我们在 onAnimationUpdate 的回调中通过 animation.getAnimatedValue() 获取到的值 50 就是这么来的。</strong>  </p>
</li>
<li><p><strong>如果有设置估值器，那么就按估值器的规则来进行映射。</strong>  </p>
</li>
<li><p><strong>当关键帧超过两个时，需要先找到当前动画进度是落于哪两个关键帧之间，然后将这个进度值先映射到这两个关键帧之间的取值，接着就可以将这两个关键帧看成是第一帧和最后一帧，那么就可以按照只有两个关键帧的情况下的映射规则来进行计算了。</strong>  </p>
</li>
<li><p><strong>而进度值映射到两个关键帧之间的取值，这就需要知道每个关键帧在整个关键帧组中的位置信息，或者说权重。而这个位置信息是在创建每个关键帧时就传进来的。onInt() 的规则是所有关键帧按等比例来分配权重，比如有三个关键帧，第一帧是 0，那么第二帧就是 0.5， 最后一帧 1。</strong>  </p>
</li>
</ol>
<p>至此，我们已经将整个流程梳理出来了，<strong>两部分小结</strong>的内容整合起来就是这次梳理出来的整个属性动画从 <code>start()</code> 之后，到我们在 onAnimationUpdate 回调中取到我们需要的值，再到动画结束后如何清理资源的整个过程中的原理解析。  </p>
<p>梳理清楚后，大伙应该就要清楚，属性动画是如何接收到屏幕刷新信号事件的？是如何反复接收到屏幕刷新信号事件直到整个动画执行结束？方式是否是有区别于 Animation 动画的？计算当前帧的动画工作都包括了哪些？是如何将 0-1 的动画进度映射到我们需要的值上面的？  </p>
<p>如果看完本篇，这些问题你心里都有谱了，那么就说明，本篇的主要内容你都吸收进去了。当然，如果有错的地方，欢迎指出来，毕竟内容确实很多，很有可能存在写错的地方没发现。  </p>
<p>来张时序图结尾：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-6d825c6da4d4a7a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VauleAnimatior运行原理时序图.png"></p>
<p>最后，有一点想提的是，我们本篇只是过完了 ValueAnimator 的整个流程原理，但这整个过程中，注意到了没有，我们并没有看到有任何一个地方涉及到了 ui 操作。在上一篇博客 <strong><em>Android 屏幕刷新机制</em></strong>中，我们也清楚了，界面的绘制其实就是交由 ViewRootImpl 来发起的，但很显然，ValueAnimator 跟 ViewRootImpl 并没有任何交集。  </p>
<p>那么，ValueAnimator 又是怎么实现动画效果的呢？其实，ValueAnimator 只是按照我们设定的变化区间(<code>ofInt(0, 100)</code>)，持续时长(<code>setDuration(1000)</code>)，插值器规则，估值器规则，内部在每一帧内通过一系列计算，转换等工作，最后输出每一帧一个数值而已。而如果要实现一个动画效果，那么我们只能在进度回调接口取到这个输出的值，然后手动应用到某个 View 上面(<code>mView.setX()</code>)。所以，这种使用方式，本质上仍然是通过 View 的内部方法最终走到 ViewRootImpl 去触发界面的更新绘制。  </p>
<p>而 ObjectAnimator 却又不同了，它内部就有涉及到 ui 的操作，具体原理是什么，留待后续再分析。  </p>
<h1 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h1><p>都说属性动画是通过改变属性值来达到动画效果的，计划写这一篇时，本来以为可以梳理清楚这点的，谁知道单单只是把 ValueAnimator 的流程原理梳理出来篇幅就这么长了，所以 ObjectAnimator 就另找时间再来梳理吧，这个问题就作为遗留问题了。  </p>
<p><strong>Q1：都说属性动画是通过改变属性值来达到动画效果的，那么它的原理是什么呢？</strong>    </p>
]]></content>
      <categories>
        <category>Android源码解析</category>
      </categories>
  </entry>
  <entry>
    <title>移动端造json假数据时的坑（转义符问题）</title>
    <url>/2018/03/15/Android%E7%9F%A5%E8%AF%86/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%A0json%E5%81%87%E6%95%B0%E6%8D%AE%E6%97%B6%E7%9A%84%E5%9D%91%EF%BC%88%E8%BD%AC%E4%B9%89%E7%AC%A6%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>最近在 Json 数据的解析上碰到了一些坑，特此记录一下。  </p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>迭代开发中，经常出现服务端接口还没开发完成的情况，所以经常需要移动端自己在本地造一些假数据。  </p>
<p>emmm，虽然说好像造假数据也不是什么很难的事，但问题是，我是做 Tv app 的，手机 app 首页的 json 数据结构怎么样我不清楚，但 Tv 应用的主页复杂的要命，服务端下发的 json 数据格式是一层嵌套一层，每次看接口文档都一脸懵逼，接触了半年多了，我甚至对这个 json 数据结构还不是很熟悉，哎~~  </p>
<p>举个例子吧：  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-a5848230b7caffc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="json示例.png"></p>
<p>咦，这么一简化，好像感觉也不是很复杂。哎，反正，实际上，整个 json 数据结构特别复杂，每一层里字段就特别多，然后还不断的嵌套。不管了，不管了，这个不是今天的主题，只是顺便抱怨一下而已。  </p>
<p>不说废话了，回到今天的主题，注意看上图中我标箭号的地方，先提个问题：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;aaa&quot;:&#123;...&#125;,</span><br><span class="line">    &quot;bbb&quot;:&quot;&#123;...&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">**Q1：你们觉得上面的 aaa 字段和 bbb 字段有区别么？**  </span><br><span class="line"></span><br><span class="line">emmm，大伙不要鄙视我问这么基础的问题，慢慢看下去，你们就清楚我本篇想讲的是什么了。  </span><br><span class="line"></span><br><span class="line">首先，先确定下这个答案，aaa 对应的是一个新的 json 结构对象，如果要建模的话，要么直接使用 Object 对象，要么就是根据 &#123;...&#125; 里的结构创建一个对应的实体类；而 bbb 对应的就是一个字符串，不管 &#123;...&#125; 里的结构怎么样，解析的时候它就是一个 String 对象。所以，我们建模时的实体类应该就是这样吧：  </span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">public class WoZuiShuai &#123;</span><br><span class="line">    private Object aaa;</span><br><span class="line">    private String bbb;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">没错吧，那么，接下去该是造假数据了，我们填充一些值进去：</span><br></pre></td></tr></table></figure>

<p>{<br>    “aaa”:{“ccc”:”nifangpi”},<br>    “bbb”:”{“ddd”:”wojiufangpi”}”<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这样填充没问题吧，然后为了方便，我们不在文件里造假数据，把这个 json 数据复制到代码中：  </span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">public static String JSON = &quot;&#123;\n&quot; +</span><br><span class="line">            &quot;    \&quot;aaa\&quot;:&#123;\&quot;ccc\&quot;:\&quot;nifangpi\&quot;&#125;,\n&quot; +</span><br><span class="line">            &quot;    \&quot;bbb\&quot;:\&quot;&#123;wojiufangpi&#125;\&quot;\n&quot; +</span><br><span class="line">            &quot;&#125;&quot;;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">我们只需要先打个 `&quot; &quot;`，然后在这之间粘贴刚才复制的 json 串，as 会自动将转义符、换行符添加上去，没错吧，那么第二个问题来了：  </span><br><span class="line"></span><br><span class="line">**Q2:你们觉得直接拿这个 JSON 数据去解析，可以得到结果么？**  </span><br><span class="line"></span><br><span class="line">禁止逆向思维，不要说什么，如果能得到结果我就不会写了。严肃点，好好想想。我们可以简单的写个单元测试，测一下：  </span><br><span class="line">![测试.png](https://upload-images.jianshu.io/upload_images/1924341-aa2629755881b10b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">跑一下，看一下结果：  </span><br><span class="line">![测试结果.png](https://upload-images.jianshu.io/upload_images/1924341-8fff7e7c2bc4d31d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">果然出错了，bbb 解析失败，**那么，想明白为什么会出错了么？**  </span><br><span class="line"></span><br><span class="line">哎，其实，还是自己对 json 不够了解，如果对 json 格式比较熟悉的话，一眼就看出在哪里出错了。  </span><br><span class="line"></span><br><span class="line">**其实，在我们填充数据的那个步骤就已经错了。**</span><br></pre></td></tr></table></figure>

<p>{<br>    “aaa”:{“ccc”:”nifangpi”},<br>    “bbb”:”{“ddd”:”wojiufangpi”}”<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这个 json 数据是错误的，拿到网上验证一下就清楚了，我比较习惯用 chrome 的 JSON-handle 插件，</span><br><span class="line">![验证.png](https://upload-images.jianshu.io/upload_images/1924341-d91af8cfd179b2b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">**这其实就是涉及到 json 结构如果是多层嵌套的话，内层的 `&quot;` 冒号必须用转义符标志，这样计算机才能区分这个 `&quot;` 是跟外层的匹配，还是跟内层的匹配。**  </span><br><span class="line"></span><br><span class="line">也就是说，下面这样改完后才是正确的：</span><br></pre></td></tr></table></figure>

<p>{<br>    “aaa”:{“ccc”:”nifangpi”},<br>    “bbb”:”{&quot;ddd&quot;:&quot;wojiufangpi&quot;}”<br>}</p>
<pre><code>那么，对应的复制到代码里的样子是这样的：  </code></pre><p>public static String JSON = “{\n” +<br>            “    &quot;aaa&quot;:{&quot;ccc&quot;:&quot;nifangpi&quot;},\n” +<br>            “    &quot;bbb&quot;:&quot;{\&quot;ddd\&quot;:\&quot;wojiufangpi\&quot;}&quot;\n” +<br>            “}”;</p>
<pre><code>
这样改完后，再跑下单元测试就发现是正确的了，这个就是最近碰到的一个坑了，现在来反省下自己为什么会跳进这个坑。  

# 反省  
1. 对 json 格式不够理解  

2. 当初是有想过转义符的问题，但看到 as 已经自动添加了转义符了，就想当然的以为转义符没问题了，其实内嵌的 `&quot;` 号问题， java 本身就需要一层转义符，然后 json 也需要一层转义符，所以总的来说是需要有两层转义符，就像上图的代码块。  

3. 然后，服务端也得背点锅，因为你们给我的示例数据里就是没有转义符的，我当然以为你们是对的！！！  

4. 最后，自己造完数据其实也还是有拿去校验一遍的，但当初没注意看错误提示，插件定位到 bbb 那行结构是错的，然后就想当然的以为是 `&quot;{...}&quot;` 这外面那两个冒号的问题，想当然的以为这个冒号是多余的，就去掉了。然后更要命的是，去掉了之后的结构刚刚好是正确的，插件可以解析出来。然后拿到代码里测试时，却发现又解析不了，因为 bbb 定义的是 String 类型，但现在已经是一个 Object 类型了。所以，我的大脑就这样进入死锁了，加上冒号，插件验证格式错误，测试也通不过，去掉冒号，插件验证格式正确，但测试却还是通不过。哎，在这里卡了好久的。  

以上，仅记录下来，提醒自己不要再犯傻了~~~</code></pre>]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>Android 屏幕刷新机制</title>
    <url>/2018/01/18/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Android-%E5%B1%8F%E5%B9%95%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</strong>    </p>
</blockquote>
<p>这次就来梳理一下 Android 的屏幕刷新机制，把我这段时间因为研究动画而梳理出来的一些关于屏幕刷新方面的知识点分享出来，能力有限，有错的地方还望指点一下。另外，内容有点多，毕竟要讲清楚不容易，所以慢慢看哈。    </p>
<h1 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h1><p>阅读源码还是得带着问题或目的性的去阅读，这样阅读过程中比较有条理性，不会跟偏或太深入，所以，还是先来几个问题吧：  </p>
<p>大伙都清楚，Android 每隔 16.6ms 会刷新一次屏幕。  </p>
<p><strong>Q1：但是大伙想过没有，这个 16.6ms 刷新一次屏幕到底是什么意思呢？是指每隔 16.6ms 调用 onDraw() 绘制一次么？</strong>  </p>
<p><strong>Q2：如果界面一直保持没变的话，那么还会每隔 16.6ms 刷新一次屏幕么？</strong>  </p>
<p><strong>Q3：界面的显示其实就是一个 Activity 的 View 树里所有的 View 都进行测量、布局、绘制操作之后的结果呈现，那么如果这部分工作都完成后，屏幕会马上就刷新么？</strong>  </p>
<p><strong>Q4：网上都说避免丢帧的方法之一是保证每次绘制界面的操作要在 16.6ms 内完成，但如果这个 16.6ms 是一个固定的频率的话，请求绘制的操作在代码里被调用的时机是不确定的啊，那么如果某次用户点击屏幕导致的界面刷新操作是在某一个 16.6ms 帧快结束的时候，那么即使这次绘制操作小于 16.6 ms，按道理不也会造成丢帧么？这又该如何理解？</strong>  </p>
<p><strong>Q5：大伙都清楚，主线程耗时的操作会导致丢帧，但是耗时的操作为什么会导致丢帧？它是如何导致丢帧发生的？</strong>  </p>
<p>本篇主要就是搞清楚这几个问题，分析的源码基本只涉及 <strong>ViewRootImpl</strong> 和 <strong>Choreographer</strong> 这两个类。  </p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>ps:本篇分析的源码均是 android-25 版本，版本不一样，源码可能会有些许差异，大伙过的时候注意一下。  </p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>首先，先来过一下一些基本概念，摘抄自网上文章<a href="http://blog.csdn.net/litefish/article/details/53939882" target="_blank" rel="noopener">android屏幕刷新显示机制</a>：  </p>
<blockquote>
<p>在一个典型的显示系统中，一般包括CPU、GPU、display三个部分， CPU负责计算数据，把计算好数据交给GPU,GPU会对图形数据进行渲染，渲染好后放到buffer里存起来，然后display（有的文章也叫屏幕或者显示器）负责把buffer里的数据呈现到屏幕上。  </p>
<p>显示过程，简单的说就是CPU/GPU准备好数据，存入buffer，display每隔一段时间去buffer里取数据，然后显示出来。display读取的频率是固定的，比如每个16ms读一次，但是CPU/GPU写数据是完全无规律的。  </p>
</blockquote>
<p>上述内容概括一下，大体意思就是说，屏幕的刷新包括三个步骤：<strong>CPU 计算屏幕数据、GPU 进一步处理和缓存、最后 display 再将缓存中（buffer）的屏幕数据显示出来。</strong>  </p>
<p>（ps:开发过程中应该接触不到 GPU、display 这些层面的东西，所以我把这部分工作都称作底层的工作了，下文出现的底层指的就是除了 CPU 计算屏幕数据之外的工作。）</p>
<p>对于 Android 而言，第一个步骤：<strong>CPU 计算屏幕数据</strong>指的也就是 View 树的绘制过程，也就是 Activity 对应的视图树从根布局 DecorView 开始层层遍历每个 View，分别执行测量、布局、绘制三个操作的过程。  </p>
<p>也就是说，我们常说的 Android 每隔 16.6ms 刷新一次屏幕其实是指：<strong>底层以固定的频率，比如每 16.6ms 将 buffer 里的屏幕数据显示出来。</strong>  </p>
<p>如果还不清楚，那再看一张网上很常见的图（摘自上面同一篇文章）：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-d8ebbbd67051dd6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>结合这张图，再来讲讲 16.6 ms 屏幕刷新一次的意思。  </p>
<p>Display 这一行可以理解成屏幕，所以可以看到，底层是以固定的频率发出 VSync 信号的，而这个固定频率就是我们常说的每 16.6ms 发送一个 VSync 信号，至于什么叫 VSync 信号，我们可以不用深入去了解，只要清楚这个信号就是屏幕刷新的信号就可以了。  </p>
<p>继续看图，Display 黄色的这一行里有一些数字：<code>0, 1, 2, 3, 4</code>，可以看到每次屏幕刷新信号到了的时候，数字就会变化，所以这些数字其实可以理解成每一帧屏幕显示的画面。也就是说，屏幕每一帧的画面可以持续 16.6ms，当过了 16.6ms，底层就会发出一个屏幕刷新信号，而屏幕就会去显示下一帧的画面。  </p>
<p>以上都是一些基本概念，也都是底层的工作，我们了解一下就可以了。接下去就还是看这图，然后讲讲我们 app 层该干的事了：  </p>
<p>继续看图，CPU 蓝色的这行，上面也说过了，CPU 这块的耗时其实就是我们 app 绘制当前 View 树的时间，而这段时间就跟我们自己写的代码有关系了，如果你的布局很复杂，层次嵌套很多，每一帧内需要刷新的 View 又很多时，那么每一帧的绘制耗时自然就会多一点。  </p>
<p>继续看图，CPU 蓝色这行里也有一些数字，其实这些数字跟 Display 黄色的那一行里的数字是对应的，在 Display 里我们解释过这些数字表示的是每一帧的画面，那么在 CPU 这一行里，其实就是在计算对应帧的画面数据，也叫屏幕数据。也就是说，在当前帧内，CPU 是在计算下一帧的屏幕画面数据，当屏幕刷新信号到的时候，屏幕就去将 CPU 计算的屏幕画面数据显示出来；同时 CPU 也接收到屏幕刷新信号，所以也开始去计算下一帧的屏幕画面数据。  </p>
<p>CPU 跟 Display 是不同的硬件，它们是可以并行工作的。要理解的一点是，我们写的代码，只是控制让 CPU 在接收到屏幕刷新信号的时候开始去计算下一帧的画面工作。而底层在每一次屏幕刷新信号来的时候都会去切换这一帧的画面，这点我们是控制不了的，是底层的工作机制。之所以要讲这点，是因为，当我们的 app 界面没有必要再刷新时（比如用户不操作了，当前界面也没动画），这个时候，我们 app 是接收不到屏幕刷新信号的，所以也就不会让 CPU 去计算下一帧画面数据，但是底层仍然会以固定的频率来切换每一帧的画面，只是它后面切换的每一帧画面都一样，所以给我们的感觉就是屏幕没刷新。  </p>
<p>所以，我觉得上面那张图还可以再继续延深几帧的长度，这样就更容易理解了：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-f3938ff87259b9ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕刷新机制.png"></p>
<p>我在那张图的基础上延长了几帧，我想这样应该可以更容易理解点。  </p>
<p>看我画的这张图，前三帧跟原图一样，从第三帧之后，因为我们的 app 界面不需要刷新了（用户不操作了，界面也没有动画），那么这之后我们 app 就不会再接收到屏幕刷新信号了，所以也就不会再让 CPU 去绘制视图树来计算下一帧画面了。<strong>但是</strong>，底层还是会每隔 16.6ms 发出一个屏幕刷新信号，只是我们 app 不会接收到而已，Display 还是会在每一个屏幕刷新信号到的时候去显示下一帧画面，只是下一帧画面一直是第4帧的内容而已。  </p>
<p>好了，到这里 Q1，Q2，Q3 都可以先回答一半了，<strong>那么我们就先稍微来梳理一下</strong>：  </p>
<ol>
<li><p><strong>我们常说的 Android 每隔 16.6 ms 刷新一次屏幕其实是指底层会以这个固定频率来切换每一帧的画面。</strong>  </p>
</li>
<li><p><strong>这个每一帧的画面也就是我们的 app 绘制视图树（View 树）计算而来的，这个工作是交由 CPU 处理，耗时的长短取决于我们写的代码：布局复不复杂，层次深不深，同一帧内刷新的 View 的数量多不多。</strong>  </p>
</li>
<li><p><strong>CPU 绘制视图树来计算下一帧画面数据的工作是在屏幕刷新信号来的时候才开始工作的，而当这个工作处理完毕后，也就是下一帧的画面数据已经全部计算完毕，也不会马上显示到屏幕上，而是会等下一个屏幕刷新信号来的时候再交由底层将计算完毕的屏幕画面数据显示出来。</strong>  </p>
</li>
<li><p><strong>当我们的 app 界面不需要刷新时（用户无操作，界面无动画），app 就接收不到屏幕刷新信号所以也就不会让 CPU 再去绘制视图树计算画面数据工作，但是底层仍然会每隔 16.6 ms 切换下一帧的画面，只是这个下一帧画面一直是相同的内容。</strong>  </p>
</li>
</ol>
<p>这部分虽然说是一些基本概念，但其实也包含了一些结论了，所以可能大伙看着会有些困惑：<strong>为什么界面不刷新时 app 就接收不到屏幕刷新信号了？为什么绘制视图树计算下一帧画面的工作会是在屏幕刷新信号来的时候才开始的？</strong>等等。  </p>
<p>emmm，有这些困惑很棒，这样，我们下面一起过源码时，大伙就更有目的性了，这样过源码我觉得效率是比较高一点的。继续看下去，跟着过完源码，你就清楚为什么了。好了，那我们下面就开始过源码了。  </p>
<h2 id="ViewRootImpl-与-DecorView-的绑定"><a href="#ViewRootImpl-与-DecorView-的绑定" class="headerlink" title="ViewRootImpl 与 DecorView 的绑定"></a>ViewRootImpl 与 DecorView 的绑定</h2><p>阅读源码从哪开始看起一直都是个头疼的问题，所以找一个合适的切入点来跟的话，整个梳理的过程可能会顺畅一点。本篇是研究屏幕的刷新，那么建议就是从某个会导致屏幕刷新的方法入手，比如 <code>View#invalidate()</code>。  </p>
<p><code>View#invalidate()</code> 是请求重绘的一个操作，所以我们切入点可以从这个方法开始一步步跟下去。我们在上一篇博客<a href="https://www.jianshu.com/p/48317612c164" target="_blank" rel="noopener">View 动画 Animation 运行原理解析</a>已经分析过 <code>View#invalidate()</code> 这个方法了。  </p>
<p>想再过一遍的可以再去看看，我们这里就直接说结论了。我们跟着 <code>invalidate()</code> 一步步往下走的时候，发现最后跟到了 <code>ViewRootImpl#scheduleTraversals()</code> 就停止了。而 ViewRootImpl 就是今天我们要介绍的重点对象了。  </p>
<p>大伙都清楚，Android 设备呈现到界面上的大多数情况下都是一个 Activity，真正承载视图的是一个 Window，每个 Window 都有一个 DecorView，我们调用 <code>setContentView()</code> 其实是将我们自己写的布局文件添加到以 DecorView 为根布局的一个 ViewGroup 里，构成一颗 View 树。  </p>
<p>这些大伙都清楚，每个 Activity 对应一颗以 DecorView 为根布局的 View 树，但其实 DecorView 还有 mParent，而且就是 ViewRootImpl，而且每个界面上的 View 的刷新，绘制，点击事件的分发其实都是由 ViewRootImpl 作为发起者的，由 ViewRootImpl 控制这些操作从 DecorView 开始遍历 View 树去分发处理。  </p>
<p>在上一篇动画分析的博客里，分析 <code>View#invalidate()</code> 时，也可以看到内部其实是有一个 do{}while() 循环来不断寻找 mParent，所以最终才会走到 ViewRootImpl 里去，那么可能大伙就会疑问了，<strong>为什么 DecorView 的 mParent 会是 ViewRootImpl 呢？换个问法也就是，在什么时候将 DevorView 和 ViewRootImpl 绑定起来？</strong>  </p>
<p>Activity 的启动是在 ActivityThread 里完成的，<code>handleLaunchActivity()</code> 会依次间接的执行到 Activity 的 <code>onCreate()</code>, <code>onStart()</code>, <code>onResume()</code>。在执行完这些后 ActivityThread 会调用 <code>WindowManager#addView()</code>，而这个 <code>addView()</code> 最终其实是调用了 WindowManagerGlobal 的 <code>addView()</code> 方法，我们就从这里开始看：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-ed0644ba1b8932da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WindowManagerGlobal#addView"></p>
<p>WindowManager 维护着所有 Activity 的 DecorView 和 ViewRootImpl。这里初始化了一个 ViewRootImpl，然后调用了它的 <code>setView()</code> 方法，将 DevorView 作为参数传递了进去。所以看看 ViewRootImpl 中的 <code>setView()</code> 做了什么：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-b7826be67afd2fb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl#setView"></p>
<p>在 <code>setView()</code> 方法里调用了 DecorView 的 <code>assignParent()</code> 方法，所以去看看 View 的这个方法：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-3135d20601e737e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View#assignParent"></p>
<p>参数是 ViewParent，而 ViewRootImpl 是实现了 ViewParent 接口的，所以在这里就将 DecorView 和 ViewRootImpl 绑定起来了。每个Activity 的根布局都是 DecorView，而 DecorView 的 parent 又是 ViewRootImpl，所以在子 View 里执行 <code>invalidate()</code> 之类的操作，循环找 parent 时，最后都会走到 ViewRootImpl 里来。</p>
<p>跟界面刷新相关的方法里应该都会有一个循环找 parent 的方法，或者是不断调用 parent 的方法，这样最终才都会走到 ViewRootImpl 里，也就是说实际上 View 的刷新都是由 ViewRootImpl 来控制的。</p>
<p>即使是界面上一个小小的 View 发起了重绘请求时，都要层层走到 ViewRootImpl，由它来发起重绘请求，然后再由它来开始遍历 View 树，一直遍历到这个需要重绘的 View 再调用它的 <code>onDraw()</code> 方法进行绘制。</p>
<p>我们重新看回 ViewRootImpl 的 <code>setView()</code> 这个方法，这个方法里还调用了一个 <code>requestLayout()</code> 方法：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-434582ab6f08ff14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl#requestLayout"></p>
<p>这里调用了一个 <code>scheduleTraversals()</code>，还记得当 View 发起重绘操作 <code>invalidate()</code> 时，最后也调用了 <code>scheduleTraversals()</code> 这个方法么。其实这个方法就是屏幕刷新的关键，它是安排一次绘制 View 树的任务等待执行，具体后面再说。  </p>
<p>也就是说，<strong>其实打开一个 Activity，当它的 onCreate—onResume 生命周期都走完后，才将它的 DecoView 与新建的一个 ViewRootImpl 对象绑定起来，同时开始安排一次遍历 View 任务也就是绘制 View 树的操作等待执行，然后将 DecoView 的 parent 设置成 ViewRootImpl 对象</strong>。</p>
<p>这也就是为什么在 <code>onCreate---onResume</code> 里获取不到 View 宽高的原因，因为在这个时刻 ViewRootImpl 甚至都还没创建，更不用说是否已经执行过测量操作了。</p>
<p>还可以得到一点信息是，一个 Activity 界面的绘制，其实是在 <code>onResume()</code> 之后才开始的。</p>
<h2 id="ViewRootImpl-scheduleTraversals"><a href="#ViewRootImpl-scheduleTraversals" class="headerlink" title="ViewRootImpl#scheduleTraversals"></a>ViewRootImpl#scheduleTraversals</h2><p>到这里，我们梳理清楚了，调用一个 View 的 <code>invalidate()</code> 请求重绘操作，内部原来是要层层通知到 ViewRootImpl 的 <code>scheduleTraversals()</code> 里去。而且打开一个新的 Activity，它的界面绘制原来是在 <code>onResume()</code> 之后也层层通知到 ViewRootImpl 的 <code>scheduleTraversals()</code> 里去。虽然其他关于 View 的刷新操作，比如 <code>requestLayout()</code> 等等之类的方法我们还没有去看，但我们已经可以大胆猜测，这些跟 View 刷新有关的操作最终也都会层层走到 ViewRootImpl 中的 <code>scheduleTraversals()</code> 方法里去的。  </p>
<p>那么这个方法究竟干了些什么，我们就要好好来分析了：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-66a63c915c2b5613.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl#scheduleTraversals"></p>
<p>mTraversalScheduled 这个 boolean 变量的作用等会再来看，先看看 <code>mChoreographer.postCallback()</code> 这个方法，传入了三个参数，第二个参数是一个 Runnable 对象，先来看看这个 Runnable：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-c626c7dfe285b564.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TraversalRunnable"></p>
<p>这个 Runnable 做的事很简单，就调用了一个方法，<code>doTraversal()</code>:<br><img src="http://upload-images.jianshu.io/upload_images/1924341-464766462e408366.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl#doTraversal"></p>
<p>看看这个方法做的事，跟 <code>scheduleTraversals()</code> 正好相反，一个将变量置成 true，这里置成 false，一个是 <code>postSyncBarrier()</code>，这里是 <code>removeSyncBarrier()</code>，具体作用等会再说，继续先看看 <code>performTraversals()</code>，这个方法也是屏幕刷新的关键：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-55aadc3c3f1b8b80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl#performTraversals"></p>
<p>View 的测量、布局、绘制三大流程都是交由 ViewRootImpl 发起，而且还都是在 <code>performTraversals()</code> 方法中发起的，所以这个方法的逻辑很复杂，因为每次都需要根据相应状态判断是否需要三个流程都走，有时可能只需要执行 <code>performDraw()</code> 绘制流程，有时可能只执行 <code>performMeasure()</code> 测量和 <code>performLayout()</code> 布局流程（一般测量和布局流程是一起执行的）。不管哪个流程都会遍历一次 View 树，所以其实界面的绘制是需要遍历很多次的，如果页面层次太过复杂，每一帧需要刷新的 View 又很多时，耗时就会长一点。  </p>
<p>当然，测量、布局、绘制这些流程在遍历时并不一定会把整颗 View 树都遍历一遍，ViewGroup 在传递这些流程时，还会再根据相应状态判断是否需要继续往下传递。  </p>
<p><strong>了解了 <code>performTraversals()</code> 是刷新界面的源头后，接下去就需要了解下它是什么时候执行的，和 <code>scheduleTraversals()</code> 又是什么关系？</strong>  </p>
<p><code>performTraversals()</code> 是在 <code>doTraversal()</code> 中被调用的，而 <code>doTraversal()</code> 又被封装到一个 Runnable 里，那么关键就是这个 Runnable 什么时候被执行了？</p>
<h2 id="Choreographer"><a href="#Choreographer" class="headerlink" title="Choreographer"></a>Choreographer</h2><p><code>scheduleTraversals()</code> 里调用了 Choreographer 的 <code>postCallback()</code> 将 Runnable 作为参数传了进去，所以跟进去看看：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-b59ba6d6b9789e00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Choreographer#postCallback"><br><img src="http://upload-images.jianshu.io/upload_images/1924341-1b4f5fb7244d6c4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Choreographer#postCallbackDelayedInternal"></p>
<p>因为 <code>postCallback()</code> 调用 <code>postCallbackDelayed()</code> 时传了 delay = 0 进去，所以在 <code>postCallbackDelayedInternal()</code> 里面会先根据当前时间戳将这个 Runnable 保存到一个 mCallbackQueue 队列里，这个队列跟 MessageQueue 很相似，里面待执行的任务都是根据一个时间戳来排序。然后走了 <code>scheduleFrameLocked()</code> 方法这边，看看做了些什么：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-67497e732640cb27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Choreographer#scheduleFrameLocked"></p>
<p>如果代码走了 else 这边来发送一个消息，那么这个消息做的事肯定很重要，因为对这个 Message 设置了异步的标志而且用了<code>sendMessageAtFrontOfQueue()</code> 方法，这个方法是将这个 Message 直接放到 MessageQueue 队列里的头部，可以理解成设置了这个 Message 为最高优先级，那么先看看这个 Message 做了些什么：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-bf505ec644d63b29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Choreograhper$FrameHandler#handleMessage"><br><img src="http://upload-images.jianshu.io/upload_images/1924341-9508e47fa74249c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Choreographer#doScheduleVsync"></p>
<p>所以这个 Message 最后做的事就是 <code>scheduleVsyncLocked()</code>。我们回到 <code>scheduleFrameLocked()</code> 这个方法里，当走 if 里的代码时，直接调用了 <code>scheduleVsyncLocked()</code>，当走 else 里的代码时，发了一个最高优先级的 Message，这个 Message 也是执行 <code>scheduleVsyncLocked()</code>。既然两边最后调用的都是同一个方法，那么为什么这么做呢？</p>
<p>关键在于 if 条件里那个方法，我的理解那个方法是用来判断当前是否是在主线程的，我们知道主线程也是一直在执行着一个个的 Message，那么如果在主线程的话，直接调用这个方法，那么这个方法就可以直接被执行了，如果不是在主线程，那么 post 一个最高优先级的 Message 到主线程去，保证这个方法可以第一时间得到处理。</p>
<p>那么这个方法是干嘛的呢，为什么需要在最短时间内被执行呢，而且只能在主线程？<br><img src="http://upload-images.jianshu.io/upload_images/1924341-67d8db7087fb2523.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Choreographer#scheduleVsyncLocked"><br><img src="http://upload-images.jianshu.io/upload_images/1924341-f294d32882480e39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DisplayEventReceiver#scheduleVsync"></p>
<p>调用了 native 层的一个方法，那跟到这里就跟不下去了。  </p>
<p>那到这里，我们先来梳理一下：  </p>
<p><strong>到这里为止，我们知道一个 View 发起刷新的操作时，会层层通知到 ViewRootImpl 的 scheduleTraversals() 里去，然后这个方法会将遍历绘制 View 树的操作 performTraversals() 封装到 Runnable 里，传给 Choreographer，以当前的时间戳放进一个 mCallbackQueue 队列里，然后调用了 native 层的一个方法就跟不下去了。所以这个 Runnable 什么时候会被执行还不清楚。那么，下去的重点就是搞清楚它什么时候从队列里被拿出来执行了？</strong>  </p>
<p>接下去只能换种方式继续跟了，既然这个 Runnable 操作被放在一个 mCallbackQueue 队列里，那就从这个队列着手，看看这个队列的取操作在哪被执行了：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-9f0e770caec64f99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Choreographer$CallbackQueue"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-cfa351f92bce62d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Choreographer#doCallbacks"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-0d00d2ae6a4f1b82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Choreographer#doFrame"></p>
<p>还记得我们说过在 ViewRootImpl 的 <code>scheduleTraversals()</code> 里会将遍历 View 树绘制的操作封装到 Runnable 里，然后调用 Choreographer 的 <code>postCallback()</code> 将这个 Runnable 放进队列里么，而当时调用 <code>postCallback()</code> 时传入了多个参数，这是因为 Choreographer 里有多个队列，而第一个参数 Choreographer.CALLBACK_TRAVERSAL 这个参数是用来区分队列的，可以理解成各个队列的 key 值。</p>
<p>那么这样一来，就找到关键的方法了：<code>doFrame()</code>，这个方法里会根据一个时间戳去队列里取任务出来执行，而这个任务就是 ViewRootImpl 封装起来的 <code>doTraversal()</code> 操作，而 <code>doTraversal()</code> 会去调用 <code>performTraversals()</code> 开始根据需要测量、布局、绘制整颗 View 树。所以剩下的问题就是 <code>doFrame()</code> 这个方法在哪里被调用了。</p>
<p>有几个调用的地方，但有个地方很关键：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-b721f5f919c5ceb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Choreographer$FrameDisplayEventReceiver"></p>
<p>关键的地方来了，这个继承自 DisplayEventReceiver 的 FrameDisplayEventReceiver 类的作用很重要。跟进去看注释，我只能理解它是用来接收底层信号用的。但看了网上的解释后，所有的都理解过来了：  </p>
<blockquote>
<p>FrameDisplayEventReceiver继承自DisplayEventReceiver接收底层的VSync信号开始处理UI过程。VSync信号由SurfaceFlinger实现并定时发送。FrameDisplayEventReceiver收到信号后，调用onVsync方法组织消息发送到主线程处理。这个消息主要内容就是run方法里面的doFrame了，这里mTimestampNanos是信号到来的时间参数。</p>
</blockquote>
<p>也就是说，<code>onVsync()</code> 是底层会回调的，可以理解成每隔 16.6ms 一个帧信号来的时候，底层就会回调这个方法，当然前提是我们得先注册，这样底层才能找到我们 app 并回调。当这个方法被回调时，内部发起了一个 Message，注意看代码对这个 Message 设置了 callback 为 this，Handler 在处理消息时会先查看 Message 是否有 callback，有则优先交由 Message 的 callback 处理消息，没有的话再去看看Handler 有没有 callback，如果也没有才会交由 <code>handleMessage()</code> 这个方法执行。</p>
<p>这里这么做的原因，我猜测可能 <code>onVsync()</code> 是由底层回调的，那么它就不是运行在我们 app 的主线程上，毕竟上层 app 对底层是隐藏的。但这个 <code>doFrame()</code> 是个 ui 操作，它需要在主线程中执行，所以才通过 Handler 切到主线程中。</p>
<p>还记得我们前面分析 <code>scheduleTraversals()</code> 方法时，最后跟到了一个 native 层方法就跟不下去了么，现在再回过来想想这个 native 层方法的作用是什么，应该就比较好猜测了。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-5284718010e3a320.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DisplayEventReceiver#scheduleVsync"></p>
<p>英文不大理解，大体上可能是说安排接收一个 vsync 信号。而根据我们的分析，如果这个 vsync 信号发出的话，底层就会回调 DisplayEventReceiver 的 <code>onVsync()</code> 方法。</p>
<p>那如果只是这样的话，就有一点说不通了，<strong>首先上层 app 对于这些发送 vsync 信号的底层来说肯定是隐藏的，也就是说底层它根本不知道上层 app 的存在，那么在它的每 16.6ms 的帧信号来的时候，它是怎么找到我们的 app，并回调它的方法呢？</strong></p>
<p>这就有点类似于观察者模式，或者说发布-订阅模式。既然上层 app 需要知道底层每隔 16.6ms 的帧信号事件，那么它就需要先注册监听才对，这样底层在发信号的时候，直接去找这些观察者通知它们就行了。</p>
<p>这是我的理解，所以，这样一来，<code>scheduleVsync()</code> 这个调用到了 native 层方法的作用大体上就可以理解成注册监听了，这样底层也才找得到上层 app，并在每 16.6ms 刷新信号发出的时候回调上层 app 的 onVsync() 方法。这样一来，应该就说得通了。</p>
<p>还有一点，<code>scheduleVsync()</code> 注册的监听应该只是监听下一个屏幕刷新信号的事件而已，而不是监听所有的屏幕刷新信号。比如说当前监听了第一帧的刷新信号事件，那么当第一帧的刷新信号来的时候，上层 app 就能接收到事件并作出反应。但如果还想监听第二帧的刷新信号，那么只能等上层 app 接收到第一帧的刷新信号之后再去监听下一帧。  </p>
<p>虽然现在能力还不足以跟踪到 native 层，这些结论虽然是猜测的，但都经过调试，对注释、代码理解之后梳理出来的结论，跟原理应该不会偏差太多，这样子的理解应该是可以的。  </p>
<p>本篇内容确实有点多，所以到这里还是继续来先来<strong>梳理一下目前的信息</strong>，防止都忘记上面讲了些什么：  </p>
<ol>
<li><p><strong>我们知道一个 View 发起刷新的操作时，最终是走到了 ViewRootImpl 的 scheduleTraversals() 里去，然后这个方法会将遍历绘制 View 树的操作 performTraversals() 封装到 Runnable 里，传给 Choreographer，以当前的时间戳放进一个 mCallbackQueue 队列里，然后调用了 native 层的方法向底层注册监听下一个屏幕刷新信号事件。</strong>  </p>
</li>
<li><p><strong>当下一个屏幕刷新信号发出的时候，如果我们 app 有对这个事件进行监听，那么底层它就会回调我们 app 层的 onVsync() 方法来通知。当 onVsync() 被回调时，会发一个 Message 到主线程，将后续的工作切到主线程来执行。</strong>  </p>
</li>
<li><p><strong>切到主线程的工作就是去 mCallbackQueue 队列里根据时间戳将之前放进去的 Runnable 取出来执行，而这些 Runnable 有一个就是遍历绘制 View 树的操作 performTraversals()。在这次的遍历操作中，就会去绘制那些需要刷新的 View。</strong>  </p>
</li>
<li><p><strong>所以说，当我们调用了 invalidate()，requestLayout()，等之类刷新界面的操作时，并不是马上就会执行这些刷新的操作，而是通过 ViewRootImpl 的 scheduleTraversals() 先向底层注册监听下一个屏幕刷新信号事件，然后等下一个屏幕刷新信号来的时候，才会去通过 performTraversals() 遍历绘制 View 树来执行这些刷新操作。</strong>  </p>
</li>
</ol>
<h2 id="过滤一帧内重复的刷新请求"><a href="#过滤一帧内重复的刷新请求" class="headerlink" title="过滤一帧内重复的刷新请求"></a>过滤一帧内重复的刷新请求</h2><p>整体上的流程我们已经梳理出来的，但还有几点问题需要解决。我们在一个 16.6ms 的一帧内，代码里可能会有多个 View 发起了刷新请求，这是非常常见的场景了，比如某个动画是有多个 View 一起完成，比如界面发生了滑动等等。  </p>
<p>按照我们上面梳理的流程，只要 View 发起了刷新请求最终都会走到 ViewRootImpl 中的 <code>scheduleTraversals()</code> 里去，是吧。而这个方法又会封装一个遍历绘制 View 树的操作 <code>performTraversals()</code> 到 Runnable 然后扔到队列里等刷新信号来的时候取出来执行，没错吧。  </p>
<p><strong>那如果多个 View 发起了刷新请求，岂不是意味着会有多次遍历绘制 View 树的操作？</strong>  </p>
<p>其实，这点不用担心，还记得我们在最开始分析 <code>scheduleTraverslas()</code> 的时候先跳过了一些代码么？现在我们回过来继续看看这些代码：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-891a24ff8272cd90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl#scheduleTraversals2"></p>
<p>我们上面分析的 <code>scheduleTraversals()</code> 干的那一串工作，前提是 mTraversalScheduled 这个 boolean 类型变量等于 false 才会去执行。那这个变量在什么时候被赋值被 false 了呢：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-ad5db083217001ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl#doTraversal2"></p>
<p>只有三个被赋值为 false 的地方，一个是上图的 <code>doTraversal()</code>，还有就是声明时默认为 false，剩下一个是在取消遍历绘制 View 操作 <code>unscheduleTraversals()</code> 里。这两个可以先不去看，就看看 <code>doTraversal()</code>。还记得这个方法吧，就是在 <code>scheduleTraversals()</code> 中封装到 Runnable 里的那个方法。  </p>
<p>也就是说，<strong>当我们调用了一次 <code>scheduleTraversals()</code>之后，直到下一个屏幕刷新信号来的时候，<code>doTraversal()</code> 被取出来执行。在这期间重复调用 <code>scheduleTraversals()</code> 都会被过滤掉的。那么为什么需要这样呢？</strong>  </p>
<p>其实，想想就能明白了。View 最终是怎么刷新的呢，就是在执行 <code>performTraversals()</code> 遍历绘制 View 树过程中层层遍历到需要刷新的 View，然后去绘制它的吧。既然是遍历，那么不管上一帧内有多少个 View 发起了刷新的请求，在这一次的遍历过程中全部都会去处理的吧。这也是我们从代码上看到的，每一个屏幕刷新信号来的时候，只会去执行一次 <code>performTraversals()</code>，因为只需遍历一遍，就能够刷新所有的 View 了。  </p>
<p>而 <code>performTraversals()</code> 会被执行的前提是调用了 <code>scheduleTraversals()</code> 来向底层注册监听了下一个屏幕刷新信号事件，所以在同一个 16.6ms 的一帧内，只需要第一个发起刷新请求的 View 来走一遍 <code>scheduleTraversals()</code> 干的事就可以了，其他不管还有多少 View 发起了刷新请求，没必要再去重复向底层注册监听下一个屏幕刷新信号事件了，反正只要有一次遍历绘制 View 树的操作就可以对它们进行刷新了。  </p>
<h2 id="postSyncBarrier-—同步屏障消息"><a href="#postSyncBarrier-—同步屏障消息" class="headerlink" title="postSyncBarrier()—同步屏障消息"></a>postSyncBarrier()—同步屏障消息</h2><p>还剩最后一个问题，<code>scheduleTraversals()</code> 里我们还有一行代码没分析。这个问题是这样的：  </p>
<p>我们清楚主线程其实是一直在处理 MessageQueue 消息队列里的 Message，每个操作都是一个 Message，打开 Activity 是一个 Message，遍历绘制 View 树来刷新屏幕也是一个 Message。  </p>
<p>而且，上面梳理完我们也清楚，遍历绘制 View 树的操作是在屏幕刷新信号到的时候，底层回调我们 app 的 <code>onVsync()</code>，这个方法再去将遍历绘制 View 树的操作 post 到主线程的 MessageQueue 中去等待执行。主线程同一时间只能处理一个 Message，这些 Message 就肯定有先后的问题，那么会不会出现下面这种情况呢：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-fece980970f1da64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同步分隔栏.png"></p>
<p>也就是说，当我们的 app 接收到屏幕刷新信号时，来不及第一时间就去执行刷新屏幕的操作，这样一来，即使我们将布局优化得很彻底，保证绘制当前 View 树不会超过 16ms，但如果不能第一时间优先处理绘制 View 的工作，那等 16.6 ms 过了，底层需要去切换下一帧的画面了，我们 app 却还没处理完，这样也照样会出现丢帧了吧。而且这种场景是非常有可能出现的吧，毕竟主线程需要处理的事肯定不仅仅是刷新屏幕的事而已，那么这个问题是怎么处理的呢？  </p>
<p>所以我们继续回来看 <code>scheduleTraversals()</code>：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-1a379f2694deb009.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl#scheduleTraversals3"><br><img src="http://upload-images.jianshu.io/upload_images/1924341-5d619c20a2729589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl#doTraversal2"></p>
<p>在逻辑走进 Choreographer 前会先往队列里发送一个同步屏障，而当 <code>doTraversal()</code> 被调用时才将同步屏障移除。这个同步屏障又涉及到消息机制了，不深入了，这里就只给出结论。</p>
<p>这个同步屏障的作用可以理解成拦截同步消息的执行，主线程的 Looper 会一直循环调用 MessageQueue 的 <code>next()</code> 来取出队头的 Message 执行，当 Message 执行完后再去取下一个。当 <code>next()</code> 方法在取 Message 时发现队头是一个同步屏障的消息时，就会去遍历整个队列，只寻找设置了异步标志的消息，如果有找到异步消息，那么就取出这个异步消息来执行，否则就让 <code>next()</code> 方法陷入阻塞状态。如果 <code>next()</code> 方法陷入阻塞状态，那么主线程此时就是处于空闲状态的，也就是没在干任何事。所以，如果队头是一个同步屏障的消息的话，那么在它后面的所有同步消息就都被拦截住了，直到这个同步屏障消息被移除出队列，否则主线程就一直不会去处理同步屏幕后面的同步消息。  </p>
<p>而所有消息默认都是同步消息，只有手动设置了异步标志，这个消息才会是异步消息。另外，同步屏障消息只能由内部来发送，这个接口并没有公开给我们使用。</p>
<p>最后，仔细看上面 Choreographer 里所有跟 message 有关的代码，你会发现，都手动设置了异步消息的标志，所以这些操作是不受到同步屏障影响的。这样做的原因可能就是为了尽可能保证上层 app 在接收到屏幕刷新信号时，可以在第一时间执行遍历绘制 View 树的工作。  </p>
<p>因为主线程中如果有太多消息要执行，而这些消息又是根据时间戳进行排序，如果不加一个同步屏障的话，那么遍历绘制 View 树的工作就可能被迫延迟执行，因为它也需要排队，那么就有可能出现当一帧都快结束的时候才开始计算屏幕数据，那即使这次的计算少于 16.6ms，也同样会造成丢帧现象。  </p>
<p>那么，<strong>有了同步屏障消息的控制就能保证每次一接收到屏幕刷新信号就第一时间处理遍历绘制 View 树的工作么？</strong>  </p>
<p>只能说，同步屏障是尽可能去做到，但并不能保证一定可以第一时间处理。因为，同步屏障是在 <code>scheduleTraversals()</code> 被调用时才发送到消息队列里的，也就是说，只有当某个 View 发起了刷新请求时，在这个时刻后面的同步消息才会被拦截掉。如果在 <code>scheduleTraversals()</code> 之前就发送到消息队列里的工作仍然会按顺序依次被取出来执行。  </p>
<h2 id="界面刷新控制者–ViewRootImpl"><a href="#界面刷新控制者–ViewRootImpl" class="headerlink" title="界面刷新控制者–ViewRootImpl"></a>界面刷新控制者–ViewRootImpl</h2><p>最后，就是上文经常说的一点，所有跟界面刷新相关的操作，其实最终都会走到 ViewRootImpl 中的 <code>scheduleTraversals()</code> 去的。  </p>
<p>大伙可以想想，跟界面刷新有关的操作有哪些，大概就是下面几种场景吧：  </p>
<ol>
<li>invalidate(请求重绘)  </li>
<li>requestLayout(重新布局)  </li>
<li>requestFocus(请求焦点)  </li>
<li>startActivity(打开新界面)  </li>
<li>onRestart(重新打开界面)  </li>
<li>KeyEvent(遥控器事件，本质上是焦点导致的刷新)  </li>
<li>Animation(各种动画，本质上是请求重绘导致的刷新)  </li>
<li>RecyclerView滑动（页面滑动，本质上是动画导致的刷新）  </li>
<li>setAdapter(各种adapter的更新)  </li>
<li>…  </li>
</ol>
<p>在上一篇分析动画的博客里，我们跟踪了 <code>invalidate()</code>，确实也是这样，至于其他的我并没有一一去验证，大伙有兴趣可以看看，我猜测，这些跟界面刷新有关的方法内部要么就是一个 do{}while() 循环寻找 mParent，要么就是直接不断的调用 mParent 的方法。而一颗 View 树最顶端的 mParent 就是 ViewRootImpl，所以这些跟界面刷新相关的方法，在 ViewRootImpl 肯定也是可以找到的：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-ad8bc2a439f925a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl#requestChildFocus"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-b26ba70af4f84a55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl#clearChildFocus"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-fa8fdae57d0c008e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl#requestLayout"></p>
<p>其实，以前我一直以为如果界面上某个小小的 View 发起了 <code>invalidate()</code> 重绘之类的操作，那么应该就只是它自己的 <code>onLayout()</code>, <code>onDraw()</code> 被调用来重绘而已。最后才清楚，原来，即使再小的 View，如果发起了重绘的请求，那么也需要先层层走到 ViewRootImpl 里去，而且还不是马上就执行重绘操作，而是需要等待下一个屏幕刷新信号来的时候，再从 DecorView 开始层层遍历到这些需要刷新的 View 里去重绘它们。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇篇幅确实很长，因为这部分内容要理清楚不容易，要讲清楚更不容易，大伙如果有时间，可以静下心来慢慢看，从头看下来，我相信，多少会有些收获的。如果没时间，那么也可以直接看看总结。  </p>
<ol>
<li><strong>界面上任何一个 View 的刷新请求最终都会走到 ViewRootImpl 中的 scheduleTraversals() 里来安排一次遍历绘制 View 树的任务；</strong>  </li>
<li><strong>scheduleTraversals() 会先过滤掉同一帧内的重复调用，在同一帧内只需要安排一次遍历绘制 View 树的任务即可，这个任务会在下一个屏幕刷新信号到来时调用 performTraversals() 遍历 View 树，遍历过程中会将所有需要刷新的 View 进行重绘；</strong>  </li>
<li><strong>接着 scheduleTraversals() 会往主线程的消息队列中发送一个同步屏障，拦截这个时刻之后所有的同步消息的执行，但不会拦截异步消息，以此来尽可能的保证当接收到屏幕刷新信号时可以尽可能第一时间处理遍历绘制 View 树的工作；</strong>  </li>
<li><strong>发完同步屏障后 scheduleTraversals() 才会开始安排一个遍历绘制 View 树的操作，作法是把 performTraversals() 封装到 Runnable 里面，然后调用 Choreographer 的 postCallback() 方法；</strong>  </li>
<li><strong>postCallback() 方法会先将这个 Runnable 任务以当前时间戳放进一个待执行的队列里，然后如果当前是在主线程就会直接调用一个native 层方法，如果不是在主线程，会发一个最高优先级的 message 到主线程，让主线程第一时间调用这个 native 层的方法；</strong>  </li>
<li><strong>native 层的这个方法是用来向底层注册监听下一个屏幕刷新信号，当下一个屏幕刷新信号发出时，底层就会回调 Choreographer 的onVsync() 方法来通知上层 app；</strong>  </li>
<li><strong>onVsync() 方法被回调时，会往主线程的消息队列中发送一个执行 doFrame() 方法的消息，这个消息是异步消息，所以不会被同步屏障拦截住；</strong>   </li>
<li><strong>doFrame() 方法会去取出之前放进待执行队列里的任务来执行，取出来的这个任务实际上是 ViewRootImpl 的 doTraversal() 操作；</strong>  </li>
<li><strong>上述第4步到第8步涉及到的消息都手动设置成了异步消息，所以不会受到同步屏障的拦截；</strong>  </li>
<li><strong>doTraversal() 方法会先移除主线程的同步屏障，然后调用 performTraversals() 开始根据当前状态判断是否需要执行performMeasure() 测量、perfromLayout() 布局、performDraw() 绘制流程，在这几个流程中都会去遍历 View 树来刷新需要更新的View；</strong>   </li>
</ol>
<p>再来一张时序图结尾，大伙想自己过源码时可以跟着时序图来，建议在电脑上阅读：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-26227e967f4d3506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View刷新流程时序图.png"></p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p><strong>Q1：Android 每隔 16.6 ms 刷新一次屏幕到底指的是什么意思？是指每隔 16.6ms 调用 onDraw() 绘制一次么？</strong><br><strong>Q2：如果界面一直保持没变的话，那么还会每隔 16.6ms 刷新一次屏幕么？</strong><br>答：我们常说的 Android 每隔 16.6 ms 刷新一次屏幕其实是指底层会以这个固定频率来切换每一帧的画面，而这个每一帧的画面数据就是我们 app 在接收到屏幕刷新信号之后去执行遍历绘制 View 树工作所计算出来的屏幕数据。而 app 并不是每隔 16.6ms 的屏幕刷新信号都可以接收到，只有当 app 向底层注册监听下一个屏幕刷新信号之后，才能接收到下一个屏幕刷新信号到来的通知。而只有当某个 View 发起了刷新请求时，app 才会去向底层注册监听下一个屏幕刷新信号。  </p>
<p>也就是说，只有当界面有刷新的需要时，我们 app 才会在下一个屏幕刷新信号来时，遍历绘制 View 树来重新计算屏幕数据。如果界面没有刷新的需要，一直保持不变时，我们 app 就不会去接收每隔 16.6ms 的屏幕刷新信号事件了，但底层仍然会以这个固定频率来切换每一帧的画面，只是后面这些帧的画面都是相同的而已。  </p>
<p><strong>Q3：界面的显示其实就是一个 Activity 的 View 树里所有的 View 都进行测量、布局、绘制操作之后的结果呈现，那么如果这部分工作都完成后，屏幕会马上就刷新么？</strong><br>答：我们 app 只负责计算屏幕数据而已，接收到屏幕刷新信号就去计算，计算完毕就计算完毕了。至于屏幕的刷新，这些是由底层以固定的频率来切换屏幕每一帧的画面。所以即使屏幕数据都计算完毕，屏幕会不会马上刷新就取决于底层是否到了要切换下一帧画面的时机了。</p>
<p><strong>Q4：网上都说避免丢帧的方法之一是保证每次绘制界面的操作要在 16.6ms 内完成，但如果这个 16.6ms 是一个固定的频率的话，请求绘制的操作在代码里被调用的时机是不确定的啊，那么如果某次用户点击屏幕导致的界面刷新操作是在某一个 16.6ms 帧快结束的时候，那么即使这次绘制操作小于 16.6 ms，按道理不也会造成丢帧么？这又该如何理解？</strong><br>答：之所以提了这个问题，是因为之前是以为如果某个 View 发起了刷新请求，比如调用了 <code>invalidte()</code>，那么它的重绘工作就马上开始执行了，所以以前在看网上那些介绍屏幕刷新机制的博客时，经常看见下面这张图：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-d8ebbbd67051dd6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">  </p>
<p>那个时候就是不大理解，为什么每一次 CPU 计算的工作都刚刚好是在每一个信号到来的那个瞬间开始的呢？毕竟代码里发起刷新屏幕的操作是动态的，不可能每次都刚刚好那么巧。  </p>
<p>梳理完屏幕刷新机制后就清楚了，代码里调用了某个 View 发起的刷新请求，这个重绘工作并不会马上就开始，而是需要等到下一个屏幕刷新信号来的时候才开始，所以现在回过头来看这些图就清楚多了。  </p>
<p><strong>Q5：大伙都清楚，主线程耗时的操作会导致丢帧，但是耗时的操作为什么会导致丢帧？它是如何导致丢帧发生的？</strong><br>答：造成丢帧大体上有两类原因，一是遍历绘制 View 树计算屏幕数据的时间超过了 16.6ms；二是，主线程一直在处理其他耗时的消息，导致遍历绘制 View 树的工作迟迟不能开始，从而超过了 16.6 ms 底层切换下一帧画面的时机。  </p>
<p>第一个原因就是我们写的布局有问题了，需要进行优化了。而第二个原因则是我们常说的避免在主线程中做耗时的任务。  </p>
<p>针对第二个原因，系统已经引入了同步屏障消息的机制，尽可能的保证遍历绘制 View 树的工作能够及时进行，但仍没办法完全避免，所以我们还是得尽可能避免主线程耗时工作。  </p>
<p>其实第二个原因，可以拿出来细讲的，比如有这种情况， message 不怎么耗时，但数量太多，这同样可能会造成丢帧。如果有使用一些图片框架的，它内部下载图片都是开线程去下载，但当下载完成后需要把图片加载到绑定的 view 上，这个工作就是发了一个 message 切到主线程来做，如果一个界面这种 view 特别多的话，队列里就会有非常多的 message，虽然每个都 message 并不怎么耗时，但经不起量多啊。后面有时间的话，看看要不要专门整理一篇文章来讲卡顿和丢帧的事。  </p>
<h3 id="推荐阅读（大神博客）"><a href="#推荐阅读（大神博客）" class="headerlink" title="推荐阅读（大神博客）"></a>推荐阅读（大神博客）</h3><p><a href="https://www.jianshu.com/p/a769a6028e51" target="_blank" rel="noopener">破译Android性能优化中的16ms问题</a><br><a href="http://blog.csdn.net/litefish/article/details/53939882" target="_blank" rel="noopener">android屏幕刷新显示机制</a><br><a href="https://www.jianshu.com/p/996bca12eb1d" target="_blank" rel="noopener">Android Choreographer 源码分析</a></p>
]]></content>
      <categories>
        <category>Android源码解析</category>
      </categories>
  </entry>
  <entry>
    <title>View 动画 Animation 运行原理解析</title>
    <url>/2018/01/15/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/View-%E5%8A%A8%E7%94%BB-Animation-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</strong>    </p>
</blockquote>
<p>这次想来梳理一下 View 动画也就是补间动画（ScaleAnimation, AlphaAnimation, TranslationAnimation…）这些动画运行的流程解析。内容并不会去分析动画的呈现原理是什么，诸如 Matrix 这类的原理是什么，因为我也还没搞懂。本篇主要是分析当调用了 <code>View.startAnimation()</code> 之后，动画从开始到结束的一个运行流程是什么？    </p>
<h1 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h1><p>看源码最好是带着问题去，这样比较有目的性和针对性，可以防止阅读源码时走偏和钻牛角，所以我们就先来提几个问题。  </p>
<p>Animation 动画的扩展性很高，系统只是简单的为我们封装了几个基本的动画：平移、旋转、透明度、缩放等等，感兴趣的可以去看看这几个动画的源码，它们都是继承自 Animation 类，然后实现了 <strong>applyTransformation()</strong> 方法，在这个方法里通过 Transformation 和 Matrix 实现各种各样炫酷的动画，所以，如果想要做出炫酷的动画效果，这些还是需要去搞懂的。  </p>
<p>目前我也还没搞懂，能力有限，所以优先分析动画的一个运行流程。  </p>
<p>首先看看 Animation 动画的基本用法：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-e091160e76fc0dbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本用法"></p>
<p>我们要使用一个 View 动画时，一般都是先 new 一个动画，然后配置各种参数，最后调用动画要作用到的那个 View 的 startAnimation()， 将动画实例作为参数传进去，接下去就可以看到动画运行的效果了。   </p>
<p>那么，问题来了：  </p>
<p><strong>Q1：不知道大伙想过没有，当调用了 View.startAnimation() 之后，动画是马上就执行了么？</strong>  </p>
<p><strong>Q2：假如动画持续时间 300ms，当调用了 View.startAniamtion() 之后，又发起了一次界面刷新的操作，那么界面的刷新是在 300ms 之后也就是动画执行完毕之后才执行的，还是在动画执行过程中界面刷新操作就执行了呢？</strong>  </p>
<p>我们都知道，<strong>applyTransformation()</strong> 这个方法是动画生效的地方，这个方法被回调时参数会传进来当前动画的进度（0.0 ——— 1.0）。就像数学上的画曲线，当给的点越多时画的曲线越光滑，同样当这个方法被回调越多次时，动画的效果越流畅。  </p>
<p>比如一个从 0 放大到 1280 的 View 放大动画，如果这过程该方法只回调 3 次的话，那么每次的跨度就会很大，比如 0 —— 600 —— 1280，那么这个动画效果看起来就会很突兀；相反，如果这过程该方法回调了几十次的话，那么每次跨度可能就只有 100，这样一来动画效果看起来就会很流畅。  </p>
<p>相信大伙也都有过在 <strong>applyTransformation()</strong> 里打日志来查看当前的动画进度，有时打出的日志有十几条，有时却又有几十条。  </p>
<p>那么我们的问题就来了：  </p>
<p><strong>Q3：applyTransformation() 这个方法的回调次数是根据什么来决定的？</strong>  </p>
<p>好了，本篇就是主要讲解这三个问题，这三个问题搞明白的话，以后碰到动画卡顿的时候就懂得如何去分析、定位丢帧的地方了，找到丢帧的问题所在后离解决问题也就不远了。  </p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>ps:本篇分析的源码全都基于 android-25 版本。以下源码均采用截图方式，每张图最上面是类名+方法名，大伙想自己过一遍的时候，如果不清楚方法属于哪个类的可以在每张图最上面查看。</p>
<h2 id="View-startAnimation"><a href="#View-startAnimation" class="headerlink" title="View.startAnimation()"></a>View.startAnimation()</h2><p>刚开始接触源码分析可能不清楚该从哪入手，建议可以从我们使用它的地方来 <code>startAnimation()</code>：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-a7eb5c890369b9e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="startAnimation.png"></p>
<p>代码不多，调用了四个方法，那么一个个跟进去看看，先是 <code>setStartTime()</code> ：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-f76027d2d8dd7dd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setStartTime.png"></p>
<p>所以这里只是对一些变量进行赋值，并没有运行动画的逻辑，继续看看 <code>setAnimation()</code>：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-a1e70bed1abe03cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setAnimation.png"></p>
<p>View 里面有一个 Animation 类型的成员变量，所以这个方法其实是将我们 new 的 ScaleAnimation 动画跟 View 绑定起来而已，也没有运行动画的逻辑，继续往下看看 <code>invalidateParentCached()</code>：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-6fcdf86b4c23c394.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="invalidateParentCached.png"></p>
<p><code>invalidateParentCaches()</code> 这方法更简单，给 mPrivateFlags 添加了一个标志位，虽然还不清楚干嘛的，但可以先留个心眼，因为 mPrivateFlags 这个变量在阅读跟 View 相关的源码时经常碰到，那么可以的话能搞明白就搞明白，但目前跟我们想要找出动画到底什么时候开始执行的关系好像不大，先略过，继续跟进 <code>invalidate()</code>：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-36bad2b2af631d4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="invalidateInternal.png"></p>
<p>所以 <code>invalidate()</code> 内部其实是调用了 ViewGroup 的 <code>invalidateChild()</code>，再跟进看看：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-9d9ff79ecc0c65ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="invalidateChild.png"></p>
<p>这里有一个 do{}while() 的循环操作，第一次循环的时候 parent 是 this，即 ViewGroup 本身，所以接下去就是调用 ViewGroup 本身的 <code>invalidateChildInParent()</code> 方法，然后循环终止条件是 patent == null，所以可以猜测这个方法返回的应该是 ViewGroup 的 parent，跟进看看：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-f11518c9374559f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="invalidateChildInparent.png"></p>
<p>所以关键是 PFLAG_DRAWN 和 PFLAG_DRAWING_CACHE_VALID 这两个是什么时候赋值给 mPrivateFlags，因为只要有两个标志中的一个时，该方法就会返回 mParent，具体赋值的地方还不大清楚，但能确定的是动画执行时，它是满足 if 条件的，也就是这个方法会返回 mParent。</p>
<p>一个具体的 View 的 mParent 是 ViewGroup，ViewGroup 的 mParent 也是 ViewGoup，所以在 do{}while() 循环里会一直不断的寻找 mParent，而一颗 View 树最顶端的 mParent 是 ViewRootImpl，所以最终是会走到了 ViewRootImpl 的 <code>invalidateChildInParent()</code> 里去了。</p>
<p>至于一个界面的 View 树最顶端为什么是 ViewRootImpl，这个就跟 Activity 启动过程有关了。我们都清楚，<strong>在 onCreate 里 setContentView() 的时候，是将我们自己写的布局文件添加到以 DecorView 为根布局的一个 ViewGroup 里，也就是说 DevorView 才是 View 树的根布局，那为什么又说 View 树最顶端其实是 ViewRootImpl 呢？</strong>  </p>
<p>这是因为在 <code>onResume()</code> 执行完后，WindowManager 将会执行 <code>addView()</code>，然后在这里面会去创建一个 ViewRootImpl 对象，接着将 DecorView 跟 ViewRootImpl 对象绑定起来，并且将 DecorView 的 mParent 设置成 ViewRootImpl，而 ViewRootImpl 是实现了 ViewParent 接口的，所以虽然 ViewRootImpl 没有继承 View 或 ViewGroup，但它确实是 DecorView 的 parent。这部分内容应该属于 Activity 的启动过程相关原理的，所以本篇只给出结论，不深入分析了，感兴趣的可以自行搜索一下。  </p>
<p>那么我们继续返回到寻找动画执行的地方，我们跟到了 ViewRootImpl 的 <code>invalidateChildInParent()</code> 里去了，看看它做了些什么：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-7a4d7507243abe08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl#invalidateChildInParent.png"></p>
<p>首先第一点，它的所有返回值都是 null，所以之前那个 do{}while() 循环最终就是执行到这里后肯定就会停止了。然后参数 dirty 是在最初 View 的 <code>invalidateInternal()</code> 里层层传递过来的，可以肯定的是它不为空，也不是 isEmpty，所以继续跟到 <code>invalidateRectOnScreen()</code> 方法里看看：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-db15b7fa2f3f1bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="invalidateRectOnScreen.png"></p>
<p>跟到这里就可以了，<code>scheduleTraversals()</code> 作用是将 <code>performTraversals()</code> 封装到一个 Runnable 里面，然后扔到 Choreographer 的待执行队列里，这些待执行的 Runnable 将会在最近的一个 16.6 ms 屏幕刷新信号到来的时候被执行。而 <code>performTraversals()</code> 是 View 的三大操作：测量、布局、绘制的发起者。</p>
<p><strong>View 树里面不管哪个 View 发起了布局请求、绘制请求，统统最终都会走到 ViewRootImpl 里的 scheduleTraversals()，然后在最近的一个屏幕刷新信号到了的时候再通过 ViewRootImpl 的 performTraversals() 从根布局 DecorView 开始依次遍历 View 树去执行测量、布局、绘制三大操作。这也是为什么一直要求页面布局层次不能太深，因为每一次的页面刷新都会先走到 ViewRootImpl 里，然后再层层遍历到具体发生改变的 View 里去执行相应的布局或绘制操作。</strong>  </p>
<p>这些内容应该是属于 Android 屏幕刷新机制的，这里就先只给出结论，具体分析我会在几天后再发一篇博客出来。  </p>
<p>所以，我们从 <code>View.startAnimation()</code> 开始跟进源码分析的这一过程中，也可以看出，执行动画，其实内部会调用 View 的重绘请求操作 <code>invalidate()</code> ，所以最终会走到 ViewRootImpl 的 <code>scheduleTraversals()</code>，然后在下一个屏幕刷新信号到的时候去遍历 View 树刷新屏幕。</p>
<p>所以，到这里可以得到的结论是：</p>
<p><strong>当调用了 View.startAniamtion() 之后，动画并没有马上就被执行，这个方法只是做了一些变量初始化操作，接着将 View 和 Animation 绑定起来，然后调用重绘请求操作，内部层层寻找 mParent，最终走到 ViewRootImpl 的 scheduleTraversals 里发起一个遍历 View 树的请求，这个请求会在最近的一个屏幕刷新信号到来的时候被执行，调用 performTraversals 从根布局 DecorView 开始遍历 View 树。</strong>  </p>
<h2 id="动画真正执行的地方"><a href="#动画真正执行的地方" class="headerlink" title="动画真正执行的地方"></a>动画真正执行的地方</h2><p>那么，到这里，我们可以猜测，动画其实真正执行的地方应该是在 ViewRootImpl 发起的遍历 View 树的这个过程中。测量、布局、绘制，View 显示到屏幕上的三个基本操作都是由 ViewRootImpl 的 <code>performTraversals()</code> 来控制，而作为 View 树最顶端的 parent，要控制这颗 Veiw 树的三个基本操作，只能通过层层遍历。所以，测量、布局、绘制三个基本操作的执行都会是一次遍历操作。  </p>
<p>我在跟着这三个流程走的时候，最后发现，在跟着绘制流程走的时候，看到了跟动画相关的代码，所以我们就跳过其他两个流程，直接看绘制流程：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-baa80bd0e507de89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="绘制流程.png"></p>
<p>这张图不是我画的，在网上找的，绘制流程的开始是由 ViewRootImpl 发起的，然后从 DecorView 开始遍历 View 树。而遍历的实现，是在 View#draw() 方法里的。我们可以看看这个方法的注释：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-217259d19a8d1306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="draw.png"></p>
<p>这个方法里主要做了上述六件事，大体上就是如果当前 View 需要绘制，就会去调用自己的 <code>onDraw()</code>，然后如果有子 View，就会调用<code>dispatchDraw()</code> 将绘制事件通知给子 View。ViewGroup 重写了 <code>dispatchDraw()</code>，调用了 <code>drawChild()</code>，而 <code>drawChild()</code> 调用了子 View 的 <code>draw(Canvas, ViewGroup, long)</code>，而这个方法又会去调用到 <code>draw(Canvas)</code> 方法，所以这样就达到了遍历的效果。整个流程就像上上图中画的那样。   </p>
<p>在这个流程中，当跟到 <code>draw(Canvas, ViewGroup, long)</code> 里时，发现了跟动画相关的代码：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-c31cb5ac728f99d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="draw2.png"></p>
<p>还记得我们调用 <code>View.startAnimation(Animation)</code> 时将传进来的 Animation 赋值给 mCurrentAnimation 了么。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-2631bf390e2f9f71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="getAnimation.png"></p>
<p>所以当时传进来的 Animation ，现在拿出来用了，那么动画真正执行的地方应该也就是在 <code>applyLegacyAnimation()</code> 方法里了（该方法在 android-22 版本及之前的命名是 drawAnimation）<br><img src="http://upload-images.jianshu.io/upload_images/1924341-311da86ca28772ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="applyLegacyAnimation.png"></p>
<p>这下确定动画真正开始执行是在什么地方了吧，都看到 <code>onAnimationStart()</code> 了，也看到了对动画进行初始化，以及调用了 Animation 的  <code>getTransformation</code>，这个方法是动画的核心，再跟进去看看：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-cfc210a6ec0ad79b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="getTransformation.png"></p>
<p>这个方法里做了几件事：</p>
<ol>
<li>记录动画第一帧的时间  </li>
<li>根据当前时间到动画第一帧的时间这之间的时长和动画应持续的时长来计算动画的进度  </li>
<li>把动画进度控制在 0-1 之间，超过 1 的表示动画已经结束，重新赋值为 1 即可  </li>
<li>根据插值器来计算动画的实际进度  </li>
<li>调用 applyTransformation() 应用动画效果  </li>
</ol>
<p>所以，到这里我们已经能确定 <code>applyTransformation()</code> 是什么时候回调的，动画是什么时候才真正开始执行的。那么 Q1 总算是搞定了，Q2 也基本能理清了。因为我们清楚， <code>applyTransformation()</code> 最终是在绘制流程中的 <code>draw()</code> 过程中执行到的，那么显然在每一帧的屏幕刷新信号来的时候，遍历 View 树是为了重新计算屏幕数据，也就是所谓的 View 的刷新，而动画只是在这个过程中顺便执行的。  </p>
<p>接下去就是 Q3 了，我们知道 <code>applyTransformation()</code> 是动画生效的地方，这个方法不断的被回调时，参数会传进来动画的进度，所以呈现效果就是动画根据进度在运行中。</p>
<p><strong>但是，我们从头分析下来，找到了动画真正执行的地方，找到了 applyTransformation() 被调用的地方，但这些地方都没有看到任何一个 for 或者 while 循环啊，也就是一次 View 树的遍历绘制操作，动画也就只会执行一次而已啊？那么它是怎么被回调那么多次的？</strong>  </p>
<p>我们知道 <code>applyTransformation()</code> 是在 <code>getTransformation()</code> 里被调用的，而这个方法是有一个 boolean 返回值的，我们看看它的返回逻辑是什么：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-0e6225350c2ca14c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="getTransformation2.png"></p>
<p>也就是说 <code>getTransformation()</code> 的返回值代表的是动画是否完成，还记得是哪里调用的 <code>getTransformation()</code> 吧，去 <code>applyLegacyAnimation()</code> 里看看取到这个返回值后又做了什么：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-6a1206a8e4c1084b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="applyLegacyAnimation2.png"></p>
<p>当动画如果还没执行完，就会再调用 <code>invalidate()</code> 方法，层层通知到 ViewRootImpl 再次发起一次遍历请求，当下一帧屏幕刷新信号来的时候，再通过 <code>performTraversals()</code> 遍历 View 树绘制时，该 View 的 draw 收到通知被调用时，会再次去调用 <code>applyLegacyAnimation()</code> 方法去执行动画相关操作，包括调用 <code>getTransformation()</code> 计算动画进度，调用 <code>applyTransformation()</code> 应用动画。</p>
<p>也就是说，动画很流畅的情况下，其实是每隔 16.6ms 即每一帧到来的时候，执行一次 <code>applyTransformation()</code>，直到动画完成。所以这个 <code>applyTransformation()</code> 被回调多次是这么来的，而且这个回调次数并没有办法人为进行设定。</p>
<p>这就是为什么当动画持续时长越长时，这个方法打出的日志越多次的原因。</p>
<p>还记得 <code>getTransformation()</code> 方法在计算动画进度时是根据参数传进来的 currentTime 的么，而这个 currentTime 可以理解成是发起遍历操作这个时刻的系统时间（实际 currentTime 是在 Choreographer 的 doFrame() 里经过校验调整之后的一个时间，但离发起遍历操作这个时刻的系统时间相差很小，所以不深究的话，可以像上面那样理解，比较容易明白）。  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上，我们稍微整理一下：</p>
<ol>
<li><p><strong>首先，当调用了 View.startAnimation() 时动画并没有马上就执行，而是通过 invalidate() 层层通知到 ViewRootImpl 发起一次遍历 View 树的请求，而这次请求会等到接收到最近一帧到了的信号时才去发起遍历 View 树绘制操作。</strong>  </p>
</li>
<li><p><strong>从 DecorView 开始遍历，绘制流程在遍历时会调用到 View 的 draw() 方法，当该方法被调用时，如果 View 有绑定动画，那么会去调用applyLegacyAnimation()，这个方法是专门用来处理动画相关逻辑的。</strong>  </p>
</li>
<li><p><strong>在 applyLegacyAnimation() 这个方法里，如果动画还没有执行过初始化，先调用动画的初始化方法 initialized()，同时调用 onAnimationStart() 通知动画开始了，然后调用 getTransformation() 来根据当前时间计算动画进度，紧接着调用 applyTransformation() 并传入动画进度来应用动画。</strong>  </p>
</li>
<li><p><strong>getTransformation() 这个方法有返回值，如果动画还没结束会返回 true，动画已经结束或者被取消了返回 false。所以 applyLegacyAnimation() 会根据 getTransformation() 的返回值来决定是否通知 ViewRootImpl 再发起一次遍历请求，返回值是 true 表示动画没结束，那么就去通知 ViewRootImpl 再次发起一次遍历请求。然后当下一帧到来时，再从 DecorView 开始遍历 View 树绘制，重复上面的步骤，这样直到动画结束。</strong>  </p>
</li>
<li><p><strong>有一点需要注意，动画是在每一帧的绘制流程里被执行，所以动画并不是单独执行的，也就是说，如果这一帧里有一些 View 需要重绘，那么这些工作同样是在这一帧里的这次遍历 View 树的过程中完成的。每一帧只会发起一次 perfromTraversals() 操作。</strong>  </p>
</li>
</ol>
<p>以上，就是本篇所有的内容，将 View 动画 Animation 的运行流程原理梳理清楚，但要搞清楚为什么动画会出现卡顿现象的话，还需要理解 Android 屏幕的刷新机制以及消息驱动机制；这些内容将在最近几天内整理成博客分享出来。  </p>
<h1 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h1><p>最后仍然遗留一些尚未解决的问题，等待继续探索：  </p>
<p>Q1：大伙都清楚，View 动画区别于属性动画的就是 View 动画并不会对这个 View 的属性值做修改，比如平移动画，平移之后 View 还是在原来的位置上，实际位置并不会随动画的执行而移动，那么这点的原理是什么？  </p>
<p>Q2：既然 View 动画不会改变 View 的属性值，那么如果是缩放动画时，View 需要重新执行测量操作么？    </p>
]]></content>
      <categories>
        <category>Android源码解析</category>
      </categories>
  </entry>
  <entry>
    <title>我的2017年总结</title>
    <url>/2018/01/01/%E7%9E%8E%E6%89%AF%E6%89%AF/%E6%88%91%E7%9A%842017%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 hongyangAndroid （鸿洋）独家发布</strong>  </p>
</blockquote>
<p>2017就这么的过了，最近几天朋友圈里一直在晒18岁的梗，90后彻底退出青少年时代了，不服老不行啊，今天是17年最后一天，大家都去看晚会了，空巢老人还是写篇总结来记录下自己的2017吧。 </p>
<p><strong>先回顾一下17年</strong>：  </p>
<blockquote>
<p>3月4月偷偷离校满怀憧憬的跑去公司实习；<br>5月6月回校做毕设、写论文，享受最后的校园时光，同时喜欢上了每天跑3公里，因为有着一个腹肌梦；<br>6月底找了个基友，啥准备也没有就来了趟毕业旅行，跑到了人生中离开家最远的一次，爬了山，看了水，满足；<br>7月作为职场小菜鸟步入公司，开始打怪升级，同时找了几个同学一起合租，开始学做菜，每天一下班就想着赶回去练手做菜；<br>8月用第一次工资给老爸、老妈换了部手机，当然，找老姐资助了点，但功劳都是我的，哈哈哈；<br>9月用剩余的工资给自己买了很多健身器材，开始了自己的健身梦；<br>10月发现自己还是职场小菜鸟，经验条太长升级太慢，决定做做支线任务，每月至少写篇技术博客；<br>10月底写了第一篇源码分析博客，投给了郭神，过了！成就感瞬间充满，开心，又更有动力了；<br>11月发现小腹肌有了雏形，开心，工作也开始适应了，虽然还是小菜鸟，但多少可以为公司做点贡献了；<br>11月12月事情开始多了，做菜的事也放一边了，锻炼也放一边了，给自己找了个借口：天冷；<br>12月底想要总结一下，发现这一年来，喜欢的事很多，尝试的事也很多，但更多的都是没能坚持下去；<br>18年给自己说了句话：锻炼的事得重新拿起来，不能放，博客的事也不能放，得坚持；    </p>
</blockquote>
<h1 id="笔记整理"><a href="#笔记整理" class="headerlink" title="笔记整理"></a>笔记整理</h1><p>我平时是会通过 word 来记录一些学习笔记：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-0b7cc7ffe91efb30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="笔记目录.png"></p>
<p>这一年零零散散记了有150几页，记的内容很泛，平时遇见一些不熟悉的知识点都会顺手记下来，方便后面查阅。最可惜的是，我这个习惯其实是从大三开始的，大三记了一年，记的内容好像比今年多多了，后面因为电脑坏了重装系统，居然忘记备份，就这么没了，没了！  </p>
<p>其实笔记记多了，反而会懒得去看，时间一久，如果没再次整理一下的话，笔记反而会更乱，当需要时也会忘记自己是否曾经记过某个知识点。所以，感觉还是得来梳理一下这个笔记，好的，那就开始吧。  </p>
<p>归纳了一下，笔记的主要内容大概可以分为以下几类吧：<strong>基础篇</strong>、<strong>进阶篇</strong>、<strong>工具篇</strong>，其他还包括一些热门框架的基本使用记录或一些编程思想，但内容不多。  </p>
<p>那么，这篇就大概把这些笔记内容分类梳理一下吧，方便自己以后查阅，也希望可以帮助到别人。  </p>
<h2 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h2><h3 id="1-abd-常用命令"><a href="#1-abd-常用命令" class="headerlink" title="1. abd 常用命令"></a>1. abd 常用命令</h3><h4 id="（1）删除系统应用"><a href="#（1）删除系统应用" class="headerlink" title="（1）删除系统应用"></a>（1）删除系统应用</h4><p>步骤:  </p>
<p>1) <code>mount -o rw,remount /system</code> 卸载系统应用时先运行这句<br>2) <code>chome 777 system</code> 添加 system 目录权限<br>3) 然后把 <code>/system/app</code> 和 <code>/data/data</code> 下的相关文件删掉<br>4) <code>reboot</code> 重启盒子<br>5) 然后就可以安装 <code>debug</code> 应用   </p>
<p>场景：<br>如果开发盒子的系统应用时，当通过 AS 编译运行到盒子时，如果盒子上已装有 release 版，那么 AS 是无法将项目跑到盒子上的，需要先将系统应用删除后才可以正常开发。  </p>
<h4 id="（2）修改host文件"><a href="#（2）修改host文件" class="headerlink" title="（2）修改host文件"></a>（2）修改host文件</h4><p>当 pc 跟盒子连接后（通过 usb 或 wifi 连接），在 pc 端的 cmd 窗口中输入下列命令：<br><code>adb remount</code><br><code>adb pull /system/etc/hosts</code>  //备份<br><code>adb push hosts /system/etc/hosts</code>  //将准备好的 hosts 文件 push 进去</p>
<h4 id="（3）wifi-连接调试"><a href="#（3）wifi-连接调试" class="headerlink" title="（3）wifi 连接调试"></a>（3）wifi 连接调试</h4><p><strong>方法一：需要 root 权限</strong><br>手机端下载超级终端，然后输入下面命令：<br><code>su</code><br><code>setprop service.adb.tcp.port 5555</code><br><code>stop adbd</code><br><code>start adbd</code>  </p>
<p>附 Android 终端下载地址：<a href="https://github.com/jackpal/Android-Terminal-Emulator" target="_blank" rel="noopener">https://github.com/jackpal/Android-Terminal-Emulator</a>  </p>
<p><strong>方法二：需要 usb 线，不需要 root</strong><br>usb 连接手机调试后，在 pc 端的 cmd 窗口中输入下列命令：<br><code>adb kill-server</code><br><code>adb start-server</code><br><code>adb tcpip 5555</code></p>
<p>场景：盒子应用开发时，经常会出现有的盒子 usb 无法跟 pc 连接，那么此时可以考虑通过 wifi，当 pc 和 盒子在同一个局域网内时可以通过 <code>adb connect &lt;ip address&gt;</code> 来连接盒子，当连接失败时才考虑用上面的方法操作后再次调用 <code>adb connect &lt;ip address&gt;</code>  来连接盒子即可。  </p>
<h4 id="（4）查看目前-Activity-栈"><a href="#（4）查看目前-Activity-栈" class="headerlink" title="（4）查看目前 Activity 栈"></a>（4）查看目前 Activity 栈</h4><p>命令： <code>adb shell dumpsys activity</code> </p>
<h4 id="（5）启动任意-Activity"><a href="#（5）启动任意-Activity" class="headerlink" title="（5）启动任意 Activity"></a>（5）启动任意 Activity</h4><p><img src="http://upload-images.jianshu.io/upload_images/1924341-4e7f9fe1239a7327.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动任意活动.png"><br>这位大神的博客有详细说明：<a href="http://www.jianshu.com/p/54fd9627860a" target="_blank" rel="noopener">http://www.jianshu.com/p/54fd9627860a</a>   </p>
<h3 id="2-Chrome-插件"><a href="#2-Chrome-插件" class="headerlink" title="2. Chrome 插件"></a>2. Chrome 插件</h3><p>我用的插件不多，但我感觉是都挺实用的，如下：  </p>
<p><strong>Octotree</strong>：  方便 github 项目结构查看  </p>
<p><strong>Postman</strong>：  模拟 http 请求  </p>
<p><strong>ChromeADB</strong>：  发送 adb 命令，没有遥控器的时候可以暂时用这个来控制  </p>
<p><strong>JSON-handle</strong>：  json</p>
<p><strong>AdBlock</strong>：  禁广告  </p>
<p><strong>Agar/Slither Infinity</strong>：  标签页  </p>
<p><strong>crxMouse Chrome™ Gestures</strong>：  手势操作  </p>
<h3 id="3-AS调试工具"><a href="#3-AS调试工具" class="headerlink" title="3. AS调试工具"></a>3. AS调试工具</h3><p><strong>查看当前线程信息</strong><br><img src="http://upload-images.jianshu.io/upload_images/1924341-2cd1f39fe4e43020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="as调试查看线程信息.png"></p>
<p><strong>开启显示方法的返回值</strong><br><img src="http://upload-images.jianshu.io/upload_images/1924341-ab266b593ffba593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="as调试开启方法返回值.png"></p>
<p><strong>不添加代码临时添加日志输出</strong><br><img src="http://upload-images.jianshu.io/upload_images/1924341-a41269410d692041.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="as调试添加日志输出.png"><br><img src="http://upload-images.jianshu.io/upload_images/1924341-07e5bbe2560192df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="as调试日志输出.png"></p>
<h3 id="4-AS版本管理工具（SVN-and-Git"><a href="#4-AS版本管理工具（SVN-and-Git" class="headerlink" title="4. AS版本管理工具（SVN and Git)"></a>4. AS版本管理工具（SVN and Git)</h3><p>这部分内容写过两篇简单的博客，记录了下基本使用：<br><a href="http://www.cnblogs.com/dasusu/p/5372840.html" target="_blank" rel="noopener">Android Studio的git功能的使用介绍</a><br><a href="https://www.jianshu.com/p/48fde8a22484" target="_blank" rel="noopener">如何用Android Studio同时使用SVN和Git管理项目</a>  </p>
<h2 id="基础篇（Android）"><a href="#基础篇（Android）" class="headerlink" title="基础篇（Android）"></a>基础篇（Android）</h2><p>ps:以下内容有些是平时记笔记时直接在一些博客里将自己认为的重点直接复制粘贴记录下来的，当时都没有记出处，所以如果这样会有抄袭的侵权，告知下来删。  </p>
<h3 id="1-xml控件属性"><a href="#1-xml控件属性" class="headerlink" title="1. xml控件属性"></a>1. xml控件属性</h3><p>####（1）android:clipToPadding android:clipToChildren   </p>
<p>这两个都是 <strong>ViewGroup 的属性</strong>，一般我们在 ViewGroup 里，比如在 LinearLayout 设置 padding = 10dp，那么它的子控件就都会在距离父控件边界 10dp 的内部区域显示。即使我们对子控件设置了 layout_marginTop = -10dp，来将子控件往上移到父控件的上边界，虽然子控件实际位置确实是往上移了，但是在这个 10dp 的区域内是不会绘制的，也就是说子控件上面 10dp 部分是被遮住了，不会显示出来的。而 <strong>android:clipToPadding</strong> 这个属性作用就是允许绘制在 padding 内子控件，这个属性<strong>默认值是 true</strong>，当我们把它设置成 <strong>false</strong> 后，子控件在父控件的 padding 区域内就可以显示出来了。  </p>
<p><strong>adnroid:clipToClildren</strong> 性质是一样的，<strong>默认值也是 true</strong>，只是这个属性是允许绘制超出父控件区域的子控件。正常情况下，如果我们对子控件设置 layout_marginTop 为负来将子控件的一部分区域移出父控件的边界，那么子控件超出父控件边界的这部分是不会被绘制出来的，如果对这个属性设置了 <strong>false</strong>，那么就允许绘制超出的这部分内容了。  </p>
<p>这两个属性一般是在 Tv 应用上比较常用，因为 Tv 应用经常会有一些 View 获取焦点后需要放大的效果，而有时放大后的 View 刚好会在父控件的 padding 区域内，甚至是会超出父控件的边界，如果不用这两个属性来控制，放大后的 View 就会呈现被截断的效果。     </p>
<h4 id="（2）android-drawableRight"><a href="#（2）android-drawableRight" class="headerlink" title="（2）android:drawableRight"></a>（2）android:drawableRight</h4><p>这个属性是 <strong>TextView</strong> 的属性，Tv 应用里有很多既有小图标又有文字的这种小标题 View，虽然可以用 LinearLayout 内放一个 ImageView 和一个 TextView 来搞定，但也可以直接用一个 TextView 就搞定，就是通过这个属性，这样可以优化一层布局。  </p>
<p><strong>android:drawablePadding</strong>： 是用来设置 drawable 与 text 之间的距离的。  </p>
<p>但使用这个有一些注意事项需要关注一下：  </p>
<p>注意事项：  </p>
<p>1) TextView 的 padding 作用在 drawable 之外<br>2) TextView 的高度或宽度为 wrap_content 时将是文字和 drawable 中较大的那一个，再加上 padding 和 margin<br>3) gravity只对文字起作用，对 drawable 不起作用<br>4) drawable 会在其所在的维度居中显示，比如 drawableLeft 是上下垂直居中的，以此类推  </p>
<h4 id="（3）xml焦点控制"><a href="#（3）xml焦点控制" class="headerlink" title="（3）xml焦点控制"></a>（3）xml焦点控制</h4><p><strong>android:descendantFocusability</strong>—–父容器和子控件的焦点获取问题  </p>
<p>这个属性定义了当一个焦点要传递给父容器或者子控件时，父容器和子控件之间获得焦点的关系。具体值如下：<br><code>beforeDescendants</code>：父容器会比其子控件率先获得焦点。<br><code>afterDescendants</code>：如果没有任何子控件要获得焦点的话，那么父容器才会获得焦点。<br><code>blocksDescendants</code>：父容器会阻止其子控件获得焦点（也就是说焦点会由父容器获得）。  </p>
<p><strong>android:duplicateParentState</strong>  </p>
<p>这个属性指的是当前控件是否跟随父控件的(点击、焦点等)状态。<br>我一般是结合上面的 <code>blocksDescendants</code> 和这个属性一起用，达到防止子控件获取焦点但同时子控件又能响应父控件焦点的变化状态。</p>
<p><strong>android:nextFocusRight</strong>——控制下一个焦点  </p>
<h4 id="（4）xml-动画文件里值的含义"><a href="#（4）xml-动画文件里值的含义" class="headerlink" title="（4）xml 动画文件里值的含义"></a>（4）xml 动画文件里值的含义</h4><p><img src="http://upload-images.jianshu.io/upload_images/1924341-17911cd666ed63fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="xml动画里值的含义1.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-c113668f142ae1d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="xml动画里值的含义2.png"></p>
<p>三种形式<br>绝对坐标：数字<br>相对于View本身控件坐标：数字+%<br>相对于父控件坐标：数字+%p  </p>
<h3 id="2-单元测试中通过反射测试私有方法"><a href="#2-单元测试中通过反射测试私有方法" class="headerlink" title="2.单元测试中通过反射测试私有方法"></a>2.单元测试中通过反射测试私有方法</h3><p><img src="http://upload-images.jianshu.io/upload_images/1924341-74b13470d20a0acc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码示例.png"></p>
<h3 id="3-OnGlobalLayoutListener"><a href="#3-OnGlobalLayoutListener" class="headerlink" title="3.OnGlobalLayoutListener"></a>3.OnGlobalLayoutListener</h3><p>这个回调可以用于获取 view 宽高：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int mViewHeight;</span><br><span class="line">private View mView;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//注册监听</span><br><span class="line">mView.getViewTreeObserver().addOnGlobalLayoutListener(</span><br><span class="line">    new OnGlobalLayoutListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onGlobalLayout() &#123;</span><br><span class="line">            //获取View高度</span><br><span class="line">            mViewHeight = mView.getHeight();</span><br><span class="line">            //取消监听，否则该方法会不断回调</span><br><span class="line">            mView.getViewTreeObserver().removeGlobalLayoutListener(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">我们知道在 onCreate() 中 View.getWidth 和 View.getHeight 无法获得一个 view 的高度和宽度，这是因为 View 组件布局要在 onResume() 回调后完成。所以现在需要使用 getViewTreeObserver().addOnGlobalLayoutListener() 来获得宽度或者高度。这是获得一个 view 的宽度和高度的方法之一。  </span><br><span class="line"></span><br><span class="line">但是需要注意的是 OnGlobalLayoutListener 可能会被多次触发，因此在得到了高度之后，要将OnGlobalLayoutListener 注销掉。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 4.TextView设置不同字体样式  </span><br><span class="line">![效果图.png](http://upload-images.jianshu.io/upload_images/1924341-0e963c1ae9078d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">使用方法：  </span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">//step1:</span><br><span class="line">SpannableString text = new SpannableString(“输入课程名称，如管理”);  </span><br><span class="line"></span><br><span class="line">//step2:</span><br><span class="line">text.setSpan(new ForegroundColorSpan(ContextCompat.getColor(this, R.color.text_color_gray)), 0, 10,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);  </span><br><span class="line"></span><br><span class="line">//step3:</span><br><span class="line">text.setSpan(new AbsoluteSizeSpan(textSize1), 10, 14, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line"></span><br><span class="line">//step4:</span><br><span class="line">4.TextView.setText(text);  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">关键方法：`setSpan()`  </span><br><span class="line"></span><br><span class="line">支持设置的字体格式（继承 CharacterSty 均可）：  </span><br><span class="line"></span><br><span class="line">1. 字体颜色-------ForegroundColorSpan</span><br><span class="line">1. 字体大小-------AbsoluteSizeSpan </span><br><span class="line">1. 背景颜色-------BackgroundColorSpan </span><br><span class="line">1. 超链接----------URLSpan </span><br><span class="line">1. 粗体、斜体----StyleSpan </span><br><span class="line">1. 删除线----------StrikethroughSpan </span><br><span class="line">1. 下划线----------UnderlineSpan </span><br><span class="line">1. 图片-------------ImageSpan </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.merge 标签注意事项  </span><br><span class="line"></span><br><span class="line">&gt;1. merge 必须放在布局文件的根节点上。  </span><br><span class="line">&gt;1. merge 并不是一个 ViewGroup，也不是一个 View，它相当于声明了一些视图，等待被添加。  </span><br><span class="line">&gt;1. merge 标签被添加到 A 容器下，那么 merge 下的所有视图将被添加到 A 容器下。  </span><br><span class="line">&gt;1. **因为 merge 标签并不是 View，所以在通过 LayoutInflate.inflate 方法渲染的时候， 第二个参数必须指定一个父容器，且第三个参数必须为 true，也就是必须为 merge 下的视图指定一个父亲节点。**  </span><br><span class="line">&gt;1. 如果 Activity 的布局文件根节点是 FrameLayout，可以替换为 merge 标签，这样，执行 setContentView之后，会减少一层 FrameLayout 节点。  </span><br><span class="line">&gt;1. 自定义 View 如果继承 LinearLayout，建议让自定义 View 的布局文件根节点设置成 merge，这样能少一层结点。  </span><br><span class="line">&gt;1. **因为 merge 不是 View，所以对 merge 标签设置的所有属性都是无效的**。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 6.调用系统的安装应用界面  </span><br><span class="line"></span><br><span class="line">步骤：  </span><br><span class="line">1. 设置 intent 的 dataAndType ，用隐式调用法来启动系统的安装界面  </span><br><span class="line">1. 传入apk的uri路径：file://mnt/sdcard/aa.apk  </span><br><span class="line">1. 和指定的type：application/vnd.android.package-archive  </span><br><span class="line"></span><br><span class="line">示例代码：  </span><br><span class="line">```  </span><br><span class="line">Intent intent = new Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">//传入apk路径还有设置type</span><br><span class="line">intent.setDataAndType(Uri.fromFile(new File(Config.getAppDir(content), apkName)), &quot;application/vnd.android.package-archive&quot;)  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 7.坐标基础  </span><br><span class="line"></span><br><span class="line">**View 的坐标系统**是相对于父控件而言的:  </span><br><span class="line"></span><br><span class="line">&gt; getTop();         //获取子View左上角距父View顶部的距离  </span><br><span class="line">&gt; getLeft();        //获取子View左上角距父View左侧的距离  </span><br><span class="line">&gt; getBottom();     //获取子View右下角距父View顶部的距离  </span><br><span class="line">&gt; getRight();      //获取子View右下角距父View左侧的距离  </span><br><span class="line"></span><br><span class="line">![坐标系.png](http://upload-images.jianshu.io/upload_images/1924341-83df6c0afac8b284.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">**MotionEvent 中 get 和 getRaw 的区别**:  </span><br><span class="line"></span><br><span class="line">&gt; event.getX();       //触摸点相对于其所在组件坐标系的坐标  </span><br><span class="line">&gt; event.getY();  </span><br><span class="line">&gt; event.getRawX();    //触摸点相对于屏幕默认坐标系的坐标  </span><br><span class="line">&gt; event.getRawY();  </span><br><span class="line"></span><br><span class="line">![坐标系.png](http://upload-images.jianshu.io/upload_images/1924341-9e1a5bb3d20f1bfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 8.SharePreference监听  </span><br><span class="line"></span><br><span class="line">**registerOnSharedPreferenceChangeListener(listener)**  </span><br><span class="line"></span><br><span class="line">&gt; 这个方法才是我要说的重点，因为之前有些需求就是更改了 SharedPreferences 之后，要通知相应的组件做出改变，我以前的处理方式是通过事件订阅实现的，发一个 event 出去，然后目标收到 event 再做出反应，当时觉得特别蛋疼，两边都要做些操作，显的特别啰嗦，当时就在想可不可以在 SharedPreferences 上设置一个观察者，一旦有什么风吹草动，就自动通知目标，不曾想，人家早已经实现了，只是我愚昧无知，今天去看了下源码发现了这个方法，相见恨晚。  </span><br><span class="line"></span><br><span class="line">代码示例：  </span><br><span class="line">```  </span><br><span class="line">SharedPreferences sp1 = getSharedPreferences(getPackageName() + &quot;test&quot;, MODE_PRIVATE);</span><br><span class="line">sp1.registerOnSharedPreferenceChangeListener(</span><br><span class="line">    new SharedPreferences.OnSharedPreferenceChangeListener() &#123; </span><br><span class="line">        @Override </span><br><span class="line">        public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) &#123;</span><br><span class="line">             // do any thing you want </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="9-TextView各种padding解析、长度测量"><a href="#9-TextView各种padding解析、长度测量" class="headerlink" title="9.TextView各种padding解析、长度测量"></a>9.TextView各种padding解析、长度测量</h3><p>详细说明：<a href="https://www.jianshu.com/p/fd9cce7a333f" target="_blank" rel="noopener">TextView的文字长度测量及各种padding解析</a>  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-c31a2f0fa5b2d344.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TextView.png"></p>
<p>这部分内容专门写了一篇博客分析，上面这张图概括了链接博客主要分析的内容，感兴趣的可以点进去看看。    </p>
<h2 id="进阶篇（Android）"><a href="#进阶篇（Android）" class="headerlink" title="进阶篇（Android）"></a>进阶篇（Android）</h2><p>进阶篇主要是自己在这一年里接触的一些源码阅读的笔记，现在已经陆陆续续发表了几篇源码分析的博客了，还有很多都是先简单的记录下来，想等有空闲时间再慢慢组织语言写成博客出来。  </p>
<h3 id="1-View-post-原理"><a href="#1-View-post-原理" class="headerlink" title="1.View.post()原理"></a>1.View.post()原理</h3><p>原文跳转：<a href="https://www.jianshu.com/p/85fc4decc947" target="_blank" rel="noopener">【Andorid源码解析】View.post() 到底干了啥</a>  </p>
<blockquote>
<p>Q1: 为什么 View.post() 的操作是可以对 UI 进行操作的呢，即使是在子线程中调用 View.post()？</p>
<p>Q2：网上都说 View.post() 中的操作执行时，View 的宽高已经计算完毕，所以经常看见在 Activity 的 onCreate() 里调用 View.post() 来解决获取 View 宽高为0的问题，为什么可以这样做呢？</p>
<p>Q3：用 View.postDelay() 有可能导致内存泄漏么？</p>
</blockquote>
<p>这是最近发表的一篇关于 View.post() 到底干了些什么事的博客，内容主要是从源码上分析了上述三个问题，投给了郭神了，也过啦，感谢郭神。虽然深度不是特别深，但内容应该还是有些干货的，尤其是那些想开始阅读源码来学习的同学，这篇里有介绍一些如何阅读源码的思路还有工具，因为我也是个新人，也刚刚摸索，也碰到很多问题，所以我清楚作为菜鸟对于阅读源码恐惧的种种，希望可以帮助到大伙。  </p>
<h3 id="2-KeyEvent的点击事件分发机制"><a href="#2-KeyEvent的点击事件分发机制" class="headerlink" title="2.KeyEvent的点击事件分发机制"></a>2.KeyEvent的点击事件分发机制</h3><p>原文跳转：<a href="https://www.jianshu.com/p/2f28386706a0" target="_blank" rel="noopener">Android KeyEvent 点击事件分发处理流程（一）</a>  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1924341-38bcb57fa4617d95.jpg?imageMogr2/auto-orient/" alt="KeyEvent流程图"></p>
<p>手机上的应用多数的触屏点击事件 MotionEvent，而 Tv 上的应用基本都是遥控器的点击事件 KeyEvent，两者虽然都是点击事件，分发消费机制大体上也差不了多少，但还是有些地方是有区别的。  </p>
<p>上面那篇博客里我主要是分析了在一个 Activity 界面里的遥控器点击事件 KeyEvent 的分发传递流程，但仍然还有很多遗留问题尚未搞清楚。  </p>
<h3 id="3-RecyclerView回收复用机制"><a href="#3-RecyclerView回收复用机制" class="headerlink" title="3.RecyclerView回收复用机制"></a>3.RecyclerView回收复用机制</h3><p>原文跳转：<a href="https://www.jianshu.com/p/9306b365da57" target="_blank" rel="noopener">基于滑动场景解析RecyclerView的回收复用机制原理</a>  </p>
<p>RecyclerView 的源码实在是太复杂了，之前项目有个关于滑动的问题，为了定位也去看了RecyclerView的相关源码，但最终还是失败了，因为还是没搞清楚。后来又遇到回收复用的优化需求，所以又过了这部分的源码，硬着头上了，分析到最后稍微有些收获，所以记录下来分享给大伙。  </p>
<blockquote>
<p>Q1:如果向下滑动，新一行的5个卡位的显示会去复用缓存的 ViewHolder，第一行的5个卡位会移出屏幕被回收，那么在这个过程中，是先进行复用再回收？还是先回收再复用？还是边回收边复用？也就是说，新一行的5个卡位复用的 ViewHolder 有可能是第一行被回收的5个卡位吗？  </p>
<p>Q2:在这个过程中，为什么当 RecyclerView 再次向上滑动重新显示第一行的5个卡位时，只有后面3个卡位触发了 onBindViewHolder() 方法，重新绑定数据呢？明明5个卡位都是复用的。  </p>
<p>Q3:接下去不管是向上滑动还是向下滑动，滑动几次，都不会再有 onCreateViewHolder() 的日志了，也就是说 RecyclerView 总共创建了17个 ViewHolder，但有时一行的5个卡位只有3个卡位需要重新绑定数据，有时却又5个卡位都需要重新绑定数据，这是为什么呢？</p>
</blockquote>
<p>链接给的博客里，我主要是基于滑动的场景，从源码上分析了上述三个问题，问题有结合一些前提和日志，所以如果感觉问题就看的有点懵的可以点进去看看具体的说明。    </p>
<h3 id="4-Activity切场动画"><a href="#4-Activity切场动画" class="headerlink" title="4.Activity切场动画"></a>4.Activity切场动画</h3><p>原文跳转：<a href="https://www.jianshu.com/p/559b5ed973f1" target="_blank" rel="noopener">Activity 切换动画—点击哪里从哪放大</a>  </p>
<p>这篇介绍的是如何实现 Activity 的切换动画，只是记录了下实现这个功能的一个思路，以及这过程中碰到的一大堆奇葩问题，尤其是 android:windowIsTranslucent 属性的问题。这段时间的主要经历都放在的动画的原理上，所以后期会渐渐分享这部分的知识。  </p>
<h3 id="5-app-Launch源码阅读前基础"><a href="#5-app-Launch源码阅读前基础" class="headerlink" title="5.app Launch源码阅读前基础"></a>5.app Launch源码阅读前基础</h3><p>startActivity() 打开一个页面时做的事是非常非常多的，这个过程是复杂得要死的，但大体的流程静下心来应该还是可以梳理出来的，但在这之前，需要对一些类或者变量先了解一下，这样阅读源码才不会一脸懵逼，下面的内容不是我整理的，原博客地址会贴出：  </p>
<p><a href="http://blog.csdn.net/jinzhuojun/article/details/37737439" target="_blank" rel="noopener"> Android 4.4(KitKat)窗口管理子系统 - 体系框架</a>  </p>
<blockquote>
<p><strong>Activity</strong>：描述一个Activity，它是与用户交互的基本单元。<br><strong>ActivityThread</strong>：每一个App进程有一个主线程，它由ActivityThread描述。它负责这个App进程中各个Activity的调度和执行，以及响应AMS的操作请求等。<br><strong>ApplicationThread</strong>：AMS和Activity通过它进行通信。对于AMS而言，ApplicationThread代表了App的主线程。简而言之，它是AMS与ActivityThread进行交互的接口。注意ActivityThread和ApplicationThread之间的关系并不像Activity与Application。后者的关系是Application中包含了多个Activity，而前者ActivityThread和ApplicationThread是同一个东西的两种”View”，ApplicationThread是在AMS眼中的ActivityThread。<br><strong>ViewRootImpl</strong>：主要责任包括创建Surface，和WMS的交互和App端的UI布局和渲染。同时负责把一些事件发往Activity以便Activity可以截获事件。每一个添加到WMS中的窗口对应一个ViewRootImpl，通过WindowManagerGlobal向WMS添加窗口时创建。大多数情况下，它管理Activity顶层视图DecorView。总得来说，它相当于MVC模型中的Controller。<br><strong>ViewRootImpl::W</strong>：用于向WMS提供接口，让WMS控制App端的窗口。它可看作是个代理，很多时候会调用ViewRootImpl中的功能。这种内嵌类的用法很多，特别是这种提供接口的代理类，如PhoneWindow::DecorView等。<br><strong>Instrumentation</strong>:官方提供的Hook，主要用于测试。如果只关注窗口管理流程的话可以先无视。<br><strong>WindowManagerImpl</strong>：Activity中与窗口管理系统通信的代理类，实现类是WindowManagerGlobal。WindowManagerGlobal是App中全局的窗口管理模块，因此是个Singleton。<br><strong>Window</strong>：每个App虽然都可以做得各不相同，但是作为有大量用户交互的系统，窗口之间必须要有统一的交互模式，这样才能减小用户的学习成本。这些共性比如title, action bar的显示和通用按键的处理等等。Window类就抽象了这些共性。另外，它定义了一组Callback，Activity通过实现这些Callback被调用来处理事件。注意要和在WMS中的窗口区分开来，WMS中的窗口更像是App端的View。<br><strong>PhoneWindow</strong>：PhoneWindow是Window类的唯一实现，至少目前是。这样的设计下如果要加其它平台的Window类型更加方便。每个Activity会有一个PhoneWindow，在attach到ActivityThread时创建，保存在mWindow成员中。<br><strong>Context</strong>：运行上下文，Activity和Service本质上都是一个Context，Context包含了它们作为运行实体的共性，如启动Activity，绑定Service，处理Broadcast和Receiver等等。注意Application也会有Context。Activity的Context是对应Activity的，Activity被杀掉（比如转屏后）后就变了。所以要注意如果有生命周期很长的对象有对Activity的Context的引用的话，转屏、返回这种会引起Activity销毁的操作都会引起内存泄露。而Application的Context生命周期是和App进程一致的。  </p>
</blockquote>
<h3 id="6-消息机制MessageQueue原理"><a href="#6-消息机制MessageQueue原理" class="headerlink" title="6 消息机制MessageQueue原理"></a>6 消息机制MessageQueue原理</h3><p>这部分内容想等抽个时间整理篇博客出来，下面只是我阅读源码过程中的一些笔记，还没组织语言，大体上记录了 MessageQueue 往队列里插消息和取消息的流程分析：  </p>
<p><strong>插入消息 enqueueMessage()</strong>：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-bb7dbda22cdabc1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="enqueueMessage.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-133c206b28b6601b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="enqueueMessage.png"></p>
<p>也就是说，我们自己通过Handler发送的Message的Target是绝对不会为空的，因为Handler内部会自动将Message的Target设置为Handler自己。然后消息队列其实是根据when来排队的。  </p>
<p><strong>读取消息 next()</strong>：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-b95df636e3f77f27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="next.png"></p>
<p>读操作要么返回该执行的message，要么就进入阻塞。当返回Null时表示当前Lopper已被关闭，如果是主线程，那么就意味着程序退出了。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-c3a530f62d4733ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="next.png">  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-b1ba568f41c0fe69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="next.png"></p>
<p>读取操作本身会伴随着删除操作，读操作会有阻塞，原理好像是通过Linux的epoll机制，但还不懂。按道理next()是会按照消息队列已排好序的取下一个Message，但如果碰到有同步屏障Message时，则后面所有同步的消息都不会取，只会取异步的消息，直到该同步屏障被移除。</p>
<h3 id="7-startActivityForResult-失效问题"><a href="#7-startActivityForResult-失效问题" class="headerlink" title="7.startActivityForResult()失效问题"></a>7.startActivityForResult()失效问题</h3><p>如果项目里的 Activity 有 singleTask 模式的话，而且又用到这个方法的话，那也许有可能你就碰到了这个问题，下面这篇博客里把这个问题讲解得很清楚了：<br><a href="https://www.jianshu.com/p/2a9fcf3c11e4" target="_blank" rel="noopener">我打赌你一定没搞明白的Activity启动模式</a></p>
<h3 id="8-ThreadLocal-原理"><a href="#8-ThreadLocal-原理" class="headerlink" title="8.ThreadLocal 原理"></a>8.ThreadLocal 原理</h3><p>我们知道，在 new 一个 Handler 的时候，Handler 会和当前的线程的消息队列绑定，而每个线程都可以有自己单独的消息队列，互不影响，那么它的原理其实是通过 ThreadLocal 实现的，关于这部分内容后期也想单独抽一篇博客来记录下，下面的内容也是简单的记录下 set() 和 get() 方法：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-916c02ddedd03128.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="get.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-4d07d12c45240b9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="getMap.png">  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-4019437e50b3c2a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="threadLocal.png"></p>
<p>所以，get() 方法会先获取线程的一个成员变量 threadLocals，这个变量类型是 ThreadLocal的内部类 ThreadLocalMap 对象，内部有一个 table 数组用于存放数据。所以即使是在不同的线程中使用同一个ThreadLocal对象的get() 方法来获取数据，内部其实只会到当前线程的数组里去取相应数据，所以才能做到线程之间互不影响的存取数据，不是当前线程自然拿不到当前线程的成员变量threadLocals，也就拿不到数据了。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-37145bc39e368a1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="set.png"></p>
<p>set() 方法同理。  </p>
<p>当然，ThreadLocal    Map 内部 get()，和 set() 方法并不简单，set() 方法存放每个 value 时，都会将当前的 ThreadLocal 实例作为 key 值来绑定value，也就是说如果使用不同的 ThreadLocal 对同一个线程中做get(),set() 操作的话，虽然操作的是同一个 table 数组，但即使get()，set()的key值一致，实际上获取的数据是相互独立的。</p>
<hr>
<p>虽然还有其他一些七七八八的小笔记，但这里就不列出来了，这次梳理的目的一是重新过一遍这一年来所做的笔记，权当复习；二是将这些零散的笔记稍微归类整理一下，毕竟新的一年也还是会记很多笔记，省得到时更乱；三是分享在网上，方便自己后面查阅也希望可以帮助有需要的大伙。 </p>
<p>新的一年来了，大伙一起加油吧~  </p>
]]></content>
      <categories>
        <category>谈人生</category>
      </categories>
  </entry>
  <entry>
    <title>【Andorid源码解析】View.post() 到底干了啥</title>
    <url>/2017/12/16/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E3%80%90Andorid%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91View-post()-%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E5%95%A5/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</strong>  </p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-11b143b4893d0c0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View.post示例.png"></p>
<p>emmm，大伙都知道，子线程是不能进行 UI 操作的，或者很多场景下，一些操作需要延迟执行，这些都可以通过 Handler 来解决。但说实话，实在是太懒了，总感觉写 Handler 太麻烦了，一不小心又很容易写出内存泄漏的代码来，所以为了偷懒，我就经常用 <strong>View.post() or View.postDelay()</strong> 来代替 Handler 使用。  </p>
<p>但用多了，总有点心虚，<strong>View.post()</strong> 会不会有什么隐藏的问题？所以趁有点空余时间，这段时间就来梳理一下，<strong>View.post()</strong> 原理到底是什么，内部都做了啥事。  </p>
<h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><p>开始看源码前，先提几个问题，带着问题去看源码应该会比较有效率，防止阅读源码过程中，陷得太深，跟得太偏了。  </p>
<p><strong>Q1: 为什么 View.post() 的操作是可以对 UI 进行操作的呢，即使是在子线程中调用 View.post()？</strong>  </p>
<p><strong>Q2：网上都说 View.post() 中的操作执行时，View 的宽高已经计算完毕，所以经常看见在 Activity 的 onCreate() 里调用 View.post() 来解决获取 View 宽高为0的问题，为什么可以这样做呢？</strong>  </p>
<p><strong>Q3：用 View.postDelay() 有可能导致内存泄漏么？</strong>  </p>
<p>ps:本篇分析的源码基于 <strong>andoird-25</strong> 版本，版本不一样源码可能有些区别，大伙自己过源码时可以注意一下。另，下面分析过程有点长，慢慢看哈。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>好了，就带着这几个问题来跟着源码走吧。其实，这些问题大伙心里应该都有数了，看源码也就是为了验证心里的想法。第一个问题，之所以可以对 UI 进行操作，那内部肯定也是通过 Handler 来实现了，所以看源码的时候就可以看看内部是如何对 Handler 进行封装的。而至于剩下的问题，那就在看源码过程中顺带看看能否找到答案吧。  </p>
<h2 id="View-post"><a href="#View-post" class="headerlink" title="View.post()"></a>View.post()</h2><p><img src="http://upload-images.jianshu.io/upload_images/1924341-728672bc93262ba8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View.post.png"></p>
<p>View.post() 方法很简单，代码很少。那我们就一行行的来看。  </p>
<p>如果 <strong>mAttachInfo</strong> 不为空，那就调用 <strong>mAttachInfo.mHanlder.post()</strong> 方法，如果为空，则调用 <strong>getRunQueue().post()</strong> 方法。  </p>
<p>那就找一下，<strong>mAttachInfo</strong> 是什么时候赋值的，可以借助 AS 的 <code>Ctrl + F</code> 查找功能，过滤一下 <code>mAttachInfo =</code>，注意 <code>=</code> 号后面还有一个空格，否则你查找的时候会发现全文有两百多处匹配到。我们只关注它是什么时候赋值的，使用的场景就不管了，所以过滤条件可以细一点。这样一来，全文就只有两处匹配：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-53c96cd0e2f72468.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatchAttachedToWindow.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-9bc9b67b6a242837.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatchDetachedFromWindow.png"></p>
<p>一处赋值，一处置空，刚好又是在对应的一个生命周期里： </p>
<ol>
<li><strong>dispatchAttachedToWindow() 下文简称 attachedToWindow</strong>  </li>
<li><strong>dispatchDetachedFromWindow() 下文简称 detachedFromWindow</strong>。  </li>
</ol>
<p>所以，如果 <strong>mAttachInfo</strong> 不为空的时候，走的就是 Handler 的 post()，也就是 View.post() 在这种场景下，实际上就是调用的 Handler.post()，接下去就是搞清楚一点，这个 Handler 是哪里的 Handler，在哪里初始化等等，但这点可以先暂时放一边，因为 <strong>mAttachInfo</strong> 是在 <strong>attachedToWindow</strong> 时才赋值的，所以接下去关键的一点是搞懂 <strong>attachedToWindow</strong> 到 <strong>detachedFromWindow</strong> 这个生命周期分别在什么时候在哪里被调用了。  </p>
<p>虽然我们现在还不清楚，<strong>attachedToWindow</strong> 到底是什么时候被调用的，但看到这里我们至少清楚一点，在 Activity 的 onCreate() 期间，这个 View 的 <strong>attachedToWindow</strong> 应该是还没有被调用，也就是 <strong>mAttachInfo</strong> 这时候还是为空，但我们在 onCreate() 里执行 <strong>View.post()</strong> 里的操作仍然可以保证是在 View 宽高计算完毕的，也就是开头的问题 Q2，那么这点的原理显然就是在另一个 return 那边的方法里了：<strong>getRunQueue().post()</strong>。  </p>
<p>那么，我们就先解决 Q2 吧，为什么 <strong>View.post()</strong> 可以保证操作是在 View 宽高计算完毕之后呢？跟进 <strong>getRunQueue()</strong> 看看：  </p>
<h2 id="getRunQueue-post"><a href="#getRunQueue-post" class="headerlink" title="getRunQueue().post()"></a>getRunQueue().post()</h2><p><img src="http://upload-images.jianshu.io/upload_images/1924341-439e91604d6a1132.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="getRunQueue.png"></p>
<p>所以调用的其实是 HandlerActionQueue.post() 方法，那么我们再继续跟进去看看：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-0fa077e45461c89d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HandlerActionQueue.png"></p>
<p>post(Runnable) 方法内部调用了 postDelayed(Runnable, long)，postDelayed() 内部则是将 Runnable 和 long 作为参数创建一个 HandlerAction 对象，然后添加到 mActions 数组里。下面先看看 HandlerAction：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-5dda0387f6ca5d2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HandlerAction.png"></p>
<p>很简单的数据结构，就一个 Runnable 成员变量和一个 long 成员变量。这个类作用可以理解为用于包装 <strong>View.post(Runnable)</strong> 传入的 Runnable 操作的，当然因为还有 <strong>View.postDelay()</strong> ，所以就还需要一个 long 类型的变量来保存延迟的时间了，这样一来这个数据结构就不难理解了吧。    </p>
<p>所以，我们调用 <strong>View.post(Runnable)</strong> 传进去的 Runnable 操作，在传到 HandlerActionQueue 里会先经过 HandlerAction 包装一下，然后再缓存起来。至于缓存的原理，HandlerActionQueue 是通过一个默认大小为4的数组保存这些 Runnable 操作的，当然，如果数组不够用时，就会通过 GrowingArrayUtils 来扩充数组，具体算法就不继续看下去了，不然越来越偏。  </p>
<p><strong>到这里，我们先来梳理下:</strong>  </p>
<p>当我们在 Activity 的 onCreate() 里执行 <strong>View.post(Runnable)</strong> 时，因为这时候 View 还没有 <strong>attachedToWindow</strong>，所以这些 Runnable 操作其实并没有被执行，而是先通过 HandlerActionQueue 缓存起来。  </p>
<p>那么到什么时候这些 Runnable 才会被执行呢？我们可以看看 HandlerActionQueue 这个类，它的代码不多，里面有个 <strong>executeActions()</strong> 方法，看命名就知道，这方法是用来执行这些被缓存起来的 Runnable 操作的：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-0ee2916520c4c600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="executeActions.png"></p>
<p>哇，看到重量级的人物了：<strong>Handler</strong>。看来被缓存起来没有执行的 Runnable 最后也还是通过 Hnadler 来执行的。那么，这个 Handler 又是哪里的呢？看来关键点还是这个方法在哪里被调用了，那就找找看：   </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-08af749ee07212dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查找调用executeActions的地方.png"></p>
<p>借助 AS 的 <code>Ctrl + Alt + F7</code> 快捷键，可以查找 SDK 里的某个方法在哪些地方被调用了。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-d300abbebda51577.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mRunQueue.executeActions.png"></p>
<p>很好，找到了，而且只找到这个地方。其实，这个快捷键有时并没有办法找到一些方法被调用的地方，这也是源码阅读过程中令人头疼的一点，因为没法找到这些方法到底在哪些地方被调用了，所以很难把流程梳理下来。如果方法是私有的，那很好办，就用 <code>Ctrl + F</code> 在这个类里找一下就可以，如果匹配结果太多，那就像开头那样把过滤条件详细一点。如果方法不是私有的，那真的就很难办了，这也是一开始找到 <strong>dispatchAttachedToWindow()</strong> 后为什么不继续跟踪下去转而来分析Q2：<strong>getRunQueue()</strong> 的原因，因为用 AS 找不到 <strong>dispatchAttachedToWindow()</strong> 到底在哪些地方被谁调用了。哇，好像又扯远了，回归正题回归正题。  </p>
<p>emmm，看来这里也绕回来了，<strong>dispatchAttachedToWindow()</strong> 看来是个关键的节点。  </p>
<p><strong>那到这里，我们再次来梳理一下：</strong>  </p>
<p>我们使用 <strong>View.post()</strong> 时，其实内部它自己分了两种情况处理，当 View 还没有 <strong>attachedToWindow</strong> 时，通过 <strong>View.post(Runnable)</strong> 传进来的 Runnable 操作都先被缓存在 HandlerActionQueue，然后等 View 的 <strong>dispatchAttachedToWindow()</strong> 被调用时，就通过 <strong>mAttachInfo.mHandler</strong> 来执行这些被缓存起来的 Runnable 操作。从这以后到 View 被 <strong>detachedFromWindow</strong> 这段期间，如果再次调用 <strong>View.post(Runnable)</strong> 的话，那么这些 Runnable 不用再缓存了，而是直接交给 <strong>mAttachInfo.mHanlder</strong> 来执行。  </p>
<p>以上，就是到目前我们所能得知的信息。这样一来，Q2 是不是渐渐有一些头绪了：<strong>View.post(Runnable)</strong> 的操作之所以可以保证肯定是在 View 宽高计算完毕之后才执行的，是因为这些 Runnable 操作只有在 View 的 <strong>attachedToWindow</strong> 到 <strong>detachedFromWiondow</strong> 这期间才会被执行。  </p>
<p>那么，接下去就还剩两个关键点需要搞清楚了:   </p>
<ol>
<li><strong>dispatchAttachedToWindow() 是什么时候被调用的？</strong> </li>
<li><strong>mAttachInfo 是在哪里初始化的？</strong>  </li>
</ol>
<h2 id="dispatchAttachedToWindow-amp-mAttachInfo"><a href="#dispatchAttachedToWindow-amp-mAttachInfo" class="headerlink" title="dispatchAttachedToWindow() &amp; mAttachInfo"></a>dispatchAttachedToWindow() &amp; mAttachInfo</h2><p>只借助 AS 的话，很难找到 <strong>dispatchAttachedToWindow()</strong> 到底在哪些地方被调用。所以，到这里，我又借助了 Source Insight 软件。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-65607c3ffd68e29d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sourceInsight查找dispatchAttachedToWindow.png"></p>
<p>很棒！找到了四个被调用的地方，三个在 ViewGroup 里，一个在 ViewRootImpl.performTraversals() 里。找到了就好，接下去继续用 AS 来分析吧，Source Insight 用不习惯，不过分析源码时确实可以结合这两个软件。    </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-c82e3b6e1f6612a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl.performTraversals.png"></p>
<p>哇，懵逼，完全懵逼。我就想看个 <strong>View.post()</strong>，结果跟着跟着，跟到这里来了。ViewRootImpl 我在分析<a href="http://www.jianshu.com/p/2f28386706a0" target="_blank" rel="noopener">Android KeyEvent 点击事件分发处理流程</a>时短暂接触过，但这次显然比上次还需要更深入去接触，哎，力不从心啊。  </p>
<p>我只能跟大伙肯定的是，mView 是 Activity 的 DecorView。咦~，等等，这样看来 ViewRootImpl 是调用的 DecorView 的 <strong>dispatchAttachedToWindow()</strong> ，但我们在使用 <strong>View.post()</strong> 时，这个 View 可以是任意 View，并不是非得用 DecorView 吧。哈哈哈，这是不是代表着我们找错地方了？不管了，我们就去其他三个被调用的地方： ViewGroup 里看看吧：   </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-3395ff17de45f570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewGroup.addViewInner.png"></p>
<p>addViewInner() 是 ViewGroup 在添加子 View 时的内部逻辑，也就是说当 ViewGroup addView() 时，如果 mAttachInfo 不为空，就都会去调用子 View 的 dispatchAttachedToWindow()，并将自己的 mAttachInfo 传进去。还记得 View 的 dispatchAttachedToWindow() 这个方法么：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-8718cc9b8c7877b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View.dispatachAttachedToWindow.png"></p>
<p>mAttachInfo 唯一被赋值的地方也就是在这里，那么也就是说，子 View 的 mAttachInfo 其实跟父控件 ViewGroup 里的 mAttachInfo 是同一个的。那么，关键点还是这个 <strong>mAttachInfo</strong> 什么时候才不为空，也就是说 <strong>ViewGroup 在 addViewInner() 时，传进去的 mAttachInfo 是在哪被赋值的呢</strong>？我们来找找看：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-8a4ca5fd32da1b1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查找ViewGroup的mAttachInfo.png"></p>
<p>咦，利用 AS 的 <code>Ctrl + 左键</code> 怎么找不到 mAttachInfo 被定义的地方呢，不管了，那我们用 <code>Ctrl + F</code> 搜索一下在 ViewGroup 类里 mAttachInfo 被赋值的地方好了：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-0320935717cf131c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewGroup里查找mAttachInfo被赋值的地方.png"></p>
<p>咦，怎么一个地方也没有。难道说，这个 mAttachInfo 是父类 View 定义的变量么，既然 AS 找不到，我们换 Source Insight 试试：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-3e3b441afb817714.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用SourceInsight查找mAttachInfo.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-8d5d5a95c882ba6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View.mAttachInfo.png"></p>
<p>还真的是，ViewGroup 是继承的 View，并且处于同一个包里，所以可以直接使用该变量，那这样一来，我们岂不是又绕回来了。前面说过，<strong>dispatchAttachedToWindow()</strong> 在 ViewGroup 里有三处调用的地方，既然 addViewInner() 这里的看不出什么，那去另外两个地方看看：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-d55e4478f13c55e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewGroup.dispatchAttachedToWindow.png"></p>
<p>剩下的两个地方就都是在 ViewGroup 重写的 dispatchAttachedToWindow() 方法里了，这代码也很好理解，在该方法被调用的时候，先执行 super 也就是 View 的 dispatchAttachedToWindow() 方法，还没忘记吧，mAttachInfo 就是在这里被赋值的。然后再遍历子 View，分别调用子 View 的 dispatchAttachedToWindow() 方法，并将 mAttachInfo 作为参数传递进去，这样一来，子 View 的 mAttachInfo 也都被赋值了。  </p>
<p>但这样一来，我们就绕进死胡同了。  </p>
<p><strong>我们还是先来梳理一下吧：</strong>  </p>
<p>目前，我们知道，<strong>View.post(Runnable)</strong> 的这些 Runnable 操作，在 View 被 <strong>attachedToWindow</strong> 之前会先缓存下来，然后在 <strong>dispatchAttachedToWindow()</strong> 被调用时，就将这些缓存下来的 Runnable 通过 <strong>mAttachInfo</strong> 的 mHandler 来执行。在这之后再调用 <strong>View.post(Runnable)</strong> 的话，这些 Runnable 操作就不用再被缓存了，而是直接交由 mAttachInfo 的 mHandler 来执行。  </p>
<p>所以，我们得搞清楚 <strong>dispatchAttachedToWindow()</strong> 在什么时候被调用，以及 <strong>mAttachInfo</strong> 是在哪被初始化的，因为需要知道它的变量如 mHandler 都是些什么以及验证 mHandler 执行这些 Runnable 操作是在 measure 之后的，这样才能保证此时的宽高不为0。  </p>
<p>然后，我们在跟踪 <strong>dispatchAttachedToWindow()</strong> 被调用的地方时，跟到了 ViewGroup 的 addViewInner() 里。在这里我们得到的信息是如果 <strong>mAttachInfo</strong> 不为空时，会直接调用子 View 的 <strong>dispatchAttachedToWindow()</strong>，这样新 add 进来的子 View 的 <strong>mAttachInfo</strong> 就会被赋值了。但 ViewGroup 的 <strong>mAttachInfo</strong> 是父类 View 的变量，所以为不为空的关键还是回到了 <strong>dispatchAttachedToWindow()</strong> 被调用的时机。  </p>
<p>我们还跟到了 ViewGroup 重写的 <strong>dispatchAttachedToWindow()</strong> 方法里，但显然，ViewGroup 重写这个方法只是为了将 attachedToWindow 这个事件通知给它所有的子 View。  </p>
<p>所以，最后，我们能得到的结论就是，我们还得再回去 ViewRootImpl 里，<strong>dispatchAttachedToWindow()</strong> 被调用的地方，除了 ViewRootImpl，我们都分析过了，得不到什么信息，只剩最后 ViewRootImpl 这里了，所以关键点肯定在这里。看来这次，不行也得上了。  </p>
<h2 id="ViewRootImpl-performTraversals"><a href="#ViewRootImpl-performTraversals" class="headerlink" title="ViewRootImpl.performTraversals()"></a>ViewRootImpl.performTraversals()</h2><p><img src="http://upload-images.jianshu.io/upload_images/1924341-2b17524b6dfa389b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl.performTraversals.png"></p>
<p>这方法代码有八百多行！！不过，我们只关注我们需要的点就行，这样一省略无关代码来看，是不是感觉代码就简单得多了。  </p>
<p>mFirst 初始化为 true，全文只有一处赋值，所以 if(mFirst) 块里的代码只会执行一次。我对 ViewRootImpl 不是很懂，performTraversals() 这个方法应该是通知 Activity 的 View 树开始测量、布局、绘制。而 DevorView 是 Activity 视图的根布局、View 树的起点，它继承 FrameLayout，所以也是个 ViewGroup，而我们之前对 ViewGroup 的 <strong>dispatchAttachedToWindow()</strong> 分析过了吧，在这个方法里会将 mAttachInfo 传给所有子 View。也就是说，在 Activity 首次进行 View 树的遍历绘制时，ViewRootImpl 会将自己的 <strong>mAttachInfo</strong> 通过根布局 DecorView 传递给所有的子 View 。  </p>
<p>那么，我们就来看看 ViewRootImpl 的 <strong>mAttachInfo</strong> 什么时候初始化的吧：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-e658c8824fe873e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewRootImpl构造函数.png"></p>
<p>在构造函数里对 mAttachInfo 进行初始化，传入了很多参数，我们关注的应该是 mHandler 这个变量，所以看看这个变量定义：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-53c74d20d7d8f735.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mHandler.png"></p>
<p>终于找到 <strong>new Handler()</strong> 的地方了，至于这个自定义的 Handler 类做了啥，我们不关心，反正通过 post() 方式执行的操作跟它自定义的东西也没有多大关系。我们关心的是在哪 new 了这个 Handler。<strong>因为每个 Handler 在 new 的时候都会绑定一个 Looper，这里 new 的时候是无参构造函数，那默认绑定的就是当前线程的 Looper，而这句 new 代码是在主线程中执行的，所以这个 Handler 绑定的也就是主线程的 Looper</strong>。至于这些的原理，就涉及到 Handler 的源码和 ThreadLocal 的原理了，就不继续跟进了，太偏了，大伙清楚结论这点就好。    </p>
<p><strong>这也就是为什么 View.post(Runnable) 的操作可以更新 UI 的原因，因为这些 Runnable 操作都通过 ViewRootImpl 的 mHandler 切到主线程来执行了。</strong>  </p>
<p>这样 Q1 就搞定了，终于搞定了一个问题，不容易啊，本来以为很简单的来着。  </p>
<p>跟到 ViewRootImpl 这里应该就可以停住了。至于 ViewRootImpl 跟 Activity 有什么关系、什么时候被实例化的、跟 DecroView 如何绑定的就不跟进了，因为我也还不是很懂，感兴趣的可以自己去看看，我在末尾会给一些参考博客。  </p>
<p>至此，我们清楚了 <strong>mAttachInfo</strong> 的由来，也知道了 <strong>mAttachInfo.mHandler</strong>，还知道在 Activity 首次遍历 View 树进行测量、绘制时会通过 DecorView 的 <strong>dispatchAttachedToWindow()</strong> 将 ViewRootImpl 的 <strong>mAttachInfo</strong> 传递给所有子 View，并通知所有调用 <strong>View.post(Runnable)</strong> 被缓存起来的 Runnable 操作可以执行了。  </p>
<p>但不知道大伙会不会跟我一样还有一点疑问：<strong>看网上对 ViewRootImpl.performTraversals() 的分析：遍历 View 树进行测量、布局、绘制操作的代码显然是在调用了 dispatchAttachedToWindow() 之后才执行，那这样一来是如何保证 View.post(Runnable) 的 Runnable 操作可以获取到 View 的宽高呢？明明测量的代码 performMeasure() 是在 dispatchAttachedToWindow() 后面才执行。</strong>  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-155a2652da011069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="performTraversals.png"></p>
<p>我在这里卡了很久，一直没想明白。我甚至以为是 PhoneWindow 在加载 layout 布局到 DecorView 时就进行了测量的操作，所以一直跟，跟到 LayoutInflater.inflate()，跟到了 ViewGroup.addView()，最后发现跟测量有关的操作最终都又绕回到 ViewRootImpl 中去了。  </p>
<p>最后，感谢<a href="http://blog.csdn.net/scnuxisan225/article/details/49815269" target="_blank" rel="noopener">通过View.post()获取View的宽高引发的两个问题</a>这篇博客的作者，解答了我的疑问。  </p>
<p>原来是自己火候不够，对 Android 的消息机制还不大理解，这篇博客前前后后写了一两个礼拜，就是在不断查缺补漏，学习、理解相关的知识点。  </p>
<p>大概的来讲，就是我们的 app 都是基于消息驱动机制来运行的，主线程的 Looper 会无限的循环，不断的从 MessageQueue 里取出 Message 来执行，当一个 Message 执行完后才会去取下一个 Message 来执行。而 Handler 则是用于将 Message 发送到 MessageQueue 里，等轮到 Message 执行时，又通过 Handler 发送到 Target 去执行，等执行完再取下一个 Message，如此循环下去。  </p>
<p><strong>清楚了这点后，我们再回过头来看看：</strong>  </p>
<p>performTraversals() 会先执行 dispatchAttachedToWindow()，这时候所有子 View 通过 <strong>View.post(Runnable)</strong> 缓存起来的 Runnable 操作就都会通过 mAttachInfo.mHandler 的 post() 方法将这些 Runnable 封装到 Message 里发送到 MessageQueue 里。mHandler 我们上面也分析过了，绑定的是主线程的 Looper，所以这些 Runnable 其实都是发送到主线程的 MessageQueue 里排队，等待执行。然后 performTraversals() 继续往下工作，相继执行 performMeasure()，performLayout() 等操作。等全部执行完后，表示这个 Message 已经处理完毕，所以 Looper 才会去取下一个 Message，这时候，才有可能轮到这些 Runnable 执行。所以，这些 Runnable 操作也就肯定会在 performMeasure() 操作之后才执行，宽高也就可以获取到了。画张图，帮助理解一下：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-143abd8e262ac64f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler消息机制.png"></p>
<p>哇，Q2的问题终于也搞定了，也不容易啊。本篇也算是结束了。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析了半天，最后我们来稍微小结一下：  </p>
<ol>
<li><p><strong>View.post(Runnable) 内部会自动分两种情况处理，当 View 还没 attachedToWindow 时，会先将这些 Runnable 操作缓存下来；否则就直接通过 mAttachInfo.mHandler 将这些 Runnable 操作 post 到主线程的 MessageQueue 中等待执行。</strong>  </p>
</li>
<li><p><strong>如果 View.post(Runnable) 的 Runnable 操作被缓存下来了，那么这些操作将会在 dispatchAttachedToWindow() 被回调时，通过 mAttachInfo.mHandler.post() 发送到主线程的 MessageQueue 中等待执行。</strong>  </p>
</li>
<li><p><strong>mAttachInfo 是 ViewRootImpl 的成员变量，在构造函数中初始化，Activity View 树里所有的子 View 中的 mAttachInfo 都是 ViewRootImpl.mAttachInfo 的引用。</strong>  </p>
</li>
<li><p><strong>mAttachInfo.mHandler 也是 ViewRootImpl 中的成员变量，在声明时就初始化了，所以这个 mHandler 绑定的是主线程的 Looper，所以 View.post() 的操作都会发送到主线程中执行，那么也就支持 UI 操作了。</strong>  </p>
</li>
<li><p><strong>dispatchAttachedToWindow() 被调用的时机是在 ViewRootImol 的 performTraversals() 中，该方法会进行 View 树的测量、布局、绘制三大流程的操作。</strong>  </p>
</li>
<li><p><strong>Handler 消息机制通常情况下是一个 Message 执行完后才去取下一个 Message 来执行（异步 Message 还没接触），所以 View.post(Runnable) 中的 Runnable 操作肯定会在 performMeaure() 之后才执行，所以此时可以获取到 View 的宽高。</strong>  </p>
</li>
</ol>
<p>好了，就到这里了。至于开头所提的问题，前两个已经在上面的分析过程以及总结里都解答了。而至于剩下的问题，这里就稍微提一下：  </p>
<p>使用 <strong>View.post()</strong>，还是有可能会造成内存泄漏的，Handler 会造成内存泄漏的原因是由于内部类持有外部的引用，如果任务是延迟的，就会造成外部类无法被回收。而根据我们的分析，mAttachInfo.mHandler 只是 ViewRootImpl 一个内部类的实例，所以使用不当还是有可能会造成内存泄漏的。  </p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>虽然只是过一下 View.post() 的源码，但真正过下去才发现，要理解清楚，还得理解 Handler 的消息机制、ViewRootImpl 的作用、ViewRootImpl 和 Activity 的关系，何时绑定等等。所以，需要学的还好多，也感谢各个前辈大神费心整理的博客，下面列一些供大伙参考：  </p>
<ol>
<li><p><a href="http://blog.csdn.net/scnuxisan225/article/details/49815269" target="_blank" rel="noopener">scnuxisan225#通过View.post()获取View的宽高引发的两个问题</a>  </p>
</li>
<li><p><a href="http://blog.csdn.net/kc58236582/article/details/52088224" target="_blank" rel="noopener">kc专栏#Activity WMS ViewRootImpl三者关系</a>  </p>
</li>
<li><p><a href="http://blog.csdn.net/feiduclear_up/article/details/46772477" target="_blank" rel="noopener">废墟的树#从ViewRootImpl类分析View绘制的流程</a>  </p>
</li>
<li><p><a href="http://blog.csdn.net/qian520ao/article/details/78262289?locationNum=2&fps=1" target="_blank" rel="noopener">凶残的程序员#Android 消息机制——你真的了解Handler？</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android源码解析</category>
      </categories>
  </entry>
  <entry>
    <title>Activity 切换动画---点击哪里从哪放大</title>
    <url>/2017/11/30/Android-Tv/Activity-%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB---%E7%82%B9%E5%87%BB%E5%93%AA%E9%87%8C%E4%BB%8E%E5%93%AA%E6%94%BE%E5%A4%A7/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 安卓巴士Android开发者门户 独家发布</strong>  </p>
</blockquote>
<p>emmmm，这次来梳理一下 Activity 切换动画的研究。首先，老规矩，看一下效果图：  </p>
<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="http://upload-images.jianshu.io/upload_images/1924341-48ee346a06f201d3.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图.gif">  </p>
<p>这次要实现的动画效果就是类似于上图那样，<strong>点击某个 view，就从那个 view 展开下个 Activity，Activity 退出时原路返回，即缩放到点击的那个 view</strong>。  </p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>emmm，如果要你来做这样一个效果，你会怎么做呢？  </p>
<p>我们就一步步的来思考。  </p>
<p>首先来说说，要给 Activity 的切换写动画的话，可以通过什么来实现？也许这种场景比较少，但相信大家多多少少知道一些，嗯，如果你还是不大清楚的话，可以先看看这篇<a href="http://blog.csdn.net/qq_23547831/article/details/51821159" target="_blank" rel="noopener">实现Activity跳转动画的五种方式</a>，这个大神总结了几种方式，大概过一下有哪些方案即可，我也没深入阅读，感兴趣的话再慢慢看就可以了。  </p>
<p>这里就大概总结一下几种方式：  </p>
<blockquote>
<p>1.使用 style 的方式定义 Activity 的切换动画<br>2.使用 overridePendingTransition 方法实现 Activity 跳转动画<br>3.使用 ActivityOptions 切换动画实现 Activity 跳转动画(部分动画可支持到 api &gt;= 16)<br>4.使用 ActivityOptions 动画共享组件的方式实现跳转 Activity 动画(api &gt;= 21)  </p>
</blockquote>
<p>目前我了解的也大概就是以上几种方式，前两种使用方式很简单，只需要在 xml 中写相应的动画（滑进滑出动画、渐变动画、放大动画等），然后应用到相应的 activity 即可。而且还不需要考虑兼容低版本问题。  </p>
<pre><code>&lt;!--style方式--&gt;
&lt;item name=&quot;android:activityOpenEnterAnimation&quot;&gt;@anim/anim_activity_enter&lt;/item&gt;
&lt;item name=&quot;android:activityCloseExitAnimation&quot;&gt;@anim/anim_activity_exit&lt;/item&gt;

//代码方式
startActivity(intent)
overridePendingTransition(R.anim.anim_activity_enter, R.anim.anim_activity_exit);

//anim_activity_enter.xml 和 anim_activity_exit.xml 就是在 xml 中写动画</code></pre><p>上述两种方式使用很简单，效果也很好。<strong>缺点就是，不够灵活，只能实现 xml 写出的动画，即平移、渐变、缩放等基本动画的组合，无法实现炫酷的动画。</strong>  </p>
<p>所以，显然，我们开头效果图展示的动画，用这两种 xml 实现的动画方式并没有办法做到，因为<strong>放大动画的中心点位置是需要动态计算的</strong>。xml 中写缩放动画时，中心点只能是写死的。  </p>
<p>这样的话， <strong>style 的动画方案和 overridePendingTransition 的方案就只能先抛弃了</strong>，那么再继续看看其他的方案。  </p>
<p>ActivityOptions 动画实现方案应该是 Google 在 Android 5.0 之后推出 Material Design 系列里的一个转场动画方案。当然，Google 在后续也推出了一些内置动画，方便开发者直接使用。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-2f158d671ad7f419.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MaterialDesign动画示例.gif"></p>
<p>上图就是 Google 推出的 Material Design 规范的动画实现里一个示例。关于 Android 5.0 后的动画，网上一大堆相关文章，我也没在这方面里去深入研究过，所以这里就不打算介绍动画要怎么用（不然误导大家就不好了），感兴趣的可以自己去网上找找哈，这里就说下如果要实现开头介绍的动画，用这种方式可行不可行，可行的话又该怎么做。 </p>
<h2 id="Android-5-0-Activity-转场动画"><a href="#Android-5-0-Activity-转场动画" class="headerlink" title="Android 5.0+ Activity 转场动画"></a>Android 5.0+ Activity 转场动画</h2><p>开个小标题，因为觉得下面会讲比较多的东西。  </p>
<p>开头效果图的动画：新的 Activity 在点击的 View 的中心点放大。  </p>
<p>看上图 MaterialDesign 动画示例中，好像动画效果也是某个 View 展开下个 Activity？那这么说的话，这种方式应该就是可行的了？  </p>
<p>对 5.0+ 动画有所了解的话，示例中的动画应该有个名称叫：<strong>共享元素切换动画</strong>。意思就是字面上说的，两个 Activity 切换，可以设置它们的共享元素，也就是可以让上个界面的某个 View 在下个界面上做动画的一种效果。  </p>
<p>既然这样，我们就先来看看 5.0+ 动画，用代码怎么写。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-0b5886ad9c85137b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.0后切场动画调用.png">  </p>
<p>那些动画要怎么实现的我们就不看了，直接看怎么使用。上图的代码是个例子，如果要使用 5.0+ 的 Activity 转场动画，那就不能再继续使用 startActivity(Intent intent) 了，而是要使用 startActivity(Intent intent, Bundle options) 这个方法了。而 options 参数要传入的就通过 ActivityOptions 类指定的一些转场动画了，Google 为我们封装了一些动画接口，我们就来看看它支持哪些转场。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-a88ab7ebf2dcefc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ActivityOptions动画接口列表.png">  </p>
<p>所以，下面就来讲讲 <strong>makeScaleUpAnimation()</strong> 放大动画和 <strong>makeSceneTransitionAnimation()</strong> 共享元素动画。因为好像只有这两个可以实现开头效果图展示的动画效果。  </p>
<p>对了，上上图中的 ActivityOptionsCompat 类作用的 ActivityOptions 一样，只是前者是 Google 为我们提供的一个兼容实现，因为这是 5.0+ 动画，那么在 5.0 以下的版本就不能使用了，所以 Google 提供了兼容处理，让有些动画可以支持更低版本，动画效果都一致，至于内部具体是怎么实现，有兴趣可以去看看。但也不是所有的动画都做到兼容处理的，像 ActivityOptions 提供的几种动画，基本都可以兼容，但共享元素动画就不行了。至于哪些动画可以兼容，哪些不行，打开 ActivityOptionsCompat 类就清楚了，这个类在 support v4包里，下面就贴张图看看：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-d7d7fd5e7df1a22d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ActivityOptionsCompat.png"></p>
<h3 id="makeScaleUpAnimation"><a href="#makeScaleUpAnimation" class="headerlink" title="makeScaleUpAnimation()"></a>makeScaleUpAnimation()</h3><p><img src="http://upload-images.jianshu.io/upload_images/1924341-11505ea33d501f89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="makeScaleUpAnimation.png">  </p>
<p>接口参数的作用都在上图里注释了，理解了之后有没有发现，这个接口实现的动画效果就是我们想要的！！从哪放大，宽高从多少开始放大都可以自己设定，完美是不是！</p>
<p><strong>不是的</strong>，还是别高兴太早了，这个接口确实可以实现点击哪个 View，就从哪个 View 放大的效果。但是返回呢，Activity 退出时要按原路缩小至点击的 View，这个要怎么做？是吧，找遍了所有接口都没有。  </p>
<p>不止这点，还有我们常见的 <strong>setDuration()</strong> 有找到么，<strong>setInterpolator()</strong> 有找到么？没有，都没有，也就是说如果要用这个接口做动画的话，动画的执行时间，还有插值器我们都没办法设置，那这肯定没法满足产品的需求啊，哪里有不修改执行时间和插值器的动画！<strong>所以，这个方案也抛弃</strong>。  </p>
<h3 id="makeSceneTransitionAnimation"><a href="#makeSceneTransitionAnimation" class="headerlink" title="makeSceneTransitionAnimation()"></a>makeSceneTransitionAnimation()</h3><p>共享元素动画就复杂多了，不管是我们要使用它的方式还是它内部做的事。总之，我对这个接触也不多，这里就大概概括一下使用的一些步骤：  </p>
<ol>
<li><p>需要对共享的元素设置 transitionName，在 xml 中设置 android:transitionName 或代码里调用 View.setTransitionName()。  </p>
</li>
<li><p>startActivity(Intent) 换成 startActivity(Intent intent, Bundle options)，options 需要通过 ActivityOptions.makeSceneTransitionAnimation() 设置。  </p>
</li>
</ol>
<p>优点和缺点一会再说，先看看效果：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-2fb8d1a9aba1c0bb.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="共享元素动画.gif"></p>
<p>效果貌似就是我们想要的，那我们就来说说这种方式的优缺点，然后再做决定。  </p>
<p><strong>优点：</strong>  </p>
<ol>
<li>进入和退出时的动画都是由内部实现了，我们只需要设置参数就行。  </li>
</ol>
<p><strong>缺点：</strong>  </p>
<ol>
<li><p>共享的元素需要设置相同的 transitionName，我们点击的 View 和打开的 Activity 是动态的，不确定性的。所以，如果对这些 View 都设置相同的 transitionName 不知道会不会有新的问题产生。  </p>
</li>
<li><p>新 Activity 的起始宽高和位置无法设置，默认位置是共享的 View，也可以理解成点击的 View，这点没问题。但起始宽高默认是点击 View 的大小，上面 gif 图演示可能效果不太好。也就是说，放大动画开始时，新 Activity 是从点击 View 的宽高作为起始放大至全屏，返回时从全屏缩小至点击 View 的宽高。上图中点击的 view 都很小，所以看不出什么，但在 Tv 应用的页面中，经常有那种特别大的 view，如果是这种情况，那动画就很难看了。  </p>
</li>
<li><p>第2点缺点也许可以自己继承 Transition 写动画来解决，但没研究过共享动画的原理，还不懂怎么修改。  </p>
</li>
<li><p>最大的缺点是只支持 api &gt;= 21 的。</p>
</li>
</ol>
<p>基于目前能力不够，不足以解决以上缺点所列问题，所以<strong>暂时抛弃该方案</strong>，但后期会利用时间来学习下 5.0+ 转场动画原理。  </p>
<p>emmm，这样一来，岂不是就没办法实现效果图所需要的动画了？别急，方案还是有的，继续往下看。  </p>
<h2 id="Github-开源库方案"><a href="#Github-开源库方案" class="headerlink" title="Github 开源库方案"></a>Github 开源库方案</h2><p>其实，Github 上有很多这种动画效果的开源库，我找了几个把项目下载下来看了下代码，发现有的人思路是这样的：  </p>
<blockquote>
<p>Activity 跳转时，先把当前界面截图，然后将这张图传给下个 Activity，然后下个 Activity 打开时将背景设置成上个界面截图传过来的图片，然后再对根布局做放大动画，动画结束后将背景取消掉。  </p>
<p>Activity 退出时有两种方案：  </p>
<p>方案一：将当前 Activity 背景设置成上个界面的截图（这需要对这张图片进行缓存处理，不然图片很大可能已经被回收了），然后对根布局做缩小动画，动画结束之后再执行真正的 finish() 操作。  </p>
<p>方案二：将当前 Activity 界面截图，然后传给新展示到界面的 Activity，然后做缩小动画。（这需要 Activity 有一个置于顶层的 View 来设置截图为背景，然后对这个 View 做动画。  </p>
</blockquote>
<h2 id="用-View-动画来实现-Activity-转场动画效果"><a href="#用-View-动画来实现-Activity-转场动画效果" class="headerlink" title="用 View 动画来实现 Activity 转场动画效果"></a>用 View 动画来实现 Activity 转场动画效果</h2><p><strong>（该集中注意力啦，亲爱的读者们，上面其实都是废话啦，就是我自己在做这个动画效果过程中的一些摸索阶段啦，跟本篇要讲的动画实现方案其实关系不大了，不想看废话的可以略过，但下面就是本篇要讲的 Activity 切换动画的实现方案了）</strong>  </p>
<p>受到了 Github 上大神开源库的启发，我在想，Activity 界面其实也就是个 View，那既然这样我要打开的 Activity 设置成透明的，然后对根布局做放大动画，这样不就行了？  </p>
<p>想到就做，先是在 style.xml 中设置透明：  </p>
<pre><code>&lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;</code></pre><p>然后实例化一个放大动画：  </p>
<pre><code>ScaleAnimation scaleAnimation = new ScaleAnimation(0.0f, 1.0f, 0.0f, 1.0f, x, y);</code></pre><p>宽高从 0 开始放大至全屏，x,y 是放大的中心点，这个可以根据点击的 View 来计算，先看看效果行不行，x,y 就先随便传个值。  </p>
<p>动画也有了，那需要找到 Activity 的根布局。想了下，这动画的代码要么是写在基类里，要么是写个专门的辅助类，不管怎样，代码都需要有共用性，那怎么用相同的代码找到所有不同 Activity 的根布局呢？  </p>
<p>规定一个相同的 id，然后设置到每个 Activity 布局文件的第一个 ViewGroup 里？—是可行，但太麻烦了，要改动的地方也太多了。  </p>
<p>别忘了，<strong>每个 Activity 最底层就是一个 DecorView，虽然这个 DecorView 没有 id，但我们可以通过 getWindow().getDecorView() 来获取到它的引用啊</strong>。  </p>
<p>再不然，<strong>我们 setContentLayout() 都是将自己写的布局文件设置到一个 FrameLayout 里，记得吧，这个 FrameLayout 是有 id 的，是 Window 的一个静态常量 ID_ANDROID_CONTENT</strong>, 所以我们可以通过下面方式来获取到：  </p>
<pre><code>View view = activity.findViewById(activity.getWindow().ID_ANDROID_CONTENT);
//View view = activity.getWindow().getDecorView();</code></pre><p>透明属性，动画，View 都有了，那接下去就是执行了，在哪里执行好呢，onCreate() 里或 onStart() 里应该都可以。那就先在 onCreate() 里执行试试看好了。  </p>
<p>噢，对了，很重要一点，<strong>别忘了，Activity 转场是有默认动画的，不同系统可能实现的不同，所以得把这个默认动画关掉</strong>，所以可以在 BaseActivity 里重写下 startActivity()，如下：  </p>
<pre><code>@Override
public void startActivity(Intent intent) {
    super.startActivity(intent);
    overridePendingTransition(0, 0);
}</code></pre><p>overridePendingTransition(0, 0) 传入 0 表示不执行切换动画，呈现出来的效果就是下个 Activity 瞬间就显示在屏幕上了，而我们又对下个 Activity 设置了宽高从 0 开始放大的效果，那么理想中实现的效果应该是：当前 Activity 呈现在界面上，然后下个 Activity 逐渐放大到覆盖住全屏。  </p>
<p>好，运行，看下效果：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-62a4b5795ee7cec5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity放大动画问题.png"></p>
<p>咦~，为什么周围会是黑色的呢，都设置了 windowBackground 是透明的了啊，emmm，上网查了下，发现还需要一个半透明属性 windowIsTranslucent，所以去 style.xml 中再加上：  </p>
<pre><code>&lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;
&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</code></pre><p>再运行试一下，看下效果：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-404a5dc4fb83aae3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity放大动画.png"></p>
<p>嗯，效果出来了。那就下去就是退出时的动画了。退出动画跟打开动画其实就是反过程，动画变成缩小动画：</p>
<pre><code>ScaleAnimation scaleAnimation = new ScaleAnimation(1.0f, 0.0f, 1.0f, 0.0f, x, y);</code></pre><p>之前从 0 开始放大，现在换成从全屏开始缩小，x,y 就保存在 intent 携带的数据里。那么也就只剩最后一个问题，缩小动画该什么时候执行呢？  </p>
<p>我们退出一个页面时一般都是用 finish() 的吧，既然这样，在基类里重写一下这个方法：  </p>
<pre><code>@Override
public void finish() {
    ActivityAnimationHelper.animScaleDown(this, new AbsAnimationListener() {
        @Override
        public void onAnimationEnd() {
            BaseActivity.super.finish();
        }
    });
}</code></pre><p>x,y 的计算，动画的实现、执行我都是写在一个辅助类里，然后在 BaseActivity 里调用。这个不重要，思想比较重要。我们重写了 finish()，然后去执行缩小动画，同样动画是应用在 Activity 的根布局，然后写一个动画进度的回调，但动画结束时再去调用 super.finish()。也就是说，但调用了 finish() 时，实际上 Activity 并没有 finish() 掉，而是先去执行缩小动画，动画执行完毕再真正的去执行 finish() 操作。  </p>
<p>至此，开头所展示的效果图的动画效果已经实现。  </p>
<p><strong>但你以为事情做完了么？不，填坑之路才刚开始！（哭丧脸）</strong>  </p>
<h3 id="优化之路，又名填坑之路"><a href="#优化之路，又名填坑之路" class="headerlink" title="优化之路，又名填坑之路"></a>优化之路，又名填坑之路</h3><p>我前面说过，这种方案只能算是一种暂时性的替代方案，知道我什么这么说么？因为这种方案实现是会碰到太多坑了。  </p>
<p><strong>1.动画的流畅性问题</strong>  </p>
<p>首先是动画的流畅性问题，本篇里演示的 gif 图之所以看起来还很流畅，是因为切换的两个 Activity 界面都太简单了，但界面布局复杂一点时，打开一个 Activity 界面的测量、布局、绘制以及我们在 onCreate() 里写的一些加载数据、网络请求操作跟放大动画都挤到一起去了，甚至网络请求回来后更新界面时动画都还有可能在执行中，这样动画的流畅性就更惨了。  </p>
<p>在优化时，找到一个大神的一篇文章：<a href="http://codethink.me/2015/06/21/a-new-implementation-of-activity-transition-animations/" target="_blank" rel="noopener">一种新的Activity转换动画实现方式</a>  </p>
<p>这篇文章里讲的实现原理正是本篇介绍的方案，而且讲得更详细，可以继续去这篇看一下，相信你对本篇介绍的方案会更理解。  </p>
<p>有一点不同的是，大神的放大动画的执行时机是在 onPreDraw() 时机开启的，如下：  </p>
<pre><code>view.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
    @Override
    public boolean onPreDraw() {
    view.getViewTreeObserver().removeOnPreDrawListener(this);
        if (view.getAnimation() == animation &amp;&amp; !animation.hasEnded()) {
          return false;
        }
         view.startAnimation(animation);
         return true;
     }
});</code></pre><p>emmm，说实话，这个回调第一次见，我也不大清楚它的回调时机是什么，作用是什么，网上的解释也摸棱两可，没看明白，待后续有时间自己看看源码好了。  </p>
<p>但我可以跟你们肯定的是，我看了一部分 5.0+ 动画源码，它内部也是在一个 Activity 的 onStart() 方法里注册了 onPreDraw() 回调监听，然后在回调时执行 5.0+ 的动画。但它内部做的事，远不止这些，实在是太多了，估计是进行的一些优化操作，我目前是还没有能力去搞懂。<br>但我们动画执行的时机是需要换一下了，想一下也知道，在 onCreate() 里做动画，听着就感觉有点奇怪。既然大神，还有 Google 官方都是在 onPreDraw() 里执行，那我们当然可以模仿学习。  </p>
<p>看 5.0+ 源码过程中，发现它在动画开始和结束前会调用一个 ViewGroup 的 suppressLayout() 方法，这个方法是隐藏的：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-a7a7aed7e16f2663.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="suppressLayout.png"></p>
<p>这是一个隐藏的方法，我们要调用的话，就需要通过反射的方式。这个方法的注释大概是说禁止 ViewGroup 进行 layout() 操作。这样的话，我们有一个可以优化的地方，我们可以在动画开始时调用这个方法禁止 layout() 操作，动画结束时恢复。  </p>
<p>这样做的好处是，动画执行过程中，如果网络或本地数据已经回调，通知 adapter 去刷新 view 时，这样会导致动画很卡顿。所以，当我们用 suppressLayout() 做了优化之后，就只有等动画结束的时候界面才会去重新 layout 刷新布局，优化动画流畅性。  </p>
<p>但这样做也有一个问题是，如果你在 onCreate() 或 onResume() 之类的方法发起一个 requestFocus() 操作的话，很有可能这个操作会被丢弃掉，导致界面理应获得焦点的 view 发生错乱问题。  </p>
<p>至于原因，因为对 suppressLayout() 也还不是很理解，打算等对 onPreDraw() 理解了之后一起研究一下。  </p>
<p><strong>2.windowIsTranslucent 半透明引发的问题</strong><br>哇，这个属性，真的是。。。<br>你们好奇的话，就网上搜一下这个半透明属性，一堆各种问题。但其实，网上碰到的那些问题，我基本都没遇到过，但我遇到的是更奇葩，网上没找到解决方案的问题，哭瞎。  </p>
<p>emmm，我是做 Tv 应用开发的，windowIsTranslucent 这个在不同的盒子上表现的效果不一样，简直了。  </p>
<p>在设置了 android:windowIsTranslucent=true 时，有的盒子界面就会是透明的，即使你设置了一张不透明的背景图，但透明度不会很明显。<br>有的盒子则是在新的 Activity 打开时，如果 view 没有完全加载出来，则会显示上个 Activity 的界面，造成的现象就是打开新 Activity 时，会一瞬间闪过上个界面的画面。  </p>
<p>还有，Tv 应用一般都会跟视频播放有关，那就涉及到播放器。而播放器需要一个 surfaceview，而 surfaceview 遇到半透明属性时，问题更多。  </p>
<p>原因，都不清楚（哎，可悲）。但只要不使用半透明这个属性，就一切正常了，但如果不用这个属性，本篇介绍的动画方案又没法实现。这真的是鱼和熊掌不可兼得啊。  </p>
<p>所以，我就在想，<strong>既然 windowIsTranslucent 为 false 时，一切正常；为 true 时，动画正常。那是否有办法在动画过程中设置为 true，动画结束之后设置为 false 呢？</strong>如果可以的话，按理来说应该正好解决问题。  </p>
<p>但找了半天，没有找到相关的接口来动态设置这个属性的值，这个半透明属性值是设置在 style.xml 里的。网上有一些介绍说：在代码动态修改 style 的，但打开那些文章你会发现，说的是动态修改，但基本都要求要么在 super.onCreate() 之前调用，要么在 setContentLayout() 之前，要么重写 setTheme()，这么多限制，那哪里有用。  </p>
<p>后来，在找播放器黑屏的问题时，找到一篇大神写的博客：<a href="http://www.jianshu.com/p/b6d682e301c2" target="_blank" rel="noopener">Android版与微信Activity侧滑后退效果完全相同的SwipeBackLayout</a>。  </p>
<p>题目虽然看起来跟本篇一点关系都没有，但作者遇到的问题跟我的问题本质上是一个的，也是 windowIsTranslucent 属性导致的问题。很开心的是，作者介绍了<strong>利用反射去调用 Activity 里的 convertFromTranslucent() 和 convertToTranslucent() 方法来动态修改这个半透明属性值，这两个方法是对外隐藏的</strong>。  </p>
<p>后来，我很好奇 5.0+ 的动画到底是怎么实现的这种动画效果，因为它明明不需要设置 windowIsTranslucent 为 true，但它的动画，Activity 在跳转时，上个 Activity 是可见的，这是怎么做到的。  </p>
<p>我跟踪了一部分源码，也很开心的发现，原来它内部也是用的 Activity 里的这两个方法，在动画开始前将 Activity 设置成半透明的，动画结束后设置回去。当然，内部它有权限调用 Activity 的方法，而我们没有权限，所以只能通过反射来调用。  </p>
<p>开心，问题解决了。我们只要通过反射，在动画开始之前调用 Activity 的 convertToTranslucent() 将 Activity 设置成半透明的，动画结束再调用 convertFromTranslucent() 设置回去，这样动画的效果达到了，又不会因为设置了 windowIsTranslucent 为 true 而引入各种问题。  </p>
<p><strong>但是，测试时发现，在 api 21 以下的盒子上，这个方法没启作用。</strong>  </p>
<p>我去查看，比较了下 21 以上和以下 Activity 的代码，发现 convertToTranslucent() 这个方法它的内部实现是不一样的，21及以上是一套代码，21以下至19是一套代码，19以下则是没有这两个方法。  </p>
<p>后来又仔细看了上面大神那篇文章，发现说，原来 19-21 的版本，这两个方法要能够生效的话，需要默认在 style.xml 先将 Activity 设置成半透明的，而 21 及以上的，则不需要。至于19以下的，就完全不能用这个方法了。</p>
<p>解决方法也很简单，那就在 style.xml 默认设置 Activity 是半透明的，这样动画结束之后再设回去就可以了。  </p>
<p><strong>但是，这样播放器就会有问题—黑屏</strong>。原因是因为调用了 convertFromTranslucent() 设置不透明，一旦调用这个方法，如果该界面有播放器，那么就会黑屏。至于具体原因，还是不清楚，上面那个大神的文章里也提到了这个现象，但他也不知道如何解决，我也不知道。  </p>
<p>最后，为了解决黑屏的问题，只能是如果界面有播放器的话，那个这个界面的动画就换另外一种方法来实现，至于是什么方案也可以实现开头介绍的动画效果，我就不说了，Github 上很多，但都有同一个特点，那就是贼麻烦。  </p>
<p>稍微总结一下，本篇提的动画方案适用于以下几种场景：  </p>
<ol>
<li><p><strong>如果你的应用设置了 windowIsTranslucent 为 true 时，没有发现什么问题的话，那恭喜你，该动画方案可以兼容各种版本。</strong>  </p>
</li>
<li><p><strong>如果你的应用设置了 windowIsTranslucent 为 true 时会有一些问题，但你的应用里没有播放器的话，那恭喜你，该动画方案可以兼容 19 及以上版本。</strong>  </p>
</li>
<li><p><strong>如果你的应用设置了 windowIsTranslucent 为 true 时会有一些问题，而且应用里也有播放器的话，那如果你实在走投无路想使用该动画方案的话，那你再来找我吧，在研究出其他方案之前，咱们一起来慢慢填坑。</strong>    </p>
</li>
</ol>
<p><strong>注：本篇侧重点是介绍一种 Activity 动画方案的实现思路，注意，是思路！因为本篇所介绍的动画方案并不成熟，仍有很多坑，所以，学习、探讨就可以，慎用！</strong></p>
<h1 id="Github-链接"><a href="#Github-链接" class="headerlink" title="Github 链接"></a>Github 链接</h1><p>上传了一个 demo，如果对这种动画方案感兴趣的话，可以去看看代码。跟动画有关的代码都在 ui/anim 文件夹里。<br><a href="https://github.com/woshidasusu/ActivityAnimationDemo" target="_blank" rel="noopener">一种 Activity 转场动画—-点击哪里从哪放大</a>  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-ab7dc4915dc5ec24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目.png"></p>
<h1 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h1><p>老样子，最后再留几个问题给大家思考一下（其实我也不懂，还望有大神能解答一下）  </p>
<p><strong>Q1：overridePendingTransition() 实现的转场动画一点都不卡，但用 View 动画方案来实现 Activity 转场动画有时会有些卡顿，感觉是 Activity 启动做的那一大堆事跟动画挤一起了，那 overridePendingTransition() 原理到底是怎么实现？跟着源码跳进去看感觉有点懵，有时间得再研究一下这部分的源码。</strong>  </p>
<p><strong>Q2：Activity 切换时，一般下个 Activity 直接覆盖在本 Activity 上了，按我的理解，如果对要打开的 Activity 的 window 设置成透明属性，那应该就可以看到下层的 Activity 才对，为什么不行呢？为什么一定要设置 android:windowIsTranslucent = true 才可以呢？android 5.0 的共享元素动画很明显可以看到下个 Activity 在缩放时，上个 Activity 是可见的，那么它又是怎么实现的呢？原理是什么呢？这部分源码看了一部分了，等理解透了点，在梳理出来。</strong>  </p>
]]></content>
      <categories>
        <category>Android-TV</category>
      </categories>
  </entry>
  <entry>
    <title>如何用Android Studio同时使用SVN和Git管理项目</title>
    <url>/2017/11/02/%E6%95%99%E7%A8%8B%E7%B1%BB/%E5%A6%82%E4%BD%95%E7%94%A8Android-Studio%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8SVN%E5%92%8CGit%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>这篇来讲讲如何在 Android Studio 上同时用 SVN 和 Git 来管理项目。我知道，你肯定会说我吃饱了撑着，没事找事做，为啥要同时用 SVN 和 Git 来管理项目。问题是，我也不想啊，我也很无奈啊（:(哭丧脸）。  </p>
<h1 id="为啥要同时用-SVN-和-Git-管理项目"><a href="#为啥要同时用-SVN-和-Git-管理项目" class="headerlink" title="为啥要同时用 SVN 和 Git 管理项目"></a>为啥要同时用 SVN 和 Git 管理项目</h1><p>这小题目也可以叫做使用场景  </p>
<p>是这样的，我之所以要同时用两个工具来管理项目，是因为，项目原先是用 SVN 管理的，SVN 虽然使用简单，但分支功能远没有 Git 那么好用，如果一开始项目就是用 Git 来管理，我就不会去瞎折腾了，但公司项目都是通过 SVN 来管理，所以，我绝对不是因为喜欢瞎折腾才来搞这个的（严肃脸$_$）。  </p>
<p>来说说我的遇到的问题  </p>
<p>有个项目由于种种原因，需要尝试替换图片框架，而这个项目前期开发时并没有考虑到这点，所以，emmm，你知道的，需要改动到的地方太多了。产品想要的是稳定性，所以对于换框架的事也不急，我也就抽空做做。  </p>
<p>然后，这时候还是得并行处理一些 Bug。  </p>
<p>再然后，没多久，新的迭代又开始了，所以我这边是需要并行处理几个工作的，这几个工作肯定是需要单独分开的，都需要开个分支来做，以免影响主分支的代码。  </p>
<p><strong>而 SVN 开分支，我只知道这相当于对主分支的代码 Copy 了几份过去，所以说，如果我要换分支开发，等于说我要用 Android Studio 打开多个项目</strong>，就像这样：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-c4c3e1bc22a67644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="svn开分支.png"></p>
<p>每次换分支，都要重新打开一个项目，要是分支多了，电脑上就得对应多个文件夹，时间一长不就乱套了，而且你们知道，我们最多就是在项目外再建一个文件夹通过命名来区分不同的分支，但是 AS 的 open recent 里是不会显示外面那层文件夹的，结果就是一个列表下来都是同名的项目，我都不知道哪个是哪个，头疼之下，我突然很想念 Git 的分支功能，所以就瞎搞了半天来看看怎么用 Git 配合 SVN 管理项目。  </p>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>我的使用方式是：  </p>
<blockquote>
<ol>
<li>SVN：同步远程仓库代码和提交操作  </li>
<li>Git：本地管理项目，方便开分支  </li>
</ol>
</blockquote>
<h4 id="第1步"><a href="#第1步" class="headerlink" title="第1步"></a>第1步</h4><p>首先，项目已经通过 SVN 在管理了，所以我们只要<strong>去根目录下执行下 <code>git init</code> 将项目也添加进 Git 管理</strong>。  </p>
<p>这时候，根目录下是有 .svn 和 .git 的隐藏文件的。  </p>
<h4 id="第2步（重要）"><a href="#第2步（重要）" class="headerlink" title="第2步（重要）"></a>第2步（重要）</h4><p><strong>新建或找到 .gitignore 文件，将 .svn 添加进 Git 的忽略名单里。</strong>  </p>
<p>SVN 通过 .svn 来管理项目， Git 通过 .git 来管理。如果没有将 .svn 添加进 .gitignore 中的话，那 svn 就会受到 git 回退，切分支等等操作的影响了，我们应该让这两个工具都独立工作，不要影响彼此。所以，你还可以去 svn 的配置里也把 .git 添加进忽略里，但这点不是必要的，如果 SVN 只用于同步和提交操作的话，再说，也很少对通过 SVN 对整个项目进行回退等操作，所以 SVN 对 .git 文件夹的影响不大。  </p>
<h4 id="第3步（重要）"><a href="#第3步（重要）" class="headerlink" title="第3步（重要）"></a>第3步（重要）</h4><p>对 Git 进行如下的配置：  </p>
<p><strong>git config –global core.autocrlf false</strong><br><strong>git config –global core.safecrlf false</strong>  </p>
<p>如果你是用 Window 开发的话，这个配置一定要在 <code>git init</code> 后，首次执行 <code>git add</code> 前配置好，否则你会掉入一个大坑里的，我在这个坑了爬了好久。  </p>
<p>原因是这样的，Window 下换行符是 CRLF，但是 Git bash 是基于 Linux 的，所以它的换行符是 LF，默认情况下，当你执行 <code>git add</code>， <code>git commit</code>， 的时候，会自动将代码里的 CRLF 替换成 LF 的，所以会出现这样一种情况：  </p>
<p>Local Changes 里是没有任何文件改动记录的，也就是说 SVN 和 Git 当前的工作区间没有改动什么文件，然后你通过 Git 切换到分支上去，开发完后再切回主分支时，按理说，现在的 Local Changes 里应该是要没有任何东西的，但是你会发现，就有一些文件被改动的记录，然后你 show diff 查看这些改动的文件，你会发现两边代码一模一样，没有任何一处是有改动到的，唯一不同的就是 CRLF 和 LF，就想这样：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-99e3029897b4cb79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="show diff.png"></p>
<p>经常使用 AS 的 show diff 应该对这个很熟悉，两边明明没有任何代码上的改动对比，就是因为 CRLF 和 LF 的问题，导致这个文件出现在了 Local Changes 里。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-58762b0755ae63f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Local Changes.png"></p>
<p>而我们在写完代码提交到远程仓库时，经常都是通过这个 Local Changes 面板来选择一些文件进行提交，很少会对整个文件夹提交，因为可能开发过程中改动到其他地方，所以提交前我都习惯先来这边过一遍。  </p>
<p>但因为这个 CRLF 和 LF 的问题，会导致这边 Local Changes 乱套的。而上面那两句 git 命令就是设置默认文件原本的换行符格式，不对其发起警告也不对其自动替换。  </p>
<h4 id="第4步"><a href="#第4步" class="headerlink" title="第4步"></a>第4步</h4><p>经过上面几步操作后，接下去你就可以执行<br><code>git add</code><br><code>git commit</code><br><code>git checkout -b XXXbranch</code><br><code>git checkout master</code>  </p>
<p>等等的 git 分支相关的操作了。  </p>
<h1 id="AS-上同时使用-SVN-和-Git"><a href="#AS-上同时使用-SVN-和-Git" class="headerlink" title="AS 上同时使用 SVN 和 Git"></a>AS 上同时使用 SVN 和 Git</h1><p>以上可以说只是完成首次使用的配置而已，接下去才是我们想要的。 AS 提供的 Version Control 图形操作界面非常方便和好用，我就是因为喜欢 AS 这点，才想用 Git 来管理项目。如果对 AS 上 Git 的使用不熟悉的话，可以去看看<a href="http://www.cnblogs.com/dasusu/p/5372840.html" target="_blank" rel="noopener">我之前写的一篇简单介绍的博客</a>。AS 上 SVN 的操作跟 Git 基本一致。  </p>
<p>那么，<strong>到底可不可以在 AS 上既用 SVN 又用 Git 呢？可以是可以，但会有点小问题</strong>。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-b5506a9ec973d81f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="settings_versionControl.png"></p>
<p>首次打开先去 Settings-&gt;Version Control 里配置一下，然后你就会在底部栏发现 AS 提供的各个版本操作工具了。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-e202bb233a852f7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AS的各个VersionControl面板.png"></p>
<p>以上几个 AS 的面板都非常好用，既可以查看历史提交的代码信息，本地的修改信息，还可以比对各个提交的不同等等。  </p>
<p>但 AS 如果同时使用 SVN 和 Git 的话，Local Changes 这边就只会显示 Git 的本地修改了。也就是说，如果 SVN 记录的本地修改和 Git 不同的话，这里只会显示 Git 记录的信息。而且，如果是只使用 SVN 的情况下，我们可以在这里直接通过右键来提交我们选中的修改到 SVN 上。但如果 SVN 和 Git 同时使用，SVN 的 commit 功能就失效了，就只有 Git 的 commit 和 push 可以用，但我们又不需要 Git 的 push，它只作为本地管理使用而已，所以小问题就是在这里了。  </p>
<p><strong>至于解决方法，也很简单，但稍微有些麻烦</strong>。也就是你每次要用 SVN 提交代码的时候，再去 Settings-&gt;Version Control 里将 Git 管理的目录暂时移除掉，只保留 SVN 的。  </p>
<p>emmm，这样操作还是有点麻烦，每次提交都要去移除。但相对于再打开一个项目来开发分支的操作算是好了一点了。  </p>
<p><strong>还有一种方法，也是我目前在使用的方法：</strong>  </p>
<p>AS 只添加 SVN，这样 SVN 的功能就能正常使用了。然后 Git 的建分支，切分支等等操作都通过 git bash 命令行方式来执行，搞定。  </p>
<p>这下，再也不用担心 SVN 建分支要重新打开项目了，好棒。  </p>
]]></content>
      <categories>
        <category>教程类</category>
      </categories>
  </entry>
  <entry>
    <title>基于滑动场景解析RecyclerView的回收复用机制原理</title>
    <url>/2017/10/28/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E5%9F%BA%E4%BA%8E%E6%BB%91%E5%8A%A8%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90RecyclerView%E7%9A%84%E5%9B%9E%E6%94%B6%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</strong>  </p>
</blockquote>
<p>最近在研究 RecyclerView 的回收复用机制，顺便记录一下。我们知道，RecyclerView 在 layout 子 View 时，都通过回收复用机制来管理。网上关于回收复用机制的分析讲解的文章也有一大堆了，分析得也都很详细，什么四级缓存啊，先去 mChangedScrap 取再去哪里取啊之类的；但其实，我想说的是，RecyclerView 的回收复用机制确实很完善，覆盖到各种场景中，但并不是每种场景的回收复用时都会将机制的所有流程走一遍的。举个例子说，在 setLayoutManager、setAdapter、notifyDataSetChanged 或者滑动时等等这些场景都会触发回收复用机制的工作。但是如果只是 RecyclerView 滑动的场景触发的回收复用机制工作时，其实并不需要四级缓存都参与的。  </p>
<p>emmm，应该讲得还是有点懵，那就继续看下去吧，会一点一点慢慢分析。本篇不会像其他大神的文章一样，把回收复用机制源码一行行分析下来，我也没那个能力，所以我会基于一种特定的场景来分析源码，这样会更容易理解的。废话结束，开始正题。  </p>
<h1 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h1><p>RecyclerView 的回收复用机制的内部实现都是由 Recycler 内部类实现，下面就都以这样一种页面的滑动场景来讲解 RecyclerView 的回收复用机制。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-2c4220087dee4a6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RecyclerView页面.png"></p>
<p>相应的版本：<br>RecyclerView:  recyclerview-v7-25.1.0.jar<br>LayoutManager:  GridLayoutManager extends LinearLayoutManager (recyclerview-v7-25.1.0.jar)</p>
<p>这个页面每行可显示5个卡位，每个卡位的 item 布局 type 一致。</p>
<p>开始分析回收复用机制之前，先提几个问题：</p>
<h4 id="Q1-如果向下滑动，新一行的5个卡位的显示会去复用缓存的-ViewHolder，第一行的5个卡位会移出屏幕被回收，那么在这个过程中，是先进行复用再回收？还是先回收再复用？还是边回收边复用？也就是说，新一行的5个卡位复用的-ViewHolder-有可能是第一行被回收的5个卡位吗？"><a href="#Q1-如果向下滑动，新一行的5个卡位的显示会去复用缓存的-ViewHolder，第一行的5个卡位会移出屏幕被回收，那么在这个过程中，是先进行复用再回收？还是先回收再复用？还是边回收边复用？也就是说，新一行的5个卡位复用的-ViewHolder-有可能是第一行被回收的5个卡位吗？" class="headerlink" title="Q1:如果向下滑动，新一行的5个卡位的显示会去复用缓存的 ViewHolder，第一行的5个卡位会移出屏幕被回收，那么在这个过程中，是先进行复用再回收？还是先回收再复用？还是边回收边复用？也就是说，新一行的5个卡位复用的 ViewHolder 有可能是第一行被回收的5个卡位吗？"></a>Q1:如果向下滑动，新一行的5个卡位的显示会去复用缓存的 ViewHolder，第一行的5个卡位会移出屏幕被回收，那么在这个过程中，是先进行复用再回收？还是先回收再复用？还是边回收边复用？也就是说，新一行的5个卡位复用的 ViewHolder 有可能是第一行被回收的5个卡位吗？</h4><p>第二个问题之前，先看几张图片：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-b92c5bdf40d5c973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="先向下再向上滑动.png"></p>
<p>黑框表示屏幕，RecyclerView 先向下滑动，第三行卡位显示出来，再向上滑动，第三行移出屏幕，第一行显示出来。我们分别在 Adapter 的 onCreateViewHolder()  和  onBindViewHolder()  里打日志，下面是这个过程的日志：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-d53948d61444967d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志.png"></p>
<p>红框1是 RecyclerView 向下滑动操作的日志，第三行5个卡位的显示都是重新创建的 ViewHolder ；红框2是再次向上滑动时的日志，第一行5个卡位的重新显示用的 ViewHolder 都是复用的，因为没有 create viewHolder 的日志，然后只有后面3个卡位重新绑定数据，调用了onBindViewHolder()；那么问题来了：</p>
<h4 id="Q2-在这个过程中，为什么当-RecyclerView-再次向上滑动重新显示第一行的5个卡位时，只有后面3个卡位触发了-onBindViewHolder-方法，重新绑定数据呢？明明5个卡位都是复用的。"><a href="#Q2-在这个过程中，为什么当-RecyclerView-再次向上滑动重新显示第一行的5个卡位时，只有后面3个卡位触发了-onBindViewHolder-方法，重新绑定数据呢？明明5个卡位都是复用的。" class="headerlink" title="Q2: 在这个过程中，为什么当 RecyclerView 再次向上滑动重新显示第一行的5个卡位时，只有后面3个卡位触发了 onBindViewHolder() 方法，重新绑定数据呢？明明5个卡位都是复用的。"></a>Q2: 在这个过程中，为什么当 RecyclerView 再次向上滑动重新显示第一行的5个卡位时，只有后面3个卡位触发了 onBindViewHolder() 方法，重新绑定数据呢？明明5个卡位都是复用的。</h4><p>在上面的操作基础上，我们继续往下操作：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-303c949a54504fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="先向下再向下.png">  </p>
<p>在第二个问题操作的基础上，目前已经创建了15个 ViewHolder，此时显示的是第1、2行的卡位，那么继续向下滑动两次，这个过程的日志如下：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-d4eddb89b0254056.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志.png"></p>
<p>红框1是第二个问题操作的日志，在这里截出来只是为了显示接下去的日志是在上面的基础上继续操作的；  </p>
<p>红框2就是第一次向下滑时的日志，对比问题2的日志，这次第三行的5个卡位用的 ViewHolder 也都是复用的，而且也只有后面3个卡位触发了 onBindViewHolder() 重新绑定数据；  </p>
<p>红框3是第二次向下滑动时的日志，这次第四行的5个卡位，前3个的卡位用的 ViewHolder 是复用的，后面2个卡位的 ViewHolder 则是重新创建的，而且5个卡位都调用了 onBindViewHolder() 重新绑定数据；</p>
<p>那么，</p>
<h4 id="Q3：接下去不管是向上滑动还是向下滑动，滑动几次，都不会再有-onCreateViewHolder-的日志了，也就是说-RecyclerView-总共创建了17个-ViewHolder，但有时一行的5个卡位只有3个卡位需要重新绑定数据，有时却又5个卡位都需要重新绑定数据，这是为什么呢？"><a href="#Q3：接下去不管是向上滑动还是向下滑动，滑动几次，都不会再有-onCreateViewHolder-的日志了，也就是说-RecyclerView-总共创建了17个-ViewHolder，但有时一行的5个卡位只有3个卡位需要重新绑定数据，有时却又5个卡位都需要重新绑定数据，这是为什么呢？" class="headerlink" title="Q3：接下去不管是向上滑动还是向下滑动，滑动几次，都不会再有 onCreateViewHolder() 的日志了，也就是说 RecyclerView 总共创建了17个 ViewHolder，但有时一行的5个卡位只有3个卡位需要重新绑定数据，有时却又5个卡位都需要重新绑定数据，这是为什么呢？"></a>Q3：接下去不管是向上滑动还是向下滑动，滑动几次，都不会再有 onCreateViewHolder() 的日志了，也就是说 RecyclerView 总共创建了17个 ViewHolder，但有时一行的5个卡位只有3个卡位需要重新绑定数据，有时却又5个卡位都需要重新绑定数据，这是为什么呢？</h4><p>如果明白 RecyclerView 的回收复用机制，那么这三个问题也就都知道原因了；反过来，如果知道这三个问题的原因，那么理解 RecyclerView 的回收复用机制也就更简单了；所以，带着问题，在特定的场景下去分析源码的话，应该会比较容易。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>其实，根据问题2的日志，我们就可以回答问题1了。在目前显示1、2行，<br>ViewHolder 的个数为10个的基础上，第三行的5个新卡位要显示出来都需要重新创建 ViewHolder，也就是说，在这个向下滑动的过程，是5个新卡位的复用机制先进行工作，然后第1行的5个被移出屏幕的卡位再进行回收机制工作。</p>
<p>那么，就先来看看复用机制的源码</p>
<h2 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h2><h4 id="getViewForPosition"><a href="#getViewForPosition" class="headerlink" title="getViewForPosition()"></a>getViewForPosition()</h4><p><img src="http://upload-images.jianshu.io/upload_images/1924341-0219f140e17d330a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Recycler.getViewForPosition()">  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-c66cd4f84f487f35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Recycler.getViewForPosition()"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-062fc4ed24ce8cc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Recycler.tryGetViewHolderForPositionByDeadline"></p>
<p>这个方法是复用机制的入口，也就是 Recycler 开放给外部使用复用机制的api，外部调用这个方法就可以返回想要的 View，而至于这个 View 是复用而来的，还是重新创建得来的，就都由 Recycler 内部实现，对外隐藏。</p>
<h4 id="tryGetViewHolderForPositionByDeadline"><a href="#tryGetViewHolderForPositionByDeadline" class="headerlink" title="tryGetViewHolderForPositionByDeadline()"></a>tryGetViewHolderForPositionByDeadline()</h4><p>所以，Recycler 的复用机制内部实现就在这个方法里。<br>分析逻辑之前，先看一下 Recycler 的几个结构体，用来缓存 ViewHolder 的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-514b75b8ac9f01a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Recycler"></p>
<p><strong>mAttachedScrap:</strong> 用于缓存显示在屏幕上的 item 的 ViewHolder，场景好像是 RecyclerView 在 onLayout 时会先把 children 都移除掉，再重新添加进去，所以这个 List 应该是用在布局过程中临时存放 children 的，反正在 RecyclerView 滑动过程中不会在这里面来找复用的 ViewHolder 就是了。  </p>
<p><strong>mChangedScrap：</strong> 这个没理解是干嘛用的，看名字应该跟 ViewHolder 的数据发生变化时有关吧，在 RecyclerView 滑动的过程中，也没有发现到这里找复用的 ViewHolder，所以这个可以先暂时放一边。  </p>
<p><strong>mCachedViews：</strong>这个就重要得多了，滑动过程中的回收和复用都是先处理的这个 List，这个集合里存的 ViewHolder 的原本数据信息都在，所以可以直接添加到 RecyclerView 中显示，不需要再次重新 onBindViewHolder()。  </p>
<p><strong>mUnmodifiableAttachedScrap：</strong> 不清楚干嘛用的，暂时跳过。  </p>
<p><strong>mRecyclerPool：</strong>这个也很重要，但存在这里的 ViewHolder 的数据信息会被重置掉，相当于 ViewHolder 是一个重创新建的一样，所以需要重新调用 onBindViewHolder 来绑定数据。  </p>
<p><strong>mViewCacheExtension：</strong>这个是留给我们自己扩展的，好像也没怎么用，就暂时不分析了。  </p>
<p>那么接下去就看看复用的逻辑：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-dd0abac988209aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第1步"></p>
<p>第一步很简单，position 如果在 item 的范围之外的话，那就抛异常吧。继续往下看</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-5955fa256f00749d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第2步"></p>
<p>如果是在 isPreLayout() 时，那么就去 mChangedScrap 中找。<br>那么这个 isPreLayout 表示的是什么？，有两个赋值的地方。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-0ad8abab6a21751d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="延伸"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-7cb20c36f5dce0f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="延伸"></p>
<p>emmm，看样子，在 LayoutManager 的 onLayoutChildren 前就会置为<br> false，不过我还是不懂这个过程是干嘛的，滑动过程中好像<br> mState.mInPreLayou = false，所以并不会来这里，先暂时跳过。继续往下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-95f3949e0eb31034.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第3步"></p>
<p>跟进这个方法看看</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-fd4004b2d8ace021.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第3.1步 getScrapOrHiddenOrCachedHolderForPosition()"></p>
<p>首先，去 mAttachedScrap 中寻找 position 一致的 viewHolder，需要匹配一些条件，大致是这个 viewHolder 没有被移除，是有效的之类的条件，满足就返回这个 viewHolder。  </p>
<p>所以，这里的关键就是要理解这个 mAttachedScrap 到底是什么，存的是哪些 ViewHolder。  </p>
<p>一次遥控器按键的操作，不管有没有发生滑动，都会导致 RecyclerView 的重新 onLayout，那要 layout 的话，RecyclerView 会先把所有 children 先 remove 掉，然后再重新 add 上去，完成一次 layout 的过程。那么这暂时性的 remove 掉的 viewHolder 要存放在哪呢，就是放在这个 mAttachedScrap 中了，这就是我的理解了。  </p>
<p>所以，感觉这个 mAttachedScrap 中存放的 viewHolder 跟回收和复用关系不大。  </p>
<p><strong>网上一些分析的文章有说，RecyclerView 在复用时会按顺序去 mChangedScrap, mAttachedScrap 等等缓存里找，没有找到再往下去找，从代码上来看是这样没错，但我觉得这样表述有问题。因为就我们这篇文章基于 RecyclerView 的滑动场景来说，新卡位的复用以及旧卡位的回收机制，其实都不会涉及到mChangedScrap 和 mAttachedScrap，所以我觉得还是基于某种场景来分析相对应的回收复用机制会比较好。就像mChangedScrap 我虽然没理解是干嘛用的，但我猜测应该是在当数据发生变化时才会涉及到的复用场景，所以当我分析基于滑动场景时的复用时，即使我对这块不理解，影响也不会很大。</strong></p>
<p>继续往下看</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-3f3d614ebc2bb4d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第3.2步"></p>
<p>emmm，这段也还是没看懂，但估计应该需要一些特定的场景下所使用的复用策略吧，看名字，应该跟 hidden 有关？不懂，跳过这段，应该也没事，滑动过程中的回收复用跟这个应该也关系不大。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-1acce2d9f2295352.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第3.3步"></p>
<p>这里就要画重点啦，记笔记记笔记，滑动场景中的复用会用到这里的机制。  </p>
<p>mCachedViews 的大小默认为2。遍历 mCachedViews，找到 position 一致的 ViewHolder，之前说过，mCachedViews 里存放的 ViewHolder 的数据信息都保存着，<strong>所以 mCachedViews 可以理解成，只有原来的卡位可以重新复用这个 ViewHolder，新位置的卡位无法从 mCachedViews 里拿 ViewHolder出来用</strong>。  </p>
<p>找到 viewholder 后</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-33c21c465f1a5f0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第4步"></p>
<p>就算 position 匹配找到了 ViewHolder，还需要判断一下这个 ViewHolder 是否已经被 remove 掉，type 类型一致不一致，如下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-80dabf9da20a7c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第4.1步"></p>
<p>以上是在 mCachedViews 中寻找，没有找到的话，就继续再找一遍，刚才是通过 position 来找，那这次就换成id，然后重复上面的步骤再找一遍，如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-752a669b3dd132e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第5步"></p>
<p>getScrapOrCachedViewForId() 做的事跟 getScrapOrHiddenOrCacheHolderForPosition() 其实差不多，只不过一个是通过 position 来找 ViewHolder，一个是通过 id 来找。而这个 id 并不是我们在 xml 中设置的 android:id， 而是 Adapter 持有的一个属性，默认是不会使用这个属性的，所以这个第5步其实是不会执行的，除非我们重写了 Adapter 的 setHasStableIds()，既然不是常用的场景，那就先略过吧，那就继续往下。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-1f1f95bc355341cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第6步"></p>
<p>这个就是常说扩展类了，RecyclerView 提供给我们自定义实现的扩展类，我们可以重写 getViewForPositionAndType() 方法来实现自己的复用策略。不过，也没用过，那这部分也当作不会执行，略过。继续往下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-7ada33cd0a3be804.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第7步"></p>
<p>这里也是重点了，记笔记记笔记。  </p>
<p>这里是去 RecyclerViewPool 里取 ViewHolder，ViewPool 会根据不同的 item type 创建不同的 List，每个 List 默认大小为5个。看一下去 ViewPool 里是怎么找的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-896c18cd0add29e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第7.1步"></p>
<p>之前说过，ViewPool 会根据不同的 viewType 创建不同的集合来存放 ViewHolder，那么复用的时候，只要 ViewPool 里相同的 type 有 ViewHolder 缓存的话，就将最后一个拿出来复用，不用像 mCachedViews 需要各种匹配条件，<strong>只要有就可以复用</strong>。  </p>
<p>继续看”图第7步”后面的代码，拿到 ViewHolder 之后，还会再次调用 resetInternal() 来重置 ViewHolder，这样 ViewHolder 就可以当作一个全新的 ViewHolder 来使用了，<strong>这也就是为什么从这里拿的 ViewHolder 都需要重新 onBindViewHolder() 了</strong>。  </p>
<p>那如果在 ViewPool 里还是没有找到呢，继续往下看</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-f7703cc224f0e0c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第8步"></p>
<p>如果 ViewPool 中都没有找到 ViewHolder 来使用的话，那就调用 Adapter 的 onCreateViewHolder 来创建一个新的 ViewHolder 使用。</p>
<p>上面一共有很多步骤来找 ViewHolder，不管在哪个步骤，只要找到 ViewHolder 的话，那下面那些步骤就不用管了，然后都要继续往下判断是否需要重新绑定数据，还有检查布局参数是否合法。如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-f9652f153a1c720b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最后1步"></p>
<p>到这里，tryGetViewHolderForPositionByDeadline() 这个方法就结束了。这大概就是 RecyclerView 的复用机制，中间我们跳过很多地方，因为 RecyclerView 有各种场景可以刷新他的 view，比如重新 setLayoutManager()，重新 setAdapter()，或者 notifyDataSetChanged()，或者滑动等等之类的场景，只要重新layout，就会去回收和复用 ViewHolder，所以这个复用机制需要考虑到各种各样的场景。  </p>
<p>把代码一行行的啃透有点吃力，所以我就只借助 RecyclerView 的滑动的这种场景来分析它涉及到的回收和复用机制。</p>
<p>下面就分析一下回收机制  </p>
<h1 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h1><p>回收机制的入口就有很多了，因为 Recycler 有各种结构体，比如mAttachedScrap，mCachedViews 等等，不同结构体回收的时机都不一样，入口也就多了。</p>
<p>所以，还是基于 RecyclerView 的滑动场景下，移出屏幕的卡位回收时的入口是：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-8d193a934e418fa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Recycler.recyclerView()"></p>
<p>本篇分析的滑动场景，在 RecyclerView 滑动时，会交由 LinearLayoutManager 的 scrollVerticallyBy() 去处理，然后 LayoutManager 会接着调用 fill() 方法去处理需要复用和回收的卡位，最终会调用上述 recyclerView() 这个方法开始进行回收工作。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-834a4aab4895b4c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="recycleViewHolderInternal()"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-f1f4e8224cf9c988.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上图第一个红框中的代码"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-83988040a9be33b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从 mCacheViews 中扔 ViewHolder 到 ViewPool中去"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-413caf31ef770f40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="addViewHolderToRecycledViewPool"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-c63dd51c788f895e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="putRecycledView()"></p>
<p>回收的逻辑比较简单，由 LayoutManager 来遍历移出屏幕的卡位，然后对每个卡位进行回收操作，回收时，都是把 ViewHolder 放在 mCachedViews 里面，如果 mCachedViews 满了，那就在 mCachedViews 里拿一个 ViewHolder 扔到 ViewPool 缓存里，然后 mCachedViews 就可以空出位置来放新回收的 ViewHolder 了。</p>
<h2 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h2><p>RecyclerView 滑动场景下的回收复用涉及到的结构体两个：<br><strong>mCachedViews 和 RecyclerViewPool</strong></p>
<p>mCachedViews 优先级高于 RecyclerViewPool，回收时，最新的 ViewHolder 都是往 mCachedViews 里放，如果它满了，那就移出一个扔到 ViewPool 里好空出位置来缓存最新的 ViewHolder。   </p>
<p>复用时，也是先到 mCachedViews 里找 ViewHolder，但需要各种匹配条件，概括一下就是只有原来位置的卡位可以复用存在 mCachedViews 里的 ViewHolder，如果 mCachedViews 里没有，那么才去 ViewPool 里找。  </p>
<p>在 ViewPool 里的 ViewHolder 都是跟全新的 ViewHolder 一样，只要 type 一样，有找到，就可以拿出来复用，重新绑定下数据即可。  </p>
<p>整体的流程图如下：（可放大查看）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-0868f1fe3dcf17b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="滑动场景下的回收复用流程图.png"></p>
<p>最后，解释一下开头的问题</p>
<h4 id="Q1-如果向下滑动，新一行的5个卡位的显示会去复用缓存的-ViewHolder，第一行的5个卡位会移出屏幕被回收，那么在这个过程中，是先进行复用再回收？还是先回收再复用？还是边回收边复用？也就是说，新一行的5个卡位复用的-ViewHolder-有可能是第一行被回收的5个卡位吗？-1"><a href="#Q1-如果向下滑动，新一行的5个卡位的显示会去复用缓存的-ViewHolder，第一行的5个卡位会移出屏幕被回收，那么在这个过程中，是先进行复用再回收？还是先回收再复用？还是边回收边复用？也就是说，新一行的5个卡位复用的-ViewHolder-有可能是第一行被回收的5个卡位吗？-1" class="headerlink" title="Q1:如果向下滑动，新一行的5个卡位的显示会去复用缓存的 ViewHolder，第一行的5个卡位会移出屏幕被回收，那么在这个过程中，是先进行复用再回收？还是先回收再复用？还是边回收边复用？也就是说，新一行的5个卡位复用的 ViewHolder 有可能是第一行被回收的5个卡位吗？"></a>Q1:如果向下滑动，新一行的5个卡位的显示会去复用缓存的 ViewHolder，第一行的5个卡位会移出屏幕被回收，那么在这个过程中，是先进行复用再回收？还是先回收再复用？还是边回收边复用？也就是说，新一行的5个卡位复用的 ViewHolder 有可能是第一行被回收的5个卡位吗？</h4><p>答：先复用再回收，新一行的5个卡位先去目前的 mCachedViews 和 ViewPool 的缓存中寻找复用，没有就重新创建，然后移出屏幕的那行的5个卡位再回收缓存到 mCachedViews 和 ViewPool 里面，所以新一行5个卡位和复用不可能会用到刚移出屏幕的5个卡位。</p>
<h4 id="Q2-在这个过程中，为什么当-RecyclerView-再次向上滑动重新显示第一行的5个卡位时，只有后面3个卡位触发了-onBindViewHolder-方法，重新绑定数据呢？明明5个卡位都是复用的。-1"><a href="#Q2-在这个过程中，为什么当-RecyclerView-再次向上滑动重新显示第一行的5个卡位时，只有后面3个卡位触发了-onBindViewHolder-方法，重新绑定数据呢？明明5个卡位都是复用的。-1" class="headerlink" title="Q2: 在这个过程中，为什么当 RecyclerView 再次向上滑动重新显示第一行的5个卡位时，只有后面3个卡位触发了 onBindViewHolder() 方法，重新绑定数据呢？明明5个卡位都是复用的。"></a>Q2: 在这个过程中，为什么当 RecyclerView 再次向上滑动重新显示第一行的5个卡位时，只有后面3个卡位触发了 onBindViewHolder() 方法，重新绑定数据呢？明明5个卡位都是复用的。</h4><p>答：滑动场景下涉及到的回收和复用的结构体是 mCachedViews 和 ViewPool，前者默认大小为2，后者为5。所以，当第三行显示出来后，第一行的5个卡位被回收，回收时先缓存在 mCachedViews，满了再移出旧的到 ViewPool 里，所有5个卡位有2个缓存在 mCachedViews 里，3个缓存在 ViewPool，至于是哪2个缓存在 mCachedViews，这是由 LayoutManager 控制。  </p>
<p>上面讲解的例子使用的是 GridLayoutManager，滑动时的回收逻辑则是在父类 LinearLayoutManager 里实现，回收第一行卡位时是从后往前回收，所以最新的两个卡位是0、1，会放在 mCachedViews 里，而2、3、4的卡位则放在 ViewPool 里。  </p>
<p>所以，当再次向上滑动时，第一行5个卡位会去两个结构体里找复用，之前说过，mCachedViews 里存放的 ViewHolder 只有原本位置的卡位才能复用，所以0、1两个卡位都可以直接去 mCachedViews 里拿 ViewHolder 复用，而且这里的 ViewHolder 是不用重新绑定数据的，至于2、3、4卡位则去 ViewPool 里找，刚好 ViewPool 里缓存着3个 ViewHolder，所以第一行的5个卡位都是用的复用的，而从 ViewPool 里拿的复用需要重新绑定数据，才会这样只有三个卡位需要重新绑定数据。</p>
<h4 id="Q3：接下去不管是向上滑动还是向下滑动，滑动几次，都不会再有-onCreateViewHolder-的日志了，也就是说-RecyclerView-总共创建了17个-ViewHolder，但有时一行的5个卡位只有3个卡位需要重新绑定数据，有时却又5个卡位都需要重新绑定数据，这是为什么呢？-1"><a href="#Q3：接下去不管是向上滑动还是向下滑动，滑动几次，都不会再有-onCreateViewHolder-的日志了，也就是说-RecyclerView-总共创建了17个-ViewHolder，但有时一行的5个卡位只有3个卡位需要重新绑定数据，有时却又5个卡位都需要重新绑定数据，这是为什么呢？-1" class="headerlink" title="Q3：接下去不管是向上滑动还是向下滑动，滑动几次，都不会再有 onCreateViewHolder() 的日志了，也就是说 RecyclerView 总共创建了17个 ViewHolder，但有时一行的5个卡位只有3个卡位需要重新绑定数据，有时却又5个卡位都需要重新绑定数据，这是为什么呢？"></a>Q3：接下去不管是向上滑动还是向下滑动，滑动几次，都不会再有 onCreateViewHolder() 的日志了，也就是说 RecyclerView 总共创建了17个 ViewHolder，但有时一行的5个卡位只有3个卡位需要重新绑定数据，有时却又5个卡位都需要重新绑定数据，这是为什么呢？</h4><p>答：有时一行只有3个卡位需要重新绑定的原因跟Q2一样，因为 mCachedView 里正好缓存着当前位置的 ViewHolder，本来就是它的 ViewHolder 当然可以直接拿来用。而至于为什么会创建了17个 ViewHolder，那是因为再第四行的卡位要显示出来时，ViewPool 里只有3个缓存，而第四行的卡位又用不了 mCachedViews 里的2个缓存，因为这两个缓存的是0、1卡位的 ViewHolder，所以就需要再重新创建2个 ViewHodler 来给第四行最后的两个卡位使用。  </p>
]]></content>
      <categories>
        <category>Android源码解析</category>
      </categories>
  </entry>
  <entry>
    <title>AndroidTv开发中常用的adb命令</title>
    <url>/2017/10/01/Android-Tv/AndroidTv%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84adb%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>盒子应用开发时，调试比手机上的开发比较麻烦一点，而且需要经常跟 adb 打交道，不管是 wifi 连接调试，还是应用删除安装等。这里记录一些常用的操作，方便查阅。  </p>
<p>#adb wifi连接调试  </p>
<p>####方法一：需要root权限<br>在网上下载超级终端工具，然后输入下面命令：  </p>
<pre><code>su  
setprop service.adb.tcp.port 5555  
stop adbd  
start adbd  
</code></pre><p>超级终端工具在各大应用市场中就可以下载，或者编译运行 github 上的终端应用，附上链接：<a href="https://github.com/jackpal/Android-Terminal-Emulator" target="_blank" rel="noopener">Android-Terminal-Emulator</a>   </p>
<p>如果不想下载终端自己输入命令，可以网上搜索一些别人封装好的工具直接运行，如我自己写的小工具，下载项目编译安装在盒子上运行一下即可。<br><a href="https://github.com/woshidasusu/DasusuDemo/tree/master/Adb" target="_blank" rel="noopener">adb</a><br>如果也不想编译项目，那么试试看可不可以直接下载apk安装，<a href="https://github.com/woshidasusu/DasusuDemo/blob/master/Adb/app/build/outputs/apk/app-debug.apk" target="_blank" rel="noopener">下载地址</a>  </p>
<p>####方法二：需要 usb 连接，不需要 root 权限<br>这是针对手机的情况，毕竟盒子如果可以有线连接调试就不用搞什么wifi这么麻烦了，具体步骤见最后的参考链接，这里不介绍了。  </p>
<p>#adb 常用调试<br>可以借助 adb 来查看数据库文件等数据，这方面内容感兴趣的可以查阅我之前的博客<a href="http://www.jianshu.com/p/a6dcdb2c74c3" target="_blank" rel="noopener">【Android】你应该知道的调试神器–adb</a>  </p>
<p>#adb 修改 ect/host 文件<br>Tv项目的正式上线，预发布还有测试时的服务器地址通常不一样，有时是根据盒子的 host 文件来决定，因此开发期间，通常会有测试和预发布的 host 文件，需要覆盖在盒子的 etc 目录下。但 etc 目录是只读权限的，所以需要 root 权限，而且简单的使用 chmod 命令无法更改 etc 目录的读写权限，需要重新挂载。总之，命令如下：  </p>
<pre><code>adb root  
//命令执行会有提示：adbd is already running as root

adb remount    
//命令执行会有提示：remount succeeded  

adb pull /system/etc/hosts  
//可选，备份原有Host  

adb push ./hosts /system/etc  
</code></pre><p>#adb 删除系统应用<br>如果做的Tv应用是盒子厂商定制的系统应用，那么在开发时需要将盒子原有的系统应用卸载，才能安装你开发的应用，步骤如下：  </p>
<pre><code>1、  mount -o rw,remount /system    卸载系统应用时先运行这句
2、 后把 /system/app 和 /data/data 下的相关文件删掉
3、 reboot重启盒子
4、 安装debug应用 
添加一下、system目录的权限，就能删了
</code></pre><h1 id="adb-启动任意-Activity"><a href="#adb-启动任意-Activity" class="headerlink" title="adb 启动任意 Activity"></a>adb 启动任意 Activity</h1><p>一个应用的不同 Activity 可能需要不同的场景下才能打开，比如6分钟不操作出现的待机页、广播打开的页面等等。某些 Activity 如果想按正常场景步骤下打开会特别麻烦，所以可以借助 adb 命令来打开指定页面，或者发送特点广播。  </p>
<pre><code>adb shell am start -n com.vilyever/com.vilyever.TestActivity  
//启动指定的Activity  

adb shell am start -a android.intent.action.VIEW -d vilyever://testactivity  
//启动隐式的Intent  -d 表示发送的data  </code></pre><p>命令参数的具体解释参考最后附上的链接，或自行网上查找。  </p>
<p>#参考链接<br><a href="http://blog.csdn.net/dabaoonline/article/details/50802952" target="_blank" rel="noopener">ADB连接方式： wifi与usb</a><br><a href="http://www.jianshu.com/p/54fd9627860a" target="_blank" rel="noopener">Andoird开发调试时不修改Manifest直接启动任意Activity的方法</a>  </p>
]]></content>
      <categories>
        <category>Android-TV</category>
      </categories>
  </entry>
  <entry>
    <title>AndroidTv Home界面实现原理（二）——Leanback 库的主页卡位缩放动画源码解析</title>
    <url>/2017/09/04/Android-Tv/AndroidTv-Home%E7%95%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Leanback-%E5%BA%93%E7%9A%84%E4%B8%BB%E9%A1%B5%E5%8D%A1%E4%BD%8D%E7%BC%A9%E6%94%BE%E5%8A%A8%E7%94%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>先看个效果图：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-e4905bba8db493da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图.png"></p>
<p>上一篇中，我们留了问题，在 Tv Home 界面这种很常见聚焦卡位放大动画效果，我们这一篇就来看看 Leanback 库是怎么实现的。  </p>
<p>如果要我们自己实现的话，思路应该不难，就是写个放大、缩小动画，然后在卡位获得焦点时应用放大动画，失去焦点时应用缩小动画，所以关键点只是在于如何进行封装。那下面就来学学 <strong>Google Leanback 库的 ItemView 缩放动画的实现思路。</strong>  </p>
<p>#源码分析<br>看源码时，我习惯带着目的性地去阅读，这样只要专注于理解跟目的相关的代码即可，不用每行代码地去分析，毕竟好多代码目前能力有限，还啃不透。  </p>
<p>那么，我们这次阅读源码的目的就是要搞清楚：<strong>卡位获得焦点时放大、缩小动画是如何实现的？</strong>  </p>
<p><strong>阅读源码时经常会碰到一个问题，那就是该从哪入手，从哪开始看？</strong>  </p>
<p>这就是为什么我习惯带着目的去阅读，因为我们可以从目的分析，猜测我们需要的代码应该在哪里，然后找到我们该从哪里阅读，再一步步的去分析。  </p>
<p>比如我们这次的任务，我们该从哪里入手阅读源码呢？首先，你得先了解一下 Leanback 库的基本使用，这就是为什么我<a href="http://www.jianshu.com/p/e48b4db2b07d" target="_blank" rel="noopener">第一篇博客先简单介绍了 Leanback 库的使用</a>。在上一篇博客里，可以看到，我们跟 Leanback 库打交道的也就是下面这几个类：  </p>
<ul>
<li><strong>ArrayObjectAdapter</strong>：作用类似于 List，装填着整个页面的数据，页面数据其实是分两级，以行为单位和以每一行中的 Item 为单位，所以整个页面有一个 ArrayObjectAdapter(mRowsAdapter) 对象，它由许多行数据 ArrayObjectAdapter(rowAdapter) 对象组成，每行数据 rowAdapter 由许多 Item 组成。初始化一个 ArrayObjectAdapter 对象时，必须提供一个 Presenter 对象与它关联。      </li>
<li><strong>ListRowPresenter</strong>：Leanback 库中的 Presenter 作用都有些类似于 RecyclerView.Adapter，用于创建 ItemView 以及将数据绑定到 ItemView 上。    </li>
<li><strong>ListRow</strong>：可以理解成一个 Mode，也就是把每一行抽象封装成一个 ListRow  </li>
<li><strong>BrowerFragment</strong>：用来展示可左右上下滑动的视频列表界面，Leanback 已高度封装，我们只需提供一个页面的 ArrayObjectAdapter(mRowsAdapter) 对象，通过 <code>setAdapter()</code> 将数据设置进去，Leanback 会自动根据 ArrayObjectAdapter 里的数据以及和它关联的 Presenter 将界面显示出来。    </li>
</ul>
<p>既然我们跟 Leanback 打交道只有这么几点，那么切入点应该就在这些，毕竟我们对 Leanback 并不熟，那么只能从我们接触到的地方来着手。  </p>
<p>那么，再来想想，既然是要实现卡位获得焦点和失去焦点时放大和缩小动画，那么肯定是需要监听 ItemView 的焦点变化，对吧？那我们通常是怎么做的，无外乎就是在 RecyclerView.Adapter 里的 <code>onCreateViewHolder()</code> 或 <code>onBindViewHolder()</code> 里监听 ItemView 的焦点变化吧。  </p>
<p>既然方向有了，那么就是要寻找 Leanback Home 界面对应的 RecyclerView.Adapter 是由哪个类实现的吧。我们也知道了在 Leanback 中 Presenter 的作用就是类似于 RecyclerView.Adapter，那么我们就先到 Presenter 里看一下。   </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-bfa25dac0ead8e70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ListRowPresenter.png"></p>
<p>ListRowPresenter 继承自 RowPresenter 继承自 Presenter，那么我们通过 Android Studio 跳到 Presenter 里看看。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-e5d9d3b3774a571b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Presenter.png"></p>
<p>Presenter 是个抽象类，有三个抽象方法， <code>onCreateViewHolder()、onBindViewHolder()、onUnbindViewHolder()</code>，跟 RecyclerView.Adapter 很像吧。根据我们之前的分析， ItemView 焦点的监听通常是在 <code>onCreateViewHolder()</code> 或 <code>onBindViewHolder()</code> 里实现的，那么我们就去它的实现类 ListRowPresenter 里看一看。  </p>
<p>ListRowPresenter 里找不到这三个方法的实现，那么就是由它的父类 RowPresenter 实现了，我们继续通过 AS 跳到 RowPresenter 里看看。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-44f99bbd6458682b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RowPresenter.onCreateVIewHolder.png">  </p>
<p><code>onCreateViewHolder()</code> 里的代码我们不用去理解，当然你有时间有能力也可以，但现在主要是想搞懂它的卡位缩放动画实现，所以我们只要看有没有跟焦点监听相关的代码即可。很显然，这里面并没有找到，里面调用了几个方法，有些方法一看就知道作用是创建某个对象的，你们也可以点进去看看，这里我们着重看一下 <code>initializeRowViewHolder()</code> 这个方法。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-d3f2d3c674917cc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RowPresenter.initializeRowViewHolder.png"></p>
<p>好像也没找到跟焦点监听的相关代码，但是左边有个标志，说明子类 ListRowPresenter 有复写这个方法，那么代码运行时实际上是调用的之类的方法，那么我们就点进去看看。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-2489b0465dc8509b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ListRowPresenter.initializeRowViewHolder.png"></p>
<p>代码很多，截图也没截完，但是我们发现了一个关键，找到了一个看名字就觉得跟焦点有关的方法 <code>FocusHighlightHelper.setupBrowseItemFocusHighlight()</code>，那么到底是不是呢？我们继续点击去看一下。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-f639ea3bc48c35f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FocusHighlightHelper.setupBrowseItemFocusHighlight.png"></p>
<p>这个方法的介绍大意就是说设置每行的 ItemView 即卡位获得焦点时的行为，这不就是指卡位的缩放动画嘛，看来我们找到了。看代码，是调用了 ItemBridgeAdapter 的 <code>setFocusHighlight()</code> 方法，继续跟进看一下。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-74d52504a0a3de89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ItemBridgeAdapter.setFocusHighlight.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-3f189aa143303b74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ItemBridgeAdapter.png"></p>
<p>方法就只是设置了 mFocusHighlight 变量的值，而 ItemBridgeAdapter 是继承 RecyclerView.Adapter 的，看来卡位的焦点监听就是在这里实现了。看一下 <code>onCreateViewHolder()</code> 方法就知道是不是了。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-f62dfded698ce22a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ItemBridgeAdpater.onCreateViewHolder.png"></p>
<p>presenterView 其实就是在 Presenter 里创建出来的 ItemView，所以这里其实就是对卡位设置焦点的变化监听，viewHolder.mFocusChangeListener 应该是 View.OnFocusChangeListener 的对象，我们看一下。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-13c4d3aef07c3565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewHolder.mFocusChangeListenre.png"></p>
<p>mFocusChangeListener 初始化通过实例化一个类对象赋值，那么这个类应该就是实现 View.OnFocusChangeListener 接口的，我们继续看一下。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-c03816ee664176ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ItemBridgeAdapter.onFocusChangeListener.png"></p>
<p>这下清楚了吧，焦点发生变化时，会去调用 mFcousHightlight 的 <code>onItemFocused()</code> 方法。而 mFcousHightlight 是之前 <code>FocusHighlightHelper.setupBrowseItemFocusHighlight()</code> 里调用了 ItemBridgeAdapter 的 <code>setFocusHighlight()</code> 方法传进来的，我们再看看它传进来的是什么。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-8ab0db29c1a8709a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FocusHighlightHelper.setupBrowseItemFocusHighlight2.png"></p>
<p>看一下 BrowseItemFocusHighlight 这个类做了什么。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-f68721b680b3f6fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OnItemFocused.png"></p>
<p>所以，在 ItemBridgeAdapter 里注册了焦点变化监听，当焦点变化时，通知 mFcousHightlight 执行  <code>onItemFocused()</code> 方法，而 mFcousHightlight 是 BrowseItemFocusHighlight 类的实例，所以实际上是来执行上图里的逻辑。看代码也很容易明白，设置 ItemView 的选中状态，并且去运行一个焦点动画，那么卡位的缩放动画应该就是在这里实现了。继续看一下是不是。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-8b5a86a4b08ea6d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="getOrCreateAnimator.png"></p>
<p>该方法其实就是创建一个动画对象，如果该对象有缓存的话，那么就从缓存中取出，没有的话，就 new 一个，这种缓存的思想很值得学习。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-87e267f9f8d837c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FocusAnimator.png"></p>
<p>该类就是实现了缩放的动画效果了，通过实现 TimeAnimator.TimeListener 接口来实现的属性动画，当然缩放动画也可以用其他方式实现，无非就是对 View 进行放大、缩小而已，这里就不具体去分析了，感兴趣的可以自己来这里看看 Google 是如何实现缩放动画的，后期有时间的话我可以再来分析一下这个类。  </p>
<p>好了，到这里基本就分析完了，Leanback 库关于卡位的缩放动画的实现，从我们要从哪里着手开始阅读源码到找到焦点监听实现的相关代码到动画实现的代码整个过程基本就是这样。以后大家在想看源码的某个功能是如何实现时，可以参考这种思路来进行分析，一步步的去跟进，只找我们目标相关的代码，这样可以不至于被整个源码的复杂性混乱掉。  </p>
<p>最后，我想再总结一下上面的过程。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>卡位缩放动画的实现在类 FocusHighlightHelper 的内部类 FocusAnimator 里实现。  </li>
<li>缩放动画跟 ItemView 的绑定过程：<br>  RowPresenter#onCreateViewHoler()<br>  -&gt; RowPresenter#initializeRowViewHolder()<br>  -&gt; ListRowPresenter#initializeRowViewHolder()<br>  -&gt; FocusHighlightHelper#setupBrowseItemFocusHighlight()<br>  -&gt; ItemBridgeAdapter#setFocusHighlight()  </li>
<li>简单点说就是，当每一行的 View 要创建时，会注册一个焦点监听器，该行里的 ItemView 焦点发生变化时会从 ItemViwe 的 Tag 里取出缩放动画对象，如果没有则 new 一个，然后应用缩放动画。  </li>
</ul>
]]></content>
      <categories>
        <category>Android-TV</category>
      </categories>
  </entry>
  <entry>
    <title>AndroidTv Home界面实现原理（一）——Leanback 库的使用</title>
    <url>/2017/08/31/Android-Tv/AndroidTv-Home%E7%95%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Leanback-%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>接下去应该是梳理一下 Android Tv 主界面实现原理及解析的一个系列博客了，大体上的安排是先介绍 Google 官方提供的 Leanback 库的使用，如何使用该库来实现简单的 Home 界面，然后再去分析 Leanback 主界面实现的相关源码，了解完 Google 是如何实现之后就可以扔掉 Leanback 自己来尝试实现，毕竟 Leanback 的可定制不高。  </p>
<hr>
<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p>首先贴几张常见的 Home 界面效果：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-64f13e93d9d03f25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="爱奇艺主界面.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-fc109dd36197541e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hejunlin2013TVSample.png">  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-f4a6081ada785119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="google sample.png"></p>
<p>第一张是爱奇艺 Tv 应用的 Home 界面，第二张是一个<a href="https://github.com/hejunlin2013/TVSample" target="_blank" rel="noopener">开源 Demo 的 Home 界面</a>，第三张是 <a href="https://github.com/googlesamples/leanback-showcase" target="_blank" rel="noopener">Google 官方 Tv Sample 的 Home 界面</a>。  </p>
<p>比较常见的 Home 界面风格应该是第一张和第二张的形式，这两种的 ui 实现也不一样，因此我就想搞懂这两种界面分别是如何实现的！！  </p>
<p>目前重点研究第一张的实现方式吧，毕竟 Google 的 Leanback 库实现出来的效果跟第一张有一些共同点，因此可以从 Leanback 入手来学习它是如何实现的。而至于第二张的实现原理，目前还没有思路，也暂时找不到相关资料来学习，Github 上面的 demo 都是忽悠人，控件全都是在 xml 中直接写死的，所以第二张图的 Home 界面实现原理以后再慢慢研究吧，或者有读者可以指点一二，非常感激。  </p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>先大概的来分析一下第一张爱奇艺 Home 界面的实现：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-8ea60dcd367acc58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Tab标签栏.png"></p>
<p>这个是 Tab 标签栏，选中不同的 Tab，内容区会显示不同的视频列表，这里的实现应该是 <strong>TabLayout + Fragment</strong> 的形式，或者 <strong>TabLayout + ViewPager</strong>,但 ViewPager 在 Tv 上使用好像会出很多坑。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-c252e89b372c0af2.png" alt="可左右上下滑动的视频列表.png"></p>
<p>这个是内容区域即可左右滑动又可上下滑动的视频列表区域，主页最复杂的实现应该就是这个地方了。要我实现的话，思路就是 <strong>RecyclerView 嵌套 RecyclerView</strong> 来实现，先不谈 RecyclerView 这种滑动的控件在 Tv 上会出问题，嵌套这个坑就足够你填的了。  </p>
<p>在 Tv 上，可以用 <strong>HorizontalGridView 和 VerticalGridView</strong> 替代 <strong>RecyclerView</strong> 使用。但要实现左右单行滑动，上下整体滑动的效果，我只能想到上下用 VerticalGridView 来实现，每一行是它 itemView，而每一行的实现则用 HorizontalGridView 来实现。也就是 <strong>1 个 VerticalGridView + 多个 HorizontalGridView</strong> 来实现。  </p>
<p>但这样的嵌套仍会有许多问题出现，比如快速移动时的焦点丢失、性能问题、每一行的 View 如何缓存、复用等。</p>
<p>有大佬清楚解决方案，或者有其他实现思路的小伙伴们欢迎指点一下，实在没有，那就只能自己慢慢去啃 Leanback 的相关源码，然后再来梳理一下了。  </p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>不出意外，接下去的空闲时间应该就是啃 Leanback Home 界面实现的相关源码，在此之前，先了解一下 Leanback 如何使用，哪些类是重点，后面分析时才方便入手。  </p>
<p>以下是我觉得应该理解的类：  </p>
<ul>
<li><strong>BrowerFragment</strong>：用来展示可左右上下滑动的视频列表界面    </li>
<li><strong>ArrayObjectAdapter</strong>：作用类似于 List，可以用于装每一行的数据，也可以用于装一行里的每一个 item 数据    </li>
<li><strong>ListRowPresenter</strong>：Leanback 库中的 Presenter 作用都有些类似于 RecyclerView.Adapter  </li>
<li><strong>ListRow</strong>：可以理解成一个 Mode，也就是把每一行抽象封装成一个 ListRow  </li>
</ul>
<p>用法跟 RecyclerView 很像，就是可能单独从命名上来理解会有些乱。只要你自己尝试去利用 Leanback 去实现个最简单的 Home 界面，大体就能理解了。比如，要实现下面这个 Home 界面：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-2c5cdd9751777165.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="简单的Home界面.png"></p>
<p>首先，界面显示的数据都存在 ArrayObjectAdapter 里面，在 RecyclerView 时我们是存在 ArrayList 里：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-90269fa003ceafb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="相关代码.png"></p>
<p>初始化 ArrayObjectAdapter 对象时需传入一个 Presenter 进去，这里跟 RecyclerView 的使用有些不同，在 RecyclerView 里，我们是将 List 对象传给 Adapter，让 Adapter 去将数据和 itemView 绑定。这里虽然反过来将 Adapter(Presenter) 传入 List(ArrayObjectAdapter) 里，但其实作用也差不多，也是将两者关联起来。只是多了一个步骤，通过一个桥梁类 ItemBridgeAdapter 来将 ArrayObjectAdapter 里的数据传给 Presenter 。之后 Presenter 的工作就跟 RecyclerView.Adapter 一样了。   </p>
<p>前面说了 Presenter 作用类似于 Adapter，它是个抽象类，继承它的之类需要实现三个方法：<code>onCreateViewHolder()、onBindViewHolder()、onUnbindViewHolder()</code>，同 RecyclerView.Adapter 一样，在 <code>onCreateViewHolder()</code> 里面创建 itemView，然后在 <code>onBindViewHolder()</code> 里面将数据和 itemView 绑定，比如：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-262c7a2b3426bcde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GridItemPresenter.png"></p>
<p>最后调用 BrowerFragment 的 setAdapter() 将总的 ArrayObjectAdapter 对象设置进去，就可以了。使用很简单，如果你第一次接触，然后直接来看这篇，也许看不懂，建议你去看看<a href="http://corochann.com/android-tv-application-hands-on-tutorial-2-85.html" target="_blank" rel="noopener">这篇博客</a>，或者自己去看一下 <a href="https://github.com/googlesamples/leanback-showcase" target="_blank" rel="noopener">Google 官方的 Tv demo</a>，然后再回来看，相信你理解就会跟深刻了。  </p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol>
<li><p>学会初步使用 Leanback 实现一个简单的 Home 界面后，你会发现，我们只需要提供每一行的数据，以及每行自己 itemView 的布局和数据绑定方式即可。但这完全没有涉及到 HorizontalGridView 和 VerticalGridView ，那么它内部的实现原理又是什么呢？  </p>
</li>
<li><p>如果你运行了 Google 官方 Tv sample 或者自己利用 Leanback 实现了简单的 Home 界面的话，你会发现，我们焦点在某个 item 上时，这个 item 会放大，焦点离开又恢复正常，这个 Leacback 又是怎么实现的呢？  </p>
</li>
<li><p>如果你运行了爱奇艺的 Tv 应用，你会发现，它焦点在移动到边界时 item 会有抖动的效果，这又要如何实现呢？  </p>
</li>
</ol>
<p>本系列梳理博客大概就是要理清上面的问题，后两个比较简单，看了 Leanback 的源码，已基本明白。所以难啃的点还是在于 Home 界面的 ui 实现原理，目前只能大体上明白每一行是一个 HorizontalGridView，上下滑动是由什么实现还没啃透。下一篇等啃得差不多了，再来梳理一下。     </p>
]]></content>
      <categories>
        <category>Android-TV</category>
      </categories>
  </entry>
  <entry>
    <title>Android KeyEvent 点击事件分发处理流程（一）</title>
    <url>/2017/08/21/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Android-KeyEvent-%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 安卓巴士Android开发者门户 独家发布</strong>  </p>
</blockquote>
<p>这次打算来梳理一下 Android Tv 中的按键点击事件 KeyEvent 的分发处理流程。一谈到点击事件机制，网上资料已经非常齐全了，像什么分发、拦截、处理三大流程啊；或者<br> dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent 啊；再或者返回 true 表示消费，返回 false 不处理啊；还有说整个流程是个 U 型分发处理，什么总经理发布任务到员工处理反馈啊之类的。前辈们早已为我们梳理了一篇篇干货，也在尽可能的写得通俗、易懂。  </p>
<p>但是今天这篇的主题是：<strong>KeyEvent 的分发处理流程</strong><br>说得明白点就是：Tv 上的遥控器按键的点击事件分发处理流程，也许你还没反应过来。想想，手机上都是触屏点击事件，而遥控器则是按键点击事件，两种事件类型的分发处理机制自然有所不同，所以，如果不搞清楚这点，很容易在 Tv 应用开发中将这两类事件分发机制混淆起来。  </p>
<p>最简单的区别就是，在 Tv 开发中已经不是再像触屏手机那样通过 dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent 来分发处理了，取而代之的则是需要使用 <strong>dispatchKeyEvent、onKeyDown/Up、onKeyLisenter</strong> 等来分发处理。  </p>
<p>#流程<br><img src="http://upload-images.jianshu.io/upload_images/1924341-38bcb57fa4617d95.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatchKeyEvent事件分发传递流程图.jpg"></p>
<p>这次梳理的就只是 KeyEvent 在一个 View 树内部的分发处理流程，简单点说，也就是，你在某个 Activity 界面点击了遥控器的某个按键，然后这个按键事件在当前这个 Activity 里是如何分发处理的。  </p>
<p><strong>流程图涉及的主要方法和类：</strong>  </p>
<ol>
<li>(PhoneWindow$)DecorView  -&gt;  dispatchKeyEvent()  </li>
<li>Activity                 -&gt;  dispatchKeyEvent()  </li>
<li>ViewGroup                -&gt;  dispatchKeyEvent()  </li>
<li>View                     -&gt;  dispatchKeyEvent()  </li>
<li>KeyEvent                 -&gt;  dispatch()  </li>
<li>View                     -&gt;  onKeyDown/Up()  </li>
</ol>
<p>硬件层、框架层那些按键事件的获取、分发、处理太深奥了，啃不透。应用层的一部分事件分发流程也还暂时没啃透，这次梳理的是在一个 View 树内部的分发处理流程。    </p>
<p>#流程解析  </p>
<p>ps:当我们在某个 Activity 界面中点击了某个遥控器按键时，会有 Action_Down 和 Action_Up 两个 KeyEvent 进行分发处理，分发流程都一样，区别就是最后交给 Activity 或 View 的 onKeyDown 或 onKeyUp 处理。  </p>
<p>###分发流程  </p>
<ol>
<li><p>当接收到 KeyEvent 事件时，首先是交给  (PhoneWindow$)DecorView 的 dispatchKeyEvent() 分发，而 DecorView 会去调用 Activity 的 dispatchKeyEvent()，交给 Activity 继续分发。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-7a0b2f1a106bc1b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DecorView_dispatchKeyEvent.png"></p>
</li>
<li><p>Activity 会先获取 PhoneWindow 对象，然后调用 PhoneWindow 的 superDispatchKeyEvent()，PhoneWindow 转而调用 DecorView 的 superDispatchKeyEvent()，而 DecorView 则调用了 super.dispatchKeyEvent() 将事件交给父类分发， DecorView 继承自 FrameLayout，但 FrameLayout 没有实现 dispatchKeyEvent()，所以实际上是交给 ViewGroup 的 dispatchKeyEvent() 来分发。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-e8cc5298a223bc27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="activity_dispatchKeyEvent.png"><br><img src="http://upload-images.jianshu.io/upload_images/1924341-c9aa9cc3b8e47f80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PhoneWindow_superDispatchKeyEvent.png"><br><img src="http://upload-images.jianshu.io/upload_images/1924341-5b9e0fe8a8010f4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DecorView_superDispatchKeyEvent.png"></p>
</li>
<li><p>ViewGroup 分发的逻辑我还不大理解，不过大体上知道 ViewGroup 递归寻找当前焦点的子 View，将事件传给焦点子 View 的 dispatchKeyEvent() 分发，具体是如何递归寻找的这部分代码待研究。  </p>
</li>
<li><p>以上就是一个 KeyEvent 事件的分发流程，跟触屏手机事件传递有些不同的是，如果你没重写以上分发事件的相关类的相关分发方法的话，一个 KeyEvent 事件是肯定会从顶层 DecorView 分发到具体的子 View 的，因为它并没有像 onInterceptTouchEvent 这种在某一层拦截的操作。  </p>
</li>
</ol>
<p>###处理流程  </p>
<p>ps:KeyEvent 事件的处理只有两个地方，一个是 Activity，另一个则是具体的 View。ViewGroup 只负责分发，不会消耗事件。同 TouchEvent 一样，返回 true 表示事件已消耗掉，返回 false 则表示事件还在。  </p>
<ol>
<li><p>当 KeyEvent 事件分到到具体的子 View 的 dispatchKeyEvent() 里时，View 会先去看下有没有设置 OnKeyListener 监听器，有则回调 OnKeyListener.onKey() 方法来处理事件。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-d63452ae450624d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="view_dispatchKeyEvent.png"></p>
</li>
<li><p>如果 View 没有设置 OnKeyListener 或者 onKey() 返回 false 时，View 会通过调用 KeyEvent 的 dispatch() 方法来回调 View 自己的 onKeyDown/Up() 来处理事件。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-1b8369d45a89999c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="keyEvent_dispatch.png"></p>
</li>
<li><p>如果没有重写 View 的 onKeyUp 方法，而且事件是 ok（确认）按键的 Action_Up 事件时，View 会再去检查看是否有设置 OnClickListener 监听器，有则调用 OnClickListener.onClick() 来<strong>消费事件</strong>，注意是消费，也就是说如果有对 View 设置 OnClickListener 监听器的话，而且事件没有在上面两个步骤中消费掉的话，那么就一定会在 onClick() 中被消耗掉，OnClickListener.onClick() 虽然并没有 boolean 返回值，但是 View 在内部 dispatchKeyEvent() 里分发事件给 onClick 时已经默认返回 true 表示事件被消耗掉了。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-ea943b9f519aecea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View_onKeyUp.png"></p>
</li>
<li><p>如果 View 没有处理事件，也就是没有设置 OnKeyListener 也没有设置 OnClickListener，而且 onKeyDown/Up() 返回的是 false 时，将会通过分发事件的原路返回告知 Activity 当前事件还未被消耗，Activity 接收到 ViewGroup 返回的 false 消息时就会去通过 KeyEvent 的 dispatch() 来调用 Activity 自己的 onKeyDown/Up() 事件，将事件交给 Activity 自己处理。这就是我们常见的在 Activity 里重写 onKeyDown/Up() 来处理点击事件，但注意，这里的处理是最后才会接收到的，所以很有可能事件在到达这里之前就被消耗掉了。  </p>
</li>
</ol>
<p>###小结  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-7ae1780f9b29d3da.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatchKeyEvent事件分发传递流程图_LI.jpg"></p>
<p>整体的分发处理流程就如上图（手抖了，不然是直线的）所示，有些较重要的点我们可以来总结下：  </p>
<ol>
<li><p>如果对 DecorView 不大了解，那么可以只侧重我们较常接触的点，如 Activity、 ViewGroup、 View，基于此：    </p>
</li>
<li><p>事件分发：Activity 最先拿到 KeyEvent 事件，但没办法拦截自己处理（这里你们肯定有反对意见，我下面解释），然后将事件分发给 ViewGroup，而 ViewGroup 就只能是递归不断的分发给子 View，事件绝不会在 ViewGroup 中被消耗掉的，最后子 View 接收到事件，分发流程结束，开始事件的处理。  </p>
</li>
<li><p>事件处理：只有 Activity 和 View 能处理事件，View 根据情况选择是在 OnKeyListener、 OnClickListener 还是在 onKeyDown/Up() 里处理，Activity 只能在 onKeyDown/Up() 里处理。  </p>
</li>
<li><p>事件处理归纳一下其实就是四个地方，按处理顺序排列如下：View 的 OnKeyListener.onKey()、onKeyDown/Up()、 OnClickListener.onClick()、  Activity 的 onKeyDown/Up()。一旦在四个地方的某处，事件被消耗了，也就是返回 true 了，事件将不会传递到后面的处理方法中去了。 </p>
</li>
</ol>
<p><strong>为什么我说 Activity 不能拦截事件交由自己处理呢？</strong><br>在触屏的 TouchEvent 点击事件机制中，我们可以通过重写 onInterceptTouchEvent() 返回 true 来停止拦截事件的分发并自己处理事件，但在 KeyEvent 中并没有这个方法，所以如果 dispatchKeyEvent() 只干事件分发的事，事件处理都在 onKeyDwon/Up、onKey()、onClick() 中完成，这样的话，Activity 确实没办法拦截事件分发交由自己的 onKeyDown/Up() 来处理。  </p>
<p>但谁规定 dispatchKeyEvent() 只能干事件传递的事呢，所以理论上按标准来说，Activity 无法拦截事件分发自己处理，但实际编程中，我经常碰见有人在 Activity 里重写 dispatchKeyEvent() 来处理事件，然后让其返回 true 或 false，停止事件的分发。  </p>
<p>#使用场景<br>KeyEvent 事件的分发处理流程大体上知道是怎么走的就行了，有兴趣的可以再去看看源码，然后自己画画流程图，就会更明白了。先把分发处理流程梳理清楚了，我们才知道该怎么用，怎么去重写分发处理的方法，下面就讲些使用场景：  </p>
<p><strong>1. 在 Activity 里重写 dispatchKeyEvent()—-最常用</strong><br>举个栗子：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-47ef9644e3e7017e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="homeActivity_dispatchKeyEvent.png"></p>
<p>这在 Tv 开发中是很常见的，经常会在 Activity 里重写 dispatchKeyEvent()，然后要么去预先处理一些工作，要么就是对特定的按键进行拦截。  </p>
<p><strong>上面这段代码能看懂么？</strong>如果你已经清楚这代码是对左右方向按键的拦截，那么你清楚各种 return 的作用么，为什么又有 return true，又有 return false，还有 return super.dispatchKeyEvent() 的？  </p>
<p>先说结论：这里的 return true 和 return false 都能起到按键拦截的作用，也就是子 View 不会接收到事件的分发或处理，Activity 的 onKeyDown/Up() 也不会收到任何消息。  </p>
<p>要明白这点，先得搞清楚什么是 return， return 是返回的意思，什么情况下需要返回，不就是调用你的那个方法需要你给个反馈，所以 return 的消息是给上一级的调用者的，所以 return 只会对上一级的调用者的行为有影响。调用 Activity.dispatchKeyEvent() 的是 DecorView 的 dispatchKeyEvent() 里，如下图：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-7e4a605ee70b57ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DecorView_dispatchKeyEvent行为.png"></p>
<p>那么，<strong>既然 Activity 返回 true 或 false 都只对 DecorView 的行为有影响，那么为什么都能起到拦截事件分发的作用呢</strong>？  </p>
<p>这是因为，事件的分发逻辑其实是在 Activity.java 的 dispatchKeyEvent() 里实现的，如果你重写了 Activity 的 dispatchKeyEvent() 方法，那么根据<br> Java 的特性程序就会执行你写的 dispatchKeyEvent()，而不会执行基类 Activity.java 的方法，因此你在重写的方法里没有自己实现事件的分发逻辑，事件当然就停止分发了啊。这也是为什么返回 super.dispatchKeyEvent() 时事件会继续分发，因为这最终会调用到基类 Activity.java 的 dispatchKeyEvent() 方法来执行事件分发的逻辑。  </p>
<p><strong>既然在 Activity 里返回 true 或 false 都表示拦截，那么有什么区别么？</strong>  </p>
<p>当然有，因为会影响 DecorView 的行为，比如我们点击遥控器的方向键时界面上的焦点会跟随着移动，这部分逻辑其实是在 DecorView 的上一级调用者中实现的，Activity 返回 true 的话，会导致 DecorView 也返回 true，那么上一级将根据 DecorView 返回 true 的结果停止焦点的移动，这就是我们常见的在 Activity 里重写 dispatchKeyEvent() 返回 true 来实现停止焦点移动的原理。那么，如果 Activity 返回的是 false，DecorView 也跟随着返回 false，那么上一级会继续执行焦点移动的逻辑，表现出来的效果就是，界面上的焦点仍然会移动，但不会触发 Activity 和 View 的事件分发和处理方法，因为已经被 Activity 拦截掉了。  </p>
<p>最后，还有一个问题，<strong>在 View 或 ViewGroup 里面重写 dispatchKeyEvent() 作用会跟 Activity 一样么？</strong>  </p>
<p>return true 或 false 或 super 的含义还是一样的，但这里要明白一个层次结构。上层：Activity，中层：ViewGroup，下层：View。  </p>
<p>不管在哪一层重写 dispatchKeyEvent()，如果返回　true 或 false，那么它下层包括它本层都不会接收到事件的分发处理，但是它的上层会接收。因为拦截的效果只作用于该层及下层，而上层只会根据你返回的值，行为受到影响。  </p>
<p>比如在 ViewGroup 中返回　true，Activity 的 onKeyDown/Up() 就不会被触发，因为被消费了；如果返回　false，那么事件就交由 Activity 处理。但不管返回 true 或 false，子 View 的 dispatchKeyEvent()、各种 onClick() 等事件处理方法都不会被触发到了。    </p>
<p><strong>2. 在 Activity 里重写 onKeyDown/Up()—-最常用</strong><br>事件能走到这里表示没有被子 View 消费掉，这里是我们能接触到的层次里面最后对事件进行处理的地方。而且就算我们在这里做了一些工作，也没有必要一定要返回 true。比如如果是方向键事件的话，你在这里返回 true 会影响到上级停止焦点的移动，所以视情况而定。  </p>
<p><strong>3. 为某个具体的 View (如 TextView) 设置 OnKeyListener()—-一般常用</strong><br>这个应该也挺常见的，在 Activity 里获取某个控件的对象，然后设置点击事件监听，然后去做一些事。</p>
<p><strong>4. 为某个具体的 View (如 Button) 设置 OnClickListener()—-一般常用</strong><br>这个应该是更常见的了，setOnClickListener，很多场景都需要监听某个控件的点击事件，明确一点就是：该监听器监听的是 ok（确认）键的 Action_Up 事件。</p>
<p><strong>小结一下：</strong>  </p>
<ol>
<li><p>dispatchKeyEvent(): 比较常见的是在 Activity 或自定义的 ViewGroup 类型控件里面重写该方法，有时是需要在事件开始分发前预处理一些工作，有时则是需要对特定按键进行拦截，注意一下拦截的作用域以及各种 return 值的作用即可。通常情况下，都会含有 return super，因为我们没有必要对所有按键都进行拦截，有些按键仍旧需要继续分发处理，因为 Android 系统默认对很多特殊按键都进行了处理。    </p>
</li>
<li><p>明确 super 的含义，重写的方法一般都会执行一下默认的逻辑工作，比如 dispatchKeyEvent 执行事件的分发，重写的时候注意是否还需要使用父类的逻辑即可。  </p>
</li>
</ol>
<p>#遗留问题  </p>
<ol>
<li><p>每次按键点击都会有 Action_Down 和 Action_Up 两次事件，目前遇到这样的场景，从 Activity A 打开 Activity B，Action_Down 和 Action_Up 会在 Activity A 中分发处理，然后 Action_Up 又会在 Activity B 中分发处理。<br>最开始的想法 Activity A 将 Action_Up 事件传递给 Activity B 进行处理，但是在 Activity A 中将 Action_Up 先消费掉即返回 true，发现 Activity B 中仍然会重新分发处理 Action_Up 事件。因此，目前对于 KeyEvent 事件在两个 Activity 中是如何分发传递的还不大了解，这部分内容应该是在 ViewRootImpl 和 PhoneWindow 中，计划下一篇就来梳理这部分内容。  </p>
</li>
<li><p>Tv 开发中最重要也让人头疼的就是焦点问题，通过遥控器方向键点击后可以控制焦点的移动，有时需要根据需求来控制焦点，比如我们经常做的就是在焦点到达边界时重写 dispatchKeyEvent 里返回 true 来停止焦点的移动，为什么可以这么做呢？其实这部分内容也在 DecorView 的 dispatchKeyEvent 里，DecorView 在高的 SDK 里已经抽出来单独一个类了，如果没找到，那么就去 PhoneWindow 里找，旧的 SDK 里，DecorView 是 PhoneWindow 的内部类，这部分内容也留着下次一起梳理吧。  </p>
</li>
</ol>
<p>#参考<br><a href="http://www.imooc.com/article/12664" target="_blank" rel="noopener">Android View框架总结（九）KeyEvent事件分发机制</a><br><a href="http://blog.csdn.net/cheris_cheris/article/details/53290625" target="_blank" rel="noopener">Android按键事件传递流程(二)</a>  </p>
]]></content>
      <categories>
        <category>Android源码解析</category>
      </categories>
  </entry>
  <entry>
    <title>【Android】又一个Gank客户端来啦</title>
    <url>/2017/06/01/Android%E9%A1%B9%E7%9B%AE/%E3%80%90Android%E3%80%91%E5%8F%88%E4%B8%80%E4%B8%AAGank%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9D%A5%E5%95%A6/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<h1 id="老规矩，看效果"><a href="#老规矩，看效果" class="headerlink" title="老规矩，看效果"></a>老规矩，看效果</h1><p><img src="http://upload-images.jianshu.io/upload_images/1924341-c995e84d73dad40b..gif?imageMogr2/auto-orient/strip" alt="image">  </p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Gank平台的移动端又来了，非常感谢Gank平台开放接口，让我们这些小白有机会练手、学习。  </p>
<p>本项目在架构方面有稍微花点心思，虽然还是最简单的MVC模式，但基本参考MVP的思想，Activity只负责ui显示逻辑，ui和业务会尽量的分离开，每个包的类权限严格控制，尽量对外部隐藏其实现细节。另外，本项目不像其他热门的Gank客户端那样使用诸如Rx系列的高级开源库，代码应该是可以很容易看懂的，吧。哈哈，有兴趣的可以fork看看，有什么问题可以联系我哈。  </p>
<p>以下是项目所依赖的第三方库：</p>
<ul>
<li>Retrofit + Okhttp （网络访问）   </li>
<li>Gson （Json数据解析）  </li>
<li>Glide （图片加载）  </li>
<li>photoview （支持手势缩放的图片查看）  </li>
<li>Jsoup （Html解析）</li>
</ul>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p><a href="https://github.com/woshidasusu/Meizi" target="_blank" rel="noopener">Github地址</a>  </p>
<p>下图是项目的代码结构图，我分成mode层和ui层，让ui与业务逻辑尽可能解耦，感兴趣的clone项目看看哈，架构方面才刚接触，很多地方考虑不周到，欢迎指点一下哈。过段时间，我会单独写篇博客来介绍项目的架构设计方面的一些想法。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-f7fee7ed9f3c98e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目代码结构图"></p>
<p>如果有clone项目的童鞋，出现了编译失败的问题，可以参考下本项目的开发环境哈：  </p>
<ul>
<li>Android Studio： 2.2.3  </li>
<li>Gradle Version： 2.14.1  </li>
<li>Android Plugin Version： 2.2.3 （根目录build.gradle里gradle的版本）  </li>
<li>compileSdkVersion： 25  </li>
<li>buildToolsVersion： “25.0.2”  </li>
</ul>
<p>以上设置在两个build.gradle里都可以找到。  </p>
<p>如果把代码下载到本地编译报错的话，有可能是因为gradle的版本不一致，也有可能是因为Android SDK的版本问题，如果有报错的童鞋试着在这几个地方查查看哈。  </p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>效果只展示了部分效果，感兴趣的可以去我Github看看更详细的，或者是下载下来试试看哈。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-d1e34d693d8bb058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果展示"></p>
<h1 id="App下载"><a href="#App下载" class="headerlink" title="App下载"></a>App下载</h1><p><a href="http://fir.im/dasugankhuo" target="_blank" rel="noopener">Fir</a>  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-760b8778b1b635b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="扫一下下载App">  </p>
<h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p><a href="https://github.com/drakeet/Meizhi" target="_blank" rel="noopener">drakeet</a>  </p>
<p><a href="https://github.com/CaMnter/EasyGank" target="_blank" rel="noopener">CaMnter</a>  </p>
<p><a href="https://github.com/burgessjp/GanHuoIO" target="_blank" rel="noopener">burgessjp</a>  </p>
]]></content>
      <categories>
        <category>Android项目</category>
      </categories>
  </entry>
  <entry>
    <title>【Android】再来一篇Fragment的懒加载（只加载一次哦）</title>
    <url>/2017/04/21/Android%E7%9F%A5%E8%AF%86/%E3%80%90Android%E3%80%91%E5%86%8D%E6%9D%A5%E4%B8%80%E7%AF%87Fragment%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%88%E5%8F%AA%E5%8A%A0%E8%BD%BD%E4%B8%80%E6%AC%A1%E5%93%A6%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>#使用前需知<br><strong>2017-7-14更新：</strong>  目前有人使用后出现了诸如首次打开显示空白界面，但点击有反应；或来回切换又变空白界面的问题。这些问题我暂时还不知道该怎么解决，后期有时间时会具体去分析下问题该怎么解决。所以你如果要使用该代码，希望考虑一下，我自己的小应用目前是没碰到这些问题。  </p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>老规矩，先来看看效果图<br><img src="http://upload-images.jianshu.io/upload_images/1924341-d8d1c58ef46e08e6.gif?imageMogr2/auto-orient/strip" alt="演示">  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-b436975d9592cfcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="log"></p>
<p>没错，我又入坑了，又重新做了个 Gank 客户端，因为之前那个代码写得太烂了，这次有好好的考虑了下架构之类的事，代码应该会更容易读懂了点了，吧。哈哈，再次欢迎来 star 交流哈。  </p>
<p>上面的截图里有注释解析了，稍微认真点看看 log 的内容哈，看看是不是你需要的需求。  </p>
<h1 id="Fragment懒加载"><a href="#Fragment懒加载" class="headerlink" title="Fragment懒加载"></a>Fragment懒加载</h1><p>如果想直接看代码，直接跳到最下面的代码部分和使用介绍即可，如果感兴趣，可以慢慢往下看看我的唠叨。  </p>
<p>之前写过一篇 <a href="http://www.jianshu.com/p/311c7ffdb85b" target="_blank" rel="noopener">Fragment懒加载和ViewPager的坑</a>，里面分析了 Fragment 结合 ViewPager 使用时会碰到的一些情况，以及为什么要用懒加载，如何用，感兴趣的也可以再回去看看。  </p>
<p>后来发现，我在那篇博客里封装的 Fragment 基类不足以满足大家的懒加载需求，所以决定重新来封装一次，这次封装的支持以下的功能：  </p>
<h4 id="1-支持数据的懒加载并且只加载一次"><a href="#1-支持数据的懒加载并且只加载一次" class="headerlink" title="1.支持数据的懒加载并且只加载一次"></a>1.支持数据的懒加载并且只加载一次</h4><h4 id="2-提供-Fragment-可见与不可见时回调，支持你在这里进行一些-ui-操作，如显示-隐藏加载框"><a href="#2-提供-Fragment-可见与不可见时回调，支持你在这里进行一些-ui-操作，如显示-隐藏加载框" class="headerlink" title="2.提供 Fragment 可见与不可见时回调，支持你在这里进行一些 ui 操作，如显示/隐藏加载框"></a>2.提供 Fragment 可见与不可见时回调，支持你在这里进行一些 ui 操作，如显示/隐藏加载框</h4><h4 id="3-支持-view-的复用，防止与-ViewPager-使用时出现重复创建-view-的问题"><a href="#3-支持-view-的复用，防止与-ViewPager-使用时出现重复创建-view-的问题" class="headerlink" title="3.支持 view 的复用，防止与 ViewPager 使用时出现重复创建 view 的问题"></a>3.支持 view 的复用，防止与 ViewPager 使用时出现重复创建 view 的问题</h4><p>第一点应该是比较需要且常用的一点，之前那篇博客里没有考虑到这点应用场景是我的疏忽。稍微讲解一下，有些时候，我们打开一个 Fragment 页面时，希望它是在可见时才去加载数据，也就是不要在后台就开始加载数据，而且，我们也希望加载数据的操作只是第一次打开该 Fragment 时才进行的操作，以后如果再重新打开该 Fragment 的话，就不要再重复的去加载数据了。  </p>
<p>具体点说，Fragment 和 ViewPager 一起用时，由于 ViewPager 的缓存机制，在打开一个 Fragment 时，它旁边的几个 Fragment 其实也已经被创建了，如果我们是在 Fragment 的 <code>onCreat()</code> 或者 <code>onCreateView()</code> 里去跟服务器交互，下载界面数据，那么这时这些已经被创建的 Fragment，就都会出现在后台下载数据的情况了。所以我们通常需要在 <code>setUserVisibleHint()</code> 里去判断当前 Fragment 是否可见，可见时再去下载数据，但是这样还是会出现一个问题，就是每次可见时都会重复去下载数据，我们希望的是只有第一次可见时才需要去下载，那么就还需要再做一些判断。这就是要封装个基类来做这些事了，具体代码见后面。  </p>
<p>即使我们在 <code>setUserVisibleHint()</code> 做了很多判断，实现了可见时加载并且只有第一次可见时才加载，可能还是会遇到其他问题。比如说，我下载完数据就直接需要对 ui 进行操作，将数据展示出来，但有时却报了 ui 控件 null 异常，这是因为 <code>setUserVisibleHint()</code> 有可能在 <code>onCreateView()</code> 创建 view 之前调用，而且数据加载时间很短，这就可能出现 null 异常了，那么我们还需要再去做些判断，保证在数据下载完后 ui 控件已经创建完成。  </p>
<p>除了懒加载，只加载一次的需求外，可能我们还需要每次 Fragment 的打开或关闭时显示数据加载进度。对吧，我们打开一个 Fragment 时，如果数据还没下载完，那么应该给个下载进度或者加载框提示，如果这个时候打开了新的 Fragment 页面，然后又重新返回时，如果数据还没加载完，那么也还应该继续给提示，对吧。这就需要有个 Fragment 可见与不可见时触发的回调方法，并且该方法还得保证是在 view 创建完后才触发的，这样才能支持对 ui 进行操作。  </p>
<p>以上，就是我们封装的 BaseFragment 基类要干的活了。下面上代码。  </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>
/**
 * Created by dasu on 2016/9/27.
 *
 * Fragment基类，封装了懒加载的实现
 *
 * 1、Viewpager + Fragment情况下，fragment的生命周期因Viewpager的缓存机制而失去了具体意义
 * 该抽象类自定义新的回调方法，当fragment可见状态改变时会触发的回调方法，和 Fragment 第一次可见时会回调的方法
 *
 * @see #onFragmentVisibleChange(boolean)
 * @see #onFragmentFirstVisible()
 */
public abstract class BaseFragment extends Fragment {

    private static final String TAG = BaseFragment.class.getSimpleName();

    private boolean isFragmentVisible;
    private boolean isReuseView;
    private boolean isFirstVisible;
    private View rootView;


    //setUserVisibleHint()在Fragment创建时会先被调用一次，传入isVisibleToUser = false
    //如果当前Fragment可见，那么setUserVisibleHint()会再次被调用一次，传入isVisibleToUser = true
    //如果Fragment从可见-&gt;不可见，那么setUserVisibleHint()也会被调用，传入isVisibleToUser = false
    //总结：setUserVisibleHint()除了Fragment的可见状态发生变化时会被回调外，在new Fragment()时也会被回调
    //如果我们需要在 Fragment 可见与不可见时干点事，用这个的话就会有多余的回调了，那么就需要重新封装一个
    @Override
    public void setUserVisibleHint(boolean isVisibleToUser) {
        super.setUserVisibleHint(isVisibleToUser);
        //setUserVisibleHint()有可能在fragment的生命周期外被调用
        if (rootView == null) {
            return;
        }
        if (isFirstVisible &amp;&amp; isVisibleToUser) {
            onFragmentFirstVisible();
            isFirstVisible = false;
        }
        if (isVisibleToUser) {
            onFragmentVisibleChange(true);
            isFragmentVisible = true;
            return;
        }
        if (isFragmentVisible) {
            isFragmentVisible = false;
            onFragmentVisibleChange(false);
        }
    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        initVariable();
    }

    @Override
    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        //如果setUserVisibleHint()在rootView创建前调用时，那么
        //就等到rootView创建完后才回调onFragmentVisibleChange(true)
        //保证onFragmentVisibleChange()的回调发生在rootView创建完成之后，以便支持ui操作
        if (rootView == null) {
            rootView = view;
            if (getUserVisibleHint()) {
                if (isFirstVisible) {
                    onFragmentFirstVisible();
                    isFirstVisible = false;
                }
                onFragmentVisibleChange(true);
                isFragmentVisible = true;
            }
        }
        super.onViewCreated(isReuseView ? rootView : view, savedInstanceState);
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        initVariable();
    }

    private void initVariable() {
        isFirstVisible = true;
        isFragmentVisible = false;
        rootView = null;
        isReuseView = true;
    }

    /**
     * 设置是否使用 view 的复用，默认开启
     * view 的复用是指，ViewPager 在销毁和重建 Fragment 时会不断调用 onCreateView() -&gt; onDestroyView() 
     * 之间的生命函数，这样可能会出现重复创建 view 的情况，导致界面上显示多个相同的 Fragment
     * view 的复用其实就是指保存第一次创建的 view，后面再 onCreateView() 时直接返回第一次创建的 view
     *
     * @param isReuse
     */
    protected void reuseView(boolean isReuse) {
        isReuseView = isReuse;
    }

    /**
     * 去除setUserVisibleHint()多余的回调场景，保证只有当fragment可见状态发生变化时才回调
     * 回调时机在view创建完后，所以支持ui操作，解决在setUserVisibleHint()里进行ui操作有可能报null异常的问题
     *
     * 可在该回调方法里进行一些ui显示与隐藏，比如加载框的显示和隐藏
     *
     * @param isVisible true  不可见 -&gt; 可见
     *                  false 可见  -&gt; 不可见
     */
    protected void onFragmentVisibleChange(boolean isVisible) {

    }

    /**
     * 在fragment首次可见时回调，可在这里进行加载数据，保证只在第一次打开Fragment时才会加载数据，
     * 这样就可以防止每次进入都重复加载数据
     * 该方法会在 onFragmentVisibleChange() 之前调用，所以第一次打开时，可以用一个全局变量表示数据下载状态，
     * 然后在该方法内将状态设置为下载状态，接着去执行下载的任务
     * 最后在 onFragmentVisibleChange() 里根据数据下载状态来控制下载进度ui控件的显示与隐藏
     */
    protected void onFragmentFirstVisible() {

    }

    protected boolean isFragmentVisible() {
        return isFragmentVisible;
    }
}

</code></pre><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>使用很简单，新建你需要的 Fragment 类继承自该 BaseFragment，然后重写两个回调方法，根据你的需要在回调方法里进行相应的操作比如下载数据等即可。<br>例如：  </p>
<pre><code>public class CategoryFragment extends BaseFragment {
    private static final String TAG = CategoryFragment.class.getSimpleName();

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_category, container, false);
        initView(view);
        return view;
    }

    @Override
    protected void onFragmentVisibleChange(boolean isVisible) {
        if (isVisible) {
            //更新界面数据，如果数据还在下载中，就显示加载框
            notifyDataSetChanged();
            if (mRefreshState == STATE_REFRESHING) {
                mRefreshListener.onRefreshing();
            }
        } else {
            //关闭加载框
            mRefreshListener.onRefreshFinish();
        }
    }

    @Override
    protected void onFragmentFirstVisible() {
        //去服务器下载数据
        mRefreshState = STATE_REFRESHING;
        mCategoryController.loadBaseData();
    }
}

</code></pre><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol>
<li><p>如果想要让 fragment 的布局复用成功，需要重写 viewpager 的适配器里的 <code>destroyItem()</code> 方法，将 super 去掉，也就是不销毁 view。  </p>
</li>
<li><p>如果出现切换回来或不相邻的Tab切换时导致空白界面的问题，解决方法：在 onCreateView中复用布局 + ViewPager 的适配器中复写 destroyItem() 方法去掉 super。  </p>
</li>
</ol>
<hr>
<p>最后，继续不要脸的贴上我最近在做的 Gank 客户端的项目地址啦，项目没引入什么高级的库，都是用的最基本的代码实现的，项目也按模块来划分，也尽可能的实现ui和逻辑的划分，各模块也严格控制权限，尽量让模块之间，类之间的耦合减少些，之所以这样是为了后面更深入理解mvp做准备，总之，代码应该还是很容易可以看懂的吧，欢迎大家star交流。  </p>
<p><a href="https://github.com/woshidasusu/GanHuo" target="_blank" rel="noopener">GanHuo:https://github.com/woshidasusu/GanHuo</a><br><a href="https://github.com/woshidasusu/Meizi" target="_blank" rel="noopener">Meizi:https://github.com/woshidasusu/Meizi</a><br><img src="http://upload-images.jianshu.io/upload_images/1924341-a714b2a5fd9ff169.gif?imageMogr2/auto-orient/strip" alt="GanHuo">  </p>
]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>【Android】TextView的文字长度测量及各种padding解析</title>
    <url>/2017/03/22/Android%E7%9F%A5%E8%AF%86/%E3%80%90Android%E3%80%91TextView%E7%9A%84%E6%96%87%E5%AD%97%E9%95%BF%E5%BA%A6%E6%B5%8B%E9%87%8F%E5%8F%8A%E5%90%84%E7%A7%8Dpadding%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 安卓巴士Android开发者门户 独家发布</strong>  </p>
</blockquote>
<p>老规矩，先上张图<br>o，这篇好像是分析篇，没有效果图。不管了，位置占着，老规矩不能坏，下面开始正文。  </p>
<hr>
<p>这篇博客会讲得比较杂：</p>
<blockquote>
<ol>
<li>TextView里各种padding的含义?  </li>
<li>如何计算每行文字的长度?  </li>
<li>设置android:maxLines=”1”和android:singleLine=”true”有什么区别?  </li>
<li>为什么设置android:maxLines=”1”时TextView的跑马灯效果就不能正常工作？    </li>
</ol>
</blockquote>
<h1 id="TextView里各种padding的含义"><a href="#TextView里各种padding的含义" class="headerlink" title="TextView里各种padding的含义?"></a>TextView里各种padding的含义?</h1><p>虽然我们平时只用TextView显示纯文本数据，但其实TextView支持设置Background,四周的drawable小图标，以及Span数据比如文本或图片。在Android里不管是什么控件都是占据一个矩形的空间，各个矩形之间基本都可以设置padding属性，这样一来TextView就被分成多个矩形区域了，而TextView也提供了获取各种padding和长度的接口，如下： </p>
<blockquote>
<p>getWidth(), getHeight()<br>  getPaddingLeft/Right/Top/Bottom()<br>  getCompoundPaddingLeft/Right/Top/Bottom()<br>  getExtendedPaddingBottom/Top()<br>  getTotalPaddingLeft/Right/Top/Bottom()  </p>
</blockquote>
<p>先看一下布局代码：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-99ada744fe8ebd18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"><br>@drawable/icon_person_n<br><img src="http://upload-images.jianshu.io/upload_images/1924341-078785888c6534a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"></p>
<p>下面是效果图，做了一些标注：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-5b763cffae661b64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png">  </p>
<p>下面来看一下上述获取长度的接口的数据，你可以使用打日志方式，我是比较习惯用调试方式：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-afbe5725d9479398.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png">  </p>
<p>所以，总结一下：<br><strong>getWidth(), getHeight()</strong>：对应你代码里的layout_width和layout_height。  </p>
<p><strong>getPaddiingLeft/Right/Top/Bottom()</strong>：对应代码里的Padding。<br>以上两个比较容易理解，毕竟经常打交道。  </p>
<p><strong>getCompoundPaddingLeft/Top/Right/Bottom()</strong>： 翻译成中文就是获取混合的Padding, 既然是混合的，那么它的值也就是padding + 图片的大小 + drawablePadding的值。说得通俗点就是，它是获取文字区域到TextView边界之间的间隔。附上源码：<br><img src="http://upload-images.jianshu.io/upload_images/1924341-8381c0f04698e797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.png"></p>
<p><strong>getExtendedPaddingTop()</strong>：这个是当有部分文字没有显示出来时，也就是设置了maxLine时，它的值就等于首行文字到TextView顶端的距离。同理，getExtendedPaddingBottom()就是最后一行文字到TextVeiw底部距离。其他情况下，他的值等于getCompoundPaddingTop/Bottom()的值。这个源码不多，但也不怎么好讲解，就贴两张图对比下，就明白了。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-66ade1367a0641a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"><br><img src="http://upload-images.jianshu.io/upload_images/1924341-a66565322f0cd4bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.png">  </p>
<p> <strong>getTotalPaddingLeft/Right/Top/Bottom()</strong>：翻译下就是获取总的Padding值，看了下源码，左右的值直接就是等于compoundPadding的值，上下的值等于ExtendedPadding的值再加上offset的值（跟Gravity的垂直方向的布局有关。说得通俗点就是，不管有没有maxLines，上下的值都分别等于首行到TextView顶端和末行到TextView底部的值。  </p>
<p>这些接口除了前面两个比较常用外，其他基本很少用吧，我也是因为在看TextView的跑马灯部分的源码才接触到，然后为了弄明白才记录下来的。至于后面那些接口的应用场景，getCompoundPadding()这个的应用场景倒是很明确，可以用来判断相应的drawable是否发生点击事件之类的需求。至于extendedPadding和totalPadding这两个的应用场景，我想了想，觉得应该是涉及需要计算显示出来后的文字高度的相关需求时会用到吧。有对这些接口很熟悉的童鞋可以分享出来哈，一起学习学习。  </p>
<p><strong>最后用一张图总结一下，我把TextView分成内容区域，内容区域和TextView边界之间的间隔就是padding的值，内容区域包括drawable区域和文字区域，drawable区域和文字区域之间的间隔就是drawablePadding的值，文字区域和TextView之间的间隔就是CompoundPadding的值。</strong>  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-5f1d2aaebafe69ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.png"></p>
<h1 id="如何计算每行文字的长度"><a href="#如何计算每行文字的长度" class="headerlink" title="如何计算每行文字的长度?"></a>如何计算每行文字的长度?</h1><p>Q：每行文字的长度不就等于TextView的宽度吗？直接getWidth()不就好了？<br>A：再看一下上面那部分内容你就清楚了，只有当TextView宽度设置为wrap_content，且没有背景图或drawable时，文字的长度才等于getWidth();当文字很少，没有填充满时，或是溢出时，文字的长度都得另外计算。  </p>
<p>Q：每行文字的长度不一样长吗？<br>A：因为TextView有自己的换行策略，如下图所示，显然每行的文字长度不一样长。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-61e9576369e701af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.png"></p>
<p>Q：文字的长度是指哪段长度？<br>A：看需求吧，我觉得通常情况下都是只需要计算显示在屏幕上的可见区域的每行文字的长度即可。还有那么一种需求，当设置了溢出内容用…表示时，那么其实每行文字的实际长度就不止可见区域那么长了。  </p>
<p>那么该如何计算文字的长度呢？单单根据上一部分里的各种Padding值肯定不够，根据各种Padding顶多计算出文字区域的宽度，但实际上每一行文字并不会那么刚刚好占满文字区域的宽度，那么就还得借助其他来进行计算。  </p>
<p><strong>方法1:TextView.getPaint().measureText(String text)</strong>  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-eeba20225c3e044a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.png"><br>但这种方法只是测试传入的text在该TextView的配置下的总长度，并不是计算每一行的长度。  </p>
<p><strong>方法2：TextView.getLayout().getLineWidth(int line)</strong><br><img src="http://upload-images.jianshu.io/upload_images/1924341-7bd8f71d48b34ed4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16.png"><br>TextView对应的是图14，正好，利用方法1验证一下，这个方法计算得到的是不是每行文字的长度。<br><img src="http://upload-images.jianshu.io/upload_images/1924341-a68e6414badcba72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="17.png"><br>完全正确，所以说这个方法确实计算得到的是每一行文字的实际长度，注意这里是实际长度，也就是说当设置singleLine属性时，用这个方法测量得到的是一整行文字的长度，包括溢出部分。  </p>
<h1 id="设置android-maxLines-”1”和android-singleLine-”true”有什么区别"><a href="#设置android-maxLines-”1”和android-singleLine-”true”有什么区别" class="headerlink" title="设置android:maxLines=”1”和android:singleLine=”true”有什么区别?"></a>设置android:maxLines=”1”和android:singleLine=”true”有什么区别?</h1><p>官方是推荐说不要再使用singleLine,用maxLines=”1”代替。但其实这两个的效果是不一样的，官方api接口里有说明,都是英文我就不贴图了，大概翻译下：<br>maxLines：限制TextView的最高高度，大概就是指通过限制行数来限制最高高度。<br>singleLine: 强制设置TextView的文字不换行。  </p>
<p>区别就是：maxLines还是会默认自动进行换行策略，假如一段文字自动换行后有5行，maxLines设置为1，那么就只显示第一行的内容，其他行不显示。<br>但是，如果是设置了singleLine, 那么这段可以有5行的文字将会被强制放在1行里，然后看最多能显示多少字符，剩下的不显示。  </p>
<p>这样的区别就是导致了很多人在使用TextVeiw的跑马灯效果时不能正常工作的状态，所以下面单独列出个问题来讲。  </p>
<h1 id="为什么设置android-maxLines-”1”时TextView的跑马灯效果就不能正常工作？"><a href="#为什么设置android-maxLines-”1”时TextView的跑马灯效果就不能正常工作？" class="headerlink" title="为什么设置android:maxLines=”1”时TextView的跑马灯效果就不能正常工作？"></a>为什么设置android:maxLines=”1”时TextView的跑马灯效果就不能正常工作？</h1><p>明白了maxLines=”1”和singleLine的区别后，只要再明白跑马灯的原理,就很容易理解为什么设置成maxLines=”1”时跑马灯不工作了。<a href="http://www.jianshu.com/p/fbc82440f6f5" target="_blank" rel="noopener">我在上一篇博客里写过跑马灯启动的条件，具体的分析可以去上一篇看</a>，这里大概说下。  </p>
<p>跑马灯要启动要同时满足四个条件，其中有一个条件就是这一行的文字长度要大于文字区域的宽度，文字区域的宽度就是TextView的getWidth()扣去ComPoundpaddingLeft再扣去CompoundPaddingRight剩下的长度。<br>如果是maxLines=”1”的话，那么就像上一问中分析的那样，所有的文字其实已经被自动换行了，只显示第一行，而换行是什么，就是为了让每行文字的长度超过文字区域的宽度才进行的换行，也就是说，如果一段文字经过TextView的换行后，那么每行的文字长度都不会超过文字区域的长度。这样一来，自然就不满足跑马灯的启动条件之一了，跑马灯也就不能正常工作了。<br>singleLine的话，则是不会对一段文字进行换行处理，这样一来，自然就超过了文字区域的长度，所以如果要设置跑马灯效果的话，只能用singleLine不能用maxLines=”1”。  </p>
]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>【Android】TextView的跑马灯效果</title>
    <url>/2017/03/21/Android%E7%9F%A5%E8%AF%86/%E3%80%90Android%E3%80%91TextView%E7%9A%84%E8%B7%91%E9%A9%AC%E7%81%AF%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>老规矩，先上图看效果。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-72ddafba5d10ad98.gif?imageMogr2/auto-orient/strip" alt="2.gif"></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>TextView的跑马灯效果也就是指当你只想让TextView单行显示，可是文本内容却又超过一行时，自动从左往右慢慢滑动显示的效果就叫跑马灯效果。  </p>
<p>其实，TextView实现跑马灯效果很简单，因为官方已经实现了，你只需要通过设置几个属性即可。而且，相关的资料其实网上也有一大堆了，之所以还写这篇博客出来是因为，网上好多人的博客都是只贴代码的啊，好一点的就是附带几张图片，可是这是动画效果啊，不动起来，谁知道跑马灯效果到底长什么样，到底是不是自己想要的效果啊（不会只有题主不知道跑马灯是什么效果吧，我不信！！！）。</p>
<p>所以，轻度强迫症的题主实在忍不住了，自己写一篇记录一下。另外，最近在学习竖直方向循环滚动显示的TextView，等理解掌握透了后也会记录下来。好了，话不多说，看代码。  </p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><blockquote>
<p><strong>android:ellipsize=”marquee”</strong>  //设置超出显示区域的内容以跑马灯效果呈现，该值还可以设置成END, START等，就是我们常见的在末尾”…”显示。<br>  <strong>android:singleLine=”true” **  //跑马灯启动的条件之一，另外官方推荐说该方法已废弃推荐使用maxLines=”1”, 不用去鸟他，用maxLines的话跑马灯效果也不会启动。<br>  **android:focusable=”true”</strong>  //跑马灯启动的条件之一<br>  <strong>android:marqueeRepeatLimit=”-1”</strong> //设置循环几次，-1表示无限循环  </p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-5649c68a187f42ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p>
<h1 id="跑马灯不能启动的问题"><a href="#跑马灯不能启动的问题" class="headerlink" title="跑马灯不能启动的问题"></a>跑马灯不能启动的问题</h1><p>如果对TextView的跑马灯不熟悉的话，第一次使用应该会碰到各种跑马灯效果不工作的状态。其实这是因为跑马灯的启动有多个条件，也就是上面的属性除了最后一条设置循环次数的除外，其他的均必须进行设置。TextView得是单行显示，还必须可以获取焦点，这样当TextView获取焦点后跑马灯效果才会启动，如最上面动图里的第二个TextView。  </p>
<p>看下TextView关于跑马灯启动的相关源码你就会更清楚  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-f76e41e7680a4321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png">  </p>
<p>至于为什么用maxLines=”1”替代singleLine=”true”时， 跑马灯不会正常工作的原因，我在<a href="http://www.jianshu.com/p/fd9cce7a333f" target="_blank" rel="noopener">下一篇博客里有解析，感兴趣的可以看看</a>。</p>
<p>#扩展<br>其实，跑马灯更常见于TV应用上，因为只有在TV应用上才需要区分获取焦点时的状态以及点击的状态，毕竟TV应用都不支持触屏模式，都是有遥控操作，焦点状态的提示就显得很重要。  </p>
<p>而对于触屏手机来说，当触摸时，也就同时获取点击状态和焦点状态了，所以在触屏手机上，跑马灯更常见的应用场景则是，不管TextView有没有获取焦点，都让跑马灯效果一直处于启动状态，正如最上面动图里的第一个TextView。如果要实现这个效果，只需要继承TextView，重写几个方法就好了。代码如下：  </p>
<pre><code>/**
 * 跑马灯效果的TextView, 使用方式：
 * 启动/关闭：{@link #setMarqueeEnable(boolean)}
 * xml文件中记得设置：android:focusable=&quot;true&quot;, android:singleLine=&quot;true&quot;
 *
 * Created by dasu on 2017/3/21.
 * http://www.jianshu.com/u/bb52a2918096
 */

public class MarqueeTextView extends TextView {

    private boolean isMarqueeEnable = false;

    public MarqueeTextView(Context context) {
        super(context);
    }

    public MarqueeTextView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
    }

    public MarqueeTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    public void setMarqueeEnable(boolean enable) {
        if (isMarqueeEnable != enable) {
            isMarqueeEnable = enable;
            if (enable) {
                setEllipsize(TextUtils.TruncateAt.MARQUEE);
            } else {
                setEllipsize(TextUtils.TruncateAt.END);
            }
            onWindowFocusChanged(enable);
        }
    }

    public boolean isMarqueeEnable() {
        return isMarqueeEnable;
    }

    @Override
    public boolean isFocused() {
        return isMarqueeEnable;
    }

    @Override
    protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {
        super.onFocusChanged(isMarqueeEnable, direction, previouslyFocusedRect);
    }

    @Override
    public void onWindowFocusChanged(boolean hasWindowFocus) {
        super.onWindowFocusChanged(isMarqueeEnable);
    }
}
</code></pre><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>以上就是使用TextView跑马灯的记录，那么，如果不用官方提供的有没有办法实现呢，答案肯定是有的，怎么做呢，不知道，最近正好没事，自己试试看去。  </p>
]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>【Android】Fragment懒加载和ViewPager的坑</title>
    <url>/2016/10/02/Android%E7%9F%A5%E8%AF%86/%E3%80%90Android%E3%80%91Fragment%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8CViewPager%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 安卓巴士Android开发者门户 独家发布</strong>  </p>
</blockquote>
<p>#效果  </p>
<p>老规矩，先来看看效果  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-f63733e001d0dd6b.gif?imageMogr2/auto-orient/strip" alt="效果图"></p>
<p>ANDROID和福利两个Fragment是设置的Fragment可见时加载数据，也就是懒加载。圆形的旋转加载图标只有一个，所以，如果当前Fragment正处于加载状态，在离开该Fragment时需要隐藏加载动画，因为另一个Fragment并不一定处于加载状态，当返回Fragment时，如果还是处于加载状态，则要可以实现自动显示加载动画，如果数据已经加载完毕则不需要再显示出来。  </p>
<p>以上效果就是今天要介绍和分享的，那么开始往下看吧。  </p>
<p>#懒加载<br>懒加载意思也就是当需要的时候才会去加载  </p>
<p>那么，为什么Fragment需要懒加载呢，一般我们都会在<strong>onCreate()</strong>或者<strong>onCreateView()</strong>里去启动一些数据加载操作，比如从本地加载或者从服务器加载。大部分情况下，这样并不会出现什么问题，但是当你使用<strong>ViewPager + Fragment</strong>的时候，问题就来了，这时就应该考虑是否需要实现懒加载了。  </p>
<p>#ViewPager + Fragment 的坑  </p>
<p>ViewPager为了让滑动的时候可以有很好的用户的体验，也就是防止出现卡顿现象，因此它有一个缓存机制。默认情况下，ViewPager会提前创建好当前Fragment旁的两个Fragment，举个例子说也就是如果你当前显示的是编号3的Fragment，那么其实编号2和4的Fragment也已经创建好了，也就是说这<strong>3个Fragment</strong>都已经执行完 <strong>onAttach() -&gt; onResume()</strong> 这之间的生命周期函数了。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-121926ffcf7c58f2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志图1"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-45b4060da633517d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>本来Fragment的 <strong>onResume()</strong>表示的是当前Fragment处于可见且可交互状态，但由于ViewPager的缓存机制，它已经失去了意义，也就是说我们只是打开了“福利”这个Fragment，但其实“休息视频”和“拓展资源”这两个Fragment的数据也都已经加载好了。  </p>
<p>如果加载数据的操作都比较耗时或者都是类似图片的占用大量内存，这时就应该考虑想想是否该实现懒加载。也就是，当我打开哪个Fragment的时候，它才会去加载数据。  </p>
<p>#懒加载实现？  </p>
<p>##setUserVisibleHint(boolean isVisibleToUser) 可以？  </p>
<p>当你去网上查找相关资料时，你会发现很多人推荐说把加载数据的操作放在这个函数里，<strong>isVisibleToUser</strong>表示当前Fragment是否可见。那么，是否真的可以就这样做呢？先来看个日志：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-a3fa159face2d9a1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志图2"></p>
<p>题主是从 <strong>DayDataFragment</strong> 跳转到 <strong>MeiziDataFragment</strong> 的，所以可以看到日志里面：<strong>DayDataFragment</strong>打出了<strong>false</strong>，表示它不可见了。而<strong>MeiziDataFragment</strong>却先打出了<strong>false</strong>，然后才打出<strong>true</strong>，这是因为<strong>setUserVisibleHint()</strong>在Fragment实例化时会先调用一次，并且默认值是false，当选中当前显示的Fragment时还会再调用一次。  </p>
<p>所以，看上面的日志，除了<strong>DayDataFragment</strong>外，其他三个Fragment均没有实例化，所以当打开<strong>MeiziDataFragment</strong>时，因为ViewPager的缓存机制，会同时创建三个Fragment的实例，所以打印了三条<strong>isVisibleToUeser: false</strong>的日志，因为选中的是<strong>MeiziDataFragment</strong>，所以它还会触发一次<strong>setUserVisibleHint()</strong>，并且打印出true。  </p>
<p>那么，是否可以在<strong>setUserVisibleHint(boolean isVisibleToUser)</strong>里进行数据加载操作来实现懒加载呢？  </p>
<p>可以是可以，如果你只是需要数据的懒加载的话，但如果你还有以下的需求，那么这种方式就不行了：  </p>
<p>#####1、如果你在Fragment可见时需要进行一些控件的操作，比如显示加载控件<br>#####2、如果你还需要在Fragment从 “可见 -&gt; 不可见” 时进行一些操作的话，比如取消加载控件显示  </p>
<p>这边再提一下，<strong>setUserVisibleHint()</strong>可能会在Fragment的生命周期之外被调用，也就是可能在view创建前就被调用，也可能在destroyView后被调用，所以如果涉及到一些控件的操作的话，可能会报 null 异常，因为控件还没初始化，或者已经摧毁了。  </p>
<p>#进一步封装  </p>
<p>题主稍微进行了一些封装，自定义了一个新的回调函数  <strong>onFragmentVisibleChange(boolean isVisible)</strong>  ，可以实现的效果有：  </p>
<p>#####1、只有两种情况会触发该函数<br>#####2、一种是Fragment从“不可见 -&gt; 可见” 时触发，并传入 isVisible = true<br>#####3、一种是Fragment从“可见   -&gt; 不可见” 时触发，并传入 isVisible = false<br>#####4、可以在该函数内进行控件的操作，不会报null异常    </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-231a7fe2289090ac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志图3"></p>
<p>题主这次仍旧是从<strong>DayDataFragment</strong> 跳转到 <strong>MeiziDataFragment</strong>， 但跟上上面的日志图片不同，这里只打印了两条日志，也就是说即使有三个Fragment被实例化了，但只有显示的那个Fragment和离开的那个Fragment才会触发回调函数，这样就可以支持我们在可见状态变化时进行一些操作，因为不会有多余的false触发。  </p>
<p>另外，因为ViewPager缓存机制，所以题主进行了view的复用，防止<strong>onCreateView()</strong>重复的创建view，其实也就是将view设置为成员变量，创建view时先判断是否为null。因为ViewPager里对Fragment的回收和创建时，如果Fragment已经创建过了，那么只会调用 <strong>onCreateView() -&gt; onDestroyView()</strong> 生命函数，<strong>onCreate()和onDestroy</strong>并不会触发，所以关于变量的初始化和赋值操作可以在<strong>onCreate()</strong>里进行，这样就可以避免重复的操作。  </p>
<p>#代码    </p>
<hr>
<p>2016-04-21 更新：该博客封装的懒加载实现有些不足，比如不支持数据只有第一次打开Fragment时才进行加载的应用场景，因此重新写了篇博客，可以移步至此观看：<a href="http://www.jianshu.com/p/254dc5ddffea" target="_blank" rel="noopener">再来一篇Fragment的懒加载（只加载一次哦）</a>  </p>
<hr>
<p>最后附上代码，另外注意一下，题主是从项目里抽出代码，进行一些修改，让它尽量可以直接复制粘贴使用，但并没有进行过测试，所以如果不行的话可以留言，题主会查看。或者你直接到我原项目里去查看，<a href="https://github.com/woshidasusu/Meizi/blob/master/app/src/main/java/coder/dasu/meizi/view/fragment/GankDataFragment.java" target="_blank" rel="noopener">代码已托管至Github上</a>，因为项目是针对具体需求的，所以类里面会增加很多其他无关的代码。再或者，你可以尝试自己进行封装下，代码很少，不到50行，理解思路就行了。  </p>
<pre><code>
/**
 * Created by dasu on 2016/9/27.
 * https://github.com/woshidasusu/Meizi
 *
 * Viewpager + Fragment情况下，fragment的生命周期因Viewpager的缓存机制而失去了具体意义
 * 该抽象类自定义一个新的回调方法，当fragment可见状态改变时会触发的回调方法，介绍看下面
 *
 * @see #onFragmentVisibleChange(boolean)
 */
public abstract class ViewPagerFragment extends Fragment {

    /**
     * rootView是否初始化标志，防止回调函数在rootView为空的时候触发
     */
    private boolean hasCreateView;

    /**
     * 当前Fragment是否处于可见状态标志，防止因ViewPager的缓存机制而导致回调函数的触发
     */
    private boolean isFragmentVisible;

    /**
     * onCreateView()里返回的view，修饰为protected,所以子类继承该类时，在onCreateView里必须对该变量进行初始化
     */
    protected View rootView;

    @Override
    public void setUserVisibleHint(boolean isVisibleToUser) {
        super.setUserVisibleHint(isVisibleToUser);
        Log.d(getTAG(), &quot;setUserVisibleHint() -&gt; isVisibleToUser: &quot; + isVisibleToUser);
        if (rootView == null) {
            return;
        }
        hasCreateView = true;
        if (isVisibleToUser) {
            onFragmentVisibleChange(true);
            isFragmentVisible = true;
            return;
        }
        if (isFragmentVisible) {
            onFragmentVisibleChange(false);
            isFragmentVisible = false;
        }
    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        initVariable();
    }

    @Override
    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        if (!hasCreateView &amp;&amp; getUserVisibleHint()) {
            onFragmentVisibleChange(true);
            isFragmentVisible = true;
        }
    }

    private void initVariable() {
        hasCreateView = false;
        isFragmentVisible = false;
    }

    /**************************************************************
     *  自定义的回调方法，子类可根据需求重写
     *************************************************************/

    /**
     * 当前fragment可见状态发生变化时会回调该方法
     * 如果当前fragment是第一次加载，等待onCreateView后才会回调该方法，其它情况回调时机跟 {@link #setUserVisibleHint(boolean)}一致
     * 在该回调方法中你可以做一些加载数据操作，甚至是控件的操作，因为配合fragment的view复用机制，你不用担心在对控件操作中会报 null 异常
     *
     * @param isVisible true  不可见 -&gt; 可见
     *                  false 可见  -&gt; 不可见
     */
    protected void onFragmentVisibleChange(boolean isVisible) {
        Log.w(getTAG(), &quot;onFragmentVisibleChange -&gt; isVisible: &quot; + isVisible);
    }
}

</code></pre><p>#用法  </p>
<p>  新建类ViewPagerFragment，将上面代码复制粘贴进去，添加需要的import语句 -&gt; 新建你需要的Fragment类，继承ViewPagerFragment，在onCreateView()里对rootView进行初始化 -&gt; 重写onFragmentVisibleChange()，在这里进行你需要的操作，比如数据加载，控制显示等。  </p>
<pre><code>public class MyFragment extends ViewPagerFragment{

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        if (rootView == null) {
            rootView = inflater.inflate(R.layout.fragment_android, container, false);

        }
        return rootView;
    } 

    @Override
    protected void onFragmentVisibleChange(boolean isVisible) {
        super.onFragmentVisibleChange(isVisible);
        if (isVisible) {
        //   do things when fragment is visible    
        //    if (ListUtils.isEmpty(mDataList) &amp;&amp; !isRefreshing()) {
        //        setRefresh(true);
        //        loadServiceData(false);
            } else {
        //        setRefresh(false);
            }
        }
    }
}
</code></pre><p>##<a href="https://github.com/woshidasusu/Meizi" target="_blank" rel="noopener">项目Github 地址</a>  </p>
<hr>
<p>##PS  </p>
<p>  以上就是这次的内容了，最近题主想利用 <strong>Gank</strong>公开的api，做一个类似于Meizi的应用出来，虽然这个App已经有无数人都做过了，但确实是一个很值得学习的项目，题主仍然是小白一个，所以还是好好学习下。drakeet的Meizi项目用到了很多高级技术，比如Rxjava之类的，题主看不懂，其他Github上一些比较出名的Meizi App要么是MVP架构，要么还是用到了目前小白的我看不懂的技术，所以这次就决定自己用最基础的MVC，一些简单常用的第三方库来做这个App，毕竟路要一步一步走，如果这个完成了，收获和体验应该会很多（这不就收获了这篇随笔了吗O(∩_∩)O），所以，如果有兴趣的话，欢迎Start，欢迎指点，欢迎拍砖，大家一起学习进步。  </p>
]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>【Android】你应该知道的调试神器--adb</title>
    <url>/2016/09/12/Android-Tv/%E3%80%90Android%E3%80%91%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E8%B0%83%E8%AF%95%E7%A5%9E%E5%99%A8--adb/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<hr>
<p>最近跟着一个前辈在做TV应用，因为不能通过usb连接调试，接触到了adb，突然间觉得自己似乎发现了另外一个世界，借助adb shell命令对应用进行调试，简直方便得不行。更重要的是，这是命令行操作啊！！！装逼神器啊，还没学的赶紧来试试看吧。  </p>
<hr>
<p>#效果  </p>
<p>老规矩，先上几张截图看看效果，这是查看xml文件数据，和sqlite数据库数据的效果  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-d05d351483037aee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-71efb7b5e6663e0b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>#介绍  </p>
<p>adb,网上介绍其实很多，就是用来对安卓系统进行一些命令操作的工具。如果你的应用需要经常查看 <strong>sharePreference文件数据</strong>、<strong>Sqlite 数据库数据</strong>，以及<strong>本地的各种数据</strong>的话，那么使用adb将会非常方便。  </p>
<p>如果你需要从电脑上发送一些文件到手机里，或者从手机获取一些文件到电脑上（比如视频之类的应用，需要经常把应用存在手机里的视频文件发送到电脑），那么借助adb也可以很方便实现。  </p>
<p>如果你想做一些TV应用的话，那么就应该要学学ADB了，学学如何通过wifi连接调试，如果pull,push文件等等了。  </p>
<p>#使用  </p>
<p>好了，现在就来看看一些常用的命令了，adb 的命令其实很多，不用特意去记，平常要用时上网搜下，等用熟悉了，自然就把一些常用的命令给记住了。下面，稍微介绍一些我经常使用到的命令：  </p>
<p>##基本命令：ls、cd、cat、rm、cp、mkdir<br>这些命令是linux系统上的一些基本命令，至少要对 <strong>ls</strong>、<strong>cd</strong>、<strong>cat</strong>这几个命令熟悉点，才能很流畅的使用adb工具，如果你还不熟悉，建议先去了解下这几个命令吧。  </p>
<p>##①adb shell<br>这个是进入手机shell操作的一个命令。通常情况下，你调试用的模拟器或者手机通过usb连接电脑后，在win上通过<code>Ctrl + R</code>，输入<code>cmd</code>，在dos窗口内执行该命令即可进入手机的shell操作。  </p>
<p>如果你连接当前电脑的手机不止一部时，这时就需要借助参数来进行选择指定的设备了。如下图：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-741a7e66e5959591.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>##②借助ls、cd命令进入应用数据地址：/data/data/{包名如:coder.dasu.meizi}/</p>
<p>该目录下就是存放该应用的 xml数据，cache数据，file数据，以及sqlite数据库数据了，如下：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-792c43e57224e984.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>##③cat命令查看SharePreference的xml数据  </p>
<p>xml中经常保存一些应用的配置数据，比如用户是否首次启动app，用户账户，用户对应用操作的一些设置啊，比如关闭消息推送等等。<br>这些数据在开发时，都可以通过log方式打印出来，查看效果是否正确。但有时，如果想要查看较多的xml数据时，又懒得一个个的敲代码，或者log信息太杂，忘记以前写的过滤条件时，这时就可以借助adb来实现了。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-d05d351483037aee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>##④神器： sqlite3  ***.db命令查看数据库  </p>
<p>以上介绍的一些功能其实就算不借助adb，也可以使用打印log等方式实现。但如果我们开发过程中，需要经常查看一些数据库内的数据时，也可以使用ddms，把db文件导出来借助工具查看，但这样总会麻烦了点，需要每次都进行导出db文件。所以，这时候，如果借助 <code>sqlite3</code>这个命令，将会非常方便。  </p>
<p>执行完 <code>sqlite3 meizi.db</code> 后，会进入一个sqlite命令状态，在这里可以使用sql语言来进行查询，也可以使用.help来查看sqlite3提供的一些快速命令.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-d3c85d711dfc4e9c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>如，执行 <code>.table</code> 可以查看当前数据库所有的表，执行 <code>.schema</code> 可以查看创建数据库的sql命令  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-3214de6c4fa35343.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>上面那图中有两张表，我们看看USER表中有什么数据，可以使用sql命令查询  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-71efb7b5e6663e0b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>ps:查询结果默认是一个记录一行的，也可以设置成list、或上图等各种显示方式，通过<code>.mode  .header</code>命令来执行，这些命令都可以通过<code>.help</code>来查看说明。  </p>
<p>虽然需要执行sql命令才能查询，但其实也就<code>select</code>一下，并不会很复杂，而且还可以借机多接触一下sql语言，学习一下。更重要的是，这很装逼，有没有O(∩_∩)O。不管在同学面前操作，还是操作给不懂这个的老板看，都会让对方觉得你很吊的。  </p>
<p>哈哈，反正我是喜欢上用这个工具就是了，因为最近开发负责的部分很多跟数据库操作相关，而且还经常出现一些bug，需要经常查看数据库内容来定位以及解决bug，所以这个用着是特别方便，相比于以前用导出db文件的方式来的话。  </p>
<p>如果你也有调试数据库这方面的需求，建议你也可以使用这个工具试试看。</p>
<p>##其他功能  </p>
<p>我使用adb工具更多的是用它来查看应用的一些数据。但其实，它还是有很多其他实用的功能的。  </p>
<p>###wifi连接调试  adb connect  {ip}<br>如果你不想用usb连接调试，可以选择使用adb 连接调试，命令是 <code>adb connect {ip}</code> ，需要在同一个局域网内。这个功能也比较实用，但首次连接时，需要另外一些配置，建议可以网上搜索下<strong>adb wifi连接手机</strong>等关键字看看。  </p>
<p>###屏幕截屏  screencap -p  {图片存储地址}<br>这个其实直接通过手机截屏再发送到电脑就可以了，但我开发的是TV应用，在盒子上没法截屏，所以这个命令对我来说还是较实用的。  </p>
<p>###获取或推送文件  adb pull/push<br>这个也挺实用的，获取手机指定位置的文件到电脑上，或者从电脑发送文件到手机上  </p>
<hr>
<p>如果上面有什么错误，欢迎指正一下。如果你还知道其他更实用的功能，也欢迎告知一下，题主也是个新手，一起好好学习学习。  </p>
]]></content>
      <categories>
        <category>Android-TV</category>
      </categories>
  </entry>
  <entry>
    <title>【Android】5.x炫酷标题栏动画使用理解</title>
    <url>/2016/09/09/Android%E7%9F%A5%E8%AF%86/%E3%80%90Android%E3%80%915-x%E7%82%AB%E9%85%B7%E6%A0%87%E9%A2%98%E6%A0%8F%E5%8A%A8%E7%94%BB%E4%BD%BF%E7%94%A8%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<p>Android5.0+推出的新控件感觉特别酷，最近想模仿大神做个看图App出来，所以先把这些新控件用熟悉了。<br>新控件的介绍、使用等等网上相应的文章已经特别多了，题主也没那能力去写篇详解出来，本篇随笔记录的主要是题主学习这些新控件时遇见的一些困惑以及在搞了半天后的一丝理解，或许也有新手也会碰到跟我一样的困惑，相互学习哈，如果有哪个地方理解错了，还望告知。  </p>
<hr>
<p>#效果  </p>
<p>首先看下效果，本篇也就是只记录以下两张动图中所涉及到的新控件  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-ee6dbaffa708e271.gif?imageMogr2/auto-orient/strip" alt></p>
<p>#AppBarLayout+CollapsingToolbarLayout+Toolbar  </p>
<p>以前手机里的App风格虽然各种各样，但对于标题栏其实都差不多，很少能见到类似上图中的效果。题主之前一直以为标题栏也就是一个简单的导航栏，也就是放个标题，配几个图标而已。但其实还可以像上面一样实现一些较酷炫的效果的。  </p>
<p>首先介绍下这里用到的控件：AppBarLayout+CollapsingToolbarLayout+Toolbar  </p>
<p>##AppBarLayout + CollapsingToolbarLayout</p>
<blockquote>
<p>AppBarLayout is a vertical LinearLayout which implements many of the features of material designs app bar concept, namely scrolling gestures.  </p>
</blockquote>
<p>　</p>
<blockquote>
<p>CollapsingToolbarLayout is a wrapper for Toolbar which implements a collapsing app bar. It is designed to be used as a direct child of a AppBarLayout. </p>
</blockquote>
<p>上面是官网的介绍，<strong>AppBarLayout</strong>其实就是一个继承自<em>LinearLayout</em>,默认实现子控件垂直布局的基本容器，相区别于<em>LinearLayout</em>的是，它提供给它的子控件一个响应滑动事件的行为。  </p>
<p><strong>CollapsingToolbarLayout</strong>则只是一个对<em>Toolbar</em>进行包装，实现了可以对标题栏进行折叠功能的一个基本容器，它是作为<strong>AppBarLayout</strong>的直接子布局来使用。</p>
<p>这么说好像也不怎么好理解，题主就按自己的理解讲得通俗点，举个例子：<br>上面那张动图里，标题栏包括了一个Toolbar、一个背景图（imageView)、一个FAB按钮。这里的Toolbar、imageView都是AppbarLayout的子控件。<br>当滑动屏幕时，子控件都做出了相应的行为（滑出屏幕，固定顶端等），这些行为其实就是AppbarLayout提供给它子控件的功能。也就是说，如果我们想要让我们的标题栏控件能够响应滑动事件的话，就需要用AppBarLayout作为他们的父容器。  </p>
<p>至于CollapsingToolbarLayout则是给子控件提供了折叠的功能，什么是折叠呢？往下看<br>不知道大家学习的时候会不会跟题主一样，有个疑问：<strong>既然AppBarLayout已经为子控件提供了响应滑动的行为，那么为什么还需要一个CollapsingToolbarLayout？</strong>  </p>
<p>我们先来看下，上面那动画实现的布局代码结构：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;AppBarLayout&gt;  </span><br><span class="line">    &lt;CollapsingToolbarLayout app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed|snap&quot;&gt;  </span><br><span class="line">        &lt;ImageView app:layout_collapseMode=&quot;parallax&quot;&gt;  &lt;/ImageView&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;Toolbar app:layout_collapseMode=&quot;pin&quot;&gt;  &lt;/Toolbar&gt;</span><br><span class="line">    &lt;/CollapsingToolbarLayout&gt;</span><br><span class="line">&lt;/AppBarLayout&gt;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">CollapsingToolbarLayout作为AppBarLayout的子控件，设置了ScrollFlags的属性值，因此它可以响应滑动事件，所以会出现上面动图的效果。  </span><br><span class="line">*那么，我们来尝试下，如果去掉CollapsingToolbarLayout会怎么样呢？*  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">布局代码结构：</span><br></pre></td></tr></table></figure>

<appbarlayout>  
    <imageview app:layout_scrollflags="scroll">  </imageview>

<pre><code>&lt;Toolbar app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;  &lt;/Toolbar&gt;</code></pre></appbarlayout>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">效果： </span><br><span class="line"></span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1924341-979e292be5a0fda2.gif?imageMogr2/auto-orient/strip)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">图片背景只是简单的往上滑，没有之前那种视差的效果了。而且Toolbar也跑到下面去了，*那么，我们在把ImageView和Toolbar换个位置试下：*  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">布局代码结构：</span><br></pre></td></tr></table></figure>

<appbarlayout>     
    <toolbar app:layout_scrollflags="scroll|exitUntilCollapsed">  </toolbar>

<pre><code>&lt;ImageView app:layout_scrollFlags=&quot;scroll&quot;&gt;  &lt;/ImageView&gt;</code></pre></appbarlayout>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">效果：  </span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1924341-1064fbb9965bb11d.gif?imageMogr2/auto-orient/strip)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Toolbar和ImageView不滑动了！！为什么，下面说。</span><br><span class="line"></span><br><span class="line">很明显的一点，ImageView和Toolbar变成了线性垂直布局的了。细心点的读者会发现，我们上面刚提到过AppBarLayout是继承自**LinearLayout**默认实现子控件垂直布局。  </span><br><span class="line"></span><br><span class="line">也就是说，AppBarLayout只是提供给它的子控件们，按照从上到下的优先级来响应子控件设置的响应行为。什么意思，如果AppBarLayout的第一个子控件没有设置ScrollFlags属性或者没有设置*scroll*值，那么这个子控件就不会响应滑动事件，那么这个子控件下方的控件即使设置了各种响应行为，也不会有任何效果。  </span><br><span class="line"></span><br><span class="line">我们上面的代码中，Toolbar是AppBarLayout的第一个子控件，虽然设置了*scroll*值，但也设置了*exitUntilCollapsed*值，这个的作用是，当向上滑动时，这个控件也会跟着滑出屏幕，直到它还留在屏幕内的高度达到最小高度（没有设置好像默认就是wrap_content)时停止。  </span><br><span class="line"></span><br><span class="line">再回到我们问题来，Toolbar已经达到了它的最小高度了，所以它被固定在顶端不会动了，因此，即便在它下方的ImageView也设置了*scroll*属性值，但由于是线性布局，它也就动不了了。所以也就有了CollapsingToolbarLayout。  </span><br><span class="line"></span><br><span class="line">所以，CollapsingToolbarLayout就是给这些子控件们安排具体的滑动细节，**例如：ImageView要实现渐变的效果；Toolbar的标题要能够有收缩/扩展的效果;最上面的子控件不动，下面的先滑动等等效果。**这些就是由CollapsingToolbarLayout来提供的效果。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**总结下，Toolbar、ImageView都是作为标题栏的元素，AppBarLayout给它们提供可以响应滑动的行为，而CollapsingToolbarLayout则是来安排谁不动，谁先动、怎么动。**    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##如何使用  </span><br><span class="line"></span><br><span class="line">好了，这样一来对于AppBarLayout和CollapsingToolbarLayout就有一个大概的理解了，那么下面就看看该怎么用。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###AppBarLayout  </span><br><span class="line">&gt;Children should provide their desired scrolling behavior through setScrollFlags(int) and the associated layout xml attribute: app:layout_scrollFlags.  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AppBarLayout提供了一个布局参数**scrollFlags**,通过在它的子控件中设置这个属性的值，就可以实现相应的行为。使用方法就像上面官网说的，可以在xml布局文件中直接在子控件中通过设置**app:layout_scrollFlags**，也可以在java代码中通过子控件实例对象调用**setScrollFlags(int)**来实现。  </span><br><span class="line"></span><br><span class="line">至于ScrollFlags的值一共有以下几种：  </span><br><span class="line"></span><br><span class="line">**scroll|enterAlways|enterAlwaysCollapsed|exitUntilCollapsed|snap**  </span><br><span class="line"></span><br><span class="line">**scroll：** 想要子控件能有响应的行为，**scroll**是必须要设置的；也就是说，要想其他值能起作用，那么scroll值必须设置，中间用**|**隔开。这点很重要，网上很多文章只是介绍*ScrollFlags*属性有这几个取值，新手自己动手时往往不知道**scroll**是必须要的，经常就出现没任何滑动的效果。然后就卡在这，比如题主（囧）。  </span><br><span class="line"></span><br><span class="line">**enterAlways|enterAlwaysCollapsed：**把这两个放一起介绍是因为，后者要起作用必须要在前者的基础上，也就是说两个值都设置时后者才会起作用。至于作用其实就是当你一向下滑动屏幕时，控件就能马上显示出来，不必滑到顶端。  </span><br><span class="line"></span><br><span class="line">**snap：**当你停止滑到屏幕时，控件自动恢复原样或者自动滑到底。  </span><br><span class="line"></span><br><span class="line">###CollapsingToolbarLayout  </span><br><span class="line"></span><br><span class="line">跟AppBarLayout很像，CollapsingToolbarLayout提供了一个布局参数**CollapseMode**，一样是两种方法，xml布局文件中通过**app:layout_collapseMode**设置，或者在java代码中调用**setCollapseMode(int)**。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###注意  </span><br><span class="line"></span><br><span class="line">**ScrollFlags**属性只能设置在AppBarLayout的子控件上面，在孙子或曾孙子等等设置没有效果。拿上面的例子说，CollapsingToolbarLayout是AppBarLayout的子控件，ImageView、Toolbar是AppBarLayout的孙子控件，如果你在ImageView、Toolbar控件上面设置**app:layout_scrollFlags**属性值是不会起作用的，只有在CollapsingToolbarLayout设置才能起作用。  </span><br><span class="line"></span><br><span class="line">题主开始时想当然的以为在CollapsingToolbarLayout上面只设置**scroll**值，在ImageView、上设置**snap**,在Toolbar上面设置**exitUntilCollapsed**。这样就可以单独设置各自需要的效果。本来还自己这样想是正确的，结果一直没得到预期的效果，在这里瞎琢磨了半天（囧）。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##例如</span><br></pre></td></tr></table></figure>

<pre><code>&lt;android.support.design.widget.AppBarLayout
    android:id=&quot;@+id/appbar&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:fitsSystemWindows=&quot;true&quot;
    android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt;

    &lt;android.support.design.widget.CollapsingToolbarLayout
        android:id=&quot;@+id/collapse&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        app:contentScrim=&quot;?attr/colorPrimary&quot;
        app:expandedTitleGravity=&quot;bottom|center&quot;
        app:expandedTitleMarginStart=&quot;48dp&quot;
        app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed|snap&quot;&gt;

        &lt;ImageView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:scaleType=&quot;centerCrop&quot;
            android:src=&quot;@drawable/meinv3&quot;
            app:layout_collapseMode=&quot;parallax&quot;
            app:layout_collapseParallaxMultiplier=&quot;0.7&quot; /&gt;

        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;?attr/actionBarSize&quot;
            android:minWidth=&quot;?attr/actionBarSize&quot;
            app:layout_collapseMode=&quot;pin&quot;
            app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot; /&gt;

    &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;
&lt;/android.support.design.widget.AppBarLayout&gt;</code></pre><pre><code></code></pre>]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>【Android】属性动画的使用理解</title>
    <url>/2016/09/08/Android%E7%9F%A5%E8%AF%86/%E3%80%90Android%E3%80%91%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p><strong>本篇文章已授权微信公众号 dasu_Android（大苏）独家发布</strong>  </p>
</blockquote>
<hr>
<p>属性动画的教程网上已经特别多了，本篇也不打算再去各种详解知识点，主要就是记录题主学习属性动画时的碰到的一些困惑，以及后来自己的理解。如果有人也碰到相似的问题，正好可以一起讨论下。  </p>
<hr>
<p>#概要<br>本篇主要涉及的知识点包括：  </p>
<ol>
<li>ObjectAnimator  </li>
<li>ValueAnimator  </li>
</ol>
<p>老规矩，首先先来看下效果图：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-8f099a69c991d2fc.gif?imageMogr2/auto-orient/strip" alt></p>
<p>这种折叠/展开，隐藏/显示的动画在很多地方都会有用到，如果再加上使用5.0后引进的Z属性，实现各种酷炫的立体动画就更吸引人了。所以，还是先掌握好这基础的属性动画吧。  </p>
<p>#分析  </p>
<p>如果你还对属性动画不太明白，或者没用过ObjectAnimator、ValueAnimator的话，建议先去看下<a href="http://blog.csdn.net/guolin_blog/article/details/43536355" target="_blank" rel="noopener">郭神的这篇</a>。  </p>
<p>从上图很容易可以看出，这需要用到<strong>translationX/Y</strong>属性，即平移的属性。也许你会觉得，这不是很简单吗，不就设置下平移的起止值，动画时长，搞定。  </p>
<p>没错，是很简单，就是这么实现的。但其实，对于新手来说，知道怎么做和把它做出来其实还是两码事。题主也还是个初学者，当初也是觉得这很简单啊，然后自己做的时候却出现了各种问题。下面就来讲讲题主做的过程中碰到的一些问题吧。  </p>
<p>##1、平移的距离如何确定？  </p>
<p>先来看那个竖直收缩/扩展的效果，每个控件都平移到最底下控件的位置，然后消失。有时候我们的需求就是这样，不要求将控件全部移出屏幕，只移到某个指定位置，然后消失之类的。如果是移出屏幕，那么距离很容易设定，但像这种情况下，我们要如何去设置每个控件应该平移多长的距离呢？  </p>
<p>很多博客，在对属性动画介绍时，给出的示例代码都是简单的设置某个具体的数值，然后让我们看效果。但这里还能继续用写死的固定值吗，显然不行，那么就需要我们在代码中动态的来计算两个控件之间的距离，然后再来确定控件应该平移的距离。  </p>
<p>经过一番查找，题主找到可以用<strong>View.getLocationOnScreen()</strong>这个方法来实现。  </p>
<pre><code>/**
 * 计算两个view的距离
 * @param v1
 * @param v2
 * @return 返回new int[2], [0]横坐标距离，[1]纵坐标的距离
 */
private int[] calculateWidgetsDistance(View v1, View v2){
    int[] location1 = new int[2];
    int[] location2 = new int[2];
    int[] ret = new int[2];

    v1.getLocationOnScreen(location1);
    v2.getLocationOnScreen(location2);

    ret[0] = Math.abs(location1[0] - location2[0]);
    ret[1] = Math.abs(location1[1] - location2[1]);
    return ret;
}
</code></pre><p>##2、setTranslationX(float translationX) 参数值的含义  </p>
<p>如果我们使用<strong>ValueAnimator</strong>来实现动画效果，那么我们就需要接触到<strong>setTranslationX()</strong>这类方法了，如下：  </p>
<pre><code> ValueAnimator animator = ValueAnimator.ofFloat(mView.getTranslationY(),300.0f);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
         @Override
         public void onAnimationUpdate(ValueAnimator animation) {
             float value = (float) animation.getAnimatedValue();
             mView.setTranslationY(value);
         }
  });
animator.setDuration(1000);
animator.start();
</code></pre><p>那么好，问题来了。上面动画的效果是什么？或者说 <strong>300.0f</strong>代表的是什么含义？ </p>
<p>先来说说动画的效果，是将mView从当前位置，沿Y轴平移到Y坐标300的地方？还是从当前位置沿Y正方向平移300？我们看下效果是什么：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-5d11ed8ae7429086.gif?imageMogr2/auto-orient/strip" alt></p>
<p>好像是沿Y平移了300，那么真的是这样吗？如果上面代码的效果表示的意思真是从当前位置沿Y平移300，那么当我们再次点击按钮时，应该继续往下移300，不断的点击就不断的往下移才对，但很明显，从上图中我们看出，当再次点击时没有任何动画效果了。所以，上面代码的动画效果显然不是沿Y平移300.  </p>
<p>那么到底是什么效果呢？我们来将代码稍微做些改动，先<strong>复制</strong>上面代码，然后把<strong>300.0f改成200.0f</strong>,然后把复制的这个动画绑定到其他按钮（如下图的FAB)上，这样当我们先点击FAB，再点击按钮本身，也就是先启动平移200f动画，再启动平移300f的动画。看看会有什么效果：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-63629b4b61d85f80.gif?imageMogr2/auto-orient/strip" alt></p>
<p>注意看上图里的点击顺序，为了更方便讲解，我们这里标好步骤：  </p>
<ol>
<li>点击FAB时，控件往下平移一段距离  </li>
<li>再点击控件本身时，控件继续往下平移一段距离，但比第一次平移的距离短  </li>
<li>然后不断点击按钮本身时，没任何动画效果  </li>
<li>但是当再点击FAB时，按钮往上平移了  </li>
<li>此时再点击按钮本身时，咦！发现有效果了，往下平移了  </li>
<li>然后再点击按钮本身发现又没任何效果了。但是再点击FAB时，按钮又往上平移了！发现没有，当按钮处于最底时，点击FAB会将按钮返回到第2个步骤了。  </li>
</ol>
<p>我稍微的对上面那图做些备注，你们就很容易明白为什么是这个动画效果，以及最初那几个问题（300.0f代表什么含义）。  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1924341-f9d6d736922ab1fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>明白了没有，<strong>300.0f表示的是相对于控件最初最初位置的一个距离</strong>，因为这里是Y轴平移，所以上面那代码的动画效果就是<strong>将mView控件从当前位置，沿Y轴平移到距离控件最初位置300的地方</strong>。  </p>
<p>所以，当我们改动代码后才会有那个效果，因为点击FAB，是将控件平移到距离最初起始位置为200的地方。然后再点击按钮本身时，代码意思是将控件从当前位置平移到距离最初位置300的地方，但此时控件的位置并不是在最初的位置，而是已经经过一次平移，处于距离最初位置200的地方，当前控件要平移到300的地方，只需要再平移100就够了。所以第二次控件下移的距离才会比第一次短。之后的效果就不要我再来讲解了吧，记住300.f和200.0f都是相对于最初位置的距离，然后就可以很好的理解上图的动画了。  </p>
<p>花这么多力气说这个，是因为题主觉得，对于初学者来说，要确切的理解参数的含义，这样才可以根据自己想要实现的动画效果来计算需要传递进去的数值是多少。  </p>
<p>好了，如果我们现在要实现这样一个动画效果，让控件从当前位置沿Y轴平移到距离最初位置200的地方，那么代码该怎么写？</p>
<pre><code>ValueAnimator animator = ValueAnimator.ofFloat(mView.getTranslationY(),200.0f);
...</code></pre><p>现在再来实现，很简单，对吧。那么，再来，如果我们要实现，让控件从当前位置沿Y轴平移200呢？  </p>
<pre><code>ValueAnimator animator = ValueAnimator.ofFloat(mView.getTranslationY() , mView.getTranslationY() + 200.0f );
... 
</code></pre><p>怎么样，想对了吗。注意这里的需求是要相对于当前位置移动200，所以数值要怎么计算明白了吧。  </p>
<p>理解了参数的含义，想要实现各种动画效果就更有可能了。以上，均为题主学习中碰到的问题和自己的理解，如果有错误的地方，还望告知，不然误导了别人可就不好了。  </p>
<p>##ObjectAnimator  </p>
<p>题主是先接触的ValueAnimator，然后才接触ObjectAnimator的，基本的动画效果用这两个都能实现，而且ObjectAnimator实现起来，比ValueAnimator方便多了，反正题主现在是喜欢用ObjectAnimator就是了。  </p>
<p>给你们看下，上面贴出来的代码实现的动画效果，用ObjectAnimator该怎么写：  </p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(mView,&quot;translationY&quot;,mView.getTranslationY(),300.0f); 
animator.setDuration(1000);
animator.start();
</code></pre><p>一句代码就搞定，简单多了。虽然简单，但也有几点需要注意的，数值的确定问题跟上面一样，上面理解了这里就可以直接用了，就不再多说了。  </p>
<p>那么，就只剩下第二个参数<strong>“translationY”</strong>这个问题了。它的作用就是指定要实现的是哪个动画属性，说白点，属性动画就是通过不断修改属性值来达到效果的，这点在上面分析的第二点给出的代码上也可以很容易看出来。  </p>
<p>那么，这个属性值到底有哪些，这个字符串的参数可以传递哪些进去？不知道有没有初学者跟题主一样，刚接触时都有这个困惑。  </p>
<p>去网上查找，你会发现，很多大神都给列举出了其他一些取值，比如”alpha”、”rotationX/Y”等等，那么这些值是从哪来的呢？可以看一看<a href="http://blog.csdn.net/guolin_blog/article/details/43816093" target="_blank" rel="noopener">郭神的这一篇</a>。这里就稍微提一下，如果你突然忘记某个动画单词该怎么拼，或者不知道它支不支持使用这个方法，可以利用AS的查看源码方式到View里面去查找一下setXXX()和getXXX()方法，如果有，则支持。  </p>
<p>#Github  </p>
<p>最后附上Demo源代码地址，有兴趣可以看看，代码很粗糙，只是为了理解怎么用而写的，大家就忽略掉这个问题吧。  </p>
<p><a href="https://github.com/woshidasusu/AnimatorDemo" target="_blank" rel="noopener">AnimatorDemo:https://github.com/woshidasusu/AnimatorDemo</a>  </p>
]]></content>
      <categories>
        <category>Android知识</category>
      </categories>
  </entry>
  <entry>
    <title>小码农的故事05</title>
    <url>/2016/09/08/%E7%9E%8E%E6%89%AF%E6%89%AF/%E5%B0%8F%E7%A0%81%E5%86%9C%E7%9A%84%E6%95%85%E4%BA%8B05/</url>
    <content><![CDATA[<hr>
<p>前言：这应该是最后一章了，故事虽然到这就结束了，但现实里还要继续下去，希望在很久的以后来回顾时，能因自己学生时代有这样的经历而欣慰。<br>说明：故事中的人物均是化名，故事情节经过些许加工，故事情节并没有针对任何人，仅以此纪念自己的成长。<br>回顾上一章：<a href="http://www.jianshu.com/p/59273956629f" target="_blank" rel="noopener">详情请猛戳</a></p>
<hr>
<p>##第四章：Beta收官</p>
<hr>
<p>　　三个多周的Alpha冲刺，一个周左右的休息调整时间。紧接着也就是Beta阶段的冲刺了。</p>
<p>　　在Alpha版本中，虽然你们预期的功能基本都实现了，但仍然有很多不足。比如界面太丑，代码模块化太烂等等。瓜哥跟你在那一周的休息调整时间里都表示过，要在Beta阶段大干一场，好好的将这些问题都解决掉。然而，现实总是残酷了，当然，这是后话，暂且不提。</p>
<p>　　在Alpha结束后，你写了篇总结。也就是总结了下在Alpha阶段的一些感想，里面你提到了你们的项目因准备不足而陷入各种难题，提到了队友因意见不合而不断争吵的问题。总之，这三周过来，或多或少都学到了很多。</p>
<p>　　在Alpha刚开始的编程时，你记得懂哥说项目要学会使用在框架的基础上进行开发，而不是所有代码都自己来书写。带着这种观念，你在写界面的时候引入了一大堆第三方库。需要一个点击效果，好，引入。需要一个弹窗效果，好，引入。然而你并没有真正的深入去学习你所引入的第三方库，导致很多库之间其实已经有冗余的功能了。</p>
<p>　　更糟糕的是，队友因为你引入这么多库，从而导致在编译项目时花费了大量时间。因此，你打算在Beta阶段时将多余的库都删除掉。</p>
<p>　　另一个项目的问题是，当初因为没认真考虑，而引入了一个不熟悉的数据库框架。到后面进行开发时，才发现你们需要的很多功能那个框架都实现不了，但已经有很多基础的数据库功能是基于那个框架上面编写的，如果要换掉那个框架，将是一个工作量巨大的任务。但如果不换掉，想要的功能又没办法实现。</p>
<p>　　为了解决这个问题，你查了各种资料，做了各种尝试，熬到了半夜两三点。最后用一种特别暴力的方法去暂时的解决掉，搞定后你特别想去睡一觉，这种活简直了！日后需要怎么做再留给瓜哥去头疼吧。</p>
<p>　　Beta期间也有两三周的时间，但懂哥只要求进行七次会议记录而已。瓜哥为了能让项目保持一种稳定，平均的进展，安排了每过两三四天开一次会议。但计划总是赶不上变化。</p>
<p>　　第一周还好，因为大家第一周里面都没有什么考试，进展也还算顺利，一些Alpha遗留的问题也渐渐的解决了。但到了第二周时，有的队员有考试，而且是接连两三场考试，基于此，瓜哥最后表示，这周就先把项目放一边，大家好好复习，准备考试，等最后一周再来继续项目。</p>
<p>　　本来以为，放一周的时间去调整，不做项目可以让大家到最后一周时能更有干劲。但事实却是，一周没碰过项目，导致大家对于项目的热情大大的降低了。不仅如此，对于项目很多地方都渐渐的感到陌生了，更可怕的是，你居然忘记了某块有合作的代码当初到底是不是你编写的。</p>
<p>　　日后瓜哥也提过，当初因为放了一周，导致他也对于项目的进展掌握出现了很多问题。当然，这是后话，暂且不提。第二周的Beta过去了，大家都在忙着复习，确确实实都把项目扔一边去了。等到了第三周时，第一次会议上，大家甚至都不知道要说什么话。</p>
<p>　　离最后的时间也就只剩下一周左右了，你突然觉得来不及了。自己无聊时不断地手工测试你们的软件，你发现似乎还存在一大堆问题，但就是不知道怎么把这个问题描述出来。你觉得队友应该也会自己去手工测试，然后发现相同的问题，但事实上队友基本没提过你发现的问题。</p>
<p>　　在一次会议上，你直接表示出了厌烦，你表示说这样下去项目根本做不出来，现在仍然存在很多问题。瓜哥要你说出具体有哪些问题，但你又说不出来，你说自己跑一遍就会发现一堆问题了，但瓜哥却表示，你说有问题却又不把问题说清楚。这样，在Alpha阶段发生的一次冲突到现在又出现了一次。只是这次你没有继续接话下去，因为你突然很不想说话了。</p>
<p>　　甚至，你出现了厌工。你总觉得，软件只有你一个人在测试，在找Bug，但事实上很多Bug都被你因为自己的心情烦躁而放大了。你不知道这是不是因为情绪不好，还是因为时间快临近截止，还是因为缺少跟队友的沟通，从而导致了你对于项目厌工的心情。</p>
<p>　　你甚至出现过，你不做了的想法，放一边去，反正等最后验收时没办法完成作品那责任也不是你自己去担。</p>
<p>　　然而，就在你自己胡思乱想，乱发脾气时。瓜哥又对总仓库进行了一次提交，你去看了下瓜哥的提交代码。你发现，瓜哥居然把你一直很苦恼的一些BUG解决了。瞬间，你冷静下来了。每个人都在为这个项目不断的熬夜，不断的努力。在别人埋头修BUG的时候，你却在抱怨，却在厌工。</p>
<p>　　那天你没敲什么代码，就只是早早结束熬夜，提前上床。你想平静下自己，想让自己恢复到Alpha阶段时的状态。你觉得如果你继续以这种情绪下去的话，特别对不起瓜哥。当初是你把瓜哥拉进队伍里来的，瓜哥对于项目也一直很负责，你不能只是因为自己的情绪不好就厌工。这对项目，对瓜哥，对队员都很不公平。</p>
<p>　　调整了状态后，你继续做项目下去。每次的会议上，你也很少再带有情绪，而是静静的听着瓜哥的安排。然后根据瓜哥安排的任务，尽可能的保证在规定时间内完成。</p>
<p>　　Beta阶段的主要任务是实现跟网页端小组的项目的互联互通。使用同一个数据库，对数据库中表的设计，字段的设计，瓜哥都去找网页端的负责人讨论，然后再把结果告诉你们。但实现的过程中仍然碰到很多问题，为了解决这些问题，基本都把时间放在上面。</p>
<p>　　导致了你们一开始计划在Beta阶段对界面进行大修改，对项目进行大重构的安排完全被丢到一边去了。</p>
<p>　　在Beta的演示验收上面，又出现了各种问题，更奇葩的是这问题竟不带重复的。Alpha阶段演示验收时你们就碰上了无网络，服务器崩了，数据线连接没反应等问题导致被迫下台，先让下一组演示。而这一次的演示上，居然碰上了服务器连接不上，重启不了，演示时漏掉演示某部分功能~~</p>
<p>　　Beta的演示验收是由各小组互评加懂哥点评结合完成的。其他小组对于你们的项目看法基本都是功能太单一了，太简单了！好吧，其实是没演示。</p>
<p>　　演示验收完毕，这学期的软工实践算是告一段落了。也是时候再写篇总结了。</p>
<p>　　不同于以往的数据库实践之类的课程，这门课确实让你经历了很多。见客户、每日会议、分工开发、Github团队合作、争吵讨论、编码规范、写文档等等。懂哥说过，他最大的希望就是通过这门课程，可以让他的学生能有能力接私活。你突然很期待起来，好想自己接一次私活看看。那么，就再继续充实自己吧，让自己可以拥有接私活的能力。加油吧。</p>
<p>　　<strong>（完结。再次向懂哥，范老师表示致敬）</strong></p>
]]></content>
      <categories>
        <category>谈人生</category>
      </categories>
  </entry>
  <entry>
    <title>小码农的故事04</title>
    <url>/2016/09/07/%E7%9E%8E%E6%89%AF%E6%89%AF/%E5%B0%8F%E7%A0%81%E5%86%9C%E7%9A%84%E6%95%85%E4%BA%8B04/</url>
    <content><![CDATA[<hr>
<p>前言：咳咳，一个多月了，最近忙这忙那，都把这个故事给落下了，昨晚刚回到家，白天得干活，晚上赶紧把这个故事写完，以此纪念自己的软工。<br>说明：故事中的人物均是化名，故事情节经过些许加工，故事情节并没有针对任何人，仅以此纪念自己的成长。<br>回顾上一章：<a href="http://www.jianshu.com/p/484754ba3356" target="_blank" rel="noopener">详情请猛戳</a></p>
<hr>
<p>##第四章：Alpha冲刺</p>
<hr>
<p>　　Alpha阶段的冲刺就这么的来了，似乎来得有点晚，因为你已经接近一个月没有敲过代码了。这个月来，懂哥一直要求你们写文档，学工具。其实，这些都是编程前的准备，但你们确实还没领悟到它们的重要性。</p>
<p>　　冲刺的阶段碰上了你们的电工实习，懂哥说这段时间不用上课，正好可以拿来敲代码。</p>
<p>　　但第一天的电工实习，你们发现，似乎时间不够，白天一整天都要在实验室焊字焊表，敲代码的时间就只剩下晚上了。在你们第一次的会议上（懂哥要求你们在Alpha冲刺阶段必须要有十次的会议记录），瓜哥为你们其他三人都分配了任务，你负责界面的编写，而BOSS继续学生服务器的知识，元哥负责一些工具的编写。瓜哥表示他不参与编程，他专心做PM。</p>
<p>　　一开始都是处于各种探索的状态，不管是任务的分配，还是敲码的分工，以及编码规范等。这些任务都是由瓜哥来负责，并且瓜哥还特意花了一晚上的时间给你们讲解编码规范的各种要求。虽然在日后你们并不是次次按照文档的要求，毕竟你们各自的风格习惯一时改不过来。</p>
<p>　　你的第一次任务就是编写一些基本界面，有标题栏，有列表等。虽然是第一次接触安卓，你照着教程书上的代码，自己做些修改，勉强算是完成了任务。但花费的时间其实比瓜哥给你预定的时间还长，但你觉得还行，毕竟还是在当天就完成了，虽然为此熬夜到了半夜一二点。</p>
<p>　　第一天过了，瓜哥审核了你们提交的代码，然后合并到仓库中。瓜哥找到你，叫你可以先写个基类的界面，把所有界面的一些共有属性提取出来。你一听，这个好，可以这么做。然后在自己琢磨时才发现，其实你对Java的继承，多态并不是很了解，而且你似乎没办法找出各个界面的共有属性，你突然觉得好烦躁。这一天的时间就要这么的浪费掉了，一点进展都没有。</p>
<p>　　无奈之下，你只能出下下策。你跟瓜哥表示，你找不出有多少共有的属性可以提取出来的。而且，一旦界面是继承基类的话，就没办法再实现自己的界面布局了，其实是你没搞懂安卓的界面机制。但也没时间留给你慢慢去推敲了，所以只能在以后碰到共有的属性时复制粘贴了，这是个很低级但却能解决的办法。</p>
<p>　　就这样，你们小组的项目在一点点的进展着，期间你们又开了几次会议。其实，你之前并没有这么正式的开发软件的经验，以前的实践课虽然也有组队，但都是各做各的，有的同学是抱大腿的，大家也都心知肚明，能带就带。开会这种事，也就是QQ上说两句而已。因此，在第一次开会中，你看见瓜哥那么重视，你觉得似乎没这种必要。</p>
<p>　　但瓜哥仍旧一直这么严肃下去，在之后的几次开会中，瓜哥次次要求围成一个圈，不能坐着，不能嘻哈。看见瓜哥那么重视会议，你也渐渐的端正了态度，也重视起了会议来。在会议上都是汇报自己的进展，然后说一下自己遇到了什么困难，最后再讨论一些解决方案。</p>
<p>　　一个礼拜的时间，你负责的界面却还没有全部完成，懂哥给的时间是两个礼拜。只剩下一个礼拜，既要完成界面，又要完成各种逻辑的书写，你突然觉得时间来不及了。而且，这并不是你们这一组的状况，似乎有很多小组都进展缓慢，很多人在群里抱怨说任务量太大了，白天要焊字，晚上敲代码，已经连续一个礼拜在熬夜了。</p>
<p>　　最后，懂哥表示，截止时间可以延后一个星期。这确实是一个令人兴奋的消息。</p>
<p>　　瓜哥为了能更好的安排进展，叫你们把各自每天能挤出多少时间来敲代码都自己先算一下，然后汇报给他。然后，瓜哥根据你们各自的安排，给你们安排了一个礼拜的工作量。</p>
<p>　　这样看下来，进展似乎就能保证了。而且，每个人也具体到每天要做什么了，但其实，就像你在几个月后读人月神话中看到的一句话一样，<strong>“我们采用的估算技术隐含地假设人和月可以互换，错误地将进度和工作量混淆”</strong></p>
<p>　　瓜哥给你的安排的每天的任务里，都给出了预计的用时。但真正开始时，总会碰上各种想不通的问题，为了解决自己不断地找资料，这样一来，时间将大大的超出了预计的用时。当实在不知道怎么实现的时候，你烦躁得想吐槽，并不是给你时间，你就能做出结果来。有的问题，实在是无法搞定。</p>
<p>　　吐槽归吐槽，项目还是要继续做。这条路不行，那就换一条试试。时间超了，今天的任务要来不及了，那就自己熬夜去吧，反正给瓜哥汇报的时间里又没有算上熬夜的时间，自己在预定的时间里完成不了，就只能自己再次挤时间来补充了。</p>
<p>　　时间一天一天地过，在第一个礼拜里，你白天都用来焊字了，瓜哥还曾表示说没必要花这么多的时间在上面，项目重要。但你觉得这毕竟这门2学分的实践课，老师布置的作业还是好好做吧。但当第一个礼拜末，你含辛茹苦的焊了四五天的字在老师的手中待了不到0.5秒时，你才意识到自己太年轻了。之前还吐槽说学长骗人，这门课根本就不水，白天都要焊字。现在，算是见识到了。</p>
<p>　　在第二个礼拜的实践里，你花费更多的时间投入到了项目里去了。至于电工实习，花完时间学懂就放一边了。算上第一个礼拜，你总共花费了一个半礼拜将所有界面草草完成。接下去必须进入逻辑的书写了，或者有专业术语叫业务层的逻辑。但由于你们之前并没有对这个项目进行架构设计，这些东西并没有区分得特别开。</p>
<p>　　甚至你还在界面代码里混杂着对数据库的操作，因此，被瓜哥一顿批评。</p>
<p>　　会议保持着一定周期开着，进展也一天天的提高。你和元哥一起负责着安卓端的逻辑实现，两个礼拜过去了，一些基层的逻辑也完成了，但也找出了几处BUG，而且有的思路不懂怎么实现，只能暂时假想客户会正确的使用软件，这样程序就不会崩了。</p>
<p>　　是时候跟服务器端连接上了，在一次的会议上，针对这个问题的实现思路组员出现了分歧。元哥，你还有瓜哥都有各自的实现思路，都觉得对方的并不合理。为此，你们讨论了将近一个小时，但仍然没有谁说服谁，瓜哥不得不终止这场会议。瓜哥说怎么实现，搜集好更多的资料再来继续讨论。</p>
<p>　　而且，BOSS负责的服务器端进展也很缓慢。后来，为了能按时完成任务，瓜哥表示，他要开始参与进敲代码的工作了。瓜哥说，让团队里编码能力最强的来做PM是个错误的决定，你却觉得这才是正确的决定。或许放到公司里这是错误的，但这只是在学生之间，团队的成员并没有像公司的职员一样，已经具备基础能力，懂得各种开发流程，只剩下一个PM来领导。</p>
<p>　　相反，团队成员里基本都是零基础，都是第一次接触。这时，要是没有一个能力强的来领导团队，给队员安排好任务，指导学习方向，那么这个项目很可能根本就启动不了。</p>
<p>　　瓜哥参与编程后，先是完成了一个服务器端的接口，然后让BOSS照着学习，完成剩余的。而安卓端也可以开始着手进行与服务器的交互。之后，瓜哥便参与进了安卓端的任务，就这样项目的进展一下子快了起来。</p>
<p>　　但参与越多，瓜哥越生气，他表示你跟元哥的代码实在让人看不下去，太多地方需要重构了。为此，瓜哥叫停了你们的工作，他要先对当前的项目代码进行一次大修改，然后大家再继续去完成。</p>
<p>　　瓜哥是怕到时会出现太多冲突，然后才让你们停下手头工作。你却觉得自己对Github已经足够掌握了，没有听取瓜哥的安排，继续你的开发。结果，你算是体会到了大冲突的滋味了，而且冲突最后也是交由瓜哥进行处理，你才彻底的服了，对于Github的操作你还需要多学习。</p>
<p>　　就这样，三个多礼拜的Alpah冲刺，你们碰上了各种问题。有过冲突，有过争吵，有过烦躁，甚至有过厌工。最终，算是挺过来了，Alpha版本预计的功能基本上已经实现。懂哥的验收演示上，虽然临时出了各种意想不到的问题，比如没网络，服务器崩了！但最终还是完成了，成绩也不错，这几个礼拜的努力也是值得了。</p>
<p>　　接下去就是好好休息几天，然后等待懂哥的Beta冲刺了。
　　</p>
]]></content>
      <categories>
        <category>谈人生</category>
      </categories>
  </entry>
  <entry>
    <title>小码农的故事03</title>
    <url>/2016/09/06/%E7%9E%8E%E6%89%AF%E6%89%AF/%E5%B0%8F%E7%A0%81%E5%86%9C%E7%9A%84%E6%95%85%E4%BA%8B03/</url>
    <content><![CDATA[<hr>
<p>前言：逛知乎时，经常看见有大神将各种经历写成小故事，感觉特别有趣。咳咳，这次也自己来尝试下，将这学期的软工实践写成故事试试看，故事中均已第二人称来描述。故事中的人物均是化名。故事情节经过些许加工。<br>说明：故事情节并没有针对任何人，仅以此纪念自己的成长。<br>回顾上一章：<a href="http://www.jianshu.com/p/2060b7676a00" target="_blank" rel="noopener">详情请猛戳</a></p>
<hr>
<p>##第三章：项目编程前夕</p>
<hr>
<p>　　课程已经进入团队合作开发阶段了，并不太糟的是你的团队组成了，成员个个也都很不错。首先是担当PM的瓜哥，是个学习能力特强的大神，曾经从年级排名一百多外加挂两科的位置突突突地飙升到年级第一。接下去是元哥，放弃暑期玩耍时间，留校自学的好学分子。还有一个外号BOSS，硬盘，平板，资源啥都有的“收藏家”。当然，还有一个你。</p>
<p>　　懂哥多次强调，他的软工课不是语言课，不是教你怎么编程，而是教你如何开发产品。因此，懂哥表示，团队任务并不会一开始就直接编程。那要做什么，当然是写文档。所以懂哥布置了团队的第一个任务，写需求规格说明书。</p>
<p>　　懂哥给的时间有一周，你觉得时间应该很充足了，可以慢慢来不用急。正好你跟瓜哥讨论该如何完成这次任务，你建议是先指派一个去查找并整理出来《需求规格说明书》到底需要写哪些内容。瓜哥同意了你的建议，并把这个任务交给了你。至于他们三个，则负责跟客户约谈，收集并理清需求。</p>
<p>　　你接受了瓜哥的安排，一开始你觉得这个任务应该很简单，不就是查一查资料，整理一下嘛。但其实，查资料简单是简单，但想要查到高质量，准确的资料却是需要一定的经验和技巧的。可惜的是你一开始根本没有意识到这一点。</p>
<p>　　懂哥要求文档的格式必须按照国际规范来书写，于是你上百度，输入关键字。渐渐的，你发现，你换了很多关键字，但搜出来的文档却有好多种格式，你开始疑惑到底哪个才是国际规范的格式。</p>
<p>　　休息了一会，你突然想起，助教多次强调不要用百度，用Google。虽然你并不知道为什么不能用百度，但你觉得或许可以试试用Google搜索试试。好在，给力的瓜哥整理了几种翻墙的方法，你不需要再多花时间去搞翻墙。</p>
<p>　　一用之下，你发现效果好像是比百度好多了，你不确定这到底是不是因为你的心理暗示的作用。因为你发现，搜索出来的大多数都是英文的，对于这种用英文提问，英文解答，英文官方文档的，你总觉得它们很高大上，觉得看英文是大神的专属特权。</p>
<p>　　你突然觉得，自己或许可以装一把大神看看。于是你强迫着自己一个词一个词的看着那些英文，虽然这样耗费了你很长时间。好在，最后你找到了。但你又疑惑了，因为你找到了一份国标，也就是国家规范，还找到了一份国际规范。</p>
<p>　　之所以会疑惑，是因为你很确定国标是从官方查找到的，你能保证它的格式就是国标。但国际规范的文档，只是文档的标题写了国际规范四个字，你并没有找到官方的文档介绍，所以你有点怀疑这到底是不是国际规范。想了想，你还是选择了那份国际规范的文档，把它整理了出来。毕竟懂哥的要求在那摆着。</p>
<p>　　当你整理完后，软工群里开始有人在吐槽懂哥要求的国际规范格式找不到。懂哥看到后，给大家提供了关键字，叫大家按照大概的关键字自己去搜索下载。这时又有人吐槽，都给了关键字，干嘛不直接把文档提供出来，这样岂不是更麻烦。其实，你自己也有这样抱怨过，但事后你才发现原来懂哥不直接提供文档就是要让你们自己去学习如何搜索，如何获取资料，但没想到大家竟让他这么失望，居然还要懂哥他来提供关键字。提供了关键字了居然还有直接要文档的，懂哥应该都快气哭了。当然，这是后话，暂且不提。</p>
<p>　　你比对着懂哥给的关键字搜出来的文档才发现，懂哥其实给的要求是国标，可是你之前整理出来的却是另一份。你突然意识到不好了，因为队员们已经在你整理出来的那份文档上面开始书写了。你急忙跟瓜哥汇报，瓜哥叫停了大家写文档的工作，叫你赶快抓紧时间改过来。</p>
<p>　　由于这时已经快临近任务提交的截止时间了，等你改完后已经耽搁了一段时间了。最后，你的团队为了能按时完成任务，在截止时间前一天晚上都熬夜到了凌晨三四点。事后，瓜哥表示很不满意你的表现。</p>
<p>　　你也觉得自己做得不够好，明明看着一份挺简单的任务完成的质量却还是那么差。当你在碰过疑惑时，如果自己搞不定，就应该向别人请教。是，你是害怕如果你问的问题太简单，会不会让对方有不好的印象。但事实却是，你总是想得太多，你要学会请教，这并不是什么丢人的事，有疑问时就应该提出来，让大伙一起解决。你总是没意识到这点，这很不好，要改。</p>
<p>　　好了，时间再稍微往前推点。当你整理完国际规范的文档出来后，瓜哥便开始按照你整理出来的文档分配任务给大家。你们花了一个晚上的时间，根据瓜哥第一次见客户时留下的录音资料，一起讨论、整理了一下客户的需求。并将一些有疑惑的地方都罗列出来。</p>
<p>　　瓜哥说，他准备再约客户一次。将有疑惑的地方都弄清楚，但你却有点害怕。因为客户其实是个教师，是负责学院某方面工作的负责人。要跟这种大人物打交道，而且你还只是个学生，并没有能力保证最后能做出个产品出来，现在就跟客户各种商谈最后做不出的话那该怎么办。</p>
<p>　　很明显，瓜哥在这方面表现的比你优越多了，也对，毕竟是团队的PM。跟客户约好时间后，做了些准备。第二天，元哥有课，所以你们三个带着资料就过去找客户了。客户来之前，你很紧张，虽然到时演示、交流，基本都由瓜哥负责，但你还是忍不住的紧张。</p>
<p>　　跟客户谈了大约有一个小时，具体谈了什么你基本都已经忘记了，只记得整个过程，基本都是由瓜哥跟客户交谈，你在旁边记录重点，偶尔当瓜哥意外卡顿时，赶紧插上话，给客户解释他的疑惑。然后，就没有然后了。你只记得到最后懂哥急急忙忙的跑过来，他说他以为你们会没钥匙开这个会议室的门进来，说完懂哥又急急忙忙的走了，走之前懂哥好像还笑了下，你偷偷的在心里想，懂哥不知道会不会吐槽你们这三个小兔崽子，瞒着其他团队偷偷见客户。</p>
<p>　　回到宿舍后，瓜哥找你要录音资料。你突然很意外，因为瓜哥并没有说要录音，所以你并没有去把交谈过程录下来。瓜哥说，这还用说嘛，他需要演示原型给客户，手机没法录音，他说他以为你们会自觉录音去。</p>
<p>　　你跟BOSS都表示，没关系，你们已经把重点都写下来了。但瓜哥表示，客户有时的描述前后都会矛盾，你们的理解也都是个人的，不录音下来好好讨论下有的内容还是会理解错的。无奈，你跟BOSS只能表示下次一定注意，不会再犯了。没录音资料，瓜哥也没其他的办法了，把记录下来的整理了一下，然后根据你之前整理的文档规范分配任务了。</p>
<p>　　好了，时间回到正轨。当你们熬夜完成文档后，第二天需要课堂演示文档内容，懂哥当场点评验收。你觉得你们文档完成的质量应该算是挺不错的，毕竟瓜哥曾约客户再次确认了客户的需求。其他一些跟你们做相同项目的团队并没有采取什么行动，只是在第一次由懂哥约客户让做这个项目的团队都到场听客户讲述需求。所以，瓜哥表示你们的团队已经领先其他组了。</p>
<p>　　一个早上，十几个团队都把文档演示了一遍。懂哥表示，大家都辛苦了，有的组确实完成的很不错，内容很详细，明确。有的组仍然有些地方需要修改，你们的团队虽然并没有哪个地方需要大改，整体上还算很好，但个别部分还可以改进。懂哥尤其表扬了你隔壁舍那一组，也就是你在上一章提到的开学初说好要一起组队的那几个同学所在的组。</p>
<p>　　看了他们的文档，你也表示特别惊讶，有部分内容你们只用了一页来描述，而他们用了整整8页多。刚好，懂哥表示，下次作业就是修改本次文档中不足的部分。于是，瓜哥计划参照被表扬的那组的文档，修改你们的文档。</p>
<p>　　懂哥给的新任务的时间有点长，有十来天的时间。元哥跟BOSS问项目要什么时候开始敲代码，瓜哥跟你都表示，不要急着敲，先把项目理清，前期准备做充足了再开始动手。虽然不管是书本，还是懂哥都是这样说的，你们也确实是这么做的。但你们还是嫩了点，你们确实是不急着敲代码，但你们根本不知道前期准备具体要做什么。</p>
<p>　　你记得懂哥说过，项目最好可以在框架上完成，不要所有代码都自己敲。你搜索了一些快速开发框架，知道了所谓的框架到底是什么鬼，没办法，你是这学期才刚接触的安卓，确实很多专业名词不懂。你建议瓜哥，项目可以选择在快速开发框架上完成，瓜哥表示他会考虑，但最后他并没有采取你的建议，当然这是后话，暂时不提。</p>
<p>　　懂哥布置的这次任务，除了修改文档，其他就是计划项目启动后的整体安排计划。由于这基本都属于瓜哥的工作，瓜哥也表示，这期间你们可以先抓紧学习。至于文档的修改，瓜哥只安排了你跟他来完成，因为你跟瓜哥对项目比较熟悉点，元哥和BOSS多给他们时间去抓紧学习下。</p>
<p>　　文档的修改因为有了参照，并不需要特别多的时间。所以，这十来天的时间内，瓜哥叫你要去学习MeterialDesign，他表示编码的话界面将由你负责。另外他安排元哥学习测试，安排BOSS学习服务器，至于他的话则去学习团队管理工具，安排接下去的计划，完成懂哥布置的其余内容。</p>
<p>　　一开始，大家的学习效果并不是很好，因为只给了一个学习方向，没有什么期限，没有什么要求，大家都学习得很慢。瓜哥跟你讨论说，这样不行。于是，瓜哥想出了一个办法，由他来给大家布置任务，限定大家在要求的时间内根据所学的内容做出一个小Demo,你表示同意。但你还是太高估你自己了，零基础的你要理解MeterialDesign是个什么鬼东西就要耗费你一段时间了，更不用说还要会用，会写个Demo出来。</p>
<p>　　结果，在瓜哥给的期限内，你并没有做出Demo来。在开会时，瓜哥发现，他给你们三个布置的任务没一个完成，他表示很不满意。你跟他说时间太短了，大家都是没基础的，实在是没办法完成。最后，瓜哥服软了，瓜哥表示可能是他布置的任务有点不合理。但其实现在想想，会不会是因为你们太懒了，还没激发出潜力，如果瓜哥当时坚持下去，或许你们的项目能更完美，当然这是后话，暂且不提。</p>
<p>　　本来瓜哥是想再换种方法，或者考虑要不要逼你们一把。但到这时才发现，已经没时间再去研究了。离懂哥给的任务期限已经很近了，重新看了下懂哥布置的任务要求，瓜哥表示他估计错误了，在截止时间前瓜哥得加班加点可能也才能勉强赶完工。而且由于大部分内容都是瓜哥的任务，你跟元哥反而闲了下来。</p>
<p>　　看着瓜哥在那急急忙忙的赶工，你也不好意思去打扰他。想帮着完成点什么，可是任务基本都是PM的相关工作，你也不知道你可以做什么。想了想，你决定还是去上课吧。对，上周为了赶上一次作业，你们团队四人均翘了一节课。这周看样子瓜哥还得继续翘，毕竟截止时间就是晚上了。你跟元哥还有BOSS也不知道能做什么，只好上课去，即使是一门很水的课。</p>
<p>　　BOSS还好，懂哥给的任务还有要求要设计数据库的，这属于BOSS的工作范围内。但BOSS可能觉得时间够了，他也跟着你和元哥上课去。就这样，你们团队就只留下了瓜哥翘课赶工去。或许你们这是很不团结的行为，但没办法，还是雏鸟的你们，碰到这种情况确实没多少经验。</p>
<p>　　上课时，其实这是一门特水的课，你也听不下去老师讲的内容。之所以过来上课，一是因为你发现自己似乎很闲，二是因为上次的翘课，有学院派人抽点，你被点到了旷课，害怕的你只能乖乖的来上课。想了想，你觉得就留瓜哥自己赶工去似乎真的很不好，重新翻看起了懂哥布置的任务，你想看看自己能做点什么。</p>
<p>　　懂哥给的任务要求PM学会github的issue及燃尽图等工具，这些瓜哥都在赶工中，你插不上手。懂哥还要求设计数据库，这个交给BOSS。但似乎只靠BOSS解决不了，所以你在课堂上拿了张纸在上面不停地涂涂画画。最后跟BOSS讨论了下，敲定了数据库的设计，接下去就是用懂哥要求的工具实现出来了。于是，BOSS在课还没结束时就匆匆忙忙赶回去赶工了。</p>
<p>　　人的潜力都是被逼出来的，为了能按时完成懂哥的任务，再难的问题也得上。最终，瓜哥在过了截止时间2分钟后将作业提交了上去。</p>
<p>　　你看了瓜哥汇报大家的本次任务贡献里，你和元哥贡献均为零。你突然觉得很奇怪，难道瓜哥生气了？也对，毕竟你们三曾扔下瓜哥独自一人翘课赶工。但其实是瓜哥连续几小时的赶工，忘掉了原来本次任务还包括之前他跟你修改文档的工作。事后瓜哥修改完后，在团队里敞开了心扉说，如果对他的汇报有疑问，别憋心里，勇敢说出来。</p>
<p>　　在这次敞开心扉的谈话中，你发现，瓜哥身上确实有很多需要你学的。你曾想，如果是你作为PM，就算队友的贡献度确实很低，但毕竟是同学一场，你下不了手去真实记录下来，或许会给点感情分。但瓜哥严肃的表示，这是做项目，不是感情用事的时候！你突然惊住了，如果你有瓜哥这种价值观，或许之前就不会因团队人选而烦恼了。</p>
<p>　　也正是经过这一次的谈话，在日后你们团队中碰到各种分歧时，你们均能勇敢的提出自己的观点，而不是一味的接受瓜哥的安排，这让你们的团队比有的团队更有活力，当然也多了很多冲突，这都是后话，暂且不提。</p>
<p>　　本次的任务也算是解决了，你们团队的得分属于前列，瓜哥表示很欣慰。懂哥表示，给大家留的前期时间已经结束了，接下去就是开始编程冲刺了。终于要开始敲代码了！</p>
<p>　　你发现，对于写文档你还是更喜欢敲代码，明天就要开始Alpha版冲刺了，你突然很想大声喊，“Alpha,我来了！”</p>
<p>　　但你还是没喊出去，毕竟那样太逗比了。元哥问你，要开始编程了吗？你突然觉得这句话怎么似曾相识，对了，十几天前元哥曾问过你一次，你叫他不要急，先学习。你跟瓜哥会先把框架搭好，架构设计好大家再动手。想了想，你突然意识到，又出大事了！</p>
<p>　　你们这段时间总感觉时间够用，顾着浪，忘记设计架构这事了！你似乎看到了“Alpha”正变成一个带着邪恶笑容的小恶魔，对着你大喊着，“For The Dream,我来了！”</p>
]]></content>
      <categories>
        <category>谈人生</category>
      </categories>
  </entry>
  <entry>
    <title>小码农的故事02</title>
    <url>/2016/09/04/%E7%9E%8E%E6%89%AF%E6%89%AF/%E5%B0%8F%E7%A0%81%E5%86%9C%E7%9A%84%E6%95%85%E4%BA%8B02/</url>
    <content><![CDATA[<hr>
<p>前言：逛知乎时，经常看见有大神将各种经历写成小故事，感觉特别有趣。咳咳，这次也自己来尝试下，将这学期的软工实践写成故事试试看，故事中均已第二人称来描述。故事中的人物均是化名。故事情节经过些许加工。<br>说明：故事情节并没有针对任何人，仅以此纪念自己的成长。<br>回顾上一章：<a href="http://www.cnblogs.com/dasusu/p/5063125.html" target="_blank" rel="noopener">详情请猛戳</a></p>
<hr>
<p>##第二章：团队人选风波</p>
<hr>
<p>　　结队编程终于告一段落了，接下来就是令人期待的团队合作开发阶段了。终于要开始你一直很期待的任务了，然而却发生了一件令你意想不到的事。</p>
<p>　　那是还在国庆长假期间，一天晚上，你突然收到懂哥消息说，你在结队过程中的小组被选为了种子队，职责就是在你们结队的项目基础上继续完成下去。团队剩余的两个名额得由你自己再去招人。</p>
<p>　　收到消息时，你突然感到不可思议。当初随便找个人凑个队，居然被选上了种子队。你开始觉得，自己是不是装13装过头了。你很清楚自己有几斤几两，你是很重视这门课没错，但你的基础也确实很弱。在收到懂哥的消息时，你诚惶诚恐，你觉得自己胜任不了，觉得自己最后可能没办法做出成品。于是，你小心地探着懂哥的口风，看能不能退出种子队。但其实你只是不想违约，因为你早在开学初就已经跟同学说好团队时要一起的。如果作为种子队的话，你之前的安排就全被打乱了。</p>
<p>　　你突然觉得好烦恼，不知道该怎么解决。毕竟开学初已经跟别人说好了，而且还是你主动的去邀请别人，现在却因为一场意外，开学初说好的团队必须踢掉几个。你觉得你没办法解决这件事了，所以你一直拖着。</p>
<p>　　拖得越久，你越觉得烦。你突然忍不住想吐槽懂哥，明明懂哥说过结过队的就不能再组队，现在却说结过队的仍可选择是否继续组成团队。早知道这样，当初结队的时候，你就直接找团队的人选组队好了。当初就是因为怕结完队，最后却没办法组队，所以你才和一个新同学结的队。</p>
<p>　　懂哥说过，他的软工课就是想让你们提前体验日后进公司开发过程中会遇到的各种情况。这当中自然包括，人员的变动以及计划总是赶不上变化的体验。</p>
<p>　　你突然觉得自己是该哭呢，还是该笑。你认识的一些同学是因为上课没注意听，所以不知道懂哥说过结过队就不能再组队的事，所以躲过了一劫。然而你却真真实实的体验了一把，这下好了，计划的事被打乱，还不知道该如何解决。</p>
<p>　　想了半天，你觉得你需要和你结队的新同学好好谈一谈。你在想，有没有办法说服他，要么他退出，要么你退出。可是，不懂人情世故的你，不懂交际艺术的你，却不知道该如何说出口。结果就是，跟他聊着聊着，到最后聊的话题直接变成了，你们要在团队开发中一起努力。让一方退出的话题根本就没出现过，而且还南辕北辙了，这下就更惨了。</p>
<p>　　你突然想死的心都有了，怎么会这样，怎么聊到这话题上了。你该说的怎么一句都没说出去。你越觉得自己是搞不定这事了，如果狠狠心跟他直说你想退出，因为之前跟人说好了，可是刚才才刚跟他说了要一起团队开发的，这样岂不是搞得好像在耍他。</p>
<p>　　无奈之下，你找瓜哥求助。瓜哥看了你们的聊天记录说，你的表述很有问题。于是，你让瓜哥帮你组织文字。瓜哥组织完后，你却觉得瓜哥的表述太过直接了，语气有点狠了。你觉得你如果是对方，看到这样的话后肯定会很不爽的，所以你又犹豫起来要不要发出去。瓜哥说你要果断点，看了看瓜哥，你一狠心，不管了，点击发送。</p>
<p>　　然后你结队的新同学没有回了，你等了一段时间仍旧没有什么消息。你猜想对方是不是不爽了，但也没办法，发都已经发出去了。再过了一段时间，对方发消息来说他跟懂哥沟通完毕了，他选择退出。</p>
<p>　　不知道为什么，这样的结果就是你最初想要的结果，但你却觉得高兴不起来，你突然感到很愧疚。你觉得这件事应该是由你来跟懂哥沟通，由你来选择退出的，但你却没有勇气去那么做。你突然很讨厌自己，或许这就是懂哥想要你们体验的吧，想要让你们体验，作为学生，是否可以像成人一样解决问题。很明显，这一点上，你很不及格。</p>
<p>　　日子还是需要继续过，团队的事还是需要继续解决。但当你解决跟你结队的新同学的问题后，你才发现，原来你已经拖了那么长的时间了。开学初跟你说好的一起组队的同学看你一直没去找他们，以为你抛弃了他们，以为你只找了瓜哥组队。所以，他们几个商量一下，找了另外的人组好队了。</p>
<p>　　你突然觉得，天不遂人愿。不就是组个队，编个程，怎么就会出这么多麻烦事。但其实，还是你太不成熟了，懂哥是个挖坑高手，不，安排生活体验的高手，你应该早就为各种情况做好安排的。</p>
<p>　　提交团队名单的时间快到了，你联系到了元哥，邀请他加入了你的团队。邀请了瓜哥的舍友，人称BOSS，加入了你的团队。就这样，你们的团队组成了，然后你跟瓜哥讨论，由他作为团队的PM，带领团队开发。因此，团队正式由瓜哥管理。事实也证明，瓜哥在处理各种问题时有着一套属于他自己的风格，在日后团队合作过程中发生的各种问题，你觉得很多瓜哥的做法你做不到，当然，这是后话，暂且不提。</p>
<p>　　团队的事算是基本解决了，你觉得自己得好好的休息一下，调整调整心态。过了的，只能成为过去，再去后悔当初自己要是怎样怎样，没有什么意义。把它当作一种宝贵的回忆，放在脑里来提醒自己不要再犯即可。</p>
<p>　　团队敲定后，懂哥要求大家需要进行团队的展示。你觉得是时候摆好心态，把重心放在新建的团队上了。瓜哥很有理想，给团队起了一个很文艺，很有梦想的名字：For The Dream，团队的人员也都个个很有理想，很有风格。</p>
<p>　　是时候跟队友们一起冲一冲了。</p>
<p>　　后话：几个月后，当软工课程结束，你自己要将软工写成故事的时候。你花了很多时间来回忆团队人选敲定的这件事，回忆当初的各种心理活动，好在这件事对你影响很大，你的印象很深。好在，当初因为愧疚而写下了了一篇日志可以参考。</p>
<p>　　你觉得很有必要单独写一篇博客，来记录这件事。因为你觉得，这是一个宝贵的经历，这是一个令人难以忘记的经历。你觉得，这是软工课程除了教授基本课程知识外，让你收获最多的事之一。</p>
<p>　　回想当初，你一直希望能有一种一石二鸟的解决方案，你一直希望鱼和熊掌可以兼得。但最后呢，你既抛弃了你的结队新同学，又抛弃了当初说好的同学。</p>
<p>　　但仔细想想，为什么当初你就不能选择接受你的结队新同学，为什么非得有一方退出。诚然，如果接受你结队的新同学，因为团队人数限制，当初说好的同学中肯定会有几个要出去，但这都可以沟通。是，你是不习惯，不喜欢跟陌生人互动，沟通，但你也不可能永远只活在现有的圈子里。你需要去飞翔，需要去认识新天地，需要去结交新朋友。是的，你还有很多路要走，你还需要成长。</p>
<p>　　其实当初可以选择即时地沟通的。生活中总有各种意外，计划总是赶不上变化的。为什么当初要选择拖延，要选择沉默。难道还希望在你保持沉默的这时间里，事情能够自动解决？没错，它是解决了，既扔掉了鱼又抛飞了熊掌。很多时候，需要果断就要果断，需要直接了当就直接了当，一拖再拖只会让事情更糟。</p>
<p>（本章完，请猛戳该链接。或许本章有点心灵鸡汤了，但仅以此纪念自己的成长。）</p>
]]></content>
      <categories>
        <category>谈人生</category>
      </categories>
  </entry>
  <entry>
    <title>小码农的故事01</title>
    <url>/2016/09/03/%E7%9E%8E%E6%89%AF%E6%89%AF/%E5%B0%8F%E7%A0%81%E5%86%9C%E7%9A%84%E6%95%85%E4%BA%8B01/</url>
    <content><![CDATA[<hr>
<p> 　　前言：逛知乎时，经常看见有大神写的各种小故事，感觉特别有趣。咳咳，这次也自己来尝试下，将这学期的软工实践写成故事试试看，故事中均已第二人称来描述。故事中的人物均是化名。故事情节经过些许加工。<br> 　　说明：故事情节并没有针对任何人，仅以此纪念自己的成长。  </p>
<hr>
<p>##第一章：软工前夕</p>
<hr>
<p>　　一阵微风袭来，卷起了路边的树叶。推着行李箱，背着书包的你，从公交车下挤了下来。望着学校东门那福州大学四个大字，你叹了口气，又开学了。拿起手机，打了个电话给你舍友，叫他过来载你。挂了电话，你大呼了一口气，顿了顿，往校门的方向走去。新的一学期开始了！  </p>
<p>　　时间过得真快，转眼间已经大三了啊，浑浑噩噩度过了两年的你开始觉得真的得开始做点事了，学点东西了，再这么下去毕业就找不到工作了，到时该怎么向家里说。  </p>
<p>　　回想过去的两年，因为没有什么目标，你一直是按照学校的课程安排来，虽然没有厌烦，但也没有自主学习。只是该上的课学好而已，幸运的是你拿到了那么几次奖学金，而成为了同学们所说的“学霸”，大学专有名词，明明高中时候的你比大学牛逼好学多了。你突然间感觉好讽刺，同级生都已经有人参加各种软件设计大赛了，然而身为所谓的“学霸”的你，居然连android都没接触过。  </p>
<p>　　好在，你听说了这学期的软工实践似乎就是要求要写博客，做软件的，于是你变得很期待这门课。  </p>
<p>　　终于，第一堂课上，那个叫做懂哥的老师手舞足蹈，半恐喝半安慰的讲述了这堂课的要求。他讲了很多，你并没有全部记住，但你记住了懂哥说过这门课要求所有人参与编程，要求最后做出一个发布的产品，要求要有实际用户体验。你顿时感觉非常的激动，这就是你想要学习的课程。终于不是像以前那种大白菜的学生管理系统了，终于不是那种老师都不重视，自己也懒得重视的实践了。  </p>
<p>　　兴奋的你，一下课就找了班上的另一大神，瓜哥，说明了等实践进入团队合作流程时要跟他一起组队。因为这时的你想跟着牛人一起做点牛事！好了，团队的人选搞定了，接下去是结队的对象，但懂哥说过，结队过后就不能再组成团队，于是这时你找上了暑期一起留校学习的一个伙伴，元哥。但元哥并不着急，说这也太早了吧，个人作业都还没布置呢。于是你只能暂时放一边，等结队时再说了。  </p>
<p>　　很快，第一次作业来了，要求你写一篇对这门课程的预期，以及对自己的目标,另外再发表一篇关于移动开发平台的演变。看了这题目，你突然感觉，这是什么作业，做这个有什么意义，你想学的是做软件，写博客。哎，也难怪，被同学称呼了两年的“学霸”的你，变得有点眼高手低，变得有点自负，然而自己却没有意识到。但这毕竟是第一次作业，于是你还是老实的网上找资料，对比，然后将自己的答案写上去。  </p>
<p>　　第一次作业评分下来了，满分八十，你只得了60+，属于中下，心高气傲的你觉得接受不了，于是你把分比你高的同学的博客全部看了一遍，你想找出为什么他们的分会比你高。你一直以为这种题目的作业能写的东西就那么一些，大同小异，为什么分数就会差那么多。但其实，只是你自己对这作业的态度不好而已，好的同学写出的博客一看就是很用心来完成的，或许老师布置这任务希望看到的也就是心态。于是你心服口服，并关注了那些用心写博客的同学，觉得以后可以向他们学习。  </p>
<p>　　很快，第二次作业来了，因为懂哥另有安排，于是将流程换了下，先进行结队任务。要求要进行需求分析和原型设计，需求分析还好，但原型是个什么鬼。无奈，谁叫你是第一次接触的开发，以前接触的不是C语言的黑框，就是Java的控制台，根本不知道开发一款软件的流程是什么。好在，跟你一样的基础的人占大部分，所以你还是可以接受的。可以慢慢来学习。  </p>
<p>　　但突然间，你发现你之前找的那个元哥已经被人抢走去当结队队友了。这下惨了，因为懂哥说过结队后不能再组队，可剩下的还没结队的都是你已经打算最后组成一队的成员了。无奈，只能找不认识的人了。算了，反正团队作业才是最重要的，你这样的为自己安慰道。于是等到课上时，让懂哥帮忙给剩下的还没结队的人组成一队，就这样，你开始了和一个新的同学的结队之旅。  </p>
<p>　　懂哥给的时间有几天，你觉得时间应该够了，也就没联系你的新队友，直接自己在空闲时间研究起了原型是什么鬼。经过了一天的时间，尝试过了懂哥推荐的各种工具，最终你选择了墨刀。一款可在线编辑的原型工具。然后又过了几天，你一直在等你的队友先发消息来问作业怎么完成，你好开始给他讲分工。  </p>
<p>　　其实，你自己也不知道你自己为什么不先主动发消息给你的队友，跟他讨论作业。或许你的心底里觉得你可以自己完成，或许你心里正在吐槽你又碰上一个抱大腿的了，但或许你的队友也正在心里这样的吐槽你。你并没有意识到原来是你缺少主动沟通。就这样，在几天时间里，你根据自己对需求的分析做了一个最初版的原型出来，这时的你终于忍不住了，离截止时间就剩不到两天了，你们一句话还没说过。  </p>
<p>　　于是，你上QQ问了一下他什么时候有空，他给你说了明天的一个时间。你想，那个时间你也有空，于是就没回了。你心里等着他明天那个时候再来联系你，但其实你自己却只把话说一半，别人根本不知道你想表达的是什么。到了第二天，过了那个时间点了，他仍旧没有发任何消息给你，你开始把他定位为一个抱大腿的了，但其实是你自己太高估了自己了。  </p>
<p>　　之后，你稍微意识到了一点，或许是不是因为你自己没把事说清楚，于是你联系他，你主动跟他讲了作业目前的进展，跟他讨论了你对需求的理解，跟他确定了原型的设计，跟他讨论了可行性的解决，最终叫他写段总结，然后你们交了作业。  </p>
<p>　　这时候，你意识到了自己的问题了，不能无故猜疑别人，既然两人都不习惯主动，那么必须要有一人来主持项目，或许你队友已经默认你是项目的领导者了，那么你自己也就要有这个意识，如果两人都将自己定位为底层人员，那么自然没人来推动项目的进展，底层的人自然会互相抱怨。  </p>
<p>　　又一次懂哥的课上，懂哥给排名前三的发了《构建之法》电子书作为奖励，你开始羡慕起来了，你觉得自己应该也有能力拿到才对。于是你对作业的态度更用心了，花更多时间了，别人一小时内能搞定的博客，你觉得你需要两三个小时，因为你觉得你还可以写很多东西。  </p>
<p>　　很快，作业又下来了，是一次个人作业，要求总结git的使用，懂哥说过这是个很好的工具，必须学会使用，但其实你并没有听进去，你只是觉得，你要用心把这次作业做好，你想拿到那本电子书。于是你查了很多资料，做了各种实践来学习git，或许别人只花了一早上，而你却花了整整一天的时间。写了一篇博客出来，也自认为自己已经掌握了git，但其实你还仅仅只是摸到它的门槛而已。过了几个月后的你再回来看自己当初写的博客时，突然觉得当初的自己好天真，好傻，这么简单的问题都搞不懂。当然，这是后话，暂且不提。  </p>
<p>　　果然，这次的作业你的成绩得分挺高，排名直接刷刷往上涨。但这只是次练习，并不算正式的作业，因此并没有什么奖励。虽然什么都没有，但你还是很开心，你觉得助教是个很厉害的人，你觉得你的用心收到了应有的回报。于是你的心态开始发生转变，你开始对这门课程很用心。同时，你也喜欢上了写博客，虽然经常会隔很久才发表一篇，但每一篇中，你总是会写很多很多字，别人说那是废话，你却觉得那是你的风格。  </p>
<p>　　很快，第三次作业来了。是结队编程，终于要开始编程了，你心里也激动了起来。因为从开学初到现在，你一直拿着一本《第一行代码》在看，你一直在抓紧时间学习，因为该死的懂哥说软工课不教语言，而且默认大家是已经掌握并会使用语言的程度。哦，错了，你不该骂懂哥的，他毕竟是个老师，这是很不好的行为。那就该死的软工。  </p>
<p>　　你很喜欢编程，你觉得能用自己的代码写出一个能跑起来的软件简直碉堡了。于是，当作业内容下来后，你直接跟你队友分配了下工作。这次你成长了，不再像之前那次那样谁都不主动，谁都在等对方。这次作业一下来，你就跟你队友说好了各自的内容。但其实你的经验还是太少了，你只是跟他说了他要做什么，你要做什么，你并没有跟他说清楚项目该统一使用的各种东西。  </p>
<p>　　几天的时间一下就过了，你突然觉得编程的时候时间过得好快，好在你自己给自己划分的任务基本算完成了。于是你找你的队友讨论了起来，结果一讨论你才发现，原来队友学习的方向跟你的是相反的，因为当初没有说清楚，你只是跟他说让他负责从数据库取数据的部分，并没有说清楚你选择的数据库是Android自带的SQLite，因此你的队友往mysql的方向去学习。你突然感觉很焦躁，并且你发现你们的开发工具用的也不一样，你的项目他根本打不开。于是，你开始怪你队友不早跟你说，其实是你根本没意识到你最初根本就没提过要统一这些，这是作为项目领导者你的失误，然而你却怪在别人身上。  </p>
<p>　　好在，这只是给定时间的中期，还有时间来得及补救。于是你跟你队友统一了下该统一的，并把你们在项目分歧的地方讨论了下。最终确定下了方案，然后就各自继续完成去了。  </p>
<p>　　最后，在截止时间前一天，你队友在你编写的代码基础上添加了他完成的那部分内容，最终算是完成这次任务的要求。软件可以跑起来了，虽然很多实现的地方都是写死的，但你仍然很开心。  </p>
<p>　　过了几天，成绩出来了。你跟你队友的作业得分最高，排名直接刷刷到了前列。懂哥奖励了你一本电子书，拿到书的那时，你觉得一切都值了。这几天的熬夜，都值了。你并没有觉得自己敲的代码，实现的功能有多完美，比你好的自然有。你只是觉得，你用心，花时间，花功夫完成的任务得到了肯定，这点是最让你开心的。  </p>
<p>　　后话：几个月后，结束软工课后的你再来翻当初的博客，回想当初努力的背影，你突然做出假设，要是当初自己那么多次花时间，花心思完成的作业最后老师又不重视，随便给个分数的话，那样你是否还是会保持每次用心的去对待，你是否还会保持你的热情，你的向往。  </p>
<p>　　一阵微风袭来，你抖了抖身子，呼了口气，拿起杯子喝了口热水。这时已经凌晨0点了，你回望了下你背后的舍友，仍在啪啪啪的敲着他自己的键盘，转过身。你笑了，自己居然会去做这么傻的假设。想了想，你又笑了，你突然间觉得自己太幸运了。有那么一个好学的舍友，因为他的努力让你觉得如果自己也不努力的话似乎很说不过去。如果不是他，或许你早已经沉迷在游戏中了。摇摇头，你又笑了，这次的软工选得太对了，你觉得你需要感谢的人太多了，懂哥跟助教都那么尽职尽责，是真正的良师啊。  </p>
<p>　　又一阵凉风袭来，不知道为什么，你突然觉得你还得再笑一下，这时，你身后传来声音，“你在干嘛，怎么一直在傻笑。”，“没，笑你太帅了。”你一脸笑意的继续着像以往开舍友玩笑一样对他开着玩笑。</p>
]]></content>
      <categories>
        <category>谈人生</category>
      </categories>
  </entry>
</search>
